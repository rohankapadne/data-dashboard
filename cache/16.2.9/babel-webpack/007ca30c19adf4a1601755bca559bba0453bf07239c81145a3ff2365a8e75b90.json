{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport AST from '../Renderer/HTML/AST.js';\nimport A from '../Animation/AnimationUtilities.js';\nconst {\n  animObject\n} = A;\nimport D from '../Defaults.js';\nconst {\n  defaultOptions\n} = D;\nimport F from '../Templating.js';\nconst {\n  format\n} = F;\nimport U from '../Utilities.js';\nconst {\n  addEvent,\n  defined,\n  erase,\n  extend,\n  fireEvent,\n  getNestedProperty,\n  isArray,\n  isFunction,\n  isNumber,\n  isObject,\n  merge,\n  objectEach,\n  pick,\n  syncTimeout,\n  removeEvent,\n  uniqueKey\n} = U;\n/* eslint-disable no-invalid-this, valid-jsdoc */\n/* *\n *\n *  Class\n *\n * */\n/**\n * The Point object. The point objects are generated from the `series.data`\n * configuration objects or raw numbers. They can be accessed from the\n * `Series.points` array. Other ways to instantiate points are through {@link\n * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.\n *\n * @class\n * @name Highcharts.Point\n */\nclass Point {\n  constructor() {\n    /* *\n     *\n     *  Properties\n     *\n     * */\n    /**\n     * For categorized axes this property holds the category name for the\n     * point. For other axes it holds the X value.\n     *\n     * @name Highcharts.Point#category\n     * @type {number|string}\n     */\n    this.category = void 0;\n    this.destroyed = false;\n    this.formatPrefix = 'point';\n    this.id = void 0;\n    this.isNull = false;\n    /**\n     * The name of the point. The name can be given as the first position of the\n     * point configuration array, or as a `name` property in the configuration:\n     *\n     * @example\n     * // Array config\n     * data: [\n     *     ['John', 1],\n     *     ['Jane', 2]\n     * ]\n     *\n     * // Object config\n     * data: [{\n     *        name: 'John',\n     *        y: 1\n     * }, {\n     *     name: 'Jane',\n     *     y: 2\n     * }]\n     *\n     * @name Highcharts.Point#name\n     * @type {string}\n     */\n    this.name = void 0;\n    /**\n     * The point's options as applied in the initial configuration, or\n     * extended through `Point.update`.\n     *\n     * In TypeScript you have to extend `PointOptionsObject` via an\n     * additional interface to allow custom data options:\n     *\n     * ```\n     * declare interface PointOptionsObject {\n     *     customProperty: string;\n     * }\n     * ```\n     *\n     * @name Highcharts.Point#options\n     * @type {Highcharts.PointOptionsObject}\n     */\n    this.options = void 0;\n    /**\n     * The percentage for points in a stacked series, pies or gauges.\n     *\n     * @name Highcharts.Point#percentage\n     * @type {number|undefined}\n     */\n    this.percentage = void 0;\n    this.selected = false;\n    /**\n     * The series object associated with the point.\n     *\n     * @name Highcharts.Point#series\n     * @type {Highcharts.Series}\n     */\n    this.series = void 0;\n    /**\n     * The attributes of the rendered SVG shape like in `column` or `pie`\n     * series.\n     *\n     * @readonly\n     * @name Highcharts.Point#shapeArgs\n     * @type {Readonly<Highcharts.SVGAttributes>|undefined}\n     */\n    this.shapeArgs = void 0;\n    /**\n     * The total of values in either a stack for stacked series, or a pie in a\n     * pie series.\n     *\n     * @name Highcharts.Point#total\n     * @type {number|undefined}\n     */\n    this.total = void 0;\n    /**\n     * For certain series types, like pie charts, where individual points can\n     * be shown or hidden.\n     *\n     * @name Highcharts.Point#visible\n     * @type {boolean}\n     * @default true\n     */\n    this.visible = true;\n    this.x = void 0;\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * Animate SVG elements associated with the point.\n   *\n   * @private\n   * @function Highcharts.Point#animateBeforeDestroy\n   */\n  animateBeforeDestroy() {\n    const point = this,\n      animateParams = {\n        x: point.startXPos,\n        opacity: 0\n      },\n      graphicalProps = point.getGraphicalProps();\n    graphicalProps.singular.forEach(function (prop) {\n      const isDataLabel = prop === 'dataLabel';\n      point[prop] = point[prop].animate(isDataLabel ? {\n        x: point[prop].startXPos,\n        y: point[prop].startYPos,\n        opacity: 0\n      } : animateParams);\n    });\n    graphicalProps.plural.forEach(function (plural) {\n      point[plural].forEach(function (item) {\n        if (item.element) {\n          item.animate(extend({\n            x: point.startXPos\n          }, item.startYPos ? {\n            x: item.startXPos,\n            y: item.startYPos\n          } : {}));\n        }\n      });\n    });\n  }\n  /**\n   * Apply the options containing the x and y data and possible some extra\n   * properties. Called on point init or from point.update.\n   *\n   * @private\n   * @function Highcharts.Point#applyOptions\n   *\n   * @param {Highcharts.PointOptionsType} options\n   *        The point options as defined in series.data.\n   *\n   * @param {number} [x]\n   *        Optionally, the x value.\n   *\n   * @return {Highcharts.Point}\n   *         The Point instance.\n   */\n  applyOptions(options, x) {\n    const point = this,\n      series = point.series,\n      pointValKey = series.options.pointValKey || series.pointValKey;\n    options = Point.prototype.optionsToObject.call(this, options);\n    // copy options directly to point\n    extend(point, options);\n    point.options = point.options ? extend(point.options, options) : options;\n    // Since options are copied into the Point instance, some accidental\n    // options must be shielded (#5681)\n    if (options.group) {\n      delete point.group;\n    }\n    if (options.dataLabels) {\n      delete point.dataLabels;\n    }\n    /**\n     * The y value of the point.\n     * @name Highcharts.Point#y\n     * @type {number|undefined}\n     */\n    // For higher dimension series types. For instance, for ranges, point.y\n    // is mapped to point.low.\n    if (pointValKey) {\n      point.y = Point.prototype.getNestedProperty.call(point, pointValKey);\n    }\n    // The point is initially selected by options (#5777)\n    if (point.selected) {\n      point.state = 'select';\n    }\n    /**\n     * The x value of the point.\n     * @name Highcharts.Point#x\n     * @type {number}\n     */\n    // If no x is set by now, get auto incremented value. All points must\n    // have an x value, however the y value can be null to create a gap in\n    // the series\n    if ('name' in point && typeof x === 'undefined' && series.xAxis && series.xAxis.hasNames) {\n      point.x = series.xAxis.nameToX(point);\n    }\n    if (typeof point.x === 'undefined' && series) {\n      if (typeof x === 'undefined') {\n        point.x = series.autoIncrement();\n      } else {\n        point.x = x;\n      }\n    } else if (isNumber(options.x) && series.options.relativeXValue) {\n      point.x = series.autoIncrement(options.x);\n    }\n    point.isNull = this.isValid && !this.isValid();\n    point.formatPrefix = point.isNull ? 'null' : 'point'; // #9233, #10874\n    return point;\n  }\n  /**\n   * Destroy a point to clear memory. Its reference still stays in\n   * `series.data`.\n   *\n   * @private\n   * @function Highcharts.Point#destroy\n   */\n  destroy() {\n    if (!this.destroyed) {\n      const point = this,\n        series = point.series,\n        chart = series.chart,\n        dataSorting = series.options.dataSorting,\n        hoverPoints = chart.hoverPoints,\n        globalAnimation = point.series.chart.renderer.globalAnimation,\n        animation = animObject(globalAnimation);\n      /**\n       * Allow to call after animation.\n       * @private\n       */\n      const destroyPoint = () => {\n        // Remove all events and elements\n        if (point.graphic || point.graphics || point.dataLabel || point.dataLabels) {\n          removeEvent(point);\n          point.destroyElements();\n        }\n        for (const prop in point) {\n          // eslint-disable-line guard-for-in\n          delete point[prop];\n        }\n      };\n      if (point.legendItem) {\n        // pies have legend items\n        chart.legend.destroyItem(point);\n      }\n      if (hoverPoints) {\n        point.setState();\n        erase(hoverPoints, point);\n        if (!hoverPoints.length) {\n          chart.hoverPoints = null;\n        }\n      }\n      if (point === chart.hoverPoint) {\n        point.onMouseOut();\n      }\n      // Remove properties after animation\n      if (!dataSorting || !dataSorting.enabled) {\n        destroyPoint();\n      } else {\n        this.animateBeforeDestroy();\n        syncTimeout(destroyPoint, animation.duration);\n      }\n      chart.pointCount--;\n    }\n    this.destroyed = true;\n  }\n  /**\n   * Destroy SVG elements associated with the point.\n   *\n   * @private\n   * @function Highcharts.Point#destroyElements\n   * @param {Highcharts.Dictionary<number>} [kinds]\n   */\n  destroyElements(kinds) {\n    const point = this,\n      props = point.getGraphicalProps(kinds);\n    props.singular.forEach(function (prop) {\n      point[prop] = point[prop].destroy();\n    });\n    props.plural.forEach(function (plural) {\n      point[plural].forEach(function (item) {\n        if (item && item.element) {\n          item.destroy();\n        }\n      });\n      delete point[plural];\n    });\n  }\n  /**\n   * Fire an event on the Point object.\n   *\n   * @private\n   * @function Highcharts.Point#firePointEvent\n   *\n   * @param {string} eventType\n   *        Type of the event.\n   *\n   * @param {Highcharts.Dictionary<any>|Event} [eventArgs]\n   *        Additional event arguments.\n   *\n   * @param {Highcharts.EventCallbackFunction<Highcharts.Point>|Function} [defaultFunction]\n   *        Default event handler.\n   *\n   * @emits Highcharts.Point#event:*\n   */\n  firePointEvent(eventType, eventArgs, defaultFunction) {\n    const point = this,\n      series = this.series,\n      seriesOptions = series.options;\n    // load event handlers on demand to save time on mouseover/out\n    if (seriesOptions.point.events[eventType] || point.options && point.options.events && point.options.events[eventType]) {\n      point.importEvents();\n    }\n    // add default handler if in selection mode\n    if (eventType === 'click' && seriesOptions.allowPointSelect) {\n      defaultFunction = function (event) {\n        // Control key is for Windows, meta (= Cmd key) for Mac, Shift\n        // for Opera.\n        if (!point.destroyed && point.select) {\n          // #2911, #19075\n          point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n        }\n      };\n    }\n    fireEvent(point, eventType, eventArgs, defaultFunction);\n  }\n  /**\n   * Get the CSS class names for individual points. Used internally where the\n   * returned value is set on every point.\n   *\n   * @function Highcharts.Point#getClassName\n   *\n   * @return {string}\n   *         The class names.\n   */\n  getClassName() {\n    const point = this;\n    return 'highcharts-point' + (point.selected ? ' highcharts-point-select' : '') + (point.negative ? ' highcharts-negative' : '') + (point.isNull ? ' highcharts-null-point' : '') + (typeof point.colorIndex !== 'undefined' ? ' highcharts-color-' + point.colorIndex : '') + (point.options.className ? ' ' + point.options.className : '') + (point.zone && point.zone.className ? ' ' + point.zone.className.replace('highcharts-negative', '') : '');\n  }\n  /**\n   * Get props of all existing graphical point elements.\n   *\n   * @private\n   * @function Highcharts.Point#getGraphicalProps\n   */\n  getGraphicalProps(kinds) {\n    const point = this,\n      props = [],\n      graphicalProps = {\n        singular: [],\n        plural: []\n      };\n    let prop, i;\n    kinds = kinds || {\n      graphic: 1,\n      dataLabel: 1\n    };\n    if (kinds.graphic) {\n      props.push('graphic', 'connector' // Used by dumbbell\n      );\n    }\n\n    if (kinds.dataLabel) {\n      props.push('dataLabel', 'dataLabelPath', 'dataLabelUpper');\n    }\n    i = props.length;\n    while (i--) {\n      prop = props[i];\n      if (point[prop]) {\n        graphicalProps.singular.push(prop);\n      }\n    }\n    ['graphic', 'dataLabel'].forEach(function (prop) {\n      const plural = prop + 's';\n      if (kinds[prop] && point[plural]) {\n        graphicalProps.plural.push(plural);\n      }\n    });\n    return graphicalProps;\n  }\n  /**\n   * Return the configuration hash needed for the data label and tooltip\n   * formatters.\n   *\n   * @function Highcharts.Point#getLabelConfig\n   *\n   * @return {Highcharts.PointLabelObject}\n   *         Abstract object used in formatters and formats.\n   */\n  getLabelConfig() {\n    return {\n      x: this.category,\n      y: this.y,\n      color: this.color,\n      colorIndex: this.colorIndex,\n      key: this.name || this.category,\n      series: this.series,\n      point: this,\n      percentage: this.percentage,\n      total: this.total || this.stackTotal\n    };\n  }\n  /**\n   * Returns the value of the point property for a given value.\n   * @private\n   */\n  getNestedProperty(key) {\n    if (!key) {\n      return;\n    }\n    if (key.indexOf('custom.') === 0) {\n      return getNestedProperty(key, this.options);\n    }\n    return this[key];\n  }\n  /**\n   * In a series with `zones`, return the zone that the point belongs to.\n   *\n   * @function Highcharts.Point#getZone\n   *\n   * @return {Highcharts.SeriesZonesOptionsObject}\n   *         The zone item.\n   */\n  getZone() {\n    const series = this.series,\n      zones = series.zones,\n      zoneAxis = series.zoneAxis || 'y';\n    let zone,\n      i = 0;\n    zone = zones[i];\n    while (this[zoneAxis] >= zone.value) {\n      zone = zones[++i];\n    }\n    // For resetting or reusing the point (#8100)\n    if (!this.nonZonedColor) {\n      this.nonZonedColor = this.color;\n    }\n    if (zone && zone.color && !this.options.color) {\n      this.color = zone.color;\n    } else {\n      this.color = this.nonZonedColor;\n    }\n    return zone;\n  }\n  /**\n   * Utility to check if point has new shape type. Used in column series and\n   * all others that are based on column series.\n   * @private\n   */\n  hasNewShapeType() {\n    const point = this;\n    const oldShapeType = point.graphic && (point.graphic.symbolName || point.graphic.element.nodeName);\n    return oldShapeType !== this.shapeType;\n  }\n  /**\n   * Initialize the point. Called internally based on the `series.data`\n   * option.\n   *\n   * @function Highcharts.Point#init\n   *\n   * @param {Highcharts.Series} series\n   *        The series object containing this point.\n   *\n   * @param {Highcharts.PointOptionsType} options\n   *        The data in either number, array or object format.\n   *\n   * @param {number} [x]\n   *        Optionally, the X value of the point.\n   *\n   * @return {Highcharts.Point}\n   *         The Point instance.\n   *\n   * @emits Highcharts.Point#event:afterInit\n   */\n  init(series, options, x) {\n    this.series = series;\n    this.applyOptions(options, x);\n    // Add a unique ID to the point if none is assigned\n    this.id = defined(this.id) ? this.id : uniqueKey();\n    this.resolveColor();\n    series.chart.pointCount++;\n    fireEvent(this, 'afterInit');\n    return this;\n  }\n  /**\n   * Determine if point is valid.\n   * @private\n   * @function Highcharts.Point#isValid\n   */\n  isValid() {\n    return (isNumber(this.x) || this.x instanceof Date) && isNumber(this.y);\n  }\n  /**\n   * Transform number or array configs into objects. Also called for object\n   * configs. Used internally to unify the different configuration formats for\n   * points. For example, a simple number `10` in a line series will be\n   * transformed to `{ y: 10 }`, and an array config like `[1, 10]` in a\n   * scatter series will be transformed to `{ x: 1, y: 10 }`.\n   *\n   * @deprecated\n   * @function Highcharts.Point#optionsToObject\n   *\n   * @param {Highcharts.PointOptionsType} options\n   * Series data options.\n   *\n   * @return {Highcharts.Dictionary<*>}\n   * Transformed point options.\n   */\n  optionsToObject(options) {\n    const series = this.series,\n      keys = series.options.keys,\n      pointArrayMap = keys || series.pointArrayMap || ['y'],\n      valueCount = pointArrayMap.length;\n    let ret = {},\n      firstItemType,\n      i = 0,\n      j = 0;\n    if (isNumber(options) || options === null) {\n      ret[pointArrayMap[0]] = options;\n    } else if (isArray(options)) {\n      // with leading x value\n      if (!keys && options.length > valueCount) {\n        firstItemType = typeof options[0];\n        if (firstItemType === 'string') {\n          ret.name = options[0];\n        } else if (firstItemType === 'number') {\n          ret.x = options[0];\n        }\n        i++;\n      }\n      while (j < valueCount) {\n        // Skip undefined positions for keys\n        if (!keys || typeof options[i] !== 'undefined') {\n          if (pointArrayMap[j].indexOf('.') > 0) {\n            // Handle nested keys, e.g. ['color.pattern.image']\n            // Avoid function call unless necessary.\n            Point.prototype.setNestedProperty(ret, options[i], pointArrayMap[j]);\n          } else {\n            ret[pointArrayMap[j]] = options[i];\n          }\n        }\n        i++;\n        j++;\n      }\n    } else if (typeof options === 'object') {\n      ret = options;\n      // This is the fastest way to detect if there are individual point\n      // dataLabels that need to be considered in drawDataLabels. These\n      // can only occur in object configs.\n      if (options.dataLabels) {\n        // Override the prototype function to always return true,\n        // regardless of whether data labels are enabled series-wide\n        series.hasDataLabels = () => true;\n      }\n      // Same approach as above for markers\n      if (options.marker) {\n        series._hasPointMarkers = true;\n      }\n    }\n    return ret;\n  }\n  /**\n   * Get the pixel position of the point relative to the plot area.\n   * @function Highcharts.Point#pos\n   *\n   * @sample highcharts/point/position\n   *         Get point's position in pixels.\n   *\n   * @param {boolean} chartCoordinates\n   * If true, the returned position is relative to the full chart area.\n   * If false, it is relative to the plot area determined by the axes.\n   *\n   * @param {number|undefined} plotY\n   * A custom plot y position to be computed. Used internally for some\n   * series types that have multiple `y` positions, like area range (low\n   * and high values).\n   *\n   * @return {Array<number>|undefined}\n   * Coordinates of the point if the point exists.\n   */\n  pos(chartCoordinates, plotY = this.plotY) {\n    if (!this.destroyed) {\n      const {\n          plotX,\n          series\n        } = this,\n        {\n          chart,\n          xAxis,\n          yAxis\n        } = series;\n      let posX = 0,\n        posY = 0;\n      if (isNumber(plotX) && isNumber(plotY)) {\n        if (chartCoordinates) {\n          posX = xAxis ? xAxis.pos : chart.plotLeft;\n          posY = yAxis ? yAxis.pos : chart.plotTop;\n        }\n        return chart.inverted && xAxis && yAxis ? [yAxis.len - plotY + posY, xAxis.len - plotX + posX] : [plotX + posX, plotY + posY];\n      }\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.Point#resolveColor\n   */\n  resolveColor() {\n    const series = this.series,\n      optionsChart = series.chart.options.chart,\n      styledMode = series.chart.styledMode;\n    let color,\n      colors,\n      colorCount = optionsChart.colorCount,\n      colorIndex;\n    // remove points nonZonedColor for later recalculation\n    delete this.nonZonedColor;\n    if (series.options.colorByPoint) {\n      if (!styledMode) {\n        colors = series.options.colors || series.chart.options.colors;\n        color = colors[series.colorCounter];\n        colorCount = colors.length;\n      }\n      colorIndex = series.colorCounter;\n      series.colorCounter++;\n      // loop back to zero\n      if (series.colorCounter === colorCount) {\n        series.colorCounter = 0;\n      }\n    } else {\n      if (!styledMode) {\n        color = series.color;\n      }\n      colorIndex = series.colorIndex;\n    }\n    /**\n     * The point's current color index, used in styled mode instead of\n     * `color`. The color index is inserted in class names used for styling.\n     *\n     * @name Highcharts.Point#colorIndex\n     * @type {number|undefined}\n     */\n    this.colorIndex = pick(this.options.colorIndex, colorIndex);\n    /**\n     * The point's current color.\n     *\n     * @name Highcharts.Point#color\n     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject|undefined}\n     */\n    this.color = pick(this.options.color, color);\n  }\n  /**\n   * Set a value in an object, on the property defined by key. The key\n   * supports nested properties using dot notation. The function modifies the\n   * input object and does not make a copy.\n   *\n   * @function Highcharts.Point#setNestedProperty<T>\n   *\n   * @param {T} object\n   *        The object to set the value on.\n   *\n   * @param {*} value\n   *        The value to set.\n   *\n   * @param {string} key\n   *        Key to the property to set.\n   *\n   * @return {T}\n   *         The modified object.\n   */\n  setNestedProperty(object, value, key) {\n    const nestedKeys = key.split('.');\n    nestedKeys.reduce(function (result, key, i, arr) {\n      const isLastKey = arr.length - 1 === i;\n      result[key] = isLastKey ? value : isObject(result[key], true) ? result[key] : {};\n      return result[key];\n    }, object);\n    return object;\n  }\n  shouldDraw() {\n    return !this.isNull;\n  }\n  /**\n   * Extendable method for formatting each point's tooltip line.\n   *\n   * @function Highcharts.Point#tooltipFormatter\n   *\n   * @param {string} pointFormat\n   *        The point format.\n   *\n   * @return {string}\n   *         A string to be concatenated in to the common tooltip text.\n   */\n  tooltipFormatter(pointFormat) {\n    // Insert options for valueDecimals, valuePrefix, and valueSuffix\n    const series = this.series,\n      seriesTooltipOptions = series.tooltipOptions,\n      valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),\n      valuePrefix = seriesTooltipOptions.valuePrefix || '',\n      valueSuffix = seriesTooltipOptions.valueSuffix || '';\n    // Replace default point style with class name\n    if (series.chart.styledMode) {\n      pointFormat = series.chart.tooltip.styledModeFormat(pointFormat);\n    }\n    // Loop over the point array map and replace unformatted values with\n    // sprintf formatting markup\n    (series.pointArrayMap || ['y']).forEach(function (key) {\n      key = '{point.' + key; // without the closing bracket\n      if (valuePrefix || valueSuffix) {\n        pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), valuePrefix + key + '}' + valueSuffix);\n      }\n      pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), key + ':,.' + valueDecimals + 'f}');\n    });\n    return format(pointFormat, {\n      point: this,\n      series: this.series\n    }, series.chart);\n  }\n  /**\n   * Update point with new options (typically x/y data) and optionally redraw\n   * the series.\n   *\n   * @sample highcharts/members/point-update-column/\n   *         Update column value\n   * @sample highcharts/members/point-update-pie/\n   *         Update pie slice\n   * @sample maps/members/point-update/\n   *         Update map area value in Highmaps\n   *\n   * @function Highcharts.Point#update\n   *\n   * @param {Highcharts.PointOptionsType} options\n   *        The point options. Point options are handled as described under\n   *        the `series.type.data` item for each series type. For example\n   *        for a line series, if options is a single number, the point will\n   *        be given that number as the marin y value. If it is an array, it\n   *        will be interpreted as x and y values respectively. If it is an\n   *        object, advanced options are applied.\n   *\n   * @param {boolean} [redraw=true]\n   *        Whether to redraw the chart after the point is updated. If doing\n   *        more operations on the chart, it is best practice to set\n   *        `redraw` to false and call `chart.redraw()` after.\n   *\n   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=true]\n   *        Whether to apply animation, and optionally animation\n   *        configuration.\n   *\n   * @emits Highcharts.Point#event:update\n   */\n  update(options, redraw, animation, runEvent) {\n    const point = this,\n      series = point.series,\n      graphic = point.graphic,\n      chart = series.chart,\n      seriesOptions = series.options;\n    let i;\n    redraw = pick(redraw, true);\n    /**\n     * @private\n     */\n    function update() {\n      point.applyOptions(options);\n      // Update visuals, #4146\n      // Handle mock graphic elements for a11y, #12718\n      const hasMockGraphic = graphic && point.hasMockGraphic;\n      const shouldDestroyGraphic = point.y === null ? !hasMockGraphic : hasMockGraphic;\n      if (graphic && shouldDestroyGraphic) {\n        point.graphic = graphic.destroy();\n        delete point.hasMockGraphic;\n      }\n      if (isObject(options, true)) {\n        // Destroy so we can get new elements\n        if (graphic && graphic.element) {\n          // \"null\" is also a valid symbol\n          if (options && options.marker && typeof options.marker.symbol !== 'undefined') {\n            point.graphic = graphic.destroy();\n          }\n        }\n        if (options?.dataLabels && point.dataLabel) {\n          point.dataLabel = point.dataLabel.destroy(); // #2468\n        }\n      }\n      // record changes in the parallel arrays\n      i = point.index;\n      series.updateParallelArrays(point, i);\n      // Record the options to options.data. If the old or the new config\n      // is an object, use point options, otherwise use raw options\n      // (#4701, #4916).\n      seriesOptions.data[i] = isObject(seriesOptions.data[i], true) || isObject(options, true) ? point.options : pick(options, seriesOptions.data[i]);\n      // redraw\n      series.isDirty = series.isDirtyData = true;\n      if (!series.fixedBox && series.hasCartesianSeries) {\n        // #1906, #2320\n        chart.isDirtyBox = true;\n      }\n      if (seriesOptions.legendType === 'point') {\n        // #1831, #1885\n        chart.isDirtyLegend = true;\n      }\n      if (redraw) {\n        chart.redraw(animation);\n      }\n    }\n    // Fire the event with a default handler of doing the update\n    if (runEvent === false) {\n      // When called from setData\n      update();\n    } else {\n      point.firePointEvent('update', {\n        options: options\n      }, update);\n    }\n  }\n  /**\n   * Remove a point and optionally redraw the series and if necessary the axes\n   *\n   * @sample highcharts/plotoptions/series-point-events-remove/\n   *         Remove point and confirm\n   * @sample highcharts/members/point-remove/\n   *         Remove pie slice\n   * @sample maps/members/point-remove/\n   *         Remove selected points in Highmaps\n   *\n   * @function Highcharts.Point#remove\n   *\n   * @param {boolean} [redraw=true]\n   *        Whether to redraw the chart or wait for an explicit call. When\n   *        doing more operations on the chart, for example running\n   *        `point.remove()` in a loop, it is best practice to set `redraw`\n   *        to false and call `chart.redraw()` after.\n   *\n   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=false]\n   *        Whether to apply animation, and optionally animation\n   *        configuration.\n   */\n  remove(redraw, animation) {\n    this.series.removePoint(this.series.data.indexOf(this), redraw, animation);\n  }\n  /**\n   * Toggle the selection status of a point.\n   *\n   * @see Highcharts.Chart#getSelectedPoints\n   *\n   * @sample highcharts/members/point-select/\n   *         Select a point from a button\n   * @sample highcharts/chart/events-selection-points/\n   *         Select a range of points through a drag selection\n   * @sample maps/series/data-id/\n   *         Select a point in Highmaps\n   *\n   * @function Highcharts.Point#select\n   *\n   * @param {boolean} [selected]\n   * When `true`, the point is selected. When `false`, the point is\n   * unselected. When `null` or `undefined`, the selection state is toggled.\n   *\n   * @param {boolean} [accumulate=false]\n   * When `true`, the selection is added to other selected points.\n   * When `false`, other selected points are deselected. Internally in\n   * Highcharts, when\n   * [allowPointSelect](https://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect)\n   * is `true`, selected points are accumulated on Control, Shift or Cmd\n   * clicking the point.\n   *\n   * @emits Highcharts.Point#event:select\n   * @emits Highcharts.Point#event:unselect\n   */\n  select(selected, accumulate) {\n    const point = this,\n      series = point.series,\n      chart = series.chart;\n    selected = pick(selected, !point.selected);\n    this.selectedStaging = selected;\n    // fire the event with the default handler\n    point.firePointEvent(selected ? 'select' : 'unselect', {\n      accumulate: accumulate\n    }, function () {\n      /**\n       * Whether the point is selected or not.\n       *\n       * @see Point#select\n       * @see Chart#getSelectedPoints\n       *\n       * @name Highcharts.Point#selected\n       * @type {boolean}\n       */\n      point.selected = point.options.selected = selected;\n      series.options.data[series.data.indexOf(point)] = point.options;\n      point.setState(selected && 'select');\n      // unselect all other points unless Ctrl or Cmd + click\n      if (!accumulate) {\n        chart.getSelectedPoints().forEach(function (loopPoint) {\n          const loopSeries = loopPoint.series;\n          if (loopPoint.selected && loopPoint !== point) {\n            loopPoint.selected = loopPoint.options.selected = false;\n            loopSeries.options.data[loopSeries.data.indexOf(loopPoint)] = loopPoint.options;\n            // Programatically selecting a point should restore\n            // normal state, but when click happened on other\n            // point, set inactive state to match other points\n            loopPoint.setState(chart.hoverPoints && loopSeries.options.inactiveOtherPoints ? 'inactive' : '');\n            loopPoint.firePointEvent('unselect');\n          }\n        });\n      }\n    });\n    delete this.selectedStaging;\n  }\n  /**\n   * Runs on mouse over the point. Called internally from mouse and touch\n   * events.\n   *\n   * @function Highcharts.Point#onMouseOver\n   *\n   * @param {Highcharts.PointerEventObject} [e]\n   *        The event arguments.\n   */\n  onMouseOver(e) {\n    const point = this,\n      series = point.series,\n      chart = series.chart,\n      pointer = chart.pointer;\n    e = e ? pointer.normalize(e) :\n    // In cases where onMouseOver is called directly without an event\n    pointer.getChartCoordinatesFromPoint(point, chart.inverted);\n    pointer.runPointActions(e, point);\n  }\n  /**\n   * Runs on mouse out from the point. Called internally from mouse and touch\n   * events.\n   *\n   * @function Highcharts.Point#onMouseOut\n   * @emits Highcharts.Point#event:mouseOut\n   */\n  onMouseOut() {\n    const point = this,\n      chart = point.series.chart;\n    point.firePointEvent('mouseOut');\n    if (!point.series.options.inactiveOtherPoints) {\n      (chart.hoverPoints || []).forEach(function (p) {\n        p.setState();\n      });\n    }\n    chart.hoverPoints = chart.hoverPoint = null;\n  }\n  /**\n   * Import events from the series' and point's options. Only do it on\n   * demand, to save processing time on hovering.\n   *\n   * @private\n   * @function Highcharts.Point#importEvents\n   */\n  importEvents() {\n    if (!this.hasImportedEvents) {\n      const point = this,\n        options = merge(point.series.options.point, point.options),\n        events = options.events;\n      point.events = events;\n      objectEach(events, function (event, eventType) {\n        if (isFunction(event)) {\n          addEvent(point, eventType, event);\n        }\n      });\n      this.hasImportedEvents = true;\n    }\n  }\n  /**\n   * Set the point's state.\n   *\n   * @function Highcharts.Point#setState\n   *\n   * @param {Highcharts.PointStateValue|\"\"} [state]\n   *        The new state, can be one of `'hover'`, `'select'`, `'inactive'`,\n   *        or `''` (an empty string), `'normal'` or `undefined` to set to\n   *        normal state.\n   * @param {boolean} [move]\n   *        State for animation.\n   *\n   * @emits Highcharts.Point#event:afterSetState\n   */\n  setState(state, move) {\n    const point = this,\n      series = point.series,\n      previousState = point.state,\n      stateOptions = series.options.states[state || 'normal'] || {},\n      markerOptions = defaultOptions.plotOptions[series.type].marker && series.options.marker,\n      normalDisabled = markerOptions && markerOptions.enabled === false,\n      markerStateOptions = markerOptions && markerOptions.states && markerOptions.states[state || 'normal'] || {},\n      stateDisabled = markerStateOptions.enabled === false,\n      pointMarker = point.marker || {},\n      chart = series.chart,\n      hasMarkers = markerOptions && series.markerAttribs;\n    let halo = series.halo,\n      markerAttribs,\n      pointAttribs,\n      pointAttribsAnimation,\n      stateMarkerGraphic = series.stateMarkerGraphic,\n      newSymbol;\n    state = state || ''; // empty string\n    if (\n    // already has this state\n    state === point.state && !move ||\n    // selected points don't respond to hover\n    point.selected && state !== 'select' ||\n    // series' state options is disabled\n    stateOptions.enabled === false ||\n    // general point marker's state options is disabled\n    state && (stateDisabled || normalDisabled && markerStateOptions.enabled === false) ||\n    // individual point marker's state options is disabled\n    state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false // #1610\n    ) {\n      return;\n    }\n    point.state = state;\n    if (hasMarkers) {\n      markerAttribs = series.markerAttribs(point, state);\n    }\n    // Apply hover styles to the existing point\n    // Prevent from mocked null points (#14966)\n    if (point.graphic && !point.hasMockGraphic) {\n      if (previousState) {\n        point.graphic.removeClass('highcharts-point-' + previousState);\n      }\n      if (state) {\n        point.graphic.addClass('highcharts-point-' + state);\n      }\n      if (!chart.styledMode) {\n        pointAttribs = series.pointAttribs(point, state);\n        pointAttribsAnimation = pick(chart.options.chart.animation, stateOptions.animation);\n        const opacity = pointAttribs.opacity;\n        // Some inactive points (e.g. slices in pie) should apply\n        // opacity also for their labels\n        if (series.options.inactiveOtherPoints && isNumber(opacity)) {\n          (point.dataLabels || []).forEach(function (label) {\n            if (label && !label.hasClass('highcharts-data-label-hidden')) {\n              label.animate({\n                opacity\n              }, pointAttribsAnimation);\n              if (label.connector) {\n                label.connector.animate({\n                  opacity\n                }, pointAttribsAnimation);\n              }\n            }\n          });\n        }\n        point.graphic.animate(pointAttribs, pointAttribsAnimation);\n      }\n      if (markerAttribs) {\n        point.graphic.animate(markerAttribs, pick(\n        // Turn off globally:\n        chart.options.chart.animation, markerStateOptions.animation, markerOptions.animation));\n      }\n      // Zooming in from a range with no markers to a range with markers\n      if (stateMarkerGraphic) {\n        stateMarkerGraphic.hide();\n      }\n    } else {\n      // if a graphic is not applied to each point in the normal state,\n      // create a shared graphic for the hover state\n      if (state && markerStateOptions) {\n        newSymbol = pointMarker.symbol || series.symbol;\n        // If the point has another symbol than the previous one, throw\n        // away the state marker graphic and force a new one (#1459)\n        if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {\n          stateMarkerGraphic = stateMarkerGraphic.destroy();\n        }\n        // Add a new state marker graphic\n        if (markerAttribs) {\n          if (!stateMarkerGraphic) {\n            if (newSymbol) {\n              series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height).add(series.markerGroup);\n              stateMarkerGraphic.currentSymbol = newSymbol;\n            }\n            // Move the existing graphic\n          } else {\n            stateMarkerGraphic[move ? 'animate' : 'attr']({\n              x: markerAttribs.x,\n              y: markerAttribs.y\n            });\n          }\n        }\n        if (!chart.styledMode && stateMarkerGraphic && point.state !== 'inactive') {\n          stateMarkerGraphic.attr(series.pointAttribs(point, state));\n        }\n      }\n      if (stateMarkerGraphic) {\n        stateMarkerGraphic[state && point.isInside ? 'show' : 'hide'](); // #2450\n        stateMarkerGraphic.element.point = point; // #4310\n        stateMarkerGraphic.addClass(point.getClassName(), true);\n      }\n    }\n    // Show me your halo\n    const haloOptions = stateOptions.halo;\n    const markerGraphic = point.graphic || stateMarkerGraphic;\n    const markerVisibility = markerGraphic && markerGraphic.visibility || 'inherit';\n    if (haloOptions && haloOptions.size && markerGraphic && markerVisibility !== 'hidden' && !point.isCluster) {\n      if (!halo) {\n        series.halo = halo = chart.renderer.path()\n        // #5818, #5903, #6705\n        .add(markerGraphic.parentGroup);\n      }\n      halo.show()[move ? 'animate' : 'attr']({\n        d: point.haloPath(haloOptions.size)\n      });\n      halo.attr({\n        'class': 'highcharts-halo highcharts-color-' + pick(point.colorIndex, series.colorIndex) + (point.className ? ' ' + point.className : ''),\n        'visibility': markerVisibility,\n        'zIndex': -1 // #4929, #8276\n      });\n\n      halo.point = point; // #6055\n      if (!chart.styledMode) {\n        halo.attr(extend({\n          'fill': point.color || series.color,\n          'fill-opacity': haloOptions.opacity\n        }, AST.filterUserAttributes(haloOptions.attributes || {})));\n      }\n    } else if (halo && halo.point && halo.point.haloPath) {\n      // Animate back to 0 on the current halo point (#6055)\n      halo.animate({\n        d: halo.point.haloPath(0)\n      }, null,\n      // Hide after unhovering. The `complete` callback runs in the\n      // halo's context (#7681).\n      halo.hide);\n    }\n    fireEvent(point, 'afterSetState', {\n      state\n    });\n  }\n  /**\n   * Get the path definition for the halo, which is usually a shadow-like\n   * circle around the currently hovered point.\n   *\n   * @function Highcharts.Point#haloPath\n   *\n   * @param {number} size\n   *        The radius of the circular halo.\n   *\n   * @return {Highcharts.SVGPathArray}\n   *         The path definition.\n   */\n  haloPath(size) {\n    const pos = this.pos();\n    return pos ? this.series.chart.renderer.symbols.circle(Math.floor(pos[0]) - size, pos[1] - size, size * 2, size * 2) : [];\n  }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default Point;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Function callback when a series point is clicked. Return false to cancel the\n * action.\n *\n * @callback Highcharts.PointClickCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        The point where the event occured.\n *\n * @param {Highcharts.PointClickEventObject} event\n *        Event arguments.\n */\n/**\n * Common information for a click event on a series point.\n *\n * @interface Highcharts.PointClickEventObject\n * @extends Highcharts.PointerEventObject\n */ /**\n    * Clicked point.\n    * @name Highcharts.PointClickEventObject#point\n    * @type {Highcharts.Point}\n    */\n/**\n * Configuration for the data label and tooltip formatters.\n *\n * @interface Highcharts.PointLabelObject\n */ /**\n    * The point's current color.\n    * @name Highcharts.PointLabelObject#color\n    * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject|undefined}\n    */ /**\n       * The point's current color index, used in styled mode instead of `color`. The\n       * color index is inserted in class names used for styling.\n       * @name Highcharts.PointLabelObject#colorIndex\n       * @type {number}\n       */ /**\n          * The name of the related point.\n          * @name Highcharts.PointLabelObject#key\n          * @type {string|undefined}\n          */ /**\n             * The percentage for related points in a stacked series or pies.\n             * @name Highcharts.PointLabelObject#percentage\n             * @type {number}\n             */ /**\n                * The related point. The point name, if defined, is available through\n                * `this.point.name`.\n                * @name Highcharts.PointLabelObject#point\n                * @type {Highcharts.Point}\n                */ /**\n                   * The related series. The series name is available through `this.series.name`.\n                   * @name Highcharts.PointLabelObject#series\n                   * @type {Highcharts.Series}\n                   */ /**\n                      * The total of values in either a stack for stacked series, or a pie in a pie\n                      * series.\n                      * @name Highcharts.PointLabelObject#total\n                      * @type {number|undefined}\n                      */ /**\n                         * For categorized axes this property holds the category name for the point. For\n                         * other axes it holds the X value.\n                         * @name Highcharts.PointLabelObject#x\n                         * @type {number|string|undefined}\n                         */ /**\n                            * The y value of the point.\n                            * @name Highcharts.PointLabelObject#y\n                            * @type {number|null|undefined}\n                            */\n/**\n * Gets fired when the mouse leaves the area close to the point.\n *\n * @callback Highcharts.PointMouseOutCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        Point where the event occured.\n *\n * @param {global.PointerEvent} event\n *        Event that occured.\n */\n/**\n * Gets fired when the mouse enters the area close to the point.\n *\n * @callback Highcharts.PointMouseOverCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        Point where the event occured.\n *\n * @param {global.Event} event\n *        Event that occured.\n */\n/**\n * The generic point options for all series.\n *\n * In TypeScript you have to extend `PointOptionsObject` with an additional\n * declaration to allow custom data options:\n *\n * ```\n * declare interface PointOptionsObject {\n *     customProperty: string;\n * }\n * ```\n *\n * @interface Highcharts.PointOptionsObject\n */\n/**\n * Possible option types for a data point. Use `null` to indicate a gap.\n *\n * @typedef {number|string|Highcharts.PointOptionsObject|Array<(number|string|null)>|null} Highcharts.PointOptionsType\n */\n/**\n * Gets fired when the point is removed using the `.remove()` method.\n *\n * @callback Highcharts.PointRemoveCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        Point where the event occured.\n *\n * @param {global.Event} event\n *        Event that occured.\n */\n/**\n * Possible key values for the point state options.\n *\n * @typedef {\"hover\"|\"inactive\"|\"normal\"|\"select\"} Highcharts.PointStateValue\n */\n/**\n * Gets fired when the point is updated programmatically through the `.update()`\n * method.\n *\n * @callback Highcharts.PointUpdateCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        Point where the event occured.\n *\n * @param {Highcharts.PointUpdateEventObject} event\n *        Event that occured.\n */\n/**\n * Information about the update event.\n *\n * @interface Highcharts.PointUpdateEventObject\n * @extends global.Event\n */ /**\n    * Options data of the update event.\n    * @name Highcharts.PointUpdateEventObject#options\n    * @type {Highcharts.PointOptionsType}\n    */\n/**\n * @interface Highcharts.PointEventsOptionsObject\n */ /**\n    * Fires when the point is selected either programmatically or following a click\n    * on the point. One parameter, `event`, is passed to the function. Returning\n    * `false` cancels the operation.\n    * @name Highcharts.PointEventsOptionsObject#select\n    * @type {Highcharts.PointSelectCallbackFunction|undefined}\n    */ /**\n       * Fires when the point is unselected either programmatically or following a\n       * click on the point. One parameter, `event`, is passed to the function.\n       * Returning `false` cancels the operation.\n       * @name Highcharts.PointEventsOptionsObject#unselect\n       * @type {Highcharts.PointUnselectCallbackFunction|undefined}\n       */\n/**\n * Information about the select/unselect event.\n *\n * @interface Highcharts.PointInteractionEventObject\n * @extends global.Event\n */ /**\n    * @name Highcharts.PointInteractionEventObject#accumulate\n    * @type {boolean}\n    */\n/**\n * Gets fired when the point is selected either programmatically or following a\n * click on the point.\n *\n * @callback Highcharts.PointSelectCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        Point where the event occured.\n *\n * @param {Highcharts.PointInteractionEventObject} event\n *        Event that occured.\n */\n/**\n * Fires when the point is unselected either programmatically or following a\n * click on the point.\n *\n * @callback Highcharts.PointUnselectCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        Point where the event occured.\n *\n * @param {Highcharts.PointInteractionEventObject} event\n *        Event that occured.\n */\n''; // keeps doclets above in JS file.","map":{"version":3,"names":["AST","A","animObject","D","defaultOptions","F","format","U","addEvent","defined","erase","extend","fireEvent","getNestedProperty","isArray","isFunction","isNumber","isObject","merge","objectEach","pick","syncTimeout","removeEvent","uniqueKey","Point","constructor","category","destroyed","formatPrefix","id","isNull","name","options","percentage","selected","series","shapeArgs","total","visible","x","animateBeforeDestroy","point","animateParams","startXPos","opacity","graphicalProps","getGraphicalProps","singular","forEach","prop","isDataLabel","animate","y","startYPos","plural","item","element","applyOptions","pointValKey","prototype","optionsToObject","call","group","dataLabels","state","xAxis","hasNames","nameToX","autoIncrement","relativeXValue","isValid","destroy","chart","dataSorting","hoverPoints","globalAnimation","renderer","animation","destroyPoint","graphic","graphics","dataLabel","destroyElements","legendItem","legend","destroyItem","setState","length","hoverPoint","onMouseOut","enabled","duration","pointCount","kinds","props","firePointEvent","eventType","eventArgs","defaultFunction","seriesOptions","events","importEvents","allowPointSelect","event","select","ctrlKey","metaKey","shiftKey","getClassName","negative","colorIndex","className","zone","replace","i","push","getLabelConfig","color","key","stackTotal","indexOf","getZone","zones","zoneAxis","value","nonZonedColor","hasNewShapeType","oldShapeType","symbolName","nodeName","shapeType","init","resolveColor","Date","keys","pointArrayMap","valueCount","ret","firstItemType","j","setNestedProperty","hasDataLabels","marker","_hasPointMarkers","pos","chartCoordinates","plotY","plotX","yAxis","posX","posY","plotLeft","plotTop","inverted","len","optionsChart","styledMode","colors","colorCount","colorByPoint","colorCounter","object","nestedKeys","split","reduce","result","arr","isLastKey","shouldDraw","tooltipFormatter","pointFormat","seriesTooltipOptions","tooltipOptions","valueDecimals","valuePrefix","valueSuffix","tooltip","styledModeFormat","RegExp","update","redraw","runEvent","hasMockGraphic","shouldDestroyGraphic","symbol","index","updateParallelArrays","data","isDirty","isDirtyData","fixedBox","hasCartesianSeries","isDirtyBox","legendType","isDirtyLegend","remove","removePoint","accumulate","selectedStaging","getSelectedPoints","loopPoint","loopSeries","inactiveOtherPoints","onMouseOver","e","pointer","normalize","getChartCoordinatesFromPoint","runPointActions","p","hasImportedEvents","move","previousState","stateOptions","states","markerOptions","plotOptions","type","normalDisabled","markerStateOptions","stateDisabled","pointMarker","hasMarkers","markerAttribs","halo","pointAttribs","pointAttribsAnimation","stateMarkerGraphic","newSymbol","removeClass","addClass","label","hasClass","connector","hide","currentSymbol","width","height","add","markerGroup","attr","isInside","haloOptions","markerGraphic","markerVisibility","visibility","size","isCluster","path","parentGroup","show","d","haloPath","filterUserAttributes","attributes","symbols","circle","Math","floor"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Series/Point.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport AST from '../Renderer/HTML/AST.js';\nimport A from '../Animation/AnimationUtilities.js';\nconst { animObject } = A;\nimport D from '../Defaults.js';\nconst { defaultOptions } = D;\nimport F from '../Templating.js';\nconst { format } = F;\nimport U from '../Utilities.js';\nconst { addEvent, defined, erase, extend, fireEvent, getNestedProperty, isArray, isFunction, isNumber, isObject, merge, objectEach, pick, syncTimeout, removeEvent, uniqueKey } = U;\n/* eslint-disable no-invalid-this, valid-jsdoc */\n/* *\n *\n *  Class\n *\n * */\n/**\n * The Point object. The point objects are generated from the `series.data`\n * configuration objects or raw numbers. They can be accessed from the\n * `Series.points` array. Other ways to instantiate points are through {@link\n * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.\n *\n * @class\n * @name Highcharts.Point\n */\nclass Point {\n    constructor() {\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        /**\n         * For categorized axes this property holds the category name for the\n         * point. For other axes it holds the X value.\n         *\n         * @name Highcharts.Point#category\n         * @type {number|string}\n         */\n        this.category = void 0;\n        this.destroyed = false;\n        this.formatPrefix = 'point';\n        this.id = void 0;\n        this.isNull = false;\n        /**\n         * The name of the point. The name can be given as the first position of the\n         * point configuration array, or as a `name` property in the configuration:\n         *\n         * @example\n         * // Array config\n         * data: [\n         *     ['John', 1],\n         *     ['Jane', 2]\n         * ]\n         *\n         * // Object config\n         * data: [{\n         *        name: 'John',\n         *        y: 1\n         * }, {\n         *     name: 'Jane',\n         *     y: 2\n         * }]\n         *\n         * @name Highcharts.Point#name\n         * @type {string}\n         */\n        this.name = void 0;\n        /**\n         * The point's options as applied in the initial configuration, or\n         * extended through `Point.update`.\n         *\n         * In TypeScript you have to extend `PointOptionsObject` via an\n         * additional interface to allow custom data options:\n         *\n         * ```\n         * declare interface PointOptionsObject {\n         *     customProperty: string;\n         * }\n         * ```\n         *\n         * @name Highcharts.Point#options\n         * @type {Highcharts.PointOptionsObject}\n         */\n        this.options = void 0;\n        /**\n         * The percentage for points in a stacked series, pies or gauges.\n         *\n         * @name Highcharts.Point#percentage\n         * @type {number|undefined}\n         */\n        this.percentage = void 0;\n        this.selected = false;\n        /**\n         * The series object associated with the point.\n         *\n         * @name Highcharts.Point#series\n         * @type {Highcharts.Series}\n         */\n        this.series = void 0;\n        /**\n         * The attributes of the rendered SVG shape like in `column` or `pie`\n         * series.\n         *\n         * @readonly\n         * @name Highcharts.Point#shapeArgs\n         * @type {Readonly<Highcharts.SVGAttributes>|undefined}\n         */\n        this.shapeArgs = void 0;\n        /**\n         * The total of values in either a stack for stacked series, or a pie in a\n         * pie series.\n         *\n         * @name Highcharts.Point#total\n         * @type {number|undefined}\n         */\n        this.total = void 0;\n        /**\n         * For certain series types, like pie charts, where individual points can\n         * be shown or hidden.\n         *\n         * @name Highcharts.Point#visible\n         * @type {boolean}\n         * @default true\n         */\n        this.visible = true;\n        this.x = void 0;\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Animate SVG elements associated with the point.\n     *\n     * @private\n     * @function Highcharts.Point#animateBeforeDestroy\n     */\n    animateBeforeDestroy() {\n        const point = this, animateParams = { x: point.startXPos, opacity: 0 }, graphicalProps = point.getGraphicalProps();\n        graphicalProps.singular.forEach(function (prop) {\n            const isDataLabel = prop === 'dataLabel';\n            point[prop] = point[prop].animate(isDataLabel ? {\n                x: point[prop].startXPos,\n                y: point[prop].startYPos,\n                opacity: 0\n            } : animateParams);\n        });\n        graphicalProps.plural.forEach(function (plural) {\n            point[plural].forEach(function (item) {\n                if (item.element) {\n                    item.animate(extend({ x: point.startXPos }, (item.startYPos ? {\n                        x: item.startXPos,\n                        y: item.startYPos\n                    } : {})));\n                }\n            });\n        });\n    }\n    /**\n     * Apply the options containing the x and y data and possible some extra\n     * properties. Called on point init or from point.update.\n     *\n     * @private\n     * @function Highcharts.Point#applyOptions\n     *\n     * @param {Highcharts.PointOptionsType} options\n     *        The point options as defined in series.data.\n     *\n     * @param {number} [x]\n     *        Optionally, the x value.\n     *\n     * @return {Highcharts.Point}\n     *         The Point instance.\n     */\n    applyOptions(options, x) {\n        const point = this, series = point.series, pointValKey = series.options.pointValKey || series.pointValKey;\n        options = Point.prototype.optionsToObject.call(this, options);\n        // copy options directly to point\n        extend(point, options);\n        point.options = point.options ?\n            extend(point.options, options) :\n            options;\n        // Since options are copied into the Point instance, some accidental\n        // options must be shielded (#5681)\n        if (options.group) {\n            delete point.group;\n        }\n        if (options.dataLabels) {\n            delete point.dataLabels;\n        }\n        /**\n         * The y value of the point.\n         * @name Highcharts.Point#y\n         * @type {number|undefined}\n         */\n        // For higher dimension series types. For instance, for ranges, point.y\n        // is mapped to point.low.\n        if (pointValKey) {\n            point.y = Point.prototype.getNestedProperty.call(point, pointValKey);\n        }\n        // The point is initially selected by options (#5777)\n        if (point.selected) {\n            point.state = 'select';\n        }\n        /**\n         * The x value of the point.\n         * @name Highcharts.Point#x\n         * @type {number}\n         */\n        // If no x is set by now, get auto incremented value. All points must\n        // have an x value, however the y value can be null to create a gap in\n        // the series\n        if ('name' in point &&\n            typeof x === 'undefined' &&\n            series.xAxis &&\n            series.xAxis.hasNames) {\n            point.x = series.xAxis.nameToX(point);\n        }\n        if (typeof point.x === 'undefined' && series) {\n            if (typeof x === 'undefined') {\n                point.x = series.autoIncrement();\n            }\n            else {\n                point.x = x;\n            }\n        }\n        else if (isNumber(options.x) && series.options.relativeXValue) {\n            point.x = series.autoIncrement(options.x);\n        }\n        point.isNull = this.isValid && !this.isValid();\n        point.formatPrefix = point.isNull ? 'null' : 'point'; // #9233, #10874\n        return point;\n    }\n    /**\n     * Destroy a point to clear memory. Its reference still stays in\n     * `series.data`.\n     *\n     * @private\n     * @function Highcharts.Point#destroy\n     */\n    destroy() {\n        if (!this.destroyed) {\n            const point = this, series = point.series, chart = series.chart, dataSorting = series.options.dataSorting, hoverPoints = chart.hoverPoints, globalAnimation = point.series.chart.renderer.globalAnimation, animation = animObject(globalAnimation);\n            /**\n             * Allow to call after animation.\n             * @private\n             */\n            const destroyPoint = () => {\n                // Remove all events and elements\n                if (point.graphic ||\n                    point.graphics ||\n                    point.dataLabel ||\n                    point.dataLabels) {\n                    removeEvent(point);\n                    point.destroyElements();\n                }\n                for (const prop in point) { // eslint-disable-line guard-for-in\n                    delete point[prop];\n                }\n            };\n            if (point.legendItem) {\n                // pies have legend items\n                chart.legend.destroyItem(point);\n            }\n            if (hoverPoints) {\n                point.setState();\n                erase(hoverPoints, point);\n                if (!hoverPoints.length) {\n                    chart.hoverPoints = null;\n                }\n            }\n            if (point === chart.hoverPoint) {\n                point.onMouseOut();\n            }\n            // Remove properties after animation\n            if (!dataSorting || !dataSorting.enabled) {\n                destroyPoint();\n            }\n            else {\n                this.animateBeforeDestroy();\n                syncTimeout(destroyPoint, animation.duration);\n            }\n            chart.pointCount--;\n        }\n        this.destroyed = true;\n    }\n    /**\n     * Destroy SVG elements associated with the point.\n     *\n     * @private\n     * @function Highcharts.Point#destroyElements\n     * @param {Highcharts.Dictionary<number>} [kinds]\n     */\n    destroyElements(kinds) {\n        const point = this, props = point.getGraphicalProps(kinds);\n        props.singular.forEach(function (prop) {\n            point[prop] = point[prop].destroy();\n        });\n        props.plural.forEach(function (plural) {\n            point[plural].forEach(function (item) {\n                if (item && item.element) {\n                    item.destroy();\n                }\n            });\n            delete point[plural];\n        });\n    }\n    /**\n     * Fire an event on the Point object.\n     *\n     * @private\n     * @function Highcharts.Point#firePointEvent\n     *\n     * @param {string} eventType\n     *        Type of the event.\n     *\n     * @param {Highcharts.Dictionary<any>|Event} [eventArgs]\n     *        Additional event arguments.\n     *\n     * @param {Highcharts.EventCallbackFunction<Highcharts.Point>|Function} [defaultFunction]\n     *        Default event handler.\n     *\n     * @emits Highcharts.Point#event:*\n     */\n    firePointEvent(eventType, eventArgs, defaultFunction) {\n        const point = this, series = this.series, seriesOptions = series.options;\n        // load event handlers on demand to save time on mouseover/out\n        if (seriesOptions.point.events[eventType] ||\n            (point.options &&\n                point.options.events &&\n                point.options.events[eventType])) {\n            point.importEvents();\n        }\n        // add default handler if in selection mode\n        if (eventType === 'click' && seriesOptions.allowPointSelect) {\n            defaultFunction = function (event) {\n                // Control key is for Windows, meta (= Cmd key) for Mac, Shift\n                // for Opera.\n                if (!point.destroyed && point.select) { // #2911, #19075\n                    point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n                }\n            };\n        }\n        fireEvent(point, eventType, eventArgs, defaultFunction);\n    }\n    /**\n     * Get the CSS class names for individual points. Used internally where the\n     * returned value is set on every point.\n     *\n     * @function Highcharts.Point#getClassName\n     *\n     * @return {string}\n     *         The class names.\n     */\n    getClassName() {\n        const point = this;\n        return 'highcharts-point' +\n            (point.selected ? ' highcharts-point-select' : '') +\n            (point.negative ? ' highcharts-negative' : '') +\n            (point.isNull ? ' highcharts-null-point' : '') +\n            (typeof point.colorIndex !== 'undefined' ?\n                ' highcharts-color-' + point.colorIndex : '') +\n            (point.options.className ? ' ' + point.options.className : '') +\n            (point.zone && point.zone.className ? ' ' +\n                point.zone.className.replace('highcharts-negative', '') : '');\n    }\n    /**\n     * Get props of all existing graphical point elements.\n     *\n     * @private\n     * @function Highcharts.Point#getGraphicalProps\n     */\n    getGraphicalProps(kinds) {\n        const point = this, props = [], graphicalProps = { singular: [], plural: [] };\n        let prop, i;\n        kinds = kinds || { graphic: 1, dataLabel: 1 };\n        if (kinds.graphic) {\n            props.push('graphic', 'connector' // Used by dumbbell\n            );\n        }\n        if (kinds.dataLabel) {\n            props.push('dataLabel', 'dataLabelPath', 'dataLabelUpper');\n        }\n        i = props.length;\n        while (i--) {\n            prop = props[i];\n            if (point[prop]) {\n                graphicalProps.singular.push(prop);\n            }\n        }\n        [\n            'graphic',\n            'dataLabel'\n        ].forEach(function (prop) {\n            const plural = prop + 's';\n            if (kinds[prop] && point[plural]) {\n                graphicalProps.plural.push(plural);\n            }\n        });\n        return graphicalProps;\n    }\n    /**\n     * Return the configuration hash needed for the data label and tooltip\n     * formatters.\n     *\n     * @function Highcharts.Point#getLabelConfig\n     *\n     * @return {Highcharts.PointLabelObject}\n     *         Abstract object used in formatters and formats.\n     */\n    getLabelConfig() {\n        return {\n            x: this.category,\n            y: this.y,\n            color: this.color,\n            colorIndex: this.colorIndex,\n            key: this.name || this.category,\n            series: this.series,\n            point: this,\n            percentage: this.percentage,\n            total: this.total || this.stackTotal\n        };\n    }\n    /**\n     * Returns the value of the point property for a given value.\n     * @private\n     */\n    getNestedProperty(key) {\n        if (!key) {\n            return;\n        }\n        if (key.indexOf('custom.') === 0) {\n            return getNestedProperty(key, this.options);\n        }\n        return this[key];\n    }\n    /**\n     * In a series with `zones`, return the zone that the point belongs to.\n     *\n     * @function Highcharts.Point#getZone\n     *\n     * @return {Highcharts.SeriesZonesOptionsObject}\n     *         The zone item.\n     */\n    getZone() {\n        const series = this.series, zones = series.zones, zoneAxis = series.zoneAxis || 'y';\n        let zone, i = 0;\n        zone = zones[i];\n        while (this[zoneAxis] >= zone.value) {\n            zone = zones[++i];\n        }\n        // For resetting or reusing the point (#8100)\n        if (!this.nonZonedColor) {\n            this.nonZonedColor = this.color;\n        }\n        if (zone && zone.color && !this.options.color) {\n            this.color = zone.color;\n        }\n        else {\n            this.color = this.nonZonedColor;\n        }\n        return zone;\n    }\n    /**\n     * Utility to check if point has new shape type. Used in column series and\n     * all others that are based on column series.\n     * @private\n     */\n    hasNewShapeType() {\n        const point = this;\n        const oldShapeType = point.graphic &&\n            (point.graphic.symbolName || point.graphic.element.nodeName);\n        return oldShapeType !== this.shapeType;\n    }\n    /**\n     * Initialize the point. Called internally based on the `series.data`\n     * option.\n     *\n     * @function Highcharts.Point#init\n     *\n     * @param {Highcharts.Series} series\n     *        The series object containing this point.\n     *\n     * @param {Highcharts.PointOptionsType} options\n     *        The data in either number, array or object format.\n     *\n     * @param {number} [x]\n     *        Optionally, the X value of the point.\n     *\n     * @return {Highcharts.Point}\n     *         The Point instance.\n     *\n     * @emits Highcharts.Point#event:afterInit\n     */\n    init(series, options, x) {\n        this.series = series;\n        this.applyOptions(options, x);\n        // Add a unique ID to the point if none is assigned\n        this.id = defined(this.id) ? this.id : uniqueKey();\n        this.resolveColor();\n        series.chart.pointCount++;\n        fireEvent(this, 'afterInit');\n        return this;\n    }\n    /**\n     * Determine if point is valid.\n     * @private\n     * @function Highcharts.Point#isValid\n     */\n    isValid() {\n        return ((isNumber(this.x) ||\n            this.x instanceof Date) &&\n            isNumber(this.y));\n    }\n    /**\n     * Transform number or array configs into objects. Also called for object\n     * configs. Used internally to unify the different configuration formats for\n     * points. For example, a simple number `10` in a line series will be\n     * transformed to `{ y: 10 }`, and an array config like `[1, 10]` in a\n     * scatter series will be transformed to `{ x: 1, y: 10 }`.\n     *\n     * @deprecated\n     * @function Highcharts.Point#optionsToObject\n     *\n     * @param {Highcharts.PointOptionsType} options\n     * Series data options.\n     *\n     * @return {Highcharts.Dictionary<*>}\n     * Transformed point options.\n     */\n    optionsToObject(options) {\n        const series = this.series, keys = series.options.keys, pointArrayMap = keys || series.pointArrayMap || ['y'], valueCount = pointArrayMap.length;\n        let ret = {}, firstItemType, i = 0, j = 0;\n        if (isNumber(options) || options === null) {\n            ret[pointArrayMap[0]] = options;\n        }\n        else if (isArray(options)) {\n            // with leading x value\n            if (!keys && options.length > valueCount) {\n                firstItemType = typeof options[0];\n                if (firstItemType === 'string') {\n                    ret.name = options[0];\n                }\n                else if (firstItemType === 'number') {\n                    ret.x = options[0];\n                }\n                i++;\n            }\n            while (j < valueCount) {\n                // Skip undefined positions for keys\n                if (!keys || typeof options[i] !== 'undefined') {\n                    if (pointArrayMap[j].indexOf('.') > 0) {\n                        // Handle nested keys, e.g. ['color.pattern.image']\n                        // Avoid function call unless necessary.\n                        Point.prototype.setNestedProperty(ret, options[i], pointArrayMap[j]);\n                    }\n                    else {\n                        ret[pointArrayMap[j]] = options[i];\n                    }\n                }\n                i++;\n                j++;\n            }\n        }\n        else if (typeof options === 'object') {\n            ret = options;\n            // This is the fastest way to detect if there are individual point\n            // dataLabels that need to be considered in drawDataLabels. These\n            // can only occur in object configs.\n            if (options.dataLabels) {\n                // Override the prototype function to always return true,\n                // regardless of whether data labels are enabled series-wide\n                series.hasDataLabels = () => true;\n            }\n            // Same approach as above for markers\n            if (options.marker) {\n                series._hasPointMarkers = true;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Get the pixel position of the point relative to the plot area.\n     * @function Highcharts.Point#pos\n     *\n     * @sample highcharts/point/position\n     *         Get point's position in pixels.\n     *\n     * @param {boolean} chartCoordinates\n     * If true, the returned position is relative to the full chart area.\n     * If false, it is relative to the plot area determined by the axes.\n     *\n     * @param {number|undefined} plotY\n     * A custom plot y position to be computed. Used internally for some\n     * series types that have multiple `y` positions, like area range (low\n     * and high values).\n     *\n     * @return {Array<number>|undefined}\n     * Coordinates of the point if the point exists.\n     */\n    pos(chartCoordinates, plotY = this.plotY) {\n        if (!this.destroyed) {\n            const { plotX, series } = this, { chart, xAxis, yAxis } = series;\n            let posX = 0, posY = 0;\n            if (isNumber(plotX) && isNumber(plotY)) {\n                if (chartCoordinates) {\n                    posX = xAxis ? xAxis.pos : chart.plotLeft;\n                    posY = yAxis ? yAxis.pos : chart.plotTop;\n                }\n                return chart.inverted && xAxis && yAxis ?\n                    [yAxis.len - plotY + posY, xAxis.len - plotX + posX] :\n                    [plotX + posX, plotY + posY];\n            }\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.Point#resolveColor\n     */\n    resolveColor() {\n        const series = this.series, optionsChart = series.chart.options.chart, styledMode = series.chart.styledMode;\n        let color, colors, colorCount = optionsChart.colorCount, colorIndex;\n        // remove points nonZonedColor for later recalculation\n        delete this.nonZonedColor;\n        if (series.options.colorByPoint) {\n            if (!styledMode) {\n                colors = series.options.colors || series.chart.options.colors;\n                color = colors[series.colorCounter];\n                colorCount = colors.length;\n            }\n            colorIndex = series.colorCounter;\n            series.colorCounter++;\n            // loop back to zero\n            if (series.colorCounter === colorCount) {\n                series.colorCounter = 0;\n            }\n        }\n        else {\n            if (!styledMode) {\n                color = series.color;\n            }\n            colorIndex = series.colorIndex;\n        }\n        /**\n         * The point's current color index, used in styled mode instead of\n         * `color`. The color index is inserted in class names used for styling.\n         *\n         * @name Highcharts.Point#colorIndex\n         * @type {number|undefined}\n         */\n        this.colorIndex = pick(this.options.colorIndex, colorIndex);\n        /**\n         * The point's current color.\n         *\n         * @name Highcharts.Point#color\n         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject|undefined}\n         */\n        this.color = pick(this.options.color, color);\n    }\n    /**\n     * Set a value in an object, on the property defined by key. The key\n     * supports nested properties using dot notation. The function modifies the\n     * input object and does not make a copy.\n     *\n     * @function Highcharts.Point#setNestedProperty<T>\n     *\n     * @param {T} object\n     *        The object to set the value on.\n     *\n     * @param {*} value\n     *        The value to set.\n     *\n     * @param {string} key\n     *        Key to the property to set.\n     *\n     * @return {T}\n     *         The modified object.\n     */\n    setNestedProperty(object, value, key) {\n        const nestedKeys = key.split('.');\n        nestedKeys.reduce(function (result, key, i, arr) {\n            const isLastKey = arr.length - 1 === i;\n            result[key] = (isLastKey ?\n                value :\n                isObject(result[key], true) ?\n                    result[key] :\n                    {});\n            return result[key];\n        }, object);\n        return object;\n    }\n    shouldDraw() {\n        return !this.isNull;\n    }\n    /**\n     * Extendable method for formatting each point's tooltip line.\n     *\n     * @function Highcharts.Point#tooltipFormatter\n     *\n     * @param {string} pointFormat\n     *        The point format.\n     *\n     * @return {string}\n     *         A string to be concatenated in to the common tooltip text.\n     */\n    tooltipFormatter(pointFormat) {\n        // Insert options for valueDecimals, valuePrefix, and valueSuffix\n        const series = this.series, seriesTooltipOptions = series.tooltipOptions, valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''), valuePrefix = seriesTooltipOptions.valuePrefix || '', valueSuffix = seriesTooltipOptions.valueSuffix || '';\n        // Replace default point style with class name\n        if (series.chart.styledMode) {\n            pointFormat =\n                series.chart.tooltip.styledModeFormat(pointFormat);\n        }\n        // Loop over the point array map and replace unformatted values with\n        // sprintf formatting markup\n        (series.pointArrayMap || ['y']).forEach(function (key) {\n            key = '{point.' + key; // without the closing bracket\n            if (valuePrefix || valueSuffix) {\n                pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), valuePrefix + key + '}' + valueSuffix);\n            }\n            pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), key + ':,.' + valueDecimals + 'f}');\n        });\n        return format(pointFormat, {\n            point: this,\n            series: this.series\n        }, series.chart);\n    }\n    /**\n     * Update point with new options (typically x/y data) and optionally redraw\n     * the series.\n     *\n     * @sample highcharts/members/point-update-column/\n     *         Update column value\n     * @sample highcharts/members/point-update-pie/\n     *         Update pie slice\n     * @sample maps/members/point-update/\n     *         Update map area value in Highmaps\n     *\n     * @function Highcharts.Point#update\n     *\n     * @param {Highcharts.PointOptionsType} options\n     *        The point options. Point options are handled as described under\n     *        the `series.type.data` item for each series type. For example\n     *        for a line series, if options is a single number, the point will\n     *        be given that number as the marin y value. If it is an array, it\n     *        will be interpreted as x and y values respectively. If it is an\n     *        object, advanced options are applied.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart after the point is updated. If doing\n     *        more operations on the chart, it is best practice to set\n     *        `redraw` to false and call `chart.redraw()` after.\n     *\n     * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=true]\n     *        Whether to apply animation, and optionally animation\n     *        configuration.\n     *\n     * @emits Highcharts.Point#event:update\n     */\n    update(options, redraw, animation, runEvent) {\n        const point = this, series = point.series, graphic = point.graphic, chart = series.chart, seriesOptions = series.options;\n        let i;\n        redraw = pick(redraw, true);\n        /**\n         * @private\n         */\n        function update() {\n            point.applyOptions(options);\n            // Update visuals, #4146\n            // Handle mock graphic elements for a11y, #12718\n            const hasMockGraphic = graphic && point.hasMockGraphic;\n            const shouldDestroyGraphic = point.y === null ?\n                !hasMockGraphic :\n                hasMockGraphic;\n            if (graphic && shouldDestroyGraphic) {\n                point.graphic = graphic.destroy();\n                delete point.hasMockGraphic;\n            }\n            if (isObject(options, true)) {\n                // Destroy so we can get new elements\n                if (graphic && graphic.element) {\n                    // \"null\" is also a valid symbol\n                    if (options &&\n                        options.marker &&\n                        typeof options.marker.symbol !== 'undefined') {\n                        point.graphic = graphic.destroy();\n                    }\n                }\n                if (options?.dataLabels && point.dataLabel) {\n                    point.dataLabel = point.dataLabel.destroy(); // #2468\n                }\n            }\n            // record changes in the parallel arrays\n            i = point.index;\n            series.updateParallelArrays(point, i);\n            // Record the options to options.data. If the old or the new config\n            // is an object, use point options, otherwise use raw options\n            // (#4701, #4916).\n            seriesOptions.data[i] = (isObject(seriesOptions.data[i], true) ||\n                isObject(options, true)) ?\n                point.options :\n                pick(options, seriesOptions.data[i]);\n            // redraw\n            series.isDirty = series.isDirtyData = true;\n            if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320\n                chart.isDirtyBox = true;\n            }\n            if (seriesOptions.legendType === 'point') { // #1831, #1885\n                chart.isDirtyLegend = true;\n            }\n            if (redraw) {\n                chart.redraw(animation);\n            }\n        }\n        // Fire the event with a default handler of doing the update\n        if (runEvent === false) { // When called from setData\n            update();\n        }\n        else {\n            point.firePointEvent('update', { options: options }, update);\n        }\n    }\n    /**\n     * Remove a point and optionally redraw the series and if necessary the axes\n     *\n     * @sample highcharts/plotoptions/series-point-events-remove/\n     *         Remove point and confirm\n     * @sample highcharts/members/point-remove/\n     *         Remove pie slice\n     * @sample maps/members/point-remove/\n     *         Remove selected points in Highmaps\n     *\n     * @function Highcharts.Point#remove\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart or wait for an explicit call. When\n     *        doing more operations on the chart, for example running\n     *        `point.remove()` in a loop, it is best practice to set `redraw`\n     *        to false and call `chart.redraw()` after.\n     *\n     * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=false]\n     *        Whether to apply animation, and optionally animation\n     *        configuration.\n     */\n    remove(redraw, animation) {\n        this.series.removePoint(this.series.data.indexOf(this), redraw, animation);\n    }\n    /**\n     * Toggle the selection status of a point.\n     *\n     * @see Highcharts.Chart#getSelectedPoints\n     *\n     * @sample highcharts/members/point-select/\n     *         Select a point from a button\n     * @sample highcharts/chart/events-selection-points/\n     *         Select a range of points through a drag selection\n     * @sample maps/series/data-id/\n     *         Select a point in Highmaps\n     *\n     * @function Highcharts.Point#select\n     *\n     * @param {boolean} [selected]\n     * When `true`, the point is selected. When `false`, the point is\n     * unselected. When `null` or `undefined`, the selection state is toggled.\n     *\n     * @param {boolean} [accumulate=false]\n     * When `true`, the selection is added to other selected points.\n     * When `false`, other selected points are deselected. Internally in\n     * Highcharts, when\n     * [allowPointSelect](https://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect)\n     * is `true`, selected points are accumulated on Control, Shift or Cmd\n     * clicking the point.\n     *\n     * @emits Highcharts.Point#event:select\n     * @emits Highcharts.Point#event:unselect\n     */\n    select(selected, accumulate) {\n        const point = this, series = point.series, chart = series.chart;\n        selected = pick(selected, !point.selected);\n        this.selectedStaging = selected;\n        // fire the event with the default handler\n        point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {\n            /**\n             * Whether the point is selected or not.\n             *\n             * @see Point#select\n             * @see Chart#getSelectedPoints\n             *\n             * @name Highcharts.Point#selected\n             * @type {boolean}\n             */\n            point.selected = point.options.selected = selected;\n            series.options.data[series.data.indexOf(point)] =\n                point.options;\n            point.setState(selected && 'select');\n            // unselect all other points unless Ctrl or Cmd + click\n            if (!accumulate) {\n                chart.getSelectedPoints().forEach(function (loopPoint) {\n                    const loopSeries = loopPoint.series;\n                    if (loopPoint.selected && loopPoint !== point) {\n                        loopPoint.selected = loopPoint.options.selected =\n                            false;\n                        loopSeries.options.data[loopSeries.data.indexOf(loopPoint)] = loopPoint.options;\n                        // Programatically selecting a point should restore\n                        // normal state, but when click happened on other\n                        // point, set inactive state to match other points\n                        loopPoint.setState(chart.hoverPoints &&\n                            loopSeries.options.inactiveOtherPoints ?\n                            'inactive' : '');\n                        loopPoint.firePointEvent('unselect');\n                    }\n                });\n            }\n        });\n        delete this.selectedStaging;\n    }\n    /**\n     * Runs on mouse over the point. Called internally from mouse and touch\n     * events.\n     *\n     * @function Highcharts.Point#onMouseOver\n     *\n     * @param {Highcharts.PointerEventObject} [e]\n     *        The event arguments.\n     */\n    onMouseOver(e) {\n        const point = this, series = point.series, chart = series.chart, pointer = chart.pointer;\n        e = e ?\n            pointer.normalize(e) :\n            // In cases where onMouseOver is called directly without an event\n            pointer.getChartCoordinatesFromPoint(point, chart.inverted);\n        pointer.runPointActions(e, point);\n    }\n    /**\n     * Runs on mouse out from the point. Called internally from mouse and touch\n     * events.\n     *\n     * @function Highcharts.Point#onMouseOut\n     * @emits Highcharts.Point#event:mouseOut\n     */\n    onMouseOut() {\n        const point = this, chart = point.series.chart;\n        point.firePointEvent('mouseOut');\n        if (!point.series.options.inactiveOtherPoints) {\n            (chart.hoverPoints || []).forEach(function (p) {\n                p.setState();\n            });\n        }\n        chart.hoverPoints = chart.hoverPoint = null;\n    }\n    /**\n     * Import events from the series' and point's options. Only do it on\n     * demand, to save processing time on hovering.\n     *\n     * @private\n     * @function Highcharts.Point#importEvents\n     */\n    importEvents() {\n        if (!this.hasImportedEvents) {\n            const point = this, options = merge(point.series.options.point, point.options), events = options.events;\n            point.events = events;\n            objectEach(events, function (event, eventType) {\n                if (isFunction(event)) {\n                    addEvent(point, eventType, event);\n                }\n            });\n            this.hasImportedEvents = true;\n        }\n    }\n    /**\n     * Set the point's state.\n     *\n     * @function Highcharts.Point#setState\n     *\n     * @param {Highcharts.PointStateValue|\"\"} [state]\n     *        The new state, can be one of `'hover'`, `'select'`, `'inactive'`,\n     *        or `''` (an empty string), `'normal'` or `undefined` to set to\n     *        normal state.\n     * @param {boolean} [move]\n     *        State for animation.\n     *\n     * @emits Highcharts.Point#event:afterSetState\n     */\n    setState(state, move) {\n        const point = this, series = point.series, previousState = point.state, stateOptions = (series.options.states[state || 'normal'] ||\n            {}), markerOptions = (defaultOptions.plotOptions[series.type].marker &&\n            series.options.marker), normalDisabled = (markerOptions && markerOptions.enabled === false), markerStateOptions = ((markerOptions &&\n            markerOptions.states &&\n            markerOptions.states[state || 'normal']) || {}), stateDisabled = markerStateOptions.enabled === false, pointMarker = point.marker || {}, chart = series.chart, hasMarkers = (markerOptions && series.markerAttribs);\n        let halo = series.halo, markerAttribs, pointAttribs, pointAttribsAnimation, stateMarkerGraphic = series.stateMarkerGraphic, newSymbol;\n        state = state || ''; // empty string\n        if (\n        // already has this state\n        (state === point.state && !move) ||\n            // selected points don't respond to hover\n            (point.selected && state !== 'select') ||\n            // series' state options is disabled\n            (stateOptions.enabled === false) ||\n            // general point marker's state options is disabled\n            (state && (stateDisabled ||\n                (normalDisabled &&\n                    markerStateOptions.enabled === false))) ||\n            // individual point marker's state options is disabled\n            (state &&\n                pointMarker.states &&\n                pointMarker.states[state] &&\n                pointMarker.states[state].enabled === false) // #1610\n        ) {\n            return;\n        }\n        point.state = state;\n        if (hasMarkers) {\n            markerAttribs = series.markerAttribs(point, state);\n        }\n        // Apply hover styles to the existing point\n        // Prevent from mocked null points (#14966)\n        if (point.graphic && !point.hasMockGraphic) {\n            if (previousState) {\n                point.graphic.removeClass('highcharts-point-' + previousState);\n            }\n            if (state) {\n                point.graphic.addClass('highcharts-point-' + state);\n            }\n            if (!chart.styledMode) {\n                pointAttribs = series.pointAttribs(point, state);\n                pointAttribsAnimation = pick(chart.options.chart.animation, stateOptions.animation);\n                const opacity = pointAttribs.opacity;\n                // Some inactive points (e.g. slices in pie) should apply\n                // opacity also for their labels\n                if (series.options.inactiveOtherPoints && isNumber(opacity)) {\n                    (point.dataLabels || []).forEach(function (label) {\n                        if (label &&\n                            !label.hasClass('highcharts-data-label-hidden')) {\n                            label.animate({ opacity }, pointAttribsAnimation);\n                            if (label.connector) {\n                                label.connector.animate({ opacity }, pointAttribsAnimation);\n                            }\n                        }\n                    });\n                }\n                point.graphic.animate(pointAttribs, pointAttribsAnimation);\n            }\n            if (markerAttribs) {\n                point.graphic.animate(markerAttribs, pick(\n                // Turn off globally:\n                chart.options.chart.animation, markerStateOptions.animation, markerOptions.animation));\n            }\n            // Zooming in from a range with no markers to a range with markers\n            if (stateMarkerGraphic) {\n                stateMarkerGraphic.hide();\n            }\n        }\n        else {\n            // if a graphic is not applied to each point in the normal state,\n            // create a shared graphic for the hover state\n            if (state && markerStateOptions) {\n                newSymbol = pointMarker.symbol || series.symbol;\n                // If the point has another symbol than the previous one, throw\n                // away the state marker graphic and force a new one (#1459)\n                if (stateMarkerGraphic &&\n                    stateMarkerGraphic.currentSymbol !== newSymbol) {\n                    stateMarkerGraphic = stateMarkerGraphic.destroy();\n                }\n                // Add a new state marker graphic\n                if (markerAttribs) {\n                    if (!stateMarkerGraphic) {\n                        if (newSymbol) {\n                            series.stateMarkerGraphic = stateMarkerGraphic =\n                                chart.renderer\n                                    .symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height)\n                                    .add(series.markerGroup);\n                            stateMarkerGraphic.currentSymbol = newSymbol;\n                        }\n                        // Move the existing graphic\n                    }\n                    else {\n                        stateMarkerGraphic[move ? 'animate' : 'attr']({\n                            x: markerAttribs.x,\n                            y: markerAttribs.y\n                        });\n                    }\n                }\n                if (!chart.styledMode && stateMarkerGraphic &&\n                    point.state !== 'inactive') {\n                    stateMarkerGraphic.attr(series.pointAttribs(point, state));\n                }\n            }\n            if (stateMarkerGraphic) {\n                stateMarkerGraphic[state && point.isInside ? 'show' : 'hide'](); // #2450\n                stateMarkerGraphic.element.point = point; // #4310\n                stateMarkerGraphic.addClass(point.getClassName(), true);\n            }\n        }\n        // Show me your halo\n        const haloOptions = stateOptions.halo;\n        const markerGraphic = (point.graphic || stateMarkerGraphic);\n        const markerVisibility = (markerGraphic && markerGraphic.visibility || 'inherit');\n        if (haloOptions &&\n            haloOptions.size &&\n            markerGraphic &&\n            markerVisibility !== 'hidden' &&\n            !point.isCluster) {\n            if (!halo) {\n                series.halo = halo = chart.renderer.path()\n                    // #5818, #5903, #6705\n                    .add(markerGraphic.parentGroup);\n            }\n            halo.show()[move ? 'animate' : 'attr']({\n                d: point.haloPath(haloOptions.size)\n            });\n            halo.attr({\n                'class': 'highcharts-halo highcharts-color-' +\n                    pick(point.colorIndex, series.colorIndex) +\n                    (point.className ? ' ' + point.className : ''),\n                'visibility': markerVisibility,\n                'zIndex': -1 // #4929, #8276\n            });\n            halo.point = point; // #6055\n            if (!chart.styledMode) {\n                halo.attr(extend({\n                    'fill': point.color || series.color,\n                    'fill-opacity': haloOptions.opacity\n                }, AST.filterUserAttributes(haloOptions.attributes || {})));\n            }\n        }\n        else if (halo && halo.point && halo.point.haloPath) {\n            // Animate back to 0 on the current halo point (#6055)\n            halo.animate({ d: halo.point.haloPath(0) }, null, \n            // Hide after unhovering. The `complete` callback runs in the\n            // halo's context (#7681).\n            halo.hide);\n        }\n        fireEvent(point, 'afterSetState', { state });\n    }\n    /**\n     * Get the path definition for the halo, which is usually a shadow-like\n     * circle around the currently hovered point.\n     *\n     * @function Highcharts.Point#haloPath\n     *\n     * @param {number} size\n     *        The radius of the circular halo.\n     *\n     * @return {Highcharts.SVGPathArray}\n     *         The path definition.\n     */\n    haloPath(size) {\n        const pos = this.pos();\n        return pos ? this.series.chart.renderer.symbols.circle(Math.floor(pos[0]) - size, pos[1] - size, size * 2, size * 2) : [];\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default Point;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Function callback when a series point is clicked. Return false to cancel the\n * action.\n *\n * @callback Highcharts.PointClickCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        The point where the event occured.\n *\n * @param {Highcharts.PointClickEventObject} event\n *        Event arguments.\n */\n/**\n * Common information for a click event on a series point.\n *\n * @interface Highcharts.PointClickEventObject\n * @extends Highcharts.PointerEventObject\n */ /**\n* Clicked point.\n* @name Highcharts.PointClickEventObject#point\n* @type {Highcharts.Point}\n*/\n/**\n * Configuration for the data label and tooltip formatters.\n *\n * @interface Highcharts.PointLabelObject\n */ /**\n* The point's current color.\n* @name Highcharts.PointLabelObject#color\n* @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject|undefined}\n*/ /**\n* The point's current color index, used in styled mode instead of `color`. The\n* color index is inserted in class names used for styling.\n* @name Highcharts.PointLabelObject#colorIndex\n* @type {number}\n*/ /**\n* The name of the related point.\n* @name Highcharts.PointLabelObject#key\n* @type {string|undefined}\n*/ /**\n* The percentage for related points in a stacked series or pies.\n* @name Highcharts.PointLabelObject#percentage\n* @type {number}\n*/ /**\n* The related point. The point name, if defined, is available through\n* `this.point.name`.\n* @name Highcharts.PointLabelObject#point\n* @type {Highcharts.Point}\n*/ /**\n* The related series. The series name is available through `this.series.name`.\n* @name Highcharts.PointLabelObject#series\n* @type {Highcharts.Series}\n*/ /**\n* The total of values in either a stack for stacked series, or a pie in a pie\n* series.\n* @name Highcharts.PointLabelObject#total\n* @type {number|undefined}\n*/ /**\n* For categorized axes this property holds the category name for the point. For\n* other axes it holds the X value.\n* @name Highcharts.PointLabelObject#x\n* @type {number|string|undefined}\n*/ /**\n* The y value of the point.\n* @name Highcharts.PointLabelObject#y\n* @type {number|null|undefined}\n*/\n/**\n * Gets fired when the mouse leaves the area close to the point.\n *\n * @callback Highcharts.PointMouseOutCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        Point where the event occured.\n *\n * @param {global.PointerEvent} event\n *        Event that occured.\n */\n/**\n * Gets fired when the mouse enters the area close to the point.\n *\n * @callback Highcharts.PointMouseOverCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        Point where the event occured.\n *\n * @param {global.Event} event\n *        Event that occured.\n */\n/**\n * The generic point options for all series.\n *\n * In TypeScript you have to extend `PointOptionsObject` with an additional\n * declaration to allow custom data options:\n *\n * ```\n * declare interface PointOptionsObject {\n *     customProperty: string;\n * }\n * ```\n *\n * @interface Highcharts.PointOptionsObject\n */\n/**\n * Possible option types for a data point. Use `null` to indicate a gap.\n *\n * @typedef {number|string|Highcharts.PointOptionsObject|Array<(number|string|null)>|null} Highcharts.PointOptionsType\n */\n/**\n * Gets fired when the point is removed using the `.remove()` method.\n *\n * @callback Highcharts.PointRemoveCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        Point where the event occured.\n *\n * @param {global.Event} event\n *        Event that occured.\n */\n/**\n * Possible key values for the point state options.\n *\n * @typedef {\"hover\"|\"inactive\"|\"normal\"|\"select\"} Highcharts.PointStateValue\n */\n/**\n * Gets fired when the point is updated programmatically through the `.update()`\n * method.\n *\n * @callback Highcharts.PointUpdateCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        Point where the event occured.\n *\n * @param {Highcharts.PointUpdateEventObject} event\n *        Event that occured.\n */\n/**\n * Information about the update event.\n *\n * @interface Highcharts.PointUpdateEventObject\n * @extends global.Event\n */ /**\n* Options data of the update event.\n* @name Highcharts.PointUpdateEventObject#options\n* @type {Highcharts.PointOptionsType}\n*/\n/**\n * @interface Highcharts.PointEventsOptionsObject\n */ /**\n* Fires when the point is selected either programmatically or following a click\n* on the point. One parameter, `event`, is passed to the function. Returning\n* `false` cancels the operation.\n* @name Highcharts.PointEventsOptionsObject#select\n* @type {Highcharts.PointSelectCallbackFunction|undefined}\n*/ /**\n* Fires when the point is unselected either programmatically or following a\n* click on the point. One parameter, `event`, is passed to the function.\n* Returning `false` cancels the operation.\n* @name Highcharts.PointEventsOptionsObject#unselect\n* @type {Highcharts.PointUnselectCallbackFunction|undefined}\n*/\n/**\n * Information about the select/unselect event.\n *\n * @interface Highcharts.PointInteractionEventObject\n * @extends global.Event\n */ /**\n* @name Highcharts.PointInteractionEventObject#accumulate\n* @type {boolean}\n*/\n/**\n * Gets fired when the point is selected either programmatically or following a\n * click on the point.\n *\n * @callback Highcharts.PointSelectCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        Point where the event occured.\n *\n * @param {Highcharts.PointInteractionEventObject} event\n *        Event that occured.\n */\n/**\n * Fires when the point is unselected either programmatically or following a\n * click on the point.\n *\n * @callback Highcharts.PointUnselectCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        Point where the event occured.\n *\n * @param {Highcharts.PointInteractionEventObject} event\n *        Event that occured.\n */\n''; // keeps doclets above in JS file.\n"],"mappings":"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AAM,CAAC,CAAC;EAChD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI4L,QAAQA,CAACN,IAAI,EAAE;IACX,MAAMtG,GAAG,GAAG,IAAI,CAACA,GAAG,CAAC,CAAC;IACtB,OAAOA,GAAG,GAAG,IAAI,CAAC7G,MAAM,CAACqC,KAAK,CAACI,QAAQ,CAACmL,OAAO,CAACC,MAAM,CAACC,IAAI,CAACC,KAAK,CAAClH,GAAG,CAAC,CAAC,CAAC,CAAC,GAAGsG,IAAI,EAAEtG,GAAG,CAAC,CAAC,CAAC,GAAGsG,IAAI,EAAEA,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAG,CAAC,CAAC,GAAG,EAAE;EAC7H;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,eAAe9N,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GALA,CAKI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA;AACA,SALG,CAKA;AACH;AACA;AACA;AACA,YAJG,CAIA;AACH;AACA;AACA;AACA,eAJG,CAIA;AACH;AACA;AACA;AACA;AACA,kBALG,CAKA;AACH;AACA;AACA;AACA,qBAJG,CAIA;AACH;AACA;AACA;AACA;AACA,wBALG,CAKA;AACH;AACA;AACA;AACA;AACA,2BALG,CAKA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GALA,CAKI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAFA,CAEI;AACJ;AACA;AACA;AACA;AACA;AACA,MANI,CAMD;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GALA,CAKI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}