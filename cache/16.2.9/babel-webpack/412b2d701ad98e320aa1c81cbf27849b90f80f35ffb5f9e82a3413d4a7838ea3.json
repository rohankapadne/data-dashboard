{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\n/* *\n *\n *  Imports\n *\n * */\nimport U from '../Utilities.js';\nconst {\n  clamp,\n  pick,\n  pushUnique,\n  stableSort\n} = U;\n/* *\n *\n *  Namespace\n *\n * */\nvar RendererUtilities;\n(function (RendererUtilities) {\n  /* *\n   *\n   *  Declarations\n   *\n   * */\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /* eslint-disable valid-jsdoc */\n  /**\n   * General distribution algorithm for distributing labels of differing size\n   * along a confined length in two dimensions. The algorithm takes an array\n   * of objects containing a size, a target and a rank. It will place the\n   * labels as close as possible to their targets, skipping the lowest ranked\n   * labels if necessary.\n   * @private\n   */\n  function distribute(boxes, len, maxDistance) {\n    // Original array will be altered with added .pos\n    const origBoxes = boxes,\n      reducedLen = origBoxes.reducedLen || len,\n      sortByRank = (a, b) => (b.rank || 0) - (a.rank || 0),\n      sortByTarget = (a, b) => a.target - b.target,\n      restBoxes = [],\n      // The outranked overshoot\n      boxesLength = boxes.length,\n      forDeletion = [],\n      push = restBoxes.push;\n    let i,\n      cursor,\n      step,\n      overlapping = true,\n      box,\n      target,\n      total = 0,\n      equalRank;\n    // If the total size exceeds the len, remove those boxes with the lowest\n    // rank\n    i = boxesLength;\n    while (i--) {\n      total += boxes[i].size;\n    }\n    // Sort by rank, then slice away overshoot\n    if (total > reducedLen) {\n      stableSort(boxes, sortByRank);\n      equalRank = boxes[0].rank === boxes[boxes.length - 1].rank;\n      step = equalRank ? boxesLength / 2 : -1;\n      cursor = equalRank ? step : boxesLength - 1;\n      // When the boxes have equal rank (pie data labels, flags - #10073),\n      // decimate the boxes by starting in the middle and gradually remove\n      // more items inside the array. When they are sorted by rank, just\n      // remove the ones with the lowest rank from the end.\n      while (step && total > reducedLen) {\n        i = Math.floor(cursor);\n        box = boxes[i];\n        if (pushUnique(forDeletion, i)) {\n          total -= box.size;\n        }\n        cursor += step;\n        // Start over the decimation with smaller steps\n        if (equalRank && cursor >= boxes.length) {\n          step /= 2;\n          cursor = step;\n        }\n      }\n      // Clean out the boxes marked for deletion\n      forDeletion.sort((a, b) => b - a).forEach(i => push.apply(restBoxes, boxes.splice(i, 1)));\n    }\n    // Order by target\n    stableSort(boxes, sortByTarget);\n    // So far we have been mutating the original array. Now\n    // create a copy with target arrays\n    boxes = boxes.map(box => ({\n      size: box.size,\n      targets: [box.target],\n      align: pick(box.align, 0.5)\n    }));\n    while (overlapping) {\n      // Initial positions: target centered in box\n      i = boxes.length;\n      while (i--) {\n        box = boxes[i];\n        // Composite box, average of targets\n        target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;\n        box.pos = clamp(target - box.size * box.align, 0, len - box.size);\n      }\n      // Detect overlap and join boxes\n      i = boxes.length;\n      overlapping = false;\n      while (i--) {\n        // Overlap\n        if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) {\n          // Add this size to the previous box\n          boxes[i - 1].size += boxes[i].size;\n          boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);\n          boxes[i - 1].align = 0.5;\n          // Overlapping right, push left\n          if (boxes[i - 1].pos + boxes[i - 1].size > len) {\n            boxes[i - 1].pos = len - boxes[i - 1].size;\n          }\n          boxes.splice(i, 1); // Remove this item\n          overlapping = true;\n        }\n      }\n    }\n    // Add the rest (hidden boxes)\n    push.apply(origBoxes, restBoxes);\n    // Now the composite boxes are placed, we need to put the original boxes\n    // within them\n    i = 0;\n    boxes.some(box => {\n      let posInCompositeBox = 0;\n      // Exceeded maxDistance => abort\n      return (box.targets || []).some(() => {\n        origBoxes[i].pos = box.pos + posInCompositeBox;\n        // If the distance between the position and the target exceeds\n        // maxDistance, abort the loop and decrease the length in\n        // increments of 10% to recursively reduce the  number of\n        // visible boxes by rank. Once all boxes are within the\n        // maxDistance, we're good.\n        if (typeof maxDistance !== 'undefined' && Math.abs(origBoxes[i].pos - origBoxes[i].target) > maxDistance) {\n          // Reset the positions that are already set\n          origBoxes.slice(0, i + 1).forEach(box => delete box.pos);\n          // Try with a smaller length\n          origBoxes.reducedLen = (origBoxes.reducedLen || len) - len * 0.1;\n          // Recurse\n          if (origBoxes.reducedLen > len * 0.1) {\n            distribute(origBoxes, len, maxDistance);\n          }\n          // Exceeded maxDistance => abort\n          return true;\n        }\n        posInCompositeBox += origBoxes[i].size;\n        i++;\n        return false;\n      });\n    });\n    // Add the rest (hidden) boxes and sort by target\n    stableSort(origBoxes, sortByTarget);\n    return origBoxes;\n  }\n  RendererUtilities.distribute = distribute;\n})(RendererUtilities || (RendererUtilities = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default RendererUtilities;","map":{"version":3,"names":["U","clamp","pick","pushUnique","stableSort","RendererUtilities","distribute","boxes","len","maxDistance","origBoxes","reducedLen","sortByRank","a","b","rank","sortByTarget","target","restBoxes","boxesLength","length","forDeletion","push","i","cursor","step","overlapping","box","total","equalRank","size","Math","floor","sort","forEach","apply","splice","map","targets","align","min","max","pos","concat","some","posInCompositeBox","abs","slice"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Renderer/RendererUtilities.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n/* *\n *\n *  Imports\n *\n * */\nimport U from '../Utilities.js';\nconst { clamp, pick, pushUnique, stableSort } = U;\n/* *\n *\n *  Namespace\n *\n * */\nvar RendererUtilities;\n(function (RendererUtilities) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * General distribution algorithm for distributing labels of differing size\n     * along a confined length in two dimensions. The algorithm takes an array\n     * of objects containing a size, a target and a rank. It will place the\n     * labels as close as possible to their targets, skipping the lowest ranked\n     * labels if necessary.\n     * @private\n     */\n    function distribute(boxes, len, maxDistance) {\n        // Original array will be altered with added .pos\n        const origBoxes = boxes, reducedLen = origBoxes.reducedLen || len, sortByRank = (a, b) => (b.rank || 0) - (a.rank || 0), sortByTarget = (a, b) => a.target - b.target, restBoxes = [], // The outranked overshoot\n        boxesLength = boxes.length, forDeletion = [], push = restBoxes.push;\n        let i, cursor, step, overlapping = true, box, target, total = 0, equalRank;\n        // If the total size exceeds the len, remove those boxes with the lowest\n        // rank\n        i = boxesLength;\n        while (i--) {\n            total += boxes[i].size;\n        }\n        // Sort by rank, then slice away overshoot\n        if (total > reducedLen) {\n            stableSort(boxes, sortByRank);\n            equalRank = boxes[0].rank === boxes[boxes.length - 1].rank;\n            step = equalRank ? boxesLength / 2 : -1;\n            cursor = equalRank ? step : boxesLength - 1;\n            // When the boxes have equal rank (pie data labels, flags - #10073),\n            // decimate the boxes by starting in the middle and gradually remove\n            // more items inside the array. When they are sorted by rank, just\n            // remove the ones with the lowest rank from the end.\n            while (step && total > reducedLen) {\n                i = Math.floor(cursor);\n                box = boxes[i];\n                if (pushUnique(forDeletion, i)) {\n                    total -= box.size;\n                }\n                cursor += step;\n                // Start over the decimation with smaller steps\n                if (equalRank && cursor >= boxes.length) {\n                    step /= 2;\n                    cursor = step;\n                }\n            }\n            // Clean out the boxes marked for deletion\n            forDeletion\n                .sort((a, b) => b - a)\n                .forEach((i) => push.apply(restBoxes, boxes.splice(i, 1)));\n        }\n        // Order by target\n        stableSort(boxes, sortByTarget);\n        // So far we have been mutating the original array. Now\n        // create a copy with target arrays\n        boxes = boxes.map((box) => ({\n            size: box.size,\n            targets: [box.target],\n            align: pick(box.align, 0.5)\n        }));\n        while (overlapping) {\n            // Initial positions: target centered in box\n            i = boxes.length;\n            while (i--) {\n                box = boxes[i];\n                // Composite box, average of targets\n                target = (Math.min.apply(0, box.targets) +\n                    Math.max.apply(0, box.targets)) / 2;\n                box.pos = clamp(target - box.size * box.align, 0, len - box.size);\n            }\n            // Detect overlap and join boxes\n            i = boxes.length;\n            overlapping = false;\n            while (i--) {\n                // Overlap\n                if (i > 0 &&\n                    boxes[i - 1].pos + boxes[i - 1].size >\n                        boxes[i].pos) {\n                    // Add this size to the previous box\n                    boxes[i - 1].size += boxes[i].size;\n                    boxes[i - 1].targets = boxes[i - 1]\n                        .targets\n                        .concat(boxes[i].targets);\n                    boxes[i - 1].align = 0.5;\n                    // Overlapping right, push left\n                    if (boxes[i - 1].pos + boxes[i - 1].size > len) {\n                        boxes[i - 1].pos = len - boxes[i - 1].size;\n                    }\n                    boxes.splice(i, 1); // Remove this item\n                    overlapping = true;\n                }\n            }\n        }\n        // Add the rest (hidden boxes)\n        push.apply(origBoxes, restBoxes);\n        // Now the composite boxes are placed, we need to put the original boxes\n        // within them\n        i = 0;\n        boxes.some((box) => {\n            let posInCompositeBox = 0;\n            // Exceeded maxDistance => abort\n            return (box.targets || []).some(() => {\n                origBoxes[i].pos = box.pos + posInCompositeBox;\n                // If the distance between the position and the target exceeds\n                // maxDistance, abort the loop and decrease the length in\n                // increments of 10% to recursively reduce the  number of\n                // visible boxes by rank. Once all boxes are within the\n                // maxDistance, we're good.\n                if (typeof maxDistance !== 'undefined' &&\n                    Math.abs(origBoxes[i].pos - origBoxes[i].target) > maxDistance) {\n                    // Reset the positions that are already set\n                    origBoxes\n                        .slice(0, i + 1)\n                        .forEach((box) => delete box.pos);\n                    // Try with a smaller length\n                    origBoxes.reducedLen =\n                        (origBoxes.reducedLen || len) - (len * 0.1);\n                    // Recurse\n                    if (origBoxes.reducedLen > len * 0.1) {\n                        distribute(origBoxes, len, maxDistance);\n                    }\n                    // Exceeded maxDistance => abort\n                    return true;\n                }\n                posInCompositeBox += origBoxes[i].size;\n                i++;\n                return false;\n            });\n        });\n        // Add the rest (hidden) boxes and sort by target\n        stableSort(origBoxes, sortByTarget);\n        return origBoxes;\n    }\n    RendererUtilities.distribute = distribute;\n})(RendererUtilities || (RendererUtilities = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default RendererUtilities;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}