{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport F from '../Templating.js';\nimport H from '../Globals.js';\nconst {\n  deg2rad\n} = H;\nimport U from '../Utilities.js';\nconst {\n  clamp,\n  correctFloat,\n  defined,\n  destroyObjectProperties,\n  extend,\n  fireEvent,\n  isNumber,\n  merge,\n  objectEach,\n  pick\n} = U;\n/* *\n *\n *  Class\n *\n * */\n/* eslint-disable no-invalid-this, valid-jsdoc */\n/**\n * The Tick class.\n *\n * @class\n * @name Highcharts.Tick\n *\n * @param {Highcharts.Axis} axis\n * The axis of the tick.\n *\n * @param {number} pos\n * The position of the tick on the axis in terms of axis values.\n *\n * @param {string} [type]\n * The type of tick, either 'minor' or an empty string\n *\n * @param {boolean} [noLabel=false]\n * Whether to disable the label or not. Defaults to false.\n *\n * @param {Object} [parameters]\n * Optional parameters for the tick.\n */\nclass Tick {\n  /* *\n   *\n   *  Constructors\n   *\n   * */\n  constructor(axis, pos, type, noLabel, parameters) {\n    this.isNew = true;\n    this.isNewLabel = true;\n    /**\n     * The related axis of the tick.\n     * @name Highcharts.Tick#axis\n     * @type {Highcharts.Axis}\n     */\n    this.axis = axis;\n    /**\n     * The logical position of the tick on the axis in terms of axis values.\n     * @name Highcharts.Tick#pos\n     * @type {number}\n     */\n    this.pos = pos;\n    /**\n     * The tick type, which can be `\"minor\"`, or an empty string.\n     * @name Highcharts.Tick#type\n     * @type {string}\n     */\n    this.type = type || '';\n    this.parameters = parameters || {};\n    /**\n     * The mark offset of the tick on the axis. Usually `undefined`, numeric\n     * for grid axes.\n     * @name Highcharts.Tick#tickmarkOffset\n     * @type {number|undefined}\n     */\n    this.tickmarkOffset = this.parameters.tickmarkOffset;\n    this.options = this.parameters.options;\n    fireEvent(this, 'init');\n    if (!type && !noLabel) {\n      this.addLabel();\n    }\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * Write the tick label.\n   *\n   * @private\n   * @function Highcharts.Tick#addLabel\n   */\n  addLabel() {\n    const tick = this,\n      axis = tick.axis,\n      options = axis.options,\n      chart = axis.chart,\n      categories = axis.categories,\n      log = axis.logarithmic,\n      names = axis.names,\n      pos = tick.pos,\n      labelOptions = pick(tick.options && tick.options.labels, options.labels),\n      tickPositions = axis.tickPositions,\n      isFirst = pos === tickPositions[0],\n      isLast = pos === tickPositions[tickPositions.length - 1],\n      animateLabels = (!labelOptions.step || labelOptions.step === 1) && axis.tickInterval === 1,\n      tickPositionInfo = tickPositions.info;\n    let label = tick.label,\n      dateTimeLabelFormat,\n      dateTimeLabelFormats,\n      i;\n    // The context value\n    let value = this.parameters.category || (categories ? pick(categories[pos], names[pos], pos) : pos);\n    if (log && isNumber(value)) {\n      value = correctFloat(log.lin2log(value));\n    }\n    // Set the datetime label format. If a higher rank is set for this\n    // position, use that. If not, use the general format.\n    if (axis.dateTime) {\n      if (tickPositionInfo) {\n        dateTimeLabelFormats = chart.time.resolveDTLFormat(options.dateTimeLabelFormats[!options.grid && tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName]);\n        dateTimeLabelFormat = dateTimeLabelFormats.main;\n      } else if (isNumber(value)) {\n        // #1441\n        dateTimeLabelFormat = axis.dateTime.getXDateFormat(value, options.dateTimeLabelFormats || {});\n      }\n    }\n    // set properties for access in render method\n    /**\n     * True if the tick is the first one on the axis.\n     * @name Highcharts.Tick#isFirst\n     * @readonly\n     * @type {boolean|undefined}\n     */\n    tick.isFirst = isFirst;\n    /**\n     * True if the tick is the last one on the axis.\n     * @name Highcharts.Tick#isLast\n     * @readonly\n     * @type {boolean|undefined}\n     */\n    tick.isLast = isLast;\n    // Get the string\n    const ctx = {\n      axis,\n      chart,\n      dateTimeLabelFormat: dateTimeLabelFormat,\n      isFirst,\n      isLast,\n      pos,\n      tick: tick,\n      tickPositionInfo,\n      value\n    };\n    // Fire an event that allows modifying the context for use in\n    // `labels.format` and `labels.formatter`.\n    fireEvent(this, 'labelFormat', ctx);\n    // Label formatting. When `labels.format` is given, we first run the\n    // defaultFormatter and append the result to the context as `text`.\n    // Handy for adding prefix or suffix while keeping default number\n    // formatting.\n    const labelFormatter = ctx => {\n      if (labelOptions.formatter) {\n        return labelOptions.formatter.call(ctx, ctx);\n      }\n      if (labelOptions.format) {\n        ctx.text = axis.defaultLabelFormatter.call(ctx, ctx);\n        return F.format(labelOptions.format, ctx, chart);\n      }\n      return axis.defaultLabelFormatter.call(ctx, ctx);\n    };\n    const str = labelFormatter.call(ctx, ctx);\n    // Set up conditional formatting based on the format list if existing.\n    const list = dateTimeLabelFormats && dateTimeLabelFormats.list;\n    if (list) {\n      tick.shortenLabel = function () {\n        for (i = 0; i < list.length; i++) {\n          extend(ctx, {\n            dateTimeLabelFormat: list[i]\n          });\n          label.attr({\n            text: labelFormatter.call(ctx, ctx)\n          });\n          if (label.getBBox().width < axis.getSlotWidth(tick) - 2 * labelOptions.padding) {\n            return;\n          }\n        }\n        label.attr({\n          text: ''\n        });\n      };\n    } else {\n      // #15692\n      tick.shortenLabel = void 0;\n    }\n    // Call only after first render\n    if (animateLabels && axis._addedPlotLB) {\n      tick.moveLabel(str, labelOptions);\n    }\n    // First call\n    if (!defined(label) && !tick.movedLabel) {\n      /**\n       * The rendered text label of the tick.\n       * @name Highcharts.Tick#label\n       * @type {Highcharts.SVGElement|undefined}\n       */\n      tick.label = label = tick.createLabel({\n        x: 0,\n        y: 0\n      }, str, labelOptions);\n      // Base value to detect change for new calls to getBBox\n      tick.rotation = 0;\n      // update\n    } else if (label && label.textStr !== str && !animateLabels) {\n      // When resetting text, also reset the width if dynamically set\n      // (#8809)\n      if (label.textWidth && !labelOptions.style.width && !label.styles.width) {\n        label.css({\n          width: null\n        });\n      }\n      label.attr({\n        text: str\n      });\n      label.textPxLength = label.getBBox().width;\n    }\n  }\n  /**\n   * Render and return the label of the tick.\n   *\n   * @private\n   * @function Highcharts.Tick#createLabel\n   */\n  createLabel(xy, str, labelOptions) {\n    const axis = this.axis,\n      chart = axis.chart,\n      label = defined(str) && labelOptions.enabled ? chart.renderer.text(str, xy.x, xy.y, labelOptions.useHTML).add(axis.labelGroup) : null;\n    // Un-rotated length\n    if (label) {\n      // Without position absolute, IE export sometimes is wrong\n      if (!chart.styledMode) {\n        label.css(merge(labelOptions.style));\n      }\n      label.textPxLength = label.getBBox().width;\n    }\n    return label;\n  }\n  /**\n   * Destructor for the tick prototype\n   *\n   * @private\n   * @function Highcharts.Tick#destroy\n   */\n  destroy() {\n    destroyObjectProperties(this, this.axis);\n  }\n  /**\n   * Gets the x and y positions for ticks in terms of pixels.\n   *\n   * @private\n   * @function Highcharts.Tick#getPosition\n   *\n   * @param {boolean} horiz\n   * Whether the tick is on an horizontal axis or not.\n   *\n   * @param {number} tickPos\n   * Position of the tick.\n   *\n   * @param {number} tickmarkOffset\n   * Tickmark offset for all ticks.\n   *\n   * @param {boolean} [old]\n   * Whether the axis has changed or not.\n   *\n   * @return {Highcharts.PositionObject}\n   * The tick position.\n   *\n   * @emits Highcharts.Tick#event:afterGetPosition\n   */\n  getPosition(horiz, tickPos, tickmarkOffset, old) {\n    const axis = this.axis,\n      chart = axis.chart,\n      cHeight = old && chart.oldChartHeight || chart.chartHeight,\n      pos = {\n        x: horiz ? correctFloat(axis.translate(tickPos + tickmarkOffset, void 0, void 0, old) + axis.transB) : axis.left + axis.offset + (axis.opposite ? (old && chart.oldChartWidth || chart.chartWidth) - axis.right - axis.left : 0),\n        y: horiz ? cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : correctFloat(cHeight - axis.translate(tickPos + tickmarkOffset, void 0, void 0, old) - axis.transB)\n      };\n    // Chrome workaround for #10516\n    pos.y = clamp(pos.y, -1e5, 1e5);\n    fireEvent(this, 'afterGetPosition', {\n      pos: pos\n    });\n    return pos;\n  }\n  /**\n   * Get the x, y position of the tick label\n   * @private\n   */\n  getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n    const axis = this.axis,\n      transA = axis.transA,\n      reversed =\n      // #7911\n      axis.isLinked && axis.linkedParent ? axis.linkedParent.reversed : axis.reversed,\n      staggerLines = axis.staggerLines,\n      rotCorr = axis.tickRotCorr || {\n        x: 0,\n        y: 0\n      },\n      // Adjust for label alignment if we use reserveSpace: true (#5286)\n      labelOffsetCorrection = !horiz && !axis.reserveSpaceDefault ? -axis.labelOffset * (axis.labelAlign === 'center' ? 0.5 : 1) : 0,\n      distance = labelOptions.distance,\n      pos = {};\n    let yOffset, line;\n    if (axis.side === 0) {\n      yOffset = label.rotation ? -distance : -label.getBBox().height;\n    } else if (axis.side === 2) {\n      yOffset = rotCorr.y + distance;\n    } else {\n      // #3140, #3140\n      yOffset = Math.cos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);\n    }\n    if (defined(labelOptions.y)) {\n      yOffset = axis.side === 0 && axis.horiz ? labelOptions.y + yOffset : labelOptions.y;\n    }\n    x = x + pick(labelOptions.x, [0, 1, 0, -1][axis.side] * distance) + labelOffsetCorrection + rotCorr.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);\n    y = y + yOffset - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0);\n    // Correct for staggered labels\n    if (staggerLines) {\n      line = index / (step || 1) % staggerLines;\n      if (axis.opposite) {\n        line = staggerLines - line - 1;\n      }\n      y += line * (axis.labelOffset / staggerLines);\n    }\n    pos.x = x;\n    pos.y = Math.round(y);\n    fireEvent(this, 'afterGetLabelPosition', {\n      pos: pos,\n      tickmarkOffset: tickmarkOffset,\n      index: index\n    });\n    return pos;\n  }\n  /**\n   * Get the offset height or width of the label\n   *\n   * @private\n   * @function Highcharts.Tick#getLabelSize\n   */\n  getLabelSize() {\n    return this.label ? this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] : 0;\n  }\n  /**\n   * Extendible method to return the path of the marker\n   * @private\n   */\n  getMarkPath(x, y, tickLength, tickWidth, horiz, renderer) {\n    return renderer.crispLine([['M', x, y], ['L', x + (horiz ? 0 : -tickLength), y + (horiz ? tickLength : 0)]], tickWidth);\n  }\n  /**\n   * Handle the label overflow by adjusting the labels to the left and right\n   * edge, or hide them if they collide into the neighbour label.\n   *\n   * @private\n   * @function Highcharts.Tick#handleOverflow\n   */\n  handleOverflow(xy) {\n    const tick = this,\n      axis = this.axis,\n      labelOptions = axis.options.labels,\n      pxPos = xy.x,\n      chartWidth = axis.chart.chartWidth,\n      spacing = axis.chart.spacing,\n      leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])),\n      rightBound = pick(axis.labelRight, Math.max(!axis.isRadial ? axis.pos + axis.len : 0, chartWidth - spacing[1])),\n      label = this.label,\n      rotation = this.rotation,\n      factor = {\n        left: 0,\n        center: 0.5,\n        right: 1\n      }[axis.labelAlign || label.attr('align')],\n      labelWidth = label.getBBox().width,\n      slotWidth = axis.getSlotWidth(tick),\n      xCorrection = factor,\n      css = {};\n    let modifiedSlotWidth = slotWidth,\n      goRight = 1,\n      leftPos,\n      rightPos,\n      textWidth;\n    // Check if the label overshoots the chart spacing box. If it does, move\n    // it. If it now overshoots the slotWidth, add ellipsis.\n    if (!rotation && labelOptions.overflow === 'justify') {\n      leftPos = pxPos - factor * labelWidth;\n      rightPos = pxPos + (1 - factor) * labelWidth;\n      if (leftPos < leftBound) {\n        modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;\n      } else if (rightPos > rightBound) {\n        modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;\n        goRight = -1;\n      }\n      modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177\n      if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {\n        xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));\n      }\n      // If the label width exceeds the available space, set a text width\n      // to be picked up below. Also, if a width has been set before, we\n      // need to set a new one because the reported labelWidth will be\n      // limited by the box (#3938).\n      if (labelWidth > modifiedSlotWidth || axis.autoRotation && (label.styles || {}).width) {\n        textWidth = modifiedSlotWidth;\n      }\n      // Add ellipsis to prevent rotated labels to be clipped against the edge\n      // of the chart\n    } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {\n      textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad) - leftBound);\n    } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {\n      textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad));\n    }\n    if (textWidth) {\n      if (tick.shortenLabel) {\n        tick.shortenLabel();\n      } else {\n        css.width = Math.floor(textWidth) + 'px';\n        if (!(labelOptions.style || {}).textOverflow) {\n          css.textOverflow = 'ellipsis';\n        }\n        label.css(css);\n      }\n    }\n  }\n  /**\n   * Try to replace the label if the same one already exists.\n   *\n   * @private\n   * @function Highcharts.Tick#moveLabel\n   */\n  moveLabel(str, labelOptions) {\n    const tick = this,\n      label = tick.label,\n      axis = tick.axis;\n    let moved = false,\n      labelPos;\n    if (label && label.textStr === str) {\n      tick.movedLabel = label;\n      moved = true;\n      delete tick.label;\n    } else {\n      // Find a label with the same string\n      objectEach(axis.ticks, function (currentTick) {\n        if (!moved && !currentTick.isNew && currentTick !== tick && currentTick.label && currentTick.label.textStr === str) {\n          tick.movedLabel = currentTick.label;\n          moved = true;\n          currentTick.labelPos = tick.movedLabel.xy;\n          delete currentTick.label;\n        }\n      });\n    }\n    // Create new label if the actual one is moved\n    if (!moved && (tick.labelPos || label)) {\n      labelPos = tick.labelPos || label.xy;\n      tick.movedLabel = tick.createLabel(labelPos, str, labelOptions);\n      if (tick.movedLabel) {\n        tick.movedLabel.attr({\n          opacity: 0\n        });\n      }\n    }\n  }\n  /**\n   * Put everything in place\n   *\n   * @private\n   * @param {number} index\n   *\n   * @param {boolean} [old]\n   * Use old coordinates to prepare an animation into new position\n   *\n   * @param {number} [opacity]\n   */\n  render(index, old, opacity) {\n    const tick = this,\n      axis = tick.axis,\n      horiz = axis.horiz,\n      pos = tick.pos,\n      tickmarkOffset = pick(tick.tickmarkOffset, axis.tickmarkOffset),\n      xy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n      x = xy.x,\n      y = xy.y,\n      reverseCrisp = horiz && x === axis.pos + axis.len || !horiz && y === axis.pos ? -1 : 1; // #1480, #1687\n    const labelOpacity = pick(opacity, tick.label && tick.label.newOpacity,\n    // #15528\n    1);\n    opacity = pick(opacity, 1);\n    this.isActive = true;\n    // Create the grid line\n    this.renderGridLine(old, opacity, reverseCrisp);\n    // create the tick mark\n    this.renderMark(xy, opacity, reverseCrisp);\n    // the label is created on init - now move it into place\n    this.renderLabel(xy, old, labelOpacity, index);\n    tick.isNew = false;\n    fireEvent(this, 'afterRender');\n  }\n  /**\n   * Renders the gridLine.\n   *\n   * @private\n   * @function Highcharts.Tick#renderGridLine\n   * @param {boolean} old  Whether or not the tick is old\n   * @param {number} opacity  The opacity of the grid line\n   * @param {number} reverseCrisp  Modifier for avoiding overlapping 1 or -1\n   */\n  renderGridLine(old, opacity, reverseCrisp) {\n    const tick = this,\n      axis = tick.axis,\n      options = axis.options,\n      attribs = {},\n      pos = tick.pos,\n      type = tick.type,\n      tickmarkOffset = pick(tick.tickmarkOffset, axis.tickmarkOffset),\n      renderer = axis.chart.renderer;\n    let gridLine = tick.gridLine,\n      gridLinePath,\n      gridLineWidth = options.gridLineWidth,\n      gridLineColor = options.gridLineColor,\n      dashStyle = options.gridLineDashStyle;\n    if (tick.type === 'minor') {\n      gridLineWidth = options.minorGridLineWidth;\n      gridLineColor = options.minorGridLineColor;\n      dashStyle = options.minorGridLineDashStyle;\n    }\n    if (!gridLine) {\n      if (!axis.chart.styledMode) {\n        attribs.stroke = gridLineColor;\n        attribs['stroke-width'] = gridLineWidth || 0;\n        attribs.dashstyle = dashStyle;\n      }\n      if (!type) {\n        attribs.zIndex = 1;\n      }\n      if (old) {\n        opacity = 0;\n      }\n      /**\n       * The rendered grid line of the tick.\n       * @name Highcharts.Tick#gridLine\n       * @type {Highcharts.SVGElement|undefined}\n       */\n      tick.gridLine = gridLine = renderer.path().attr(attribs).addClass('highcharts-' + (type ? type + '-' : '') + 'grid-line').add(axis.gridGroup);\n    }\n    if (gridLine) {\n      gridLinePath = axis.getPlotLinePath({\n        value: pos + tickmarkOffset,\n        lineWidth: gridLine.strokeWidth() * reverseCrisp,\n        force: 'pass',\n        old: old,\n        acrossPanes: false // #18025\n      });\n      // If the parameter 'old' is set, the current call will be followed\n      // by another call, therefore do not do any animations this time\n      if (gridLinePath) {\n        gridLine[old || tick.isNew ? 'attr' : 'animate']({\n          d: gridLinePath,\n          opacity: opacity\n        });\n      }\n    }\n  }\n  /**\n   * Renders the tick mark.\n   *\n   * @private\n   * @function Highcharts.Tick#renderMark\n   * @param {Highcharts.PositionObject} xy  The position vector of the mark\n   * @param {number} opacity  The opacity of the mark\n   * @param {number} reverseCrisp  Modifier for avoiding overlapping 1 or -1\n   */\n  renderMark(xy, opacity, reverseCrisp) {\n    const tick = this,\n      axis = tick.axis,\n      options = axis.options,\n      renderer = axis.chart.renderer,\n      type = tick.type,\n      tickSize = axis.tickSize(type ? type + 'Tick' : 'tick'),\n      x = xy.x,\n      y = xy.y,\n      tickWidth = pick(options[type !== 'minor' ? 'tickWidth' : 'minorTickWidth'], !type && axis.isXAxis ? 1 : 0),\n      // X axis defaults to 1\n      tickColor = options[type !== 'minor' ? 'tickColor' : 'minorTickColor'];\n    let mark = tick.mark;\n    const isNewMark = !mark;\n    if (tickSize) {\n      // negate the length\n      if (axis.opposite) {\n        tickSize[0] = -tickSize[0];\n      }\n      // First time, create it\n      if (!mark) {\n        /**\n         * The rendered mark of the tick.\n         * @name Highcharts.Tick#mark\n         * @type {Highcharts.SVGElement|undefined}\n         */\n        tick.mark = mark = renderer.path().addClass('highcharts-' + (type ? type + '-' : '') + 'tick').add(axis.axisGroup);\n        if (!axis.chart.styledMode) {\n          mark.attr({\n            stroke: tickColor,\n            'stroke-width': tickWidth\n          });\n        }\n      }\n      mark[isNewMark ? 'attr' : 'animate']({\n        d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth() * reverseCrisp, axis.horiz, renderer),\n        opacity: opacity\n      });\n    }\n  }\n  /**\n   * Renders the tick label.\n   * Note: The label should already be created in init(), so it should only\n   * have to be moved into place.\n   *\n   * @private\n   * @function Highcharts.Tick#renderLabel\n   * @param {Highcharts.PositionObject} xy  The position vector of the label\n   * @param {boolean} old  Whether or not the tick is old\n   * @param {number} opacity  The opacity of the label\n   * @param {number} index  The index of the tick\n   */\n  renderLabel(xy, old, opacity, index) {\n    const tick = this,\n      axis = tick.axis,\n      horiz = axis.horiz,\n      options = axis.options,\n      label = tick.label,\n      labelOptions = options.labels,\n      step = labelOptions.step,\n      tickmarkOffset = pick(tick.tickmarkOffset, axis.tickmarkOffset),\n      x = xy.x,\n      y = xy.y;\n    let show = true;\n    if (label && isNumber(x)) {\n      label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);\n      // Apply show first and show last. If the tick is both first and\n      // last, it is a single centered tick, in which case we show the\n      // label anyway (#2100).\n      if (tick.isFirst && !tick.isLast && !options.showFirstLabel || tick.isLast && !tick.isFirst && !options.showLastLabel) {\n        show = false;\n        // Handle label overflow and show or hide accordingly\n      } else if (horiz && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {\n        tick.handleOverflow(xy);\n      }\n      // apply step\n      if (step && index % step) {\n        // show those indices dividable by step\n        show = false;\n      }\n      // Set the new position, and show or hide\n      if (show && isNumber(xy.y)) {\n        xy.opacity = opacity;\n        label[tick.isNewLabel ? 'attr' : 'animate'](xy).show(true);\n        tick.isNewLabel = false;\n      } else {\n        label.hide(); // #1338, #15863\n        tick.isNewLabel = true;\n      }\n    }\n  }\n  /**\n   * Replace labels with the moved ones to perform animation. Additionally\n   * destroy unused labels.\n   *\n   * @private\n   * @function Highcharts.Tick#replaceMovedLabel\n   */\n  replaceMovedLabel() {\n    const tick = this,\n      label = tick.label,\n      axis = tick.axis;\n    // Animate and destroy\n    if (label && !tick.isNew) {\n      label.animate({\n        opacity: 0\n      }, void 0, label.destroy);\n      delete tick.label;\n    }\n    axis.isDirty = true;\n    tick.label = tick.movedLabel;\n    delete tick.movedLabel;\n  }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default Tick;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Optional parameters for the tick.\n * @private\n * @interface Highcharts.TickParametersObject\n */ /**\n    * Set category for the tick.\n    * @name Highcharts.TickParametersObject#category\n    * @type {string|undefined}\n    */ /**\n       * @name Highcharts.TickParametersObject#options\n       * @type {Highcharts.Dictionary<any>|undefined}\n       */ /**\n          * Set tickmarkOffset for the tick.\n          * @name Highcharts.TickParametersObject#tickmarkOffset\n          * @type {number|undefined}\n          */\n/**\n * Additonal time tick information.\n *\n * @interface Highcharts.TimeTicksInfoObject\n * @extends Highcharts.TimeNormalizedObject\n */ /**\n    * @name Highcharts.TimeTicksInfoObject#higherRanks\n    * @type {Array<string>}\n    */ /**\n       * @name Highcharts.TimeTicksInfoObject#totalRange\n       * @type {number}\n       */\n''; // keeps doclets above in JS file","map":{"version":3,"names":["F","H","deg2rad","U","clamp","correctFloat","defined","destroyObjectProperties","extend","fireEvent","isNumber","merge","objectEach","pick","Tick","constructor","axis","pos","type","noLabel","parameters","isNew","isNewLabel","tickmarkOffset","options","addLabel","tick","chart","categories","log","logarithmic","names","labelOptions","labels","tickPositions","isFirst","isLast","length","animateLabels","step","tickInterval","tickPositionInfo","info","label","dateTimeLabelFormat","dateTimeLabelFormats","i","value","category","lin2log","dateTime","time","resolveDTLFormat","grid","higherRanks","unitName","main","getXDateFormat","ctx","labelFormatter","formatter","call","format","text","defaultLabelFormatter","str","list","shortenLabel","attr","getBBox","width","getSlotWidth","padding","_addedPlotLB","moveLabel","movedLabel","createLabel","x","y","rotation","textStr","textWidth","style","styles","css","textPxLength","xy","enabled","renderer","useHTML","add","labelGroup","styledMode","destroy","getPosition","horiz","tickPos","old","cHeight","oldChartHeight","chartHeight","translate","transB","left","offset","opposite","oldChartWidth","chartWidth","right","bottom","height","getLabelPosition","index","transA","reversed","isLinked","linkedParent","staggerLines","rotCorr","tickRotCorr","labelOffsetCorrection","reserveSpaceDefault","labelOffset","labelAlign","distance","yOffset","line","side","Math","cos","round","getLabelSize","getMarkPath","tickLength","tickWidth","crispLine","handleOverflow","pxPos","spacing","leftBound","labelLeft","min","rightBound","labelRight","max","isRadial","len","factor","center","labelWidth","slotWidth","xCorrection","modifiedSlotWidth","goRight","leftPos","rightPos","overflow","autoRotation","floor","textOverflow","moved","labelPos","ticks","currentTick","opacity","render","reverseCrisp","labelOpacity","newOpacity","isActive","renderGridLine","renderMark","renderLabel","attribs","gridLine","gridLinePath","gridLineWidth","gridLineColor","dashStyle","gridLineDashStyle","minorGridLineWidth","minorGridLineColor","minorGridLineDashStyle","stroke","dashstyle","zIndex","path","addClass","gridGroup","getPlotLinePath","lineWidth","strokeWidth","force","acrossPanes","d","tickSize","isXAxis","tickColor","mark","isNewMark","axisGroup","show","showFirstLabel","showLastLabel","hide","replaceMovedLabel","animate","isDirty"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Axis/Tick.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport F from '../Templating.js';\nimport H from '../Globals.js';\nconst { deg2rad } = H;\nimport U from '../Utilities.js';\nconst { clamp, correctFloat, defined, destroyObjectProperties, extend, fireEvent, isNumber, merge, objectEach, pick } = U;\n/* *\n *\n *  Class\n *\n * */\n/* eslint-disable no-invalid-this, valid-jsdoc */\n/**\n * The Tick class.\n *\n * @class\n * @name Highcharts.Tick\n *\n * @param {Highcharts.Axis} axis\n * The axis of the tick.\n *\n * @param {number} pos\n * The position of the tick on the axis in terms of axis values.\n *\n * @param {string} [type]\n * The type of tick, either 'minor' or an empty string\n *\n * @param {boolean} [noLabel=false]\n * Whether to disable the label or not. Defaults to false.\n *\n * @param {Object} [parameters]\n * Optional parameters for the tick.\n */\nclass Tick {\n    /* *\n     *\n     *  Constructors\n     *\n     * */\n    constructor(axis, pos, type, noLabel, parameters) {\n        this.isNew = true;\n        this.isNewLabel = true;\n        /**\n         * The related axis of the tick.\n         * @name Highcharts.Tick#axis\n         * @type {Highcharts.Axis}\n         */\n        this.axis = axis;\n        /**\n         * The logical position of the tick on the axis in terms of axis values.\n         * @name Highcharts.Tick#pos\n         * @type {number}\n         */\n        this.pos = pos;\n        /**\n         * The tick type, which can be `\"minor\"`, or an empty string.\n         * @name Highcharts.Tick#type\n         * @type {string}\n         */\n        this.type = type || '';\n        this.parameters = parameters || {};\n        /**\n         * The mark offset of the tick on the axis. Usually `undefined`, numeric\n         * for grid axes.\n         * @name Highcharts.Tick#tickmarkOffset\n         * @type {number|undefined}\n         */\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        fireEvent(this, 'init');\n        if (!type && !noLabel) {\n            this.addLabel();\n        }\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Write the tick label.\n     *\n     * @private\n     * @function Highcharts.Tick#addLabel\n     */\n    addLabel() {\n        const tick = this, axis = tick.axis, options = axis.options, chart = axis.chart, categories = axis.categories, log = axis.logarithmic, names = axis.names, pos = tick.pos, labelOptions = pick(tick.options && tick.options.labels, options.labels), tickPositions = axis.tickPositions, isFirst = pos === tickPositions[0], isLast = pos === tickPositions[tickPositions.length - 1], animateLabels = (!labelOptions.step || labelOptions.step === 1) &&\n            axis.tickInterval === 1, tickPositionInfo = tickPositions.info;\n        let label = tick.label, dateTimeLabelFormat, dateTimeLabelFormats, i;\n        // The context value\n        let value = this.parameters.category || (categories ?\n            pick(categories[pos], names[pos], pos) :\n            pos);\n        if (log && isNumber(value)) {\n            value = correctFloat(log.lin2log(value));\n        }\n        // Set the datetime label format. If a higher rank is set for this\n        // position, use that. If not, use the general format.\n        if (axis.dateTime) {\n            if (tickPositionInfo) {\n                dateTimeLabelFormats = chart.time.resolveDTLFormat(options.dateTimeLabelFormats[(!options.grid &&\n                    tickPositionInfo.higherRanks[pos]) ||\n                    tickPositionInfo.unitName]);\n                dateTimeLabelFormat = dateTimeLabelFormats.main;\n            }\n            else if (isNumber(value)) { // #1441\n                dateTimeLabelFormat = axis.dateTime.getXDateFormat(value, options.dateTimeLabelFormats ||\n                    {});\n            }\n        }\n        // set properties for access in render method\n        /**\n         * True if the tick is the first one on the axis.\n         * @name Highcharts.Tick#isFirst\n         * @readonly\n         * @type {boolean|undefined}\n         */\n        tick.isFirst = isFirst;\n        /**\n         * True if the tick is the last one on the axis.\n         * @name Highcharts.Tick#isLast\n         * @readonly\n         * @type {boolean|undefined}\n         */\n        tick.isLast = isLast;\n        // Get the string\n        const ctx = {\n            axis,\n            chart,\n            dateTimeLabelFormat: dateTimeLabelFormat,\n            isFirst,\n            isLast,\n            pos,\n            tick: tick,\n            tickPositionInfo,\n            value\n        };\n        // Fire an event that allows modifying the context for use in\n        // `labels.format` and `labels.formatter`.\n        fireEvent(this, 'labelFormat', ctx);\n        // Label formatting. When `labels.format` is given, we first run the\n        // defaultFormatter and append the result to the context as `text`.\n        // Handy for adding prefix or suffix while keeping default number\n        // formatting.\n        const labelFormatter = (ctx) => {\n            if (labelOptions.formatter) {\n                return labelOptions.formatter.call(ctx, ctx);\n            }\n            if (labelOptions.format) {\n                ctx.text = axis.defaultLabelFormatter.call(ctx, ctx);\n                return F.format(labelOptions.format, ctx, chart);\n            }\n            return axis.defaultLabelFormatter.call(ctx, ctx);\n        };\n        const str = labelFormatter.call(ctx, ctx);\n        // Set up conditional formatting based on the format list if existing.\n        const list = dateTimeLabelFormats && dateTimeLabelFormats.list;\n        if (list) {\n            tick.shortenLabel = function () {\n                for (i = 0; i < list.length; i++) {\n                    extend(ctx, { dateTimeLabelFormat: list[i] });\n                    label.attr({\n                        text: labelFormatter.call(ctx, ctx)\n                    });\n                    if (label.getBBox().width <\n                        axis.getSlotWidth(tick) - 2 *\n                            labelOptions.padding) {\n                        return;\n                    }\n                }\n                label.attr({\n                    text: ''\n                });\n            };\n        }\n        else {\n            // #15692\n            tick.shortenLabel = void 0;\n        }\n        // Call only after first render\n        if (animateLabels && axis._addedPlotLB) {\n            tick.moveLabel(str, labelOptions);\n        }\n        // First call\n        if (!defined(label) && !tick.movedLabel) {\n            /**\n             * The rendered text label of the tick.\n             * @name Highcharts.Tick#label\n             * @type {Highcharts.SVGElement|undefined}\n             */\n            tick.label = label = tick.createLabel({ x: 0, y: 0 }, str, labelOptions);\n            // Base value to detect change for new calls to getBBox\n            tick.rotation = 0;\n            // update\n        }\n        else if (label && label.textStr !== str && !animateLabels) {\n            // When resetting text, also reset the width if dynamically set\n            // (#8809)\n            if (label.textWidth &&\n                !labelOptions.style.width &&\n                !label.styles.width) {\n                label.css({ width: null });\n            }\n            label.attr({ text: str });\n            label.textPxLength = label.getBBox().width;\n        }\n    }\n    /**\n     * Render and return the label of the tick.\n     *\n     * @private\n     * @function Highcharts.Tick#createLabel\n     */\n    createLabel(xy, str, labelOptions) {\n        const axis = this.axis, chart = axis.chart, label = defined(str) && labelOptions.enabled ?\n            chart.renderer\n                .text(str, xy.x, xy.y, labelOptions.useHTML)\n                .add(axis.labelGroup) :\n            null;\n        // Un-rotated length\n        if (label) {\n            // Without position absolute, IE export sometimes is wrong\n            if (!chart.styledMode) {\n                label.css(merge(labelOptions.style));\n            }\n            label.textPxLength = label.getBBox().width;\n        }\n        return label;\n    }\n    /**\n     * Destructor for the tick prototype\n     *\n     * @private\n     * @function Highcharts.Tick#destroy\n     */\n    destroy() {\n        destroyObjectProperties(this, this.axis);\n    }\n    /**\n     * Gets the x and y positions for ticks in terms of pixels.\n     *\n     * @private\n     * @function Highcharts.Tick#getPosition\n     *\n     * @param {boolean} horiz\n     * Whether the tick is on an horizontal axis or not.\n     *\n     * @param {number} tickPos\n     * Position of the tick.\n     *\n     * @param {number} tickmarkOffset\n     * Tickmark offset for all ticks.\n     *\n     * @param {boolean} [old]\n     * Whether the axis has changed or not.\n     *\n     * @return {Highcharts.PositionObject}\n     * The tick position.\n     *\n     * @emits Highcharts.Tick#event:afterGetPosition\n     */\n    getPosition(horiz, tickPos, tickmarkOffset, old) {\n        const axis = this.axis, chart = axis.chart, cHeight = (old && chart.oldChartHeight) || chart.chartHeight, pos = {\n            x: horiz ?\n                correctFloat(axis.translate(tickPos + tickmarkOffset, void 0, void 0, old) +\n                    axis.transB) :\n                (axis.left +\n                    axis.offset +\n                    (axis.opposite ?\n                        (((old && chart.oldChartWidth) ||\n                            chart.chartWidth) -\n                            axis.right -\n                            axis.left) :\n                        0)),\n            y: horiz ?\n                (cHeight -\n                    axis.bottom +\n                    axis.offset -\n                    (axis.opposite ? axis.height : 0)) :\n                correctFloat(cHeight -\n                    axis.translate(tickPos + tickmarkOffset, void 0, void 0, old) -\n                    axis.transB)\n        };\n        // Chrome workaround for #10516\n        pos.y = clamp(pos.y, -1e5, 1e5);\n        fireEvent(this, 'afterGetPosition', { pos: pos });\n        return pos;\n    }\n    /**\n     * Get the x, y position of the tick label\n     * @private\n     */\n    getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n        const axis = this.axis, transA = axis.transA, reversed = ( // #7911\n        axis.isLinked && axis.linkedParent ?\n            axis.linkedParent.reversed :\n            axis.reversed), staggerLines = axis.staggerLines, rotCorr = axis.tickRotCorr || { x: 0, y: 0 }, \n        // Adjust for label alignment if we use reserveSpace: true (#5286)\n        labelOffsetCorrection = (!horiz && !axis.reserveSpaceDefault ?\n            -axis.labelOffset * (axis.labelAlign === 'center' ? 0.5 : 1) :\n            0), distance = labelOptions.distance, pos = {};\n        let yOffset, line;\n        if (axis.side === 0) {\n            yOffset = label.rotation ? -distance : -label.getBBox().height;\n        }\n        else if (axis.side === 2) {\n            yOffset = rotCorr.y + distance;\n        }\n        else {\n            // #3140, #3140\n            yOffset = Math.cos(label.rotation * deg2rad) *\n                (rotCorr.y - label.getBBox(false, 0).height / 2);\n        }\n        if (defined(labelOptions.y)) {\n            yOffset = axis.side === 0 && axis.horiz ?\n                labelOptions.y + yOffset :\n                labelOptions.y;\n        }\n        x = x +\n            pick(labelOptions.x, [0, 1, 0, -1][axis.side] * distance) +\n            labelOffsetCorrection +\n            rotCorr.x -\n            (tickmarkOffset && horiz ?\n                tickmarkOffset * transA * (reversed ? -1 : 1) :\n                0);\n        y = y + yOffset - (tickmarkOffset && !horiz ?\n            tickmarkOffset * transA * (reversed ? 1 : -1) : 0);\n        // Correct for staggered labels\n        if (staggerLines) {\n            line = (index / (step || 1) % staggerLines);\n            if (axis.opposite) {\n                line = staggerLines - line - 1;\n            }\n            y += line * (axis.labelOffset / staggerLines);\n        }\n        pos.x = x;\n        pos.y = Math.round(y);\n        fireEvent(this, 'afterGetLabelPosition', { pos: pos, tickmarkOffset: tickmarkOffset, index: index });\n        return pos;\n    }\n    /**\n     * Get the offset height or width of the label\n     *\n     * @private\n     * @function Highcharts.Tick#getLabelSize\n     */\n    getLabelSize() {\n        return this.label ?\n            this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :\n            0;\n    }\n    /**\n     * Extendible method to return the path of the marker\n     * @private\n     */\n    getMarkPath(x, y, tickLength, tickWidth, horiz, renderer) {\n        return renderer.crispLine([[\n                'M',\n                x,\n                y\n            ], [\n                'L',\n                x + (horiz ? 0 : -tickLength),\n                y + (horiz ? tickLength : 0)\n            ]], tickWidth);\n    }\n    /**\n     * Handle the label overflow by adjusting the labels to the left and right\n     * edge, or hide them if they collide into the neighbour label.\n     *\n     * @private\n     * @function Highcharts.Tick#handleOverflow\n     */\n    handleOverflow(xy) {\n        const tick = this, axis = this.axis, labelOptions = axis.options.labels, pxPos = xy.x, chartWidth = axis.chart.chartWidth, spacing = axis.chart.spacing, leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])), rightBound = pick(axis.labelRight, Math.max(!axis.isRadial ? axis.pos + axis.len : 0, chartWidth - spacing[1])), label = this.label, rotation = this.rotation, factor = {\n            left: 0,\n            center: 0.5,\n            right: 1\n        }[axis.labelAlign || label.attr('align')], labelWidth = label.getBBox().width, slotWidth = axis.getSlotWidth(tick), xCorrection = factor, css = {};\n        let modifiedSlotWidth = slotWidth, goRight = 1, leftPos, rightPos, textWidth;\n        // Check if the label overshoots the chart spacing box. If it does, move\n        // it. If it now overshoots the slotWidth, add ellipsis.\n        if (!rotation && labelOptions.overflow === 'justify') {\n            leftPos = pxPos - factor * labelWidth;\n            rightPos = pxPos + (1 - factor) * labelWidth;\n            if (leftPos < leftBound) {\n                modifiedSlotWidth =\n                    xy.x + modifiedSlotWidth * (1 - factor) - leftBound;\n            }\n            else if (rightPos > rightBound) {\n                modifiedSlotWidth =\n                    rightBound - xy.x + modifiedSlotWidth * factor;\n                goRight = -1;\n            }\n            modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177\n            if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {\n                xy.x += (goRight *\n                    (slotWidth -\n                        modifiedSlotWidth -\n                        xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth))));\n            }\n            // If the label width exceeds the available space, set a text width\n            // to be picked up below. Also, if a width has been set before, we\n            // need to set a new one because the reported labelWidth will be\n            // limited by the box (#3938).\n            if (labelWidth > modifiedSlotWidth ||\n                (axis.autoRotation && (label.styles || {}).width)) {\n                textWidth = modifiedSlotWidth;\n            }\n            // Add ellipsis to prevent rotated labels to be clipped against the edge\n            // of the chart\n        }\n        else if (rotation < 0 &&\n            pxPos - factor * labelWidth < leftBound) {\n            textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad) - leftBound);\n        }\n        else if (rotation > 0 &&\n            pxPos + factor * labelWidth > rightBound) {\n            textWidth = Math.round((chartWidth - pxPos) /\n                Math.cos(rotation * deg2rad));\n        }\n        if (textWidth) {\n            if (tick.shortenLabel) {\n                tick.shortenLabel();\n            }\n            else {\n                css.width = Math.floor(textWidth) + 'px';\n                if (!(labelOptions.style || {}).textOverflow) {\n                    css.textOverflow = 'ellipsis';\n                }\n                label.css(css);\n            }\n        }\n    }\n    /**\n     * Try to replace the label if the same one already exists.\n     *\n     * @private\n     * @function Highcharts.Tick#moveLabel\n     */\n    moveLabel(str, labelOptions) {\n        const tick = this, label = tick.label, axis = tick.axis;\n        let moved = false, labelPos;\n        if (label && label.textStr === str) {\n            tick.movedLabel = label;\n            moved = true;\n            delete tick.label;\n        }\n        else { // Find a label with the same string\n            objectEach(axis.ticks, function (currentTick) {\n                if (!moved &&\n                    !currentTick.isNew &&\n                    currentTick !== tick &&\n                    currentTick.label &&\n                    currentTick.label.textStr === str) {\n                    tick.movedLabel = currentTick.label;\n                    moved = true;\n                    currentTick.labelPos = tick.movedLabel.xy;\n                    delete currentTick.label;\n                }\n            });\n        }\n        // Create new label if the actual one is moved\n        if (!moved && (tick.labelPos || label)) {\n            labelPos = tick.labelPos || label.xy;\n            tick.movedLabel = tick.createLabel(labelPos, str, labelOptions);\n            if (tick.movedLabel) {\n                tick.movedLabel.attr({ opacity: 0 });\n            }\n        }\n    }\n    /**\n     * Put everything in place\n     *\n     * @private\n     * @param {number} index\n     *\n     * @param {boolean} [old]\n     * Use old coordinates to prepare an animation into new position\n     *\n     * @param {number} [opacity]\n     */\n    render(index, old, opacity) {\n        const tick = this, axis = tick.axis, horiz = axis.horiz, pos = tick.pos, tickmarkOffset = pick(tick.tickmarkOffset, axis.tickmarkOffset), xy = tick.getPosition(horiz, pos, tickmarkOffset, old), x = xy.x, y = xy.y, reverseCrisp = ((horiz && x === axis.pos + axis.len) ||\n            (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687\n        const labelOpacity = pick(opacity, tick.label && tick.label.newOpacity, // #15528\n        1);\n        opacity = pick(opacity, 1);\n        this.isActive = true;\n        // Create the grid line\n        this.renderGridLine(old, opacity, reverseCrisp);\n        // create the tick mark\n        this.renderMark(xy, opacity, reverseCrisp);\n        // the label is created on init - now move it into place\n        this.renderLabel(xy, old, labelOpacity, index);\n        tick.isNew = false;\n        fireEvent(this, 'afterRender');\n    }\n    /**\n     * Renders the gridLine.\n     *\n     * @private\n     * @function Highcharts.Tick#renderGridLine\n     * @param {boolean} old  Whether or not the tick is old\n     * @param {number} opacity  The opacity of the grid line\n     * @param {number} reverseCrisp  Modifier for avoiding overlapping 1 or -1\n     */\n    renderGridLine(old, opacity, reverseCrisp) {\n        const tick = this, axis = tick.axis, options = axis.options, attribs = {}, pos = tick.pos, type = tick.type, tickmarkOffset = pick(tick.tickmarkOffset, axis.tickmarkOffset), renderer = axis.chart.renderer;\n        let gridLine = tick.gridLine, gridLinePath, gridLineWidth = options.gridLineWidth, gridLineColor = options.gridLineColor, dashStyle = options.gridLineDashStyle;\n        if (tick.type === 'minor') {\n            gridLineWidth = options.minorGridLineWidth;\n            gridLineColor = options.minorGridLineColor;\n            dashStyle = options.minorGridLineDashStyle;\n        }\n        if (!gridLine) {\n            if (!axis.chart.styledMode) {\n                attribs.stroke = gridLineColor;\n                attribs['stroke-width'] = gridLineWidth || 0;\n                attribs.dashstyle = dashStyle;\n            }\n            if (!type) {\n                attribs.zIndex = 1;\n            }\n            if (old) {\n                opacity = 0;\n            }\n            /**\n             * The rendered grid line of the tick.\n             * @name Highcharts.Tick#gridLine\n             * @type {Highcharts.SVGElement|undefined}\n             */\n            tick.gridLine = gridLine = renderer.path()\n                .attr(attribs)\n                .addClass('highcharts-' + (type ? type + '-' : '') + 'grid-line')\n                .add(axis.gridGroup);\n        }\n        if (gridLine) {\n            gridLinePath = axis.getPlotLinePath({\n                value: pos + tickmarkOffset,\n                lineWidth: gridLine.strokeWidth() * reverseCrisp,\n                force: 'pass',\n                old: old,\n                acrossPanes: false // #18025\n            });\n            // If the parameter 'old' is set, the current call will be followed\n            // by another call, therefore do not do any animations this time\n            if (gridLinePath) {\n                gridLine[old || tick.isNew ? 'attr' : 'animate']({\n                    d: gridLinePath,\n                    opacity: opacity\n                });\n            }\n        }\n    }\n    /**\n     * Renders the tick mark.\n     *\n     * @private\n     * @function Highcharts.Tick#renderMark\n     * @param {Highcharts.PositionObject} xy  The position vector of the mark\n     * @param {number} opacity  The opacity of the mark\n     * @param {number} reverseCrisp  Modifier for avoiding overlapping 1 or -1\n     */\n    renderMark(xy, opacity, reverseCrisp) {\n        const tick = this, axis = tick.axis, options = axis.options, renderer = axis.chart.renderer, type = tick.type, tickSize = axis.tickSize(type ? type + 'Tick' : 'tick'), x = xy.x, y = xy.y, tickWidth = pick(options[type !== 'minor' ? 'tickWidth' : 'minorTickWidth'], !type && axis.isXAxis ? 1 : 0), // X axis defaults to 1\n        tickColor = options[type !== 'minor' ? 'tickColor' : 'minorTickColor'];\n        let mark = tick.mark;\n        const isNewMark = !mark;\n        if (tickSize) {\n            // negate the length\n            if (axis.opposite) {\n                tickSize[0] = -tickSize[0];\n            }\n            // First time, create it\n            if (!mark) {\n                /**\n                 * The rendered mark of the tick.\n                 * @name Highcharts.Tick#mark\n                 * @type {Highcharts.SVGElement|undefined}\n                 */\n                tick.mark = mark = renderer.path()\n                    .addClass('highcharts-' + (type ? type + '-' : '') + 'tick')\n                    .add(axis.axisGroup);\n                if (!axis.chart.styledMode) {\n                    mark.attr({\n                        stroke: tickColor,\n                        'stroke-width': tickWidth\n                    });\n                }\n            }\n            mark[isNewMark ? 'attr' : 'animate']({\n                d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth() * reverseCrisp, axis.horiz, renderer),\n                opacity: opacity\n            });\n        }\n    }\n    /**\n     * Renders the tick label.\n     * Note: The label should already be created in init(), so it should only\n     * have to be moved into place.\n     *\n     * @private\n     * @function Highcharts.Tick#renderLabel\n     * @param {Highcharts.PositionObject} xy  The position vector of the label\n     * @param {boolean} old  Whether or not the tick is old\n     * @param {number} opacity  The opacity of the label\n     * @param {number} index  The index of the tick\n     */\n    renderLabel(xy, old, opacity, index) {\n        const tick = this, axis = tick.axis, horiz = axis.horiz, options = axis.options, label = tick.label, labelOptions = options.labels, step = labelOptions.step, tickmarkOffset = pick(tick.tickmarkOffset, axis.tickmarkOffset), x = xy.x, y = xy.y;\n        let show = true;\n        if (label && isNumber(x)) {\n            label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);\n            // Apply show first and show last. If the tick is both first and\n            // last, it is a single centered tick, in which case we show the\n            // label anyway (#2100).\n            if ((tick.isFirst &&\n                !tick.isLast &&\n                !options.showFirstLabel) ||\n                (tick.isLast &&\n                    !tick.isFirst &&\n                    !options.showLastLabel)) {\n                show = false;\n                // Handle label overflow and show or hide accordingly\n            }\n            else if (horiz &&\n                !labelOptions.step &&\n                !labelOptions.rotation &&\n                !old &&\n                opacity !== 0) {\n                tick.handleOverflow(xy);\n            }\n            // apply step\n            if (step && index % step) {\n                // show those indices dividable by step\n                show = false;\n            }\n            // Set the new position, and show or hide\n            if (show && isNumber(xy.y)) {\n                xy.opacity = opacity;\n                label[tick.isNewLabel ? 'attr' : 'animate'](xy).show(true);\n                tick.isNewLabel = false;\n            }\n            else {\n                label.hide(); // #1338, #15863\n                tick.isNewLabel = true;\n            }\n        }\n    }\n    /**\n     * Replace labels with the moved ones to perform animation. Additionally\n     * destroy unused labels.\n     *\n     * @private\n     * @function Highcharts.Tick#replaceMovedLabel\n     */\n    replaceMovedLabel() {\n        const tick = this, label = tick.label, axis = tick.axis;\n        // Animate and destroy\n        if (label && !tick.isNew) {\n            label.animate({ opacity: 0 }, void 0, label.destroy);\n            delete tick.label;\n        }\n        axis.isDirty = true;\n        tick.label = tick.movedLabel;\n        delete tick.movedLabel;\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default Tick;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Optional parameters for the tick.\n * @private\n * @interface Highcharts.TickParametersObject\n */ /**\n* Set category for the tick.\n* @name Highcharts.TickParametersObject#category\n* @type {string|undefined}\n*/ /**\n* @name Highcharts.TickParametersObject#options\n* @type {Highcharts.Dictionary<any>|undefined}\n*/ /**\n* Set tickmarkOffset for the tick.\n* @name Highcharts.TickParametersObject#tickmarkOffset\n* @type {number|undefined}\n*/\n/**\n * Additonal time tick information.\n *\n * @interface Highcharts.TimeTicksInfoObject\n * @extends Highcharts.TimeNormalizedObject\n */ /**\n* @name Highcharts.TimeTicksInfoObject#higherRanks\n* @type {Array<string>}\n*/ /**\n* @name Highcharts.TimeTicksInfoObject#totalRange\n* @type {number}\n*/\n(''); // keeps doclets above in JS file\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}