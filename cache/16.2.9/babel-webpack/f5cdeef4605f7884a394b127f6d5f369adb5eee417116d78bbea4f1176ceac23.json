{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport CU from '../CenteredUtilities.js';\nconst {\n  getStartAndEndRadians\n} = CU;\nimport ColumnSeries from '../Column/ColumnSeries.js';\nimport H from '../../Core/Globals.js';\nconst {\n  noop\n} = H;\nimport PiePoint from './PiePoint.js';\nimport PieSeriesDefaults from './PieSeriesDefaults.js';\nimport Series from '../../Core/Series/Series.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nimport Symbols from '../../Core/Renderer/SVG/Symbols.js';\nimport U from '../../Core/Utilities.js';\nconst {\n  clamp,\n  extend,\n  fireEvent,\n  merge,\n  pick,\n  relativeLength,\n  splat\n} = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * Pie series type.\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes.pie\n *\n * @augments Highcharts.Series\n */\nclass PieSeries extends Series {\n  constructor() {\n    /* *\n     *\n     *  Static Properties\n     *\n     * */\n    super(...arguments);\n    /* *\n     *\n     *  Properties\n     *\n     * */\n    this.center = void 0;\n    this.data = void 0;\n    this.options = void 0;\n    this.points = void 0;\n    /* eslint-enable valid-jsdoc */\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Animates the pies in.\n   * @private\n   */\n  animate(init) {\n    const series = this,\n      points = series.points,\n      startAngleRad = series.startAngleRad;\n    if (!init) {\n      points.forEach(function (point) {\n        const graphic = point.graphic,\n          args = point.shapeArgs;\n        if (graphic && args) {\n          // start values\n          graphic.attr({\n            // animate from inner radius (#779)\n            r: pick(point.startR, series.center && series.center[3] / 2),\n            start: startAngleRad,\n            end: startAngleRad\n          });\n          // animate\n          graphic.animate({\n            r: args.r,\n            start: args.start,\n            end: args.end\n          }, series.options.animation);\n        }\n      });\n    }\n  }\n  /**\n   * Called internally to draw auxiliary graph in pie-like series in\n   * situtation when the default graph is not sufficient enough to present\n   * the data well. Auxiliary graph is saved in the same object as\n   * regular graph.\n   * @private\n   */\n  drawEmpty() {\n    const start = this.startAngleRad,\n      end = this.endAngleRad,\n      options = this.options;\n    let centerX, centerY;\n    // Draw auxiliary graph if there're no visible points.\n    if (this.total === 0 && this.center) {\n      centerX = this.center[0];\n      centerY = this.center[1];\n      if (!this.graph) {\n        this.graph = this.chart.renderer.arc(centerX, centerY, this.center[1] / 2, 0, start, end).addClass('highcharts-empty-series').add(this.group);\n      }\n      this.graph.attr({\n        d: Symbols.arc(centerX, centerY, this.center[2] / 2, 0, {\n          start,\n          end,\n          innerR: this.center[3] / 2\n        })\n      });\n      if (!this.chart.styledMode) {\n        this.graph.attr({\n          'stroke-width': options.borderWidth,\n          fill: options.fillColor || 'none',\n          stroke: options.color || \"#cccccc\" /* Palette.neutralColor20 */\n        });\n      }\n    } else if (this.graph) {\n      // Destroy the graph object.\n      this.graph = this.graph.destroy();\n    }\n  }\n  /**\n   * Slices in pie chart are initialized in DOM, but it's shapes and\n   * animations are normally run in `drawPoints()`.\n   * @private\n   */\n  drawPoints() {\n    const renderer = this.chart.renderer;\n    this.points.forEach(function (point) {\n      // When updating a series between 2d and 3d or cartesian and\n      // polar, the shape type changes.\n      if (point.graphic && point.hasNewShapeType()) {\n        point.graphic = point.graphic.destroy();\n      }\n      if (!point.graphic) {\n        point.graphic = renderer[point.shapeType](point.shapeArgs).add(point.series.group);\n        point.delayedRendering = true;\n      }\n    });\n  }\n  /**\n   * Extend the generatePoints method by adding total and percentage\n   * properties to each point\n   * @private\n   */\n  generatePoints() {\n    super.generatePoints();\n    this.updateTotals();\n  }\n  /**\n   * Utility for getting the x value from a given y, used for anticollision\n   * logic in data labels.\n   * @private\n   */\n  getX(y, left, point, dataLabel) {\n    const center = this.center,\n      // Variable pie has individual radius\n      radius = this.radii ? this.radii[point.index] || 0 : center[2] / 2,\n      labelPosition = dataLabel.dataLabelPosition,\n      distance = labelPosition?.distance || 0;\n    const angle = Math.asin(clamp((y - center[1]) / (radius + distance), -1, 1));\n    const x = center[0] + (left ? -1 : 1) * (Math.cos(angle) * (radius + distance)) + (distance > 0 ? (left ? -1 : 1) * (dataLabel.padding || 0) : 0);\n    return x;\n  }\n  /**\n   * Define hasData function for non-cartesian series. Returns true if the\n   * series has points at all.\n   * @private\n   */\n  hasData() {\n    return !!this.processedXData.length; // != 0\n  }\n  /**\n   * Draw the data points\n   * @private\n   */\n  redrawPoints() {\n    const series = this,\n      chart = series.chart;\n    let groupTranslation, graphic, pointAttr, shapeArgs;\n    this.drawEmpty();\n    // Apply the drop-shadow to the group because otherwise each element\n    // would cast a shadow on others\n    if (series.group && !chart.styledMode) {\n      series.group.shadow(series.options.shadow);\n    }\n    // draw the slices\n    series.points.forEach(function (point) {\n      const animateTo = {};\n      graphic = point.graphic;\n      if (!point.isNull && graphic) {\n        shapeArgs = point.shapeArgs;\n        // If the point is sliced, use special translation, else use\n        // plot area translation\n        groupTranslation = point.getTranslate();\n        if (!chart.styledMode) {\n          pointAttr = series.pointAttribs(point, point.selected && 'select');\n        }\n        // Draw the slice\n        if (!point.delayedRendering) {\n          graphic.setRadialReference(series.center);\n          if (!chart.styledMode) {\n            merge(true, animateTo, pointAttr);\n          }\n          merge(true, animateTo, shapeArgs, groupTranslation);\n          graphic.animate(animateTo);\n        } else {\n          graphic.setRadialReference(series.center).attr(shapeArgs).attr(groupTranslation);\n          if (!chart.styledMode) {\n            graphic.attr(pointAttr).attr({\n              'stroke-linejoin': 'round'\n            });\n          }\n          point.delayedRendering = false;\n        }\n        graphic.attr({\n          visibility: point.visible ? 'inherit' : 'hidden'\n        });\n        graphic.addClass(point.getClassName(), true);\n      } else if (graphic) {\n        point.graphic = graphic.destroy();\n      }\n    });\n  }\n  /**\n   * Utility for sorting data labels.\n   * @private\n   */\n  sortByAngle(points, sign) {\n    points.sort(function (a, b) {\n      return typeof a.angle !== 'undefined' && (b.angle - a.angle) * sign;\n    });\n  }\n  /**\n   * Do translation for pie slices\n   * @private\n   */\n  translate(positions) {\n    fireEvent(this, 'translate');\n    this.generatePoints();\n    const series = this,\n      precision = 1000,\n      // issue #172\n      options = series.options,\n      slicedOffset = options.slicedOffset,\n      radians = getStartAndEndRadians(options.startAngle, options.endAngle),\n      startAngleRad = series.startAngleRad = radians.start,\n      endAngleRad = series.endAngleRad = radians.end,\n      circ = endAngleRad - startAngleRad,\n      // 2 * Math.PI,\n      points = series.points,\n      ignoreHiddenPoint = options.ignoreHiddenPoint,\n      len = points.length;\n    let start,\n      end,\n      angle,\n      // The x component of the radius vector for a given point\n      radiusX,\n      radiusY,\n      i,\n      point,\n      cumulative = 0;\n    // Get positions - either an integer or a percentage string must be\n    // given. If positions are passed as a parameter, we're in a\n    // recursive loop for adjusting space for data labels.\n    if (!positions) {\n      series.center = positions = series.getCenter();\n    }\n    // Calculate the geometry for each point\n    for (i = 0; i < len; i++) {\n      point = points[i];\n      // Set start and end angle\n      start = startAngleRad + cumulative * circ;\n      if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {\n        cumulative += point.percentage / 100;\n      }\n      end = startAngleRad + cumulative * circ;\n      // Set the shape\n      const shapeArgs = {\n        x: positions[0],\n        y: positions[1],\n        r: positions[2] / 2,\n        innerR: positions[3] / 2,\n        start: Math.round(start * precision) / precision,\n        end: Math.round(end * precision) / precision\n      };\n      point.shapeType = 'arc';\n      point.shapeArgs = shapeArgs;\n      // The angle must stay within -90 and 270 (#2645)\n      angle = (end + start) / 2;\n      if (angle > 1.5 * Math.PI) {\n        angle -= 2 * Math.PI;\n      } else if (angle < -Math.PI / 2) {\n        angle += 2 * Math.PI;\n      }\n      // Center for the sliced out slice\n      point.slicedTranslation = {\n        translateX: Math.round(Math.cos(angle) * slicedOffset),\n        translateY: Math.round(Math.sin(angle) * slicedOffset)\n      };\n      // Set the anchor point for tooltips\n      radiusX = Math.cos(angle) * positions[2] / 2;\n      radiusY = Math.sin(angle) * positions[2] / 2;\n      point.tooltipPos = [positions[0] + radiusX * 0.7, positions[1] + radiusY * 0.7];\n      point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;\n      point.angle = angle;\n    }\n    fireEvent(series, 'afterTranslate');\n  }\n  /**\n   * Recompute total chart sum and update percentages of points.\n   * @private\n   */\n  updateTotals() {\n    const points = this.points,\n      len = points.length,\n      ignoreHiddenPoint = this.options.ignoreHiddenPoint;\n    let i,\n      point,\n      total = 0;\n    // Get the total sum\n    for (i = 0; i < len; i++) {\n      point = points[i];\n      if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {\n        total += point.y;\n      }\n    }\n    this.total = total;\n    // Set each point's properties\n    for (i = 0; i < len; i++) {\n      point = points[i];\n      point.percentage = total > 0 && (point.visible || !ignoreHiddenPoint) ? point.y / total * 100 : 0;\n      point.total = total;\n    }\n  }\n}\nPieSeries.defaultOptions = merge(Series.defaultOptions, PieSeriesDefaults);\nextend(PieSeries.prototype, {\n  axisTypes: [],\n  directTouch: true,\n  drawGraph: void 0,\n  drawTracker: ColumnSeries.prototype.drawTracker,\n  getCenter: CU.getCenter,\n  getSymbol: noop,\n  isCartesian: false,\n  noSharedTooltip: true,\n  pointAttribs: ColumnSeries.prototype.pointAttribs,\n  pointClass: PiePoint,\n  requireSorting: false,\n  searchPoint: noop,\n  trackerGroups: ['group', 'dataLabelsGroup']\n});\nSeriesRegistry.registerSeriesType('pie', PieSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default PieSeries;","map":{"version":3,"names":["CU","getStartAndEndRadians","ColumnSeries","H","noop","PiePoint","PieSeriesDefaults","Series","SeriesRegistry","Symbols","U","clamp","extend","fireEvent","merge","pick","relativeLength","splat","PieSeries","constructor","arguments","center","data","options","points","animate","init","series","startAngleRad","forEach","point","graphic","args","shapeArgs","attr","r","startR","start","end","animation","drawEmpty","endAngleRad","centerX","centerY","total","graph","chart","renderer","arc","addClass","add","group","d","innerR","styledMode","borderWidth","fill","fillColor","stroke","color","destroy","drawPoints","hasNewShapeType","shapeType","delayedRendering","generatePoints","updateTotals","getX","y","left","dataLabel","radius","radii","index","labelPosition","dataLabelPosition","distance","angle","Math","asin","x","cos","padding","hasData","processedXData","length","redrawPoints","groupTranslation","pointAttr","shadow","animateTo","isNull","getTranslate","pointAttribs","selected","setRadialReference","visibility","visible","getClassName","sortByAngle","sign","sort","a","b","translate","positions","precision","slicedOffset","radians","startAngle","endAngle","circ","ignoreHiddenPoint","len","radiusX","radiusY","i","cumulative","getCenter","isValid","percentage","round","PI","slicedTranslation","translateX","translateY","sin","tooltipPos","half","defaultOptions","prototype","axisTypes","directTouch","drawGraph","drawTracker","getSymbol","isCartesian","noSharedTooltip","pointClass","requireSorting","searchPoint","trackerGroups","registerSeriesType"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Series/Pie/PieSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport CU from '../CenteredUtilities.js';\nconst { getStartAndEndRadians } = CU;\nimport ColumnSeries from '../Column/ColumnSeries.js';\nimport H from '../../Core/Globals.js';\nconst { noop } = H;\nimport PiePoint from './PiePoint.js';\nimport PieSeriesDefaults from './PieSeriesDefaults.js';\nimport Series from '../../Core/Series/Series.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nimport Symbols from '../../Core/Renderer/SVG/Symbols.js';\nimport U from '../../Core/Utilities.js';\nconst { clamp, extend, fireEvent, merge, pick, relativeLength, splat } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * Pie series type.\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes.pie\n *\n * @augments Highcharts.Series\n */\nclass PieSeries extends Series {\n    constructor() {\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        super(...arguments);\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        this.center = void 0;\n        this.data = void 0;\n        this.options = void 0;\n        this.points = void 0;\n        /* eslint-enable valid-jsdoc */\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Animates the pies in.\n     * @private\n     */\n    animate(init) {\n        const series = this, points = series.points, startAngleRad = series.startAngleRad;\n        if (!init) {\n            points.forEach(function (point) {\n                const graphic = point.graphic, args = point.shapeArgs;\n                if (graphic && args) {\n                    // start values\n                    graphic.attr({\n                        // animate from inner radius (#779)\n                        r: pick(point.startR, (series.center && series.center[3] / 2)),\n                        start: startAngleRad,\n                        end: startAngleRad\n                    });\n                    // animate\n                    graphic.animate({\n                        r: args.r,\n                        start: args.start,\n                        end: args.end\n                    }, series.options.animation);\n                }\n            });\n        }\n    }\n    /**\n     * Called internally to draw auxiliary graph in pie-like series in\n     * situtation when the default graph is not sufficient enough to present\n     * the data well. Auxiliary graph is saved in the same object as\n     * regular graph.\n     * @private\n     */\n    drawEmpty() {\n        const start = this.startAngleRad, end = this.endAngleRad, options = this.options;\n        let centerX, centerY;\n        // Draw auxiliary graph if there're no visible points.\n        if (this.total === 0 && this.center) {\n            centerX = this.center[0];\n            centerY = this.center[1];\n            if (!this.graph) {\n                this.graph = this.chart.renderer\n                    .arc(centerX, centerY, this.center[1] / 2, 0, start, end)\n                    .addClass('highcharts-empty-series')\n                    .add(this.group);\n            }\n            this.graph.attr({\n                d: Symbols.arc(centerX, centerY, this.center[2] / 2, 0, {\n                    start,\n                    end,\n                    innerR: this.center[3] / 2\n                })\n            });\n            if (!this.chart.styledMode) {\n                this.graph.attr({\n                    'stroke-width': options.borderWidth,\n                    fill: options.fillColor || 'none',\n                    stroke: options.color || \"#cccccc\" /* Palette.neutralColor20 */\n                });\n            }\n        }\n        else if (this.graph) { // Destroy the graph object.\n            this.graph = this.graph.destroy();\n        }\n    }\n    /**\n     * Slices in pie chart are initialized in DOM, but it's shapes and\n     * animations are normally run in `drawPoints()`.\n     * @private\n     */\n    drawPoints() {\n        const renderer = this.chart.renderer;\n        this.points.forEach(function (point) {\n            // When updating a series between 2d and 3d or cartesian and\n            // polar, the shape type changes.\n            if (point.graphic && point.hasNewShapeType()) {\n                point.graphic = point.graphic.destroy();\n            }\n            if (!point.graphic) {\n                point.graphic = renderer[point.shapeType](point.shapeArgs)\n                    .add(point.series.group);\n                point.delayedRendering = true;\n            }\n        });\n    }\n    /**\n     * Extend the generatePoints method by adding total and percentage\n     * properties to each point\n     * @private\n     */\n    generatePoints() {\n        super.generatePoints();\n        this.updateTotals();\n    }\n    /**\n     * Utility for getting the x value from a given y, used for anticollision\n     * logic in data labels.\n     * @private\n     */\n    getX(y, left, point, dataLabel) {\n        const center = this.center, \n        // Variable pie has individual radius\n        radius = this.radii ?\n            this.radii[point.index] || 0 :\n            center[2] / 2, labelPosition = dataLabel.dataLabelPosition, distance = labelPosition?.distance || 0;\n        const angle = Math.asin(clamp((y - center[1]) / (radius + distance), -1, 1));\n        const x = center[0] +\n            (left ? -1 : 1) *\n                (Math.cos(angle) * (radius + distance)) +\n            (distance > 0 ?\n                (left ? -1 : 1) * (dataLabel.padding || 0) :\n                0);\n        return x;\n    }\n    /**\n     * Define hasData function for non-cartesian series. Returns true if the\n     * series has points at all.\n     * @private\n     */\n    hasData() {\n        return !!this.processedXData.length; // != 0\n    }\n    /**\n     * Draw the data points\n     * @private\n     */\n    redrawPoints() {\n        const series = this, chart = series.chart;\n        let groupTranslation, graphic, pointAttr, shapeArgs;\n        this.drawEmpty();\n        // Apply the drop-shadow to the group because otherwise each element\n        // would cast a shadow on others\n        if (series.group && !chart.styledMode) {\n            series.group.shadow(series.options.shadow);\n        }\n        // draw the slices\n        series.points.forEach(function (point) {\n            const animateTo = {};\n            graphic = point.graphic;\n            if (!point.isNull && graphic) {\n                shapeArgs = point.shapeArgs;\n                // If the point is sliced, use special translation, else use\n                // plot area translation\n                groupTranslation = point.getTranslate();\n                if (!chart.styledMode) {\n                    pointAttr = series.pointAttribs(point, (point.selected && 'select'));\n                }\n                // Draw the slice\n                if (!point.delayedRendering) {\n                    graphic\n                        .setRadialReference(series.center);\n                    if (!chart.styledMode) {\n                        merge(true, animateTo, pointAttr);\n                    }\n                    merge(true, animateTo, shapeArgs, groupTranslation);\n                    graphic.animate(animateTo);\n                }\n                else {\n                    graphic\n                        .setRadialReference(series.center)\n                        .attr(shapeArgs)\n                        .attr(groupTranslation);\n                    if (!chart.styledMode) {\n                        graphic\n                            .attr(pointAttr)\n                            .attr({ 'stroke-linejoin': 'round' });\n                    }\n                    point.delayedRendering = false;\n                }\n                graphic\n                    .attr({\n                    visibility: point.visible ? 'inherit' : 'hidden'\n                });\n                graphic.addClass(point.getClassName(), true);\n            }\n            else if (graphic) {\n                point.graphic = graphic.destroy();\n            }\n        });\n    }\n    /**\n     * Utility for sorting data labels.\n     * @private\n     */\n    sortByAngle(points, sign) {\n        points.sort(function (a, b) {\n            return ((typeof a.angle !== 'undefined') &&\n                (b.angle - a.angle) * sign);\n        });\n    }\n    /**\n     * Do translation for pie slices\n     * @private\n     */\n    translate(positions) {\n        fireEvent(this, 'translate');\n        this.generatePoints();\n        const series = this, precision = 1000, // issue #172\n        options = series.options, slicedOffset = options.slicedOffset, radians = getStartAndEndRadians(options.startAngle, options.endAngle), startAngleRad = series.startAngleRad = radians.start, endAngleRad = series.endAngleRad = radians.end, circ = endAngleRad - startAngleRad, // 2 * Math.PI,\n        points = series.points, ignoreHiddenPoint = options.ignoreHiddenPoint, len = points.length;\n        let start, end, angle, \n        // The x component of the radius vector for a given point\n        radiusX, radiusY, i, point, cumulative = 0;\n        // Get positions - either an integer or a percentage string must be\n        // given. If positions are passed as a parameter, we're in a\n        // recursive loop for adjusting space for data labels.\n        if (!positions) {\n            series.center = positions = series.getCenter();\n        }\n        // Calculate the geometry for each point\n        for (i = 0; i < len; i++) {\n            point = points[i];\n            // Set start and end angle\n            start = startAngleRad + (cumulative * circ);\n            if (point.isValid() &&\n                (!ignoreHiddenPoint || point.visible)) {\n                cumulative += point.percentage / 100;\n            }\n            end = startAngleRad + (cumulative * circ);\n            // Set the shape\n            const shapeArgs = {\n                x: positions[0],\n                y: positions[1],\n                r: positions[2] / 2,\n                innerR: positions[3] / 2,\n                start: Math.round(start * precision) / precision,\n                end: Math.round(end * precision) / precision\n            };\n            point.shapeType = 'arc';\n            point.shapeArgs = shapeArgs;\n            // The angle must stay within -90 and 270 (#2645)\n            angle = (end + start) / 2;\n            if (angle > 1.5 * Math.PI) {\n                angle -= 2 * Math.PI;\n            }\n            else if (angle < -Math.PI / 2) {\n                angle += 2 * Math.PI;\n            }\n            // Center for the sliced out slice\n            point.slicedTranslation = {\n                translateX: Math.round(Math.cos(angle) * slicedOffset),\n                translateY: Math.round(Math.sin(angle) * slicedOffset)\n            };\n            // Set the anchor point for tooltips\n            radiusX = Math.cos(angle) * positions[2] / 2;\n            radiusY = Math.sin(angle) * positions[2] / 2;\n            point.tooltipPos = [\n                positions[0] + radiusX * 0.7,\n                positions[1] + radiusY * 0.7\n            ];\n            point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ?\n                1 :\n                0;\n            point.angle = angle;\n        }\n        fireEvent(series, 'afterTranslate');\n    }\n    /**\n     * Recompute total chart sum and update percentages of points.\n     * @private\n     */\n    updateTotals() {\n        const points = this.points, len = points.length, ignoreHiddenPoint = this.options.ignoreHiddenPoint;\n        let i, point, total = 0;\n        // Get the total sum\n        for (i = 0; i < len; i++) {\n            point = points[i];\n            if (point.isValid() &&\n                (!ignoreHiddenPoint || point.visible)) {\n                total += point.y;\n            }\n        }\n        this.total = total;\n        // Set each point's properties\n        for (i = 0; i < len; i++) {\n            point = points[i];\n            point.percentage =\n                (total > 0 && (point.visible || !ignoreHiddenPoint)) ?\n                    point.y / total * 100 :\n                    0;\n            point.total = total;\n        }\n    }\n}\nPieSeries.defaultOptions = merge(Series.defaultOptions, PieSeriesDefaults);\nextend(PieSeries.prototype, {\n    axisTypes: [],\n    directTouch: true,\n    drawGraph: void 0,\n    drawTracker: ColumnSeries.prototype.drawTracker,\n    getCenter: CU.getCenter,\n    getSymbol: noop,\n    isCartesian: false,\n    noSharedTooltip: true,\n    pointAttribs: ColumnSeries.prototype.pointAttribs,\n    pointClass: PiePoint,\n    requireSorting: false,\n    searchPoint: noop,\n    trackerGroups: ['group', 'dataLabelsGroup']\n});\nSeriesRegistry.registerSeriesType('pie', PieSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default PieSeries;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}