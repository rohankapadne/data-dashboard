{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport A from '../../Animation/AnimationUtilities.js';\nconst {\n  getDeferredAnimation\n} = A;\nimport Axis from '../Axis.js';\nimport SeriesRegistry from '../../Series/SeriesRegistry.js';\nconst {\n  series: {\n    prototype: seriesProto\n  }\n} = SeriesRegistry;\nimport StackItem from './StackItem.js';\nimport U from '../../Utilities.js';\nconst {\n  addEvent,\n  correctFloat,\n  defined,\n  destroyObjectProperties,\n  fireEvent,\n  isArray,\n  isNumber,\n  objectEach,\n  pick\n} = U;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Generate stacks for each series and calculate stacks total values\n *\n * @private\n * @function Highcharts.Chart#getStacks\n */\nfunction chartGetStacks() {\n  const chart = this,\n    inverted = chart.inverted;\n  // Reset stacks for each axis\n  chart.axes.forEach(axis => {\n    if (axis.stacking && axis.stacking.stacks && axis.hasVisibleSeries) {\n      axis.stacking.oldStacks = axis.stacking.stacks;\n    }\n  });\n  chart.series.forEach(series => {\n    const xAxisOptions = series.xAxis && series.xAxis.options || {};\n    if (series.options.stacking && series.reserveSpace()) {\n      series.stackKey = [series.type, pick(series.options.stack, ''), inverted ? xAxisOptions.top : xAxisOptions.left, inverted ? xAxisOptions.height : xAxisOptions.width].join(',');\n    }\n  });\n}\n/**\n * @private\n */\nfunction onAxisDestroy() {\n  const stacking = this.stacking;\n  if (stacking) {\n    const stacks = stacking.stacks;\n    // Destroy each stack total\n    objectEach(stacks, (stack, stackKey) => {\n      destroyObjectProperties(stack);\n      delete stacks[stackKey];\n    });\n    stacking.stackTotalGroup?.destroy();\n  }\n}\n/**\n * @private\n */\nfunction onAxisInit() {\n  if (!this.stacking) {\n    this.stacking = new AxisAdditions(this);\n  }\n}\n/**\n * Get stack indicator, according to it's x-value, to determine points with the\n * same x-value\n *\n * @private\n * @function Highcharts.Series#getStackIndicator\n */\nfunction seriesGetStackIndicator(stackIndicator, x, index, key) {\n  // Update stack indicator, when:\n  // first point in a stack || x changed || stack type (negative vs positive)\n  // changed:\n  if (!defined(stackIndicator) || stackIndicator.x !== x || key && stackIndicator.stackKey !== key) {\n    stackIndicator = {\n      x: x,\n      index: 0,\n      key,\n      stackKey: key\n    };\n  } else {\n    stackIndicator.index++;\n  }\n  stackIndicator.key = [index, x, stackIndicator.index].join(',');\n  return stackIndicator;\n}\n/**\n * Iterate over all stacks and compute the absolute values to percent\n *\n * @private\n * @function Highcharts.Series#modifyStacks\n */\nfunction seriesModifyStacks() {\n  const series = this,\n    yAxis = series.yAxis,\n    stackKey = series.stackKey || '',\n    stacks = yAxis.stacking.stacks,\n    processedXData = series.processedXData,\n    stacking = series.options.stacking,\n    stacker = series[stacking + 'Stacker'];\n  let stackIndicator;\n  if (stacker) {\n    // Modifier function exists (Series.percentStacker etc.)\n    [stackKey, '-' + stackKey].forEach(key => {\n      let i = processedXData.length,\n        x,\n        stackItem,\n        pointExtremes;\n      while (i--) {\n        x = processedXData[i];\n        stackIndicator = series.getStackIndicator(stackIndicator, x, series.index, key);\n        stackItem = stacks[key]?.[x];\n        pointExtremes = stackItem?.points[stackIndicator.key || ''];\n        if (pointExtremes) {\n          stacker.call(series, pointExtremes, stackItem, i);\n        }\n      }\n    });\n  }\n}\n/**\n * Modifier function for percent stacks. Blows up the stack to 100%.\n *\n * @private\n * @function Highcharts.Series#percentStacker\n */\nfunction seriesPercentStacker(pointExtremes, stack, i) {\n  const totalFactor = stack.total ? 100 / stack.total : 0;\n  // Y bottom value\n  pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor);\n  // Y value\n  pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor);\n  this.stackedYData[i] = pointExtremes[1];\n}\n/**\n * Set grouped points in a stack-like object. When `centerInCategory` is true,\n * and `stacking` is not enabled, we need a pseudo (horizontal) stack in order\n * to handle grouping of points within the same category.\n *\n * @private\n * @function Highcharts.Series#setGroupedPoints\n * @return {void}\n */\nfunction seriesSetGroupedPoints(axis) {\n  if (this.options.centerInCategory && (this.is('column') || this.is('columnrange')) &&\n  // With stacking enabled, we already have stacks that we can compute\n  // from\n  !this.options.stacking &&\n  // With only one series, we don't need to consider centerInCategory\n  this.chart.series.length > 1) {\n    seriesProto.setStackedPoints.call(this, axis, 'group');\n    // After updating, if we now have proper stacks, we must delete the group\n    // pseudo stacks (#14980)\n  } else {\n    axis.stacking.resetStacks();\n  }\n}\n/**\n * Adds series' points value to corresponding stack\n *\n * @private\n * @function Highcharts.Series#setStackedPoints\n */\nfunction seriesSetStackedPoints(axis, stackingParam) {\n  const type = stackingParam || this.options.stacking;\n  if (!type || !this.reserveSpace() ||\n  // Group stacks (centerInCategory) belong on the x-axis, other stacks on\n  // the y-axis.\n  ({\n    group: 'xAxis'\n  }[type] || 'yAxis') !== axis.coll) {\n    return;\n  }\n  const series = this,\n    xData = series.processedXData,\n    yData = series.processedYData,\n    stackedYData = [],\n    yDataLength = yData.length,\n    seriesOptions = series.options,\n    threshold = seriesOptions.threshold || 0,\n    stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,\n    stackOption = seriesOptions.stack,\n    stackKey = stackingParam ? `${series.type},${type}` : series.stackKey || '',\n    negKey = '-' + stackKey,\n    negStacks = series.negStacks,\n    stacking = axis.stacking,\n    stacks = stacking.stacks,\n    oldStacks = stacking.oldStacks;\n  let stackIndicator, isNegative, stack, other, key, pointKey, i, x, y;\n  stacking.stacksTouched += 1;\n  // Loop over the non-null y values and read them into a local array\n  for (i = 0; i < yDataLength; i++) {\n    x = xData[i];\n    y = yData[i];\n    stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);\n    pointKey = stackIndicator.key || '';\n    // Read stacked values into a stack based on the x value,\n    // the sign of y and the stack key. Stacking is also handled for null\n    // values (#739)\n    isNegative = negStacks && y < (stackThreshold ? 0 : threshold);\n    key = isNegative ? negKey : stackKey;\n    // Create empty object for this stack if it doesn't exist yet\n    if (!stacks[key]) {\n      stacks[key] = {};\n    }\n    // Initialize StackItem for this x\n    if (!stacks[key][x]) {\n      if (oldStacks[key]?.[x]) {\n        stacks[key][x] = oldStacks[key][x];\n        stacks[key][x].total = null;\n      } else {\n        stacks[key][x] = new StackItem(axis, axis.options.stackLabels, !!isNegative, x, stackOption);\n      }\n    }\n    // If the StackItem doesn't exist, create it first\n    stack = stacks[key][x];\n    if (y !== null) {\n      stack.points[pointKey] = stack.points[series.index] = [pick(stack.cumulative, stackThreshold)];\n      // Record the base of the stack\n      if (!defined(stack.cumulative)) {\n        stack.base = pointKey;\n      }\n      stack.touched = stacking.stacksTouched;\n      // In area charts, if there are multiple points on the same X value,\n      // let the area fill the full span of those points\n      if (stackIndicator.index > 0 && series.singleStacks === false) {\n        stack.points[pointKey][0] = stack.points[series.index + ',' + x + ',0'][0];\n      }\n      // When updating to null, reset the point stack (#7493)\n    } else {\n      delete stack.points[pointKey];\n      delete stack.points[series.index];\n    }\n    // Add value to the stack total\n    let total = stack.total || 0;\n    if (type === 'percent') {\n      // Percent stacked column, totals are the same for the positive and\n      // negative stacks\n      other = isNegative ? stackKey : negKey;\n      if (negStacks && stacks[other]?.[x]) {\n        other = stacks[other][x];\n        total = other.total = Math.max(other.total || 0, total) + Math.abs(y) || 0;\n        // Percent stacked areas\n      } else {\n        total = correctFloat(total + (Math.abs(y) || 0));\n      }\n    } else if (type === 'group') {\n      if (isArray(y)) {\n        y = y[0];\n      }\n      // In this stack, the total is the number of valid points\n      if (y !== null) {\n        total++;\n      }\n    } else {\n      total = correctFloat(total + (y || 0));\n    }\n    if (type === 'group') {\n      // This point's index within the stack, pushed to stack.points[1]\n      stack.cumulative = (total || 1) - 1;\n    } else {\n      stack.cumulative = correctFloat(pick(stack.cumulative, stackThreshold) + (y || 0));\n    }\n    stack.total = total;\n    if (y !== null) {\n      stack.points[pointKey].push(stack.cumulative);\n      stackedYData[i] = stack.cumulative;\n      stack.hasValidPoints = true;\n    }\n  }\n  if (type === 'percent') {\n    stacking.usePercentage = true;\n  }\n  if (type !== 'group') {\n    this.stackedYData = stackedYData; // To be used in getExtremes\n  }\n  // Reset old stacks\n  stacking.oldStacks = {};\n}\n/* *\n *\n *  Classes\n *\n * */\n/**\n * Adds stacking support to axes.\n * @private\n * @class\n */\nclass AxisAdditions {\n  /* *\n   *\n   *  Constructors\n   *\n   * */\n  constructor(axis) {\n    this.oldStacks = {};\n    this.stacks = {};\n    this.stacksTouched = 0;\n    this.axis = axis;\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * Build the stacks from top down\n   * @private\n   */\n  buildStacks() {\n    const stacking = this,\n      axis = stacking.axis,\n      axisSeries = axis.series,\n      isXAxis = axis.coll === 'xAxis',\n      reversedStacks = axis.options.reversedStacks,\n      len = axisSeries.length;\n    let actualSeries, i;\n    this.resetStacks();\n    stacking.usePercentage = false;\n    i = len;\n    while (i--) {\n      actualSeries = axisSeries[reversedStacks ? i : len - i - 1];\n      if (isXAxis) {\n        actualSeries.setGroupedPoints(axis);\n      }\n      actualSeries.setStackedPoints(axis);\n    }\n    // Loop up again to compute percent and stream stack\n    if (!isXAxis) {\n      for (i = 0; i < len; i++) {\n        axisSeries[i].modifyStacks();\n      }\n    }\n    fireEvent(axis, 'afterBuildStacks');\n  }\n  /**\n   * @private\n   */\n  cleanStacks() {\n    if (this.oldStacks) {\n      this.stacks = this.oldStacks;\n      // Reset stacks\n      objectEach(this.stacks, type => {\n        objectEach(type, stack => {\n          stack.cumulative = stack.total;\n        });\n      });\n    }\n  }\n  /**\n   * Set all the stacks to initial states and destroy unused ones.\n   * @private\n   */\n  resetStacks() {\n    objectEach(this.stacks, type => {\n      objectEach(type, (stack, x) => {\n        // Clean up memory after point deletion (#1044, #4320)\n        if (isNumber(stack.touched) && stack.touched < this.stacksTouched) {\n          stack.destroy();\n          delete type[x];\n          // Reset stacks\n        } else {\n          stack.total = null;\n          stack.cumulative = null;\n        }\n      });\n    });\n  }\n  /**\n   * @private\n   */\n  renderStackTotals() {\n    const stacking = this,\n      axis = stacking.axis,\n      chart = axis.chart,\n      renderer = chart.renderer,\n      stacks = stacking.stacks,\n      stackLabelsAnim = axis.options.stackLabels?.animation,\n      animationConfig = getDeferredAnimation(chart, stackLabelsAnim || false),\n      stackTotalGroup = stacking.stackTotalGroup = stacking.stackTotalGroup || renderer.g('stack-labels').attr({\n        zIndex: 6,\n        opacity: 0\n      }).add();\n    // The plotLeft/Top will change when y axis gets wider so we need to\n    // translate the stackTotalGroup at every render call. See bug #506\n    // and #516\n    stackTotalGroup.translate(chart.plotLeft, chart.plotTop);\n    // Render each stack total\n    objectEach(stacks, type => {\n      objectEach(type, stack => {\n        stack.render(stackTotalGroup);\n      });\n    });\n    stackTotalGroup.animate({\n      opacity: 1\n    }, animationConfig);\n  }\n}\n/* *\n *\n *  Composition\n *\n * */\nvar StackingAxis;\n(function (StackingAxis) {\n  /* *\n   *\n   *  Constants\n   *\n   * */\n  const composedMembers = [];\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * Extends axis with stacking support.\n   * @private\n   */\n  function compose(AxisClass, ChartClass, SeriesClass) {\n    if (U.pushUnique(composedMembers, AxisClass)) {\n      addEvent(AxisClass, 'init', onAxisInit);\n      addEvent(AxisClass, 'destroy', onAxisDestroy);\n    }\n    if (U.pushUnique(composedMembers, ChartClass)) {\n      const chartProto = ChartClass.prototype;\n      chartProto.getStacks = chartGetStacks;\n    }\n    if (U.pushUnique(composedMembers, SeriesClass)) {\n      const seriesProto = SeriesClass.prototype;\n      seriesProto.getStackIndicator = seriesGetStackIndicator;\n      seriesProto.modifyStacks = seriesModifyStacks;\n      seriesProto.percentStacker = seriesPercentStacker;\n      seriesProto.setGroupedPoints = seriesSetGroupedPoints;\n      seriesProto.setStackedPoints = seriesSetStackedPoints;\n    }\n  }\n  StackingAxis.compose = compose;\n})(StackingAxis || (StackingAxis = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default StackingAxis;","map":{"version":3,"names":["A","getDeferredAnimation","Axis","SeriesRegistry","series","prototype","seriesProto","StackItem","U","addEvent","correctFloat","defined","destroyObjectProperties","fireEvent","isArray","isNumber","objectEach","pick","chartGetStacks","chart","inverted","axes","forEach","axis","stacking","stacks","hasVisibleSeries","oldStacks","xAxisOptions","xAxis","options","reserveSpace","stackKey","type","stack","top","left","height","width","join","onAxisDestroy","stackTotalGroup","destroy","onAxisInit","AxisAdditions","seriesGetStackIndicator","stackIndicator","x","index","key","seriesModifyStacks","yAxis","processedXData","stacker","i","length","stackItem","pointExtremes","getStackIndicator","points","call","seriesPercentStacker","totalFactor","total","stackedYData","seriesSetGroupedPoints","centerInCategory","is","setStackedPoints","resetStacks","seriesSetStackedPoints","stackingParam","group","coll","xData","yData","processedYData","yDataLength","seriesOptions","threshold","stackThreshold","startFromThreshold","stackOption","negKey","negStacks","isNegative","other","pointKey","y","stacksTouched","stackLabels","cumulative","base","touched","singleStacks","Math","max","abs","push","hasValidPoints","usePercentage","constructor","buildStacks","axisSeries","isXAxis","reversedStacks","len","actualSeries","setGroupedPoints","modifyStacks","cleanStacks","renderStackTotals","renderer","stackLabelsAnim","animation","animationConfig","g","attr","zIndex","opacity","add","translate","plotLeft","plotTop","render","animate","StackingAxis","composedMembers","compose","AxisClass","ChartClass","SeriesClass","pushUnique","chartProto","getStacks","percentStacker"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Axis/Stacking/StackingAxis.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport A from '../../Animation/AnimationUtilities.js';\nconst { getDeferredAnimation } = A;\nimport Axis from '../Axis.js';\nimport SeriesRegistry from '../../Series/SeriesRegistry.js';\nconst { series: { prototype: seriesProto } } = SeriesRegistry;\nimport StackItem from './StackItem.js';\nimport U from '../../Utilities.js';\nconst { addEvent, correctFloat, defined, destroyObjectProperties, fireEvent, isArray, isNumber, objectEach, pick } = U;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Generate stacks for each series and calculate stacks total values\n *\n * @private\n * @function Highcharts.Chart#getStacks\n */\nfunction chartGetStacks() {\n    const chart = this, inverted = chart.inverted;\n    // Reset stacks for each axis\n    chart.axes.forEach((axis) => {\n        if (axis.stacking && axis.stacking.stacks && axis.hasVisibleSeries) {\n            axis.stacking.oldStacks = axis.stacking.stacks;\n        }\n    });\n    chart.series.forEach((series) => {\n        const xAxisOptions = series.xAxis && series.xAxis.options || {};\n        if (series.options.stacking && series.reserveSpace()) {\n            series.stackKey = [\n                series.type,\n                pick(series.options.stack, ''),\n                inverted ? xAxisOptions.top : xAxisOptions.left,\n                inverted ? xAxisOptions.height : xAxisOptions.width\n            ].join(',');\n        }\n    });\n}\n/**\n * @private\n */\nfunction onAxisDestroy() {\n    const stacking = this.stacking;\n    if (stacking) {\n        const stacks = stacking.stacks;\n        // Destroy each stack total\n        objectEach(stacks, (stack, stackKey) => {\n            destroyObjectProperties(stack);\n            delete stacks[stackKey];\n        });\n        stacking.stackTotalGroup?.destroy();\n    }\n}\n/**\n * @private\n */\nfunction onAxisInit() {\n    if (!this.stacking) {\n        this.stacking = new AxisAdditions(this);\n    }\n}\n/**\n * Get stack indicator, according to it's x-value, to determine points with the\n * same x-value\n *\n * @private\n * @function Highcharts.Series#getStackIndicator\n */\nfunction seriesGetStackIndicator(stackIndicator, x, index, key) {\n    // Update stack indicator, when:\n    // first point in a stack || x changed || stack type (negative vs positive)\n    // changed:\n    if (!defined(stackIndicator) ||\n        stackIndicator.x !== x ||\n        (key && stackIndicator.stackKey !== key)) {\n        stackIndicator = {\n            x: x,\n            index: 0,\n            key,\n            stackKey: key\n        };\n    }\n    else {\n        stackIndicator.index++;\n    }\n    stackIndicator.key = [index, x, stackIndicator.index].join(',');\n    return stackIndicator;\n}\n/**\n * Iterate over all stacks and compute the absolute values to percent\n *\n * @private\n * @function Highcharts.Series#modifyStacks\n */\nfunction seriesModifyStacks() {\n    const series = this, yAxis = series.yAxis, stackKey = series.stackKey || '', stacks = yAxis.stacking.stacks, processedXData = series.processedXData, stacking = series.options.stacking, stacker = series[stacking + 'Stacker'];\n    let stackIndicator;\n    if (stacker) { // Modifier function exists (Series.percentStacker etc.)\n        [stackKey, '-' + stackKey].forEach((key) => {\n            let i = processedXData.length, x, stackItem, pointExtremes;\n            while (i--) {\n                x = processedXData[i];\n                stackIndicator = series.getStackIndicator(stackIndicator, x, series.index, key);\n                stackItem = stacks[key]?.[x];\n                pointExtremes = stackItem?.points[stackIndicator.key || ''];\n                if (pointExtremes) {\n                    stacker.call(series, pointExtremes, stackItem, i);\n                }\n            }\n        });\n    }\n}\n/**\n * Modifier function for percent stacks. Blows up the stack to 100%.\n *\n * @private\n * @function Highcharts.Series#percentStacker\n */\nfunction seriesPercentStacker(pointExtremes, stack, i) {\n    const totalFactor = stack.total ? 100 / stack.total : 0;\n    // Y bottom value\n    pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor);\n    // Y value\n    pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor);\n    this.stackedYData[i] = pointExtremes[1];\n}\n/**\n * Set grouped points in a stack-like object. When `centerInCategory` is true,\n * and `stacking` is not enabled, we need a pseudo (horizontal) stack in order\n * to handle grouping of points within the same category.\n *\n * @private\n * @function Highcharts.Series#setGroupedPoints\n * @return {void}\n */\nfunction seriesSetGroupedPoints(axis) {\n    if (this.options.centerInCategory &&\n        (this.is('column') || this.is('columnrange')) &&\n        // With stacking enabled, we already have stacks that we can compute\n        // from\n        !this.options.stacking &&\n        // With only one series, we don't need to consider centerInCategory\n        this.chart.series.length > 1) {\n        seriesProto.setStackedPoints.call(this, axis, 'group');\n        // After updating, if we now have proper stacks, we must delete the group\n        // pseudo stacks (#14980)\n    }\n    else {\n        axis.stacking.resetStacks();\n    }\n}\n/**\n * Adds series' points value to corresponding stack\n *\n * @private\n * @function Highcharts.Series#setStackedPoints\n */\nfunction seriesSetStackedPoints(axis, stackingParam) {\n    const type = stackingParam || this.options.stacking;\n    if (!type ||\n        !this.reserveSpace() ||\n        // Group stacks (centerInCategory) belong on the x-axis, other stacks on\n        // the y-axis.\n        ({ group: 'xAxis' }[type] || 'yAxis') !== axis.coll) {\n        return;\n    }\n    const series = this, xData = series.processedXData, yData = series.processedYData, stackedYData = [], yDataLength = yData.length, seriesOptions = series.options, threshold = seriesOptions.threshold || 0, stackThreshold = seriesOptions.startFromThreshold ? threshold : 0, stackOption = seriesOptions.stack, stackKey = stackingParam ?\n        `${series.type},${type}` : (series.stackKey || ''), negKey = '-' + stackKey, negStacks = series.negStacks, stacking = axis.stacking, stacks = stacking.stacks, oldStacks = stacking.oldStacks;\n    let stackIndicator, isNegative, stack, other, key, pointKey, i, x, y;\n    stacking.stacksTouched += 1;\n    // Loop over the non-null y values and read them into a local array\n    for (i = 0; i < yDataLength; i++) {\n        x = xData[i];\n        y = yData[i];\n        stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);\n        pointKey = stackIndicator.key || '';\n        // Read stacked values into a stack based on the x value,\n        // the sign of y and the stack key. Stacking is also handled for null\n        // values (#739)\n        isNegative = negStacks && y < (stackThreshold ? 0 : threshold);\n        key = isNegative ? negKey : stackKey;\n        // Create empty object for this stack if it doesn't exist yet\n        if (!stacks[key]) {\n            stacks[key] = {};\n        }\n        // Initialize StackItem for this x\n        if (!stacks[key][x]) {\n            if (oldStacks[key]?.[x]) {\n                stacks[key][x] = oldStacks[key][x];\n                stacks[key][x].total = null;\n            }\n            else {\n                stacks[key][x] = new StackItem(axis, axis.options.stackLabels, !!isNegative, x, stackOption);\n            }\n        }\n        // If the StackItem doesn't exist, create it first\n        stack = stacks[key][x];\n        if (y !== null) {\n            stack.points[pointKey] = stack.points[series.index] = [\n                pick(stack.cumulative, stackThreshold)\n            ];\n            // Record the base of the stack\n            if (!defined(stack.cumulative)) {\n                stack.base = pointKey;\n            }\n            stack.touched = stacking.stacksTouched;\n            // In area charts, if there are multiple points on the same X value,\n            // let the area fill the full span of those points\n            if (stackIndicator.index > 0 && series.singleStacks === false) {\n                stack.points[pointKey][0] = stack.points[series.index + ',' + x + ',0'][0];\n            }\n            // When updating to null, reset the point stack (#7493)\n        }\n        else {\n            delete stack.points[pointKey];\n            delete stack.points[series.index];\n        }\n        // Add value to the stack total\n        let total = stack.total || 0;\n        if (type === 'percent') {\n            // Percent stacked column, totals are the same for the positive and\n            // negative stacks\n            other = isNegative ? stackKey : negKey;\n            if (negStacks && stacks[other]?.[x]) {\n                other = stacks[other][x];\n                total = other.total =\n                    Math.max(other.total || 0, total) +\n                        Math.abs(y) || 0;\n                // Percent stacked areas\n            }\n            else {\n                total = correctFloat(total + (Math.abs(y) || 0));\n            }\n        }\n        else if (type === 'group') {\n            if (isArray(y)) {\n                y = y[0];\n            }\n            // In this stack, the total is the number of valid points\n            if (y !== null) {\n                total++;\n            }\n        }\n        else {\n            total = correctFloat(total + (y || 0));\n        }\n        if (type === 'group') {\n            // This point's index within the stack, pushed to stack.points[1]\n            stack.cumulative = (total || 1) - 1;\n        }\n        else {\n            stack.cumulative = correctFloat(pick(stack.cumulative, stackThreshold) +\n                (y || 0));\n        }\n        stack.total = total;\n        if (y !== null) {\n            stack.points[pointKey].push(stack.cumulative);\n            stackedYData[i] = stack.cumulative;\n            stack.hasValidPoints = true;\n        }\n    }\n    if (type === 'percent') {\n        stacking.usePercentage = true;\n    }\n    if (type !== 'group') {\n        this.stackedYData = stackedYData; // To be used in getExtremes\n    }\n    // Reset old stacks\n    stacking.oldStacks = {};\n}\n/* *\n *\n *  Classes\n *\n * */\n/**\n * Adds stacking support to axes.\n * @private\n * @class\n */\nclass AxisAdditions {\n    /* *\n     *\n     *  Constructors\n     *\n     * */\n    constructor(axis) {\n        this.oldStacks = {};\n        this.stacks = {};\n        this.stacksTouched = 0;\n        this.axis = axis;\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Build the stacks from top down\n     * @private\n     */\n    buildStacks() {\n        const stacking = this, axis = stacking.axis, axisSeries = axis.series, isXAxis = axis.coll === 'xAxis', reversedStacks = axis.options.reversedStacks, len = axisSeries.length;\n        let actualSeries, i;\n        this.resetStacks();\n        stacking.usePercentage = false;\n        i = len;\n        while (i--) {\n            actualSeries = axisSeries[reversedStacks ? i : len - i - 1];\n            if (isXAxis) {\n                actualSeries.setGroupedPoints(axis);\n            }\n            actualSeries.setStackedPoints(axis);\n        }\n        // Loop up again to compute percent and stream stack\n        if (!isXAxis) {\n            for (i = 0; i < len; i++) {\n                axisSeries[i].modifyStacks();\n            }\n        }\n        fireEvent(axis, 'afterBuildStacks');\n    }\n    /**\n     * @private\n     */\n    cleanStacks() {\n        if (this.oldStacks) {\n            this.stacks = this.oldStacks;\n            // Reset stacks\n            objectEach(this.stacks, (type) => {\n                objectEach(type, (stack) => {\n                    stack.cumulative = stack.total;\n                });\n            });\n        }\n    }\n    /**\n     * Set all the stacks to initial states and destroy unused ones.\n     * @private\n     */\n    resetStacks() {\n        objectEach(this.stacks, (type) => {\n            objectEach(type, (stack, x) => {\n                // Clean up memory after point deletion (#1044, #4320)\n                if (isNumber(stack.touched) &&\n                    stack.touched < this.stacksTouched) {\n                    stack.destroy();\n                    delete type[x];\n                    // Reset stacks\n                }\n                else {\n                    stack.total = null;\n                    stack.cumulative = null;\n                }\n            });\n        });\n    }\n    /**\n     * @private\n     */\n    renderStackTotals() {\n        const stacking = this, axis = stacking.axis, chart = axis.chart, renderer = chart.renderer, stacks = stacking.stacks, stackLabelsAnim = axis.options.stackLabels?.animation, animationConfig = getDeferredAnimation(chart, stackLabelsAnim || false), stackTotalGroup = stacking.stackTotalGroup = (stacking.stackTotalGroup ||\n            renderer\n                .g('stack-labels')\n                .attr({\n                zIndex: 6,\n                opacity: 0\n            })\n                .add());\n        // The plotLeft/Top will change when y axis gets wider so we need to\n        // translate the stackTotalGroup at every render call. See bug #506\n        // and #516\n        stackTotalGroup.translate(chart.plotLeft, chart.plotTop);\n        // Render each stack total\n        objectEach(stacks, (type) => {\n            objectEach(type, (stack) => {\n                stack.render(stackTotalGroup);\n            });\n        });\n        stackTotalGroup.animate({\n            opacity: 1\n        }, animationConfig);\n    }\n}\n/* *\n *\n *  Composition\n *\n * */\nvar StackingAxis;\n(function (StackingAxis) {\n    /* *\n     *\n     *  Constants\n     *\n     * */\n    const composedMembers = [];\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Extends axis with stacking support.\n     * @private\n     */\n    function compose(AxisClass, ChartClass, SeriesClass) {\n        if (U.pushUnique(composedMembers, AxisClass)) {\n            addEvent(AxisClass, 'init', onAxisInit);\n            addEvent(AxisClass, 'destroy', onAxisDestroy);\n        }\n        if (U.pushUnique(composedMembers, ChartClass)) {\n            const chartProto = ChartClass.prototype;\n            chartProto.getStacks = chartGetStacks;\n        }\n        if (U.pushUnique(composedMembers, SeriesClass)) {\n            const seriesProto = SeriesClass.prototype;\n            seriesProto.getStackIndicator = seriesGetStackIndicator;\n            seriesProto.modifyStacks = seriesModifyStacks;\n            seriesProto.percentStacker = seriesPercentStacker;\n            seriesProto.setGroupedPoints = seriesSetGroupedPoints;\n            seriesProto.setStackedPoints = seriesSetStackedPoints;\n        }\n    }\n    StackingAxis.compose = compose;\n})(StackingAxis || (StackingAxis = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default StackingAxis;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}