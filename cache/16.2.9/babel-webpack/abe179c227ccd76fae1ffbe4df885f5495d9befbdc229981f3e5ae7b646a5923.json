{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\nimport SVGElement from './SVGElement.js';\nimport U from '../../Utilities.js';\nconst {\n  defined,\n  extend,\n  isNumber,\n  merge,\n  pick,\n  removeEvent\n} = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * SVG label to render text.\n * @private\n * @class\n * @name Highcharts.SVGLabel\n * @augments Highcharts.SVGElement\n */\nclass SVGLabel extends SVGElement {\n  /* *\n   *\n   *  Constructor\n   *\n   * */\n  constructor(renderer, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n    super();\n    this.paddingLeftSetter = this.paddingSetter;\n    this.paddingRightSetter = this.paddingSetter;\n    this.init(renderer, 'g');\n    this.textStr = str;\n    this.x = x;\n    this.y = y;\n    this.anchorX = anchorX;\n    this.anchorY = anchorY;\n    this.baseline = baseline;\n    this.className = className;\n    this.addClass(className === 'button' ? 'highcharts-no-tooltip' : 'highcharts-label');\n    if (className) {\n      this.addClass('highcharts-' + className);\n    }\n    // Create the text element. An undefined text content prevents redundant\n    // box calculation (#16121)\n    this.text = renderer.text(void 0, 0, 0, useHTML).attr({\n      zIndex: 1\n    });\n    // Validate the shape argument\n    let hasBGImage;\n    if (typeof shape === 'string') {\n      hasBGImage = /^url\\((.*?)\\)$/.test(shape);\n      if (hasBGImage || this.renderer.symbols[shape]) {\n        this.symbolKey = shape;\n      }\n    }\n    this.bBox = SVGLabel.emptyBBox;\n    this.padding = 3;\n    this.baselineOffset = 0;\n    this.needsBox = renderer.styledMode || hasBGImage;\n    this.deferredAttr = {};\n    this.alignFactor = 0;\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  alignSetter(value) {\n    const alignFactor = {\n      left: 0,\n      center: 0.5,\n      right: 1\n    }[value];\n    if (alignFactor !== this.alignFactor) {\n      this.alignFactor = alignFactor;\n      // Bounding box exists, means we're dynamically changing\n      if (this.bBox && isNumber(this.xSetting)) {\n        this.attr({\n          x: this.xSetting\n        }); // #5134\n      }\n    }\n  }\n\n  anchorXSetter(value, key) {\n    this.anchorX = value;\n    this.boxAttr(key, Math.round(value) - this.getCrispAdjust() - this.xSetting);\n  }\n  anchorYSetter(value, key) {\n    this.anchorY = value;\n    this.boxAttr(key, value - this.ySetting);\n  }\n  /*\n   * Set a box attribute, or defer it if the box is not yet created\n   */\n  boxAttr(key, value) {\n    if (this.box) {\n      this.box.attr(key, value);\n    } else {\n      this.deferredAttr[key] = value;\n    }\n  }\n  /*\n   * Pick up some properties and apply them to the text instead of the\n   * wrapper.\n   */\n  css(styles) {\n    if (styles) {\n      const textStyles = {};\n      // Create a copy to avoid altering the original object\n      // (#537)\n      styles = merge(styles);\n      SVGLabel.textProps.forEach(prop => {\n        if (typeof styles[prop] !== 'undefined') {\n          textStyles[prop] = styles[prop];\n          delete styles[prop];\n        }\n      });\n      this.text.css(textStyles);\n      // Update existing text, box (#9400, #12163, #18212)\n      if ('fontSize' in textStyles || 'fontWeight' in textStyles) {\n        this.updateTextPadding();\n      } else if ('width' in textStyles || 'textOverflow' in textStyles) {\n        this.updateBoxSize();\n      }\n    }\n    return SVGElement.prototype.css.call(this, styles);\n  }\n  /*\n   * Destroy and release memory.\n   */\n  destroy() {\n    // Added by button implementation\n    removeEvent(this.element, 'mouseenter');\n    removeEvent(this.element, 'mouseleave');\n    if (this.text) {\n      this.text.destroy();\n    }\n    if (this.box) {\n      this.box = this.box.destroy();\n    }\n    // Call base implementation to destroy the rest\n    SVGElement.prototype.destroy.call(this);\n    return void 0;\n  }\n  fillSetter(value, key) {\n    if (value) {\n      this.needsBox = true;\n    }\n    // for animation getter (#6776)\n    this.fill = value;\n    this.boxAttr(key, value);\n  }\n  /*\n   * Return the bounding box of the box, not the group.\n   */\n  getBBox() {\n    // If we have a text string and the DOM bBox was 0, it typically means\n    // that the label was first rendered hidden, so we need to update the\n    // bBox (#15246)\n    if (this.textStr && this.bBox.width === 0 && this.bBox.height === 0) {\n      this.updateBoxSize();\n    }\n    const padding = this.padding;\n    const paddingLeft = pick(this.paddingLeft, padding);\n    return {\n      width: this.width || 0,\n      height: this.height || 0,\n      x: this.bBox.x - paddingLeft,\n      y: this.bBox.y - padding\n    };\n  }\n  getCrispAdjust() {\n    return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this['stroke-width'] ? parseInt(this['stroke-width'], 10) : 0) % 2 / 2;\n  }\n  heightSetter(value) {\n    this.heightSetting = value;\n  }\n  /*\n   * After the text element is added, get the desired size of the border\n   * box and add it before the text in the DOM.\n   */\n  onAdd() {\n    this.text.add(this);\n    this.attr({\n      // Alignment is available now  (#3295, 0 not rendered if given\n      // as a value)\n      text: pick(this.textStr, ''),\n      x: this.x || 0,\n      y: this.y || 0\n    });\n    if (this.box && defined(this.anchorX)) {\n      this.attr({\n        anchorX: this.anchorX,\n        anchorY: this.anchorY\n      });\n    }\n  }\n  paddingSetter(value, key) {\n    if (!isNumber(value)) {\n      this[key] = void 0;\n    } else if (value !== this[key]) {\n      this[key] = value;\n      this.updateTextPadding();\n    }\n  }\n  rSetter(value, key) {\n    this.boxAttr(key, value);\n  }\n  strokeSetter(value, key) {\n    // for animation getter (#6776)\n    this.stroke = value;\n    this.boxAttr(key, value);\n  }\n  'stroke-widthSetter'(value, key) {\n    if (value) {\n      this.needsBox = true;\n    }\n    this['stroke-width'] = value;\n    this.boxAttr(key, value);\n  }\n  'text-alignSetter'(value) {\n    this.textAlign = value;\n  }\n  textSetter(text) {\n    if (typeof text !== 'undefined') {\n      // Must use .attr to ensure transforms are done (#10009)\n      this.text.attr({\n        text\n      });\n    }\n    this.updateTextPadding();\n  }\n  /*\n   * This function runs after the label is added to the DOM (when the bounding\n   * box is available), and after the text of the label is updated to detect\n   * the new bounding box and reflect it in the border box.\n   */\n  updateBoxSize() {\n    const text = this.text,\n      attribs = {},\n      padding = this.padding,\n      // #12165 error when width is null (auto)\n      // #12163 when fontweight: bold, recalculate bBox withot cache\n      // #3295 && 3514 box failure when string equals 0\n      bBox = this.bBox = (!isNumber(this.widthSetting) || !isNumber(this.heightSetting) || this.textAlign) && defined(text.textStr) ? text.getBBox() : SVGLabel.emptyBBox;\n    let crispAdjust;\n    this.width = this.getPaddedWidth();\n    this.height = (this.heightSetting || bBox.height || 0) + 2 * padding;\n    const metrics = this.renderer.fontMetrics(text);\n    // Update the label-scoped y offset. Math.min because of inline\n    // style (#9400)\n    this.baselineOffset = padding + Math.min(\n    // When applicable, use the font size of the first line (#15707)\n    (this.text.firstLineMetrics || metrics).b,\n    // When the height is 0, there is no bBox, so go with the font\n    // metrics. Highmaps CSS demos.\n    bBox.height || Infinity);\n    // #15491: Vertical centering\n    if (this.heightSetting) {\n      this.baselineOffset += (this.heightSetting - metrics.h) / 2;\n    }\n    if (this.needsBox && !text.textPath) {\n      // Create the border box if it is not already present\n      if (!this.box) {\n        // Symbol definition exists (#5324)\n        const box = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();\n        box.addClass(\n        // Don't use label className for buttons\n        (this.className === 'button' ? '' : 'highcharts-label-box') + (this.className ? ' highcharts-' + this.className + '-box' : ''));\n        box.add(this);\n      }\n      crispAdjust = this.getCrispAdjust();\n      attribs.x = crispAdjust;\n      attribs.y = (this.baseline ? -this.baselineOffset : 0) + crispAdjust;\n      // Apply the box attributes\n      attribs.width = Math.round(this.width);\n      attribs.height = Math.round(this.height);\n      this.box.attr(extend(attribs, this.deferredAttr));\n      this.deferredAttr = {};\n    }\n  }\n  /*\n   * This function runs after setting text or padding, but only if padding\n   * is changed.\n   */\n  updateTextPadding() {\n    const text = this.text;\n    if (!text.textPath) {\n      this.updateBoxSize();\n      // Determine y based on the baseline\n      const textY = this.baseline ? 0 : this.baselineOffset;\n      let textX = pick(this.paddingLeft, this.padding);\n      // compensate for alignment\n      if (defined(this.widthSetting) && this.bBox && (this.textAlign === 'center' || this.textAlign === 'right')) {\n        textX += {\n          center: 0.5,\n          right: 1\n        }[this.textAlign] * (this.widthSetting - this.bBox.width);\n      }\n      // update if anything changed\n      if (textX !== text.x || textY !== text.y) {\n        text.attr('x', textX);\n        // #8159 - prevent misplaced data labels in treemap\n        // (useHTML: true)\n        if (text.hasBoxWidthChanged) {\n          this.bBox = text.getBBox(true);\n        }\n        if (typeof textY !== 'undefined') {\n          text.attr('y', textY);\n        }\n      }\n      // record current values\n      text.x = textX;\n      text.y = textY;\n    }\n  }\n  widthSetter(value) {\n    // width:auto => null\n    this.widthSetting = isNumber(value) ? value : void 0;\n  }\n  getPaddedWidth() {\n    const padding = this.padding;\n    const paddingLeft = pick(this.paddingLeft, padding);\n    const paddingRight = pick(this.paddingRight, padding);\n    return (this.widthSetting || this.bBox.width || 0) + paddingLeft + paddingRight;\n  }\n  xSetter(value) {\n    this.x = value; // for animation getter\n    if (this.alignFactor) {\n      value -= this.alignFactor * this.getPaddedWidth();\n      // Force animation even when setting to the same value (#7898)\n      this['forceAnimate:x'] = true;\n    }\n    this.xSetting = Math.round(value);\n    this.attr('translateX', this.xSetting);\n  }\n  ySetter(value) {\n    this.ySetting = this.y = Math.round(value);\n    this.attr('translateY', this.ySetting);\n  }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nSVGLabel.emptyBBox = {\n  width: 0,\n  height: 0,\n  x: 0,\n  y: 0\n};\n/**\n * For labels, these CSS properties are applied to the `text` node directly.\n *\n * @private\n * @name Highcharts.SVGLabel#textProps\n * @type {Array<string>}\n */\nSVGLabel.textProps = ['color', 'direction', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'lineHeight', 'textAlign', 'textDecoration', 'textOutline', 'textOverflow', 'whiteSpace', 'width'];\n/* *\n *\n *  Default Export\n *\n * */\nexport default SVGLabel;","map":{"version":3,"names":["SVGElement","U","defined","extend","isNumber","merge","pick","removeEvent","SVGLabel","constructor","renderer","str","x","y","shape","anchorX","anchorY","useHTML","baseline","className","paddingLeftSetter","paddingSetter","paddingRightSetter","init","textStr","addClass","text","attr","zIndex","hasBGImage","test","symbols","symbolKey","bBox","emptyBBox","padding","baselineOffset","needsBox","styledMode","deferredAttr","alignFactor","alignSetter","value","left","center","right","xSetting","anchorXSetter","key","boxAttr","Math","round","getCrispAdjust","anchorYSetter","ySetting","box","css","styles","textStyles","textProps","forEach","prop","updateTextPadding","updateBoxSize","prototype","call","destroy","element","fillSetter","fill","getBBox","width","height","paddingLeft","strokeWidth","parseInt","heightSetter","heightSetting","onAdd","add","rSetter","strokeSetter","stroke","stroke-widthSetter","text-alignSetter","textAlign","textSetter","attribs","widthSetting","crispAdjust","getPaddedWidth","metrics","fontMetrics","min","firstLineMetrics","b","Infinity","h","textPath","symbol","rect","textY","textX","hasBoxWidthChanged","widthSetter","paddingRight","xSetter","ySetter"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGLabel.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\nimport SVGElement from './SVGElement.js';\nimport U from '../../Utilities.js';\nconst { defined, extend, isNumber, merge, pick, removeEvent } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * SVG label to render text.\n * @private\n * @class\n * @name Highcharts.SVGLabel\n * @augments Highcharts.SVGElement\n */\nclass SVGLabel extends SVGElement {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    constructor(renderer, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n        super();\n        this.paddingLeftSetter = this.paddingSetter;\n        this.paddingRightSetter = this.paddingSetter;\n        this.init(renderer, 'g');\n        this.textStr = str;\n        this.x = x;\n        this.y = y;\n        this.anchorX = anchorX;\n        this.anchorY = anchorY;\n        this.baseline = baseline;\n        this.className = className;\n        this.addClass(className === 'button' ?\n            'highcharts-no-tooltip' :\n            'highcharts-label');\n        if (className) {\n            this.addClass('highcharts-' + className);\n        }\n        // Create the text element. An undefined text content prevents redundant\n        // box calculation (#16121)\n        this.text = renderer.text(void 0, 0, 0, useHTML).attr({ zIndex: 1 });\n        // Validate the shape argument\n        let hasBGImage;\n        if (typeof shape === 'string') {\n            hasBGImage = /^url\\((.*?)\\)$/.test(shape);\n            if (hasBGImage || this.renderer.symbols[shape]) {\n                this.symbolKey = shape;\n            }\n        }\n        this.bBox = SVGLabel.emptyBBox;\n        this.padding = 3;\n        this.baselineOffset = 0;\n        this.needsBox = renderer.styledMode || hasBGImage;\n        this.deferredAttr = {};\n        this.alignFactor = 0;\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    alignSetter(value) {\n        const alignFactor = ({\n            left: 0,\n            center: 0.5,\n            right: 1\n        })[value];\n        if (alignFactor !== this.alignFactor) {\n            this.alignFactor = alignFactor;\n            // Bounding box exists, means we're dynamically changing\n            if (this.bBox && isNumber(this.xSetting)) {\n                this.attr({ x: this.xSetting }); // #5134\n            }\n        }\n    }\n    anchorXSetter(value, key) {\n        this.anchorX = value;\n        this.boxAttr(key, Math.round(value) - this.getCrispAdjust() - this.xSetting);\n    }\n    anchorYSetter(value, key) {\n        this.anchorY = value;\n        this.boxAttr(key, value - this.ySetting);\n    }\n    /*\n     * Set a box attribute, or defer it if the box is not yet created\n     */\n    boxAttr(key, value) {\n        if (this.box) {\n            this.box.attr(key, value);\n        }\n        else {\n            this.deferredAttr[key] = value;\n        }\n    }\n    /*\n     * Pick up some properties and apply them to the text instead of the\n     * wrapper.\n     */\n    css(styles) {\n        if (styles) {\n            const textStyles = {};\n            // Create a copy to avoid altering the original object\n            // (#537)\n            styles = merge(styles);\n            SVGLabel.textProps.forEach((prop) => {\n                if (typeof styles[prop] !== 'undefined') {\n                    textStyles[prop] = styles[prop];\n                    delete styles[prop];\n                }\n            });\n            this.text.css(textStyles);\n            // Update existing text, box (#9400, #12163, #18212)\n            if ('fontSize' in textStyles || 'fontWeight' in textStyles) {\n                this.updateTextPadding();\n            }\n            else if ('width' in textStyles || 'textOverflow' in textStyles) {\n                this.updateBoxSize();\n            }\n        }\n        return SVGElement.prototype.css.call(this, styles);\n    }\n    /*\n     * Destroy and release memory.\n     */\n    destroy() {\n        // Added by button implementation\n        removeEvent(this.element, 'mouseenter');\n        removeEvent(this.element, 'mouseleave');\n        if (this.text) {\n            this.text.destroy();\n        }\n        if (this.box) {\n            this.box = this.box.destroy();\n        }\n        // Call base implementation to destroy the rest\n        SVGElement.prototype.destroy.call(this);\n        return void 0;\n    }\n    fillSetter(value, key) {\n        if (value) {\n            this.needsBox = true;\n        }\n        // for animation getter (#6776)\n        this.fill = value;\n        this.boxAttr(key, value);\n    }\n    /*\n     * Return the bounding box of the box, not the group.\n     */\n    getBBox() {\n        // If we have a text string and the DOM bBox was 0, it typically means\n        // that the label was first rendered hidden, so we need to update the\n        // bBox (#15246)\n        if (this.textStr && this.bBox.width === 0 && this.bBox.height === 0) {\n            this.updateBoxSize();\n        }\n        const padding = this.padding;\n        const paddingLeft = pick(this.paddingLeft, padding);\n        return {\n            width: this.width || 0,\n            height: this.height || 0,\n            x: this.bBox.x - paddingLeft,\n            y: this.bBox.y - padding\n        };\n    }\n    getCrispAdjust() {\n        return this.renderer.styledMode && this.box ?\n            this.box.strokeWidth() % 2 / 2 :\n            (this['stroke-width'] ? parseInt(this['stroke-width'], 10) : 0) % 2 / 2;\n    }\n    heightSetter(value) {\n        this.heightSetting = value;\n    }\n    /*\n     * After the text element is added, get the desired size of the border\n     * box and add it before the text in the DOM.\n     */\n    onAdd() {\n        this.text.add(this);\n        this.attr({\n            // Alignment is available now  (#3295, 0 not rendered if given\n            // as a value)\n            text: pick(this.textStr, ''),\n            x: this.x || 0,\n            y: this.y || 0\n        });\n        if (this.box && defined(this.anchorX)) {\n            this.attr({\n                anchorX: this.anchorX,\n                anchorY: this.anchorY\n            });\n        }\n    }\n    paddingSetter(value, key) {\n        if (!isNumber(value)) {\n            this[key] = void 0;\n        }\n        else if (value !== this[key]) {\n            this[key] = value;\n            this.updateTextPadding();\n        }\n    }\n    rSetter(value, key) {\n        this.boxAttr(key, value);\n    }\n    strokeSetter(value, key) {\n        // for animation getter (#6776)\n        this.stroke = value;\n        this.boxAttr(key, value);\n    }\n    'stroke-widthSetter'(value, key) {\n        if (value) {\n            this.needsBox = true;\n        }\n        this['stroke-width'] = value;\n        this.boxAttr(key, value);\n    }\n    'text-alignSetter'(value) {\n        this.textAlign = value;\n    }\n    textSetter(text) {\n        if (typeof text !== 'undefined') {\n            // Must use .attr to ensure transforms are done (#10009)\n            this.text.attr({ text });\n        }\n        this.updateTextPadding();\n    }\n    /*\n     * This function runs after the label is added to the DOM (when the bounding\n     * box is available), and after the text of the label is updated to detect\n     * the new bounding box and reflect it in the border box.\n     */\n    updateBoxSize() {\n        const text = this.text, attribs = {}, padding = this.padding, \n        // #12165 error when width is null (auto)\n        // #12163 when fontweight: bold, recalculate bBox withot cache\n        // #3295 && 3514 box failure when string equals 0\n        bBox = this.bBox = (((!isNumber(this.widthSetting) ||\n            !isNumber(this.heightSetting) ||\n            this.textAlign) && defined(text.textStr)) ?\n            text.getBBox() :\n            SVGLabel.emptyBBox);\n        let crispAdjust;\n        this.width = this.getPaddedWidth();\n        this.height = (this.heightSetting || bBox.height || 0) + 2 * padding;\n        const metrics = this.renderer.fontMetrics(text);\n        // Update the label-scoped y offset. Math.min because of inline\n        // style (#9400)\n        this.baselineOffset = padding + Math.min(\n        // When applicable, use the font size of the first line (#15707)\n        (this.text.firstLineMetrics || metrics).b, \n        // When the height is 0, there is no bBox, so go with the font\n        // metrics. Highmaps CSS demos.\n        bBox.height || Infinity);\n        // #15491: Vertical centering\n        if (this.heightSetting) {\n            this.baselineOffset += (this.heightSetting - metrics.h) / 2;\n        }\n        if (this.needsBox && !text.textPath) {\n            // Create the border box if it is not already present\n            if (!this.box) {\n                // Symbol definition exists (#5324)\n                const box = this.box = this.symbolKey ?\n                    this.renderer.symbol(this.symbolKey) :\n                    this.renderer.rect();\n                box.addClass(// Don't use label className for buttons\n                (this.className === 'button' ?\n                    '' : 'highcharts-label-box') +\n                    (this.className ?\n                        ' highcharts-' + this.className + '-box' : ''));\n                box.add(this);\n            }\n            crispAdjust = this.getCrispAdjust();\n            attribs.x = crispAdjust;\n            attribs.y = ((this.baseline ? -this.baselineOffset : 0) + crispAdjust);\n            // Apply the box attributes\n            attribs.width = Math.round(this.width);\n            attribs.height = Math.round(this.height);\n            this.box.attr(extend(attribs, this.deferredAttr));\n            this.deferredAttr = {};\n        }\n    }\n    /*\n     * This function runs after setting text or padding, but only if padding\n     * is changed.\n     */\n    updateTextPadding() {\n        const text = this.text;\n        if (!text.textPath) {\n            this.updateBoxSize();\n            // Determine y based on the baseline\n            const textY = this.baseline ? 0 : this.baselineOffset;\n            let textX = pick(this.paddingLeft, this.padding);\n            // compensate for alignment\n            if (defined(this.widthSetting) &&\n                this.bBox &&\n                (this.textAlign === 'center' || this.textAlign === 'right')) {\n                textX += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width);\n            }\n            // update if anything changed\n            if (textX !== text.x || textY !== text.y) {\n                text.attr('x', textX);\n                // #8159 - prevent misplaced data labels in treemap\n                // (useHTML: true)\n                if (text.hasBoxWidthChanged) {\n                    this.bBox = text.getBBox(true);\n                }\n                if (typeof textY !== 'undefined') {\n                    text.attr('y', textY);\n                }\n            }\n            // record current values\n            text.x = textX;\n            text.y = textY;\n        }\n    }\n    widthSetter(value) {\n        // width:auto => null\n        this.widthSetting = isNumber(value) ? value : void 0;\n    }\n    getPaddedWidth() {\n        const padding = this.padding;\n        const paddingLeft = pick(this.paddingLeft, padding);\n        const paddingRight = pick(this.paddingRight, padding);\n        return ((this.widthSetting || this.bBox.width || 0) +\n            paddingLeft +\n            paddingRight);\n    }\n    xSetter(value) {\n        this.x = value; // for animation getter\n        if (this.alignFactor) {\n            value -= this.alignFactor * this.getPaddedWidth();\n            // Force animation even when setting to the same value (#7898)\n            this['forceAnimate:x'] = true;\n        }\n        this.xSetting = Math.round(value);\n        this.attr('translateX', this.xSetting);\n    }\n    ySetter(value) {\n        this.ySetting = this.y = Math.round(value);\n        this.attr('translateY', this.ySetting);\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nSVGLabel.emptyBBox = {\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n};\n/**\n * For labels, these CSS properties are applied to the `text` node directly.\n *\n * @private\n * @name Highcharts.SVGLabel#textProps\n * @type {Array<string>}\n */\nSVGLabel.textProps = [\n    'color', 'direction', 'fontFamily', 'fontSize', 'fontStyle',\n    'fontWeight', 'lineHeight', 'textAlign', 'textDecoration',\n    'textOutline', 'textOverflow', 'whiteSpace', 'width'\n];\n/* *\n *\n *  Default Export\n *\n * */\nexport default SVGLabel;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}