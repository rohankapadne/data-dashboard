{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport H from '../../Globals.js';\nconst {\n  isFirefox,\n  isMS,\n  isWebKit,\n  win\n} = H;\nimport SVGElement from '../SVG/SVGElement.js';\nimport U from '../../Utilities.js';\nconst {\n  css,\n  defined,\n  extend,\n  pick,\n  pInt\n} = U;\n/* *\n *\n *  Constants\n *\n * */\nconst composedMembers = [];\n/* *\n *\n *  Class\n *\n * */\n/* eslint-disable valid-jsdoc */\nclass HTMLElement extends SVGElement {\n  /* *\n   *\n   *  Static Functions\n   *\n   * */\n  /**\n   * Modifies SVGElement to support HTML elements.\n   * @private\n   */\n  static compose(SVGElementClass) {\n    if (U.pushUnique(composedMembers, SVGElementClass)) {\n      const htmlElementProto = HTMLElement.prototype,\n        svgElementProto = SVGElementClass.prototype;\n      svgElementProto.getSpanCorrection = htmlElementProto.getSpanCorrection;\n      svgElementProto.htmlCss = htmlElementProto.htmlCss;\n      svgElementProto.htmlGetBBox = htmlElementProto.htmlGetBBox;\n      svgElementProto.htmlUpdateTransform = htmlElementProto.htmlUpdateTransform;\n      svgElementProto.setSpanRotation = htmlElementProto.setSpanRotation;\n    }\n    return SVGElementClass;\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * Get the correction in X and Y positioning as the element is rotated.\n   * @private\n   */\n  getSpanCorrection(width, baseline, alignCorrection) {\n    this.xCorr = -width * alignCorrection;\n    this.yCorr = -baseline;\n  }\n  /**\n   * Apply CSS to HTML elements. This is used in text within SVG rendering.\n   * @private\n   */\n  htmlCss(styles) {\n    const wrapper = this,\n      element = wrapper.element,\n      // When setting or unsetting the width style, we need to update\n      // transform (#8809)\n      isSettingWidth = element.tagName === 'SPAN' && styles && 'width' in styles,\n      textWidth = pick(isSettingWidth && styles.width, void 0);\n    let doTransform;\n    if (isSettingWidth) {\n      delete styles.width;\n      wrapper.textWidth = textWidth;\n      doTransform = true;\n    }\n    if (styles && styles.textOverflow === 'ellipsis') {\n      styles.whiteSpace = 'nowrap';\n      styles.overflow = 'hidden';\n    }\n    wrapper.styles = extend(wrapper.styles, styles);\n    css(wrapper.element, styles);\n    // Now that all styles are applied, to the transform\n    if (doTransform) {\n      wrapper.htmlUpdateTransform();\n    }\n    return wrapper;\n  }\n  /**\n   * useHTML method for calculating the bounding box based on offsets.\n   */\n  htmlGetBBox() {\n    const wrapper = this,\n      element = wrapper.element;\n    return {\n      x: element.offsetLeft,\n      y: element.offsetTop,\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n  /**\n   * @private\n   */\n  htmlUpdateTransform() {\n    // aligning non added elements is expensive\n    if (!this.added) {\n      this.alignOnAdd = true;\n      return;\n    }\n    const wrapper = this,\n      renderer = wrapper.renderer,\n      elem = wrapper.element,\n      translateX = wrapper.translateX || 0,\n      translateY = wrapper.translateY || 0,\n      x = wrapper.x || 0,\n      y = wrapper.y || 0,\n      align = wrapper.textAlign || 'left',\n      alignCorrection = {\n        left: 0,\n        center: 0.5,\n        right: 1\n      }[align],\n      styles = wrapper.styles,\n      whiteSpace = styles && styles.whiteSpace;\n    /** @private */\n    function getTextPxLength() {\n      if (wrapper.textPxLength) {\n        return wrapper.textPxLength;\n      }\n      // Reset multiline/ellipsis in order to read width (#4928,\n      // #5417)\n      css(elem, {\n        width: '',\n        whiteSpace: whiteSpace || 'nowrap'\n      });\n      return elem.offsetWidth;\n    }\n    // apply translate\n    css(elem, {\n      marginLeft: translateX,\n      marginTop: translateY\n    });\n    if (elem.tagName === 'SPAN') {\n      const rotation = wrapper.rotation,\n        textWidth = wrapper.textWidth && pInt(wrapper.textWidth),\n        currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(',');\n      let baseline,\n        hasBoxWidthChanged = false;\n      // Update textWidth. Use the memoized textPxLength if possible, to\n      // avoid the getTextPxLength function using elem.offsetWidth.\n      // Calling offsetWidth affects rendering time as it forces layout\n      // (#7656).\n      if (textWidth !== wrapper.oldTextWidth) {\n        // #983, #1254\n        const textPxLength = getTextPxLength();\n        if ((textWidth > wrapper.oldTextWidth || textPxLength > textWidth) && (\n        // Only set the width if the text is able to word-wrap,\n        // or text-overflow is ellipsis (#9537)\n        /[ \\-]/.test(elem.textContent || elem.innerText) || elem.style.textOverflow === 'ellipsis')) {\n          css(elem, {\n            width: textPxLength > textWidth || rotation ? textWidth + 'px' : 'auto',\n            display: 'block',\n            whiteSpace: whiteSpace || 'normal' // #3331\n          });\n\n          wrapper.oldTextWidth = textWidth;\n          hasBoxWidthChanged = true; // #8159\n        }\n      }\n\n      wrapper.hasBoxWidthChanged = hasBoxWidthChanged; // #8159\n      // Do the calculations and DOM access only if properties changed\n      if (currentTextTransform !== wrapper.cTT) {\n        baseline = renderer.fontMetrics(elem).b;\n        // Renderer specific handling of span rotation, but only if we\n        // have something to update.\n        if (defined(rotation) && (rotation !== (wrapper.oldRotation || 0) || align !== wrapper.oldAlign)) {\n          wrapper.setSpanRotation(rotation, alignCorrection, baseline);\n        }\n        wrapper.getSpanCorrection(\n        // Avoid elem.offsetWidth if we can, it affects rendering\n        // time heavily (#7656)\n        !defined(rotation) && wrapper.textPxLength ||\n        // #7920\n        elem.offsetWidth, baseline, alignCorrection, rotation, align);\n      }\n      // apply position with correction\n      css(elem, {\n        left: x + (wrapper.xCorr || 0) + 'px',\n        top: y + (wrapper.yCorr || 0) + 'px'\n      });\n      // record current text transform\n      wrapper.cTT = currentTextTransform;\n      wrapper.oldRotation = rotation;\n      wrapper.oldAlign = align;\n    }\n  }\n  /**\n   * Set the rotation of an individual HTML span.\n   * @private\n   */\n  setSpanRotation(rotation, alignCorrection, baseline) {\n    const getTransformKey = () => isMS && !/Edge/.test(win.navigator.userAgent) ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : win.opera ? '-o-transform' : void 0;\n    const rotationStyle = {},\n      cssTransformKey = getTransformKey();\n    if (cssTransformKey) {\n      rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';\n      rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = alignCorrection * 100 + '% ' + baseline + 'px';\n      css(this.element, rotationStyle);\n    }\n  }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default HTMLElement;","map":{"version":3,"names":["H","isFirefox","isMS","isWebKit","win","SVGElement","U","css","defined","extend","pick","pInt","composedMembers","HTMLElement","compose","SVGElementClass","pushUnique","htmlElementProto","prototype","svgElementProto","getSpanCorrection","htmlCss","htmlGetBBox","htmlUpdateTransform","setSpanRotation","width","baseline","alignCorrection","xCorr","yCorr","styles","wrapper","element","isSettingWidth","tagName","textWidth","doTransform","textOverflow","whiteSpace","overflow","x","offsetLeft","y","offsetTop","offsetWidth","height","offsetHeight","added","alignOnAdd","renderer","elem","translateX","translateY","align","textAlign","left","center","right","getTextPxLength","textPxLength","marginLeft","marginTop","rotation","currentTextTransform","innerHTML","join","hasBoxWidthChanged","oldTextWidth","test","textContent","innerText","style","display","cTT","fontMetrics","b","oldRotation","oldAlign","top","getTransformKey","navigator","userAgent","opera","rotationStyle","cssTransformKey","transform","transformOrigin"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Renderer/HTML/HTMLElement.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport H from '../../Globals.js';\nconst { isFirefox, isMS, isWebKit, win } = H;\nimport SVGElement from '../SVG/SVGElement.js';\nimport U from '../../Utilities.js';\nconst { css, defined, extend, pick, pInt } = U;\n/* *\n *\n *  Constants\n *\n * */\nconst composedMembers = [];\n/* *\n *\n *  Class\n *\n * */\n/* eslint-disable valid-jsdoc */\nclass HTMLElement extends SVGElement {\n    /* *\n     *\n     *  Static Functions\n     *\n     * */\n    /**\n     * Modifies SVGElement to support HTML elements.\n     * @private\n     */\n    static compose(SVGElementClass) {\n        if (U.pushUnique(composedMembers, SVGElementClass)) {\n            const htmlElementProto = HTMLElement.prototype, svgElementProto = SVGElementClass.prototype;\n            svgElementProto.getSpanCorrection = htmlElementProto\n                .getSpanCorrection;\n            svgElementProto.htmlCss = htmlElementProto.htmlCss;\n            svgElementProto.htmlGetBBox = htmlElementProto.htmlGetBBox;\n            svgElementProto.htmlUpdateTransform = htmlElementProto\n                .htmlUpdateTransform;\n            svgElementProto.setSpanRotation = htmlElementProto.setSpanRotation;\n        }\n        return SVGElementClass;\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Get the correction in X and Y positioning as the element is rotated.\n     * @private\n     */\n    getSpanCorrection(width, baseline, alignCorrection) {\n        this.xCorr = -width * alignCorrection;\n        this.yCorr = -baseline;\n    }\n    /**\n     * Apply CSS to HTML elements. This is used in text within SVG rendering.\n     * @private\n     */\n    htmlCss(styles) {\n        const wrapper = this, element = wrapper.element, \n        // When setting or unsetting the width style, we need to update\n        // transform (#8809)\n        isSettingWidth = (element.tagName === 'SPAN' &&\n            styles &&\n            'width' in styles), textWidth = pick(isSettingWidth && styles.width, void 0);\n        let doTransform;\n        if (isSettingWidth) {\n            delete styles.width;\n            wrapper.textWidth = textWidth;\n            doTransform = true;\n        }\n        if (styles && styles.textOverflow === 'ellipsis') {\n            styles.whiteSpace = 'nowrap';\n            styles.overflow = 'hidden';\n        }\n        wrapper.styles = extend(wrapper.styles, styles);\n        css(wrapper.element, styles);\n        // Now that all styles are applied, to the transform\n        if (doTransform) {\n            wrapper.htmlUpdateTransform();\n        }\n        return wrapper;\n    }\n    /**\n     * useHTML method for calculating the bounding box based on offsets.\n     */\n    htmlGetBBox() {\n        const wrapper = this, element = wrapper.element;\n        return {\n            x: element.offsetLeft,\n            y: element.offsetTop,\n            width: element.offsetWidth,\n            height: element.offsetHeight\n        };\n    }\n    /**\n     * @private\n     */\n    htmlUpdateTransform() {\n        // aligning non added elements is expensive\n        if (!this.added) {\n            this.alignOnAdd = true;\n            return;\n        }\n        const wrapper = this, renderer = wrapper.renderer, elem = wrapper.element, translateX = wrapper.translateX || 0, translateY = wrapper.translateY || 0, x = wrapper.x || 0, y = wrapper.y || 0, align = wrapper.textAlign || 'left', alignCorrection = {\n            left: 0, center: 0.5, right: 1\n        }[align], styles = wrapper.styles, whiteSpace = styles && styles.whiteSpace;\n        /** @private */\n        function getTextPxLength() {\n            if (wrapper.textPxLength) {\n                return wrapper.textPxLength;\n            }\n            // Reset multiline/ellipsis in order to read width (#4928,\n            // #5417)\n            css(elem, {\n                width: '',\n                whiteSpace: whiteSpace || 'nowrap'\n            });\n            return elem.offsetWidth;\n        }\n        // apply translate\n        css(elem, {\n            marginLeft: translateX,\n            marginTop: translateY\n        });\n        if (elem.tagName === 'SPAN') {\n            const rotation = wrapper.rotation, textWidth = wrapper.textWidth && pInt(wrapper.textWidth), currentTextTransform = [\n                rotation,\n                align,\n                elem.innerHTML,\n                wrapper.textWidth,\n                wrapper.textAlign\n            ].join(',');\n            let baseline, hasBoxWidthChanged = false;\n            // Update textWidth. Use the memoized textPxLength if possible, to\n            // avoid the getTextPxLength function using elem.offsetWidth.\n            // Calling offsetWidth affects rendering time as it forces layout\n            // (#7656).\n            if (textWidth !== wrapper.oldTextWidth) { // #983, #1254\n                const textPxLength = getTextPxLength();\n                if (((textWidth > wrapper.oldTextWidth) ||\n                    textPxLength > textWidth) && (\n                // Only set the width if the text is able to word-wrap,\n                // or text-overflow is ellipsis (#9537)\n                /[ \\-]/.test(elem.textContent || elem.innerText) ||\n                    elem.style.textOverflow === 'ellipsis')) {\n                    css(elem, {\n                        width: (textPxLength > textWidth) || rotation ?\n                            textWidth + 'px' :\n                            'auto',\n                        display: 'block',\n                        whiteSpace: whiteSpace || 'normal' // #3331\n                    });\n                    wrapper.oldTextWidth = textWidth;\n                    hasBoxWidthChanged = true; // #8159\n                }\n            }\n            wrapper.hasBoxWidthChanged = hasBoxWidthChanged; // #8159\n            // Do the calculations and DOM access only if properties changed\n            if (currentTextTransform !== wrapper.cTT) {\n                baseline = renderer.fontMetrics(elem).b;\n                // Renderer specific handling of span rotation, but only if we\n                // have something to update.\n                if (defined(rotation) &&\n                    ((rotation !== (wrapper.oldRotation || 0)) ||\n                        (align !== wrapper.oldAlign))) {\n                    wrapper.setSpanRotation(rotation, alignCorrection, baseline);\n                }\n                wrapper.getSpanCorrection(\n                // Avoid elem.offsetWidth if we can, it affects rendering\n                // time heavily (#7656)\n                ((!defined(rotation) && wrapper.textPxLength) || // #7920\n                    elem.offsetWidth), baseline, alignCorrection, rotation, align);\n            }\n            // apply position with correction\n            css(elem, {\n                left: (x + (wrapper.xCorr || 0)) + 'px',\n                top: (y + (wrapper.yCorr || 0)) + 'px'\n            });\n            // record current text transform\n            wrapper.cTT = currentTextTransform;\n            wrapper.oldRotation = rotation;\n            wrapper.oldAlign = align;\n        }\n    }\n    /**\n     * Set the rotation of an individual HTML span.\n     * @private\n     */\n    setSpanRotation(rotation, alignCorrection, baseline) {\n        const getTransformKey = () => (isMS &&\n            !/Edge/.test(win.navigator.userAgent) ?\n            '-ms-transform' :\n            isWebKit ?\n                '-webkit-transform' :\n                isFirefox ?\n                    'MozTransform' :\n                    win.opera ?\n                        '-o-transform' :\n                        void 0);\n        const rotationStyle = {}, cssTransformKey = getTransformKey();\n        if (cssTransformKey) {\n            rotationStyle[cssTransformKey] = rotationStyle.transform =\n                'rotate(' + rotation + 'deg)';\n            rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin =\n                (alignCorrection * 100) + '% ' + baseline + 'px';\n            css(this.element, rotationStyle);\n        }\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nexport default HTMLElement;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AACZ,OAAOA,CAAC,MAAM,kBAAkB;AAChC,MAAM;EAAEC,SAAS;EAAEC,IAAI;EAAEC,QAAQ;EAAEC;AAAI,CAAC,GAAGJ,CAAC;AAC5C,OAAOK,UAAU,MAAM,sBAAsB;AAC7C,OAAOC,CAAC,MAAM,oBAAoB;AAClC,MAAM;EAAEC,GAAG;EAAEC,OAAO;EAAEC,MAAM;EAAEC,IAAI;EAAEC;AAAK,CAAC,GAAGL,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA,MAAMM,eAAe,GAAG,EAAE;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,SAASR,UAAU,CAAC;EACjC;AACJ;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;EACI,OAAOS,OAAOA,CAACC,eAAe,EAAE;IAC5B,IAAIT,CAAC,CAACU,UAAU,CAACJ,eAAe,EAAEG,eAAe,CAAC,EAAE;MAChD,MAAME,gBAAgB,GAAGJ,WAAW,CAACK,SAAS;QAAEC,eAAe,GAAGJ,eAAe,CAACG,SAAS;MAC3FC,eAAe,CAACC,iBAAiB,GAAGH,gBAAgB,CAC/CG,iBAAiB;MACtBD,eAAe,CAACE,OAAO,GAAGJ,gBAAgB,CAACI,OAAO;MAClDF,eAAe,CAACG,WAAW,GAAGL,gBAAgB,CAACK,WAAW;MAC1DH,eAAe,CAACI,mBAAmB,GAAGN,gBAAgB,CACjDM,mBAAmB;MACxBJ,eAAe,CAACK,eAAe,GAAGP,gBAAgB,CAACO,eAAe;IACtE;IACA,OAAOT,eAAe;EAC1B;EACA;AACJ;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;EACIK,iBAAiBA,CAACK,KAAK,EAAEC,QAAQ,EAAEC,eAAe,EAAE;IAChD,IAAI,CAACC,KAAK,GAAG,CAACH,KAAK,GAAGE,eAAe;IACrC,IAAI,CAACE,KAAK,GAAG,CAACH,QAAQ;EAC1B;EACA;AACJ;AACA;AACA;EACIL,OAAOA,CAACS,MAAM,EAAE;IACZ,MAAMC,OAAO,GAAG,IAAI;MAAEC,OAAO,GAAGD,OAAO,CAACC,OAAO;MAC/C;MACA;MACAC,cAAc,GAAID,OAAO,CAACE,OAAO,KAAK,MAAM,IACxCJ,MAAM,IACN,OAAO,IAAIA,MAAO;MAAEK,SAAS,GAAGzB,IAAI,CAACuB,cAAc,IAAIH,MAAM,CAACL,KAAK,EAAE,KAAK,CAAC,CAAC;IAChF,IAAIW,WAAW;IACf,IAAIH,cAAc,EAAE;MAChB,OAAOH,MAAM,CAACL,KAAK;MACnBM,OAAO,CAACI,SAAS,GAAGA,SAAS;MAC7BC,WAAW,GAAG,IAAI;IACtB;IACA,IAAIN,MAAM,IAAIA,MAAM,CAACO,YAAY,KAAK,UAAU,EAAE;MAC9CP,MAAM,CAACQ,UAAU,GAAG,QAAQ;MAC5BR,MAAM,CAACS,QAAQ,GAAG,QAAQ;IAC9B;IACAR,OAAO,CAACD,MAAM,GAAGrB,MAAM,CAACsB,OAAO,CAACD,MAAM,EAAEA,MAAM,CAAC;IAC/CvB,GAAG,CAACwB,OAAO,CAACC,OAAO,EAAEF,MAAM,CAAC;IAC5B;IACA,IAAIM,WAAW,EAAE;MACbL,OAAO,CAACR,mBAAmB,CAAC,CAAC;IACjC;IACA,OAAOQ,OAAO;EAClB;EACA;AACJ;AACA;EACIT,WAAWA,CAAA,EAAG;IACV,MAAMS,OAAO,GAAG,IAAI;MAAEC,OAAO,GAAGD,OAAO,CAACC,OAAO;IAC/C,OAAO;MACHQ,CAAC,EAAER,OAAO,CAACS,UAAU;MACrBC,CAAC,EAAEV,OAAO,CAACW,SAAS;MACpBlB,KAAK,EAAEO,OAAO,CAACY,WAAW;MAC1BC,MAAM,EAAEb,OAAO,CAACc;IACpB,CAAC;EACL;EACA;AACJ;AACA;EACIvB,mBAAmBA,CAAA,EAAG;IAClB;IACA,IAAI,CAAC,IAAI,CAACwB,KAAK,EAAE;MACb,IAAI,CAACC,UAAU,GAAG,IAAI;MACtB;IACJ;IACA,MAAMjB,OAAO,GAAG,IAAI;MAAEkB,QAAQ,GAAGlB,OAAO,CAACkB,QAAQ;MAAEC,IAAI,GAAGnB,OAAO,CAACC,OAAO;MAAEmB,UAAU,GAAGpB,OAAO,CAACoB,UAAU,IAAI,CAAC;MAAEC,UAAU,GAAGrB,OAAO,CAACqB,UAAU,IAAI,CAAC;MAAEZ,CAAC,GAAGT,OAAO,CAACS,CAAC,IAAI,CAAC;MAAEE,CAAC,GAAGX,OAAO,CAACW,CAAC,IAAI,CAAC;MAAEW,KAAK,GAAGtB,OAAO,CAACuB,SAAS,IAAI,MAAM;MAAE3B,eAAe,GAAG;QAClP4B,IAAI,EAAE,CAAC;QAAEC,MAAM,EAAE,GAAG;QAAEC,KAAK,EAAE;MACjC,CAAC,CAACJ,KAAK,CAAC;MAAEvB,MAAM,GAAGC,OAAO,CAACD,MAAM;MAAEQ,UAAU,GAAGR,MAAM,IAAIA,MAAM,CAACQ,UAAU;IAC3E;IACA,SAASoB,eAAeA,CAAA,EAAG;MACvB,IAAI3B,OAAO,CAAC4B,YAAY,EAAE;QACtB,OAAO5B,OAAO,CAAC4B,YAAY;MAC/B;MACA;MACA;MACApD,GAAG,CAAC2C,IAAI,EAAE;QACNzB,KAAK,EAAE,EAAE;QACTa,UAAU,EAAEA,UAAU,IAAI;MAC9B,CAAC,CAAC;MACF,OAAOY,IAAI,CAACN,WAAW;IAC3B;IACA;IACArC,GAAG,CAAC2C,IAAI,EAAE;MACNU,UAAU,EAAET,UAAU;MACtBU,SAAS,EAAET;IACf,CAAC,CAAC;IACF,IAAIF,IAAI,CAAChB,OAAO,KAAK,MAAM,EAAE;MACzB,MAAM4B,QAAQ,GAAG/B,OAAO,CAAC+B,QAAQ;QAAE3B,SAAS,GAAGJ,OAAO,CAACI,SAAS,IAAIxB,IAAI,CAACoB,OAAO,CAACI,SAAS,CAAC;QAAE4B,oBAAoB,GAAG,CAChHD,QAAQ,EACRT,KAAK,EACLH,IAAI,CAACc,SAAS,EACdjC,OAAO,CAACI,SAAS,EACjBJ,OAAO,CAACuB,SAAS,CACpB,CAACW,IAAI,CAAC,GAAG,CAAC;MACX,IAAIvC,QAAQ;QAAEwC,kBAAkB,GAAG,KAAK;MACxC;MACA;MACA;MACA;MACA,IAAI/B,SAAS,KAAKJ,OAAO,CAACoC,YAAY,EAAE;QAAE;QACtC,MAAMR,YAAY,GAAGD,eAAe,CAAC,CAAC;QACtC,IAAI,CAAEvB,SAAS,GAAGJ,OAAO,CAACoC,YAAY,IAClCR,YAAY,GAAGxB,SAAS;QAC5B;QACA;QACA,OAAO,CAACiC,IAAI,CAAClB,IAAI,CAACmB,WAAW,IAAInB,IAAI,CAACoB,SAAS,CAAC,IAC5CpB,IAAI,CAACqB,KAAK,CAAClC,YAAY,KAAK,UAAU,CAAC,EAAE;UACzC9B,GAAG,CAAC2C,IAAI,EAAE;YACNzB,KAAK,EAAGkC,YAAY,GAAGxB,SAAS,IAAK2B,QAAQ,GACzC3B,SAAS,GAAG,IAAI,GAChB,MAAM;YACVqC,OAAO,EAAE,OAAO;YAChBlC,UAAU,EAAEA,UAAU,IAAI,QAAQ,CAAC;UACvC,CAAC,CAAC;;UACFP,OAAO,CAACoC,YAAY,GAAGhC,SAAS;UAChC+B,kBAAkB,GAAG,IAAI,CAAC,CAAC;QAC/B;MACJ;;MACAnC,OAAO,CAACmC,kBAAkB,GAAGA,kBAAkB,CAAC,CAAC;MACjD;MACA,IAAIH,oBAAoB,KAAKhC,OAAO,CAAC0C,GAAG,EAAE;QACtC/C,QAAQ,GAAGuB,QAAQ,CAACyB,WAAW,CAACxB,IAAI,CAAC,CAACyB,CAAC;QACvC;QACA;QACA,IAAInE,OAAO,CAACsD,QAAQ,CAAC,KACfA,QAAQ,MAAM/B,OAAO,CAAC6C,WAAW,IAAI,CAAC,CAAC,IACpCvB,KAAK,KAAKtB,OAAO,CAAC8C,QAAS,CAAC,EAAE;UACnC9C,OAAO,CAACP,eAAe,CAACsC,QAAQ,EAAEnC,eAAe,EAAED,QAAQ,CAAC;QAChE;QACAK,OAAO,CAACX,iBAAiB;QACzB;QACA;QACE,CAACZ,OAAO,CAACsD,QAAQ,CAAC,IAAI/B,OAAO,CAAC4B,YAAY;QAAK;QAC7CT,IAAI,CAACN,WAAW,EAAGlB,QAAQ,EAAEC,eAAe,EAAEmC,QAAQ,EAAET,KAAK,CAAC;MACtE;MACA;MACA9C,GAAG,CAAC2C,IAAI,EAAE;QACNK,IAAI,EAAGf,CAAC,IAAIT,OAAO,CAACH,KAAK,IAAI,CAAC,CAAC,GAAI,IAAI;QACvCkD,GAAG,EAAGpC,CAAC,IAAIX,OAAO,CAACF,KAAK,IAAI,CAAC,CAAC,GAAI;MACtC,CAAC,CAAC;MACF;MACAE,OAAO,CAAC0C,GAAG,GAAGV,oBAAoB;MAClChC,OAAO,CAAC6C,WAAW,GAAGd,QAAQ;MAC9B/B,OAAO,CAAC8C,QAAQ,GAAGxB,KAAK;IAC5B;EACJ;EACA;AACJ;AACA;AACA;EACI7B,eAAeA,CAACsC,QAAQ,EAAEnC,eAAe,EAAED,QAAQ,EAAE;IACjD,MAAMqD,eAAe,GAAGA,CAAA,KAAO7E,IAAI,IAC/B,CAAC,MAAM,CAACkE,IAAI,CAAChE,GAAG,CAAC4E,SAAS,CAACC,SAAS,CAAC,GACrC,eAAe,GACf9E,QAAQ,GACJ,mBAAmB,GACnBF,SAAS,GACL,cAAc,GACdG,GAAG,CAAC8E,KAAK,GACL,cAAc,GACd,KAAK,CAAE;IACvB,MAAMC,aAAa,GAAG,CAAC,CAAC;MAAEC,eAAe,GAAGL,eAAe,CAAC,CAAC;IAC7D,IAAIK,eAAe,EAAE;MACjBD,aAAa,CAACC,eAAe,CAAC,GAAGD,aAAa,CAACE,SAAS,GACpD,SAAS,GAAGvB,QAAQ,GAAG,MAAM;MACjCqB,aAAa,CAACC,eAAe,IAAInF,SAAS,GAAG,QAAQ,GAAG,SAAS,CAAC,CAAC,GAAGkF,aAAa,CAACG,eAAe,GAC9F3D,eAAe,GAAG,GAAG,GAAI,IAAI,GAAGD,QAAQ,GAAG,IAAI;MACpDnB,GAAG,CAAC,IAAI,CAACyB,OAAO,EAAEmD,aAAa,CAAC;IACpC;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,eAAetE,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}