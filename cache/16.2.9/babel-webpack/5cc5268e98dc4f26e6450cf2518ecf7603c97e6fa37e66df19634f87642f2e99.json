{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport Color from './Color/Color.js';\nconst {\n  parse: color\n} = Color;\nimport H from './Globals.js';\nconst {\n  charts,\n  noop\n} = H;\nimport U from './Utilities.js';\nconst {\n  addEvent,\n  attr,\n  css,\n  defined,\n  extend,\n  find,\n  fireEvent,\n  isNumber,\n  isObject,\n  objectEach,\n  offset,\n  pick,\n  splat\n} = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * The mouse and touch tracker object. Each {@link Chart} item has one\n * associated Pointer item that can be accessed from the  {@link Chart.pointer}\n * property.\n *\n * @class\n * @name Highcharts.Pointer\n *\n * @param {Highcharts.Chart} chart\n * The chart instance.\n *\n * @param {Highcharts.Options} options\n * The root options object. The pointer uses options from the chart and tooltip\n * structures.\n */\nclass Pointer {\n  /* *\n   *\n   *  Constructors\n   *\n   * */\n  constructor(chart, options) {\n    this.lastValidTouch = {};\n    this.pinchDown = [];\n    this.runChartClick = false;\n    this.eventsToUnbind = [];\n    this.chart = chart;\n    this.hasDragged = false;\n    this.options = options;\n    this.init(chart, options);\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * Set inactive state to all series that are not currently hovered,\n   * or, if `inactiveOtherPoints` is set to true, set inactive state to\n   * all points within that series.\n   *\n   * @private\n   * @function Highcharts.Pointer#applyInactiveState\n   *\n   * @param {Array<Highcharts.Point>} points\n   * Currently hovered points\n   */\n  applyInactiveState(points) {\n    let activeSeries = [],\n      series;\n    // Get all active series from the hovered points\n    (points || []).forEach(function (item) {\n      series = item.series;\n      // Include itself\n      activeSeries.push(series);\n      // Include parent series\n      if (series.linkedParent) {\n        activeSeries.push(series.linkedParent);\n      }\n      // Include all child series\n      if (series.linkedSeries) {\n        activeSeries = activeSeries.concat(series.linkedSeries);\n      }\n      // Include navigator series\n      if (series.navigatorSeries) {\n        activeSeries.push(series.navigatorSeries);\n      }\n    });\n    // Now loop over all series, filtering out active series\n    this.chart.series.forEach(function (inactiveSeries) {\n      if (activeSeries.indexOf(inactiveSeries) === -1) {\n        // Inactive series\n        inactiveSeries.setState('inactive', true);\n      } else if (inactiveSeries.options.inactiveOtherPoints) {\n        // Active series, but other points should be inactivated\n        inactiveSeries.setAllPointsToState('inactive');\n      }\n    });\n  }\n  /**\n   * Destroys the Pointer object and disconnects DOM events.\n   *\n   * @function Highcharts.Pointer#destroy\n   */\n  destroy() {\n    const pointer = this;\n    this.eventsToUnbind.forEach(unbind => unbind());\n    this.eventsToUnbind = [];\n    if (!H.chartCount) {\n      if (Pointer.unbindDocumentMouseUp) {\n        Pointer.unbindDocumentMouseUp = Pointer.unbindDocumentMouseUp();\n      }\n      if (Pointer.unbindDocumentTouchEnd) {\n        Pointer.unbindDocumentTouchEnd = Pointer.unbindDocumentTouchEnd();\n      }\n    }\n    // memory and CPU leak\n    clearInterval(pointer.tooltipTimeout);\n    objectEach(pointer, function (_val, prop) {\n      pointer[prop] = void 0;\n    });\n  }\n  /**\n   * Calculate attrs for selection marker.\n   * @private\n   * @function Highcharts.Pointer#getSelectionMarkerAttrs\n   * @emits getSelectionMarkerAttrs\n   */\n  getSelectionMarkerAttrs(chartX, chartY) {\n    const e = {\n      args: {\n        chartX,\n        chartY\n      },\n      attrs: {},\n      shapeType: 'rect'\n    };\n    fireEvent(this, 'getSelectionMarkerAttrs', e, e => {\n      const {\n          chart,\n          mouseDownX = 0,\n          mouseDownY = 0,\n          zoomHor,\n          zoomVert\n        } = this,\n        attrs = e.attrs;\n      let size;\n      attrs.x = chart.plotLeft;\n      attrs.y = chart.plotTop;\n      attrs.width = zoomHor ? 1 : chart.plotWidth;\n      attrs.height = zoomVert ? 1 : chart.plotHeight;\n      // Adjust the width of the selection marker\n      if (zoomHor) {\n        size = chartX - mouseDownX;\n        attrs.width = Math.abs(size);\n        attrs.x = (size > 0 ? 0 : size) + mouseDownX;\n      }\n      // Adjust the height of the selection marker\n      if (zoomVert) {\n        size = chartY - mouseDownY;\n        attrs.height = Math.abs(size);\n        attrs.y = (size > 0 ? 0 : size) + mouseDownY;\n      }\n    });\n    return e;\n  }\n  /**\n   * Perform a drag operation in response to a mousemove event while the mouse\n   * is down.\n   * @private\n   * @function Highcharts.Pointer#drag\n   */\n  drag(e) {\n    const chart = this.chart,\n      chartOptions = chart.options.chart,\n      plotLeft = chart.plotLeft,\n      plotTop = chart.plotTop,\n      plotWidth = chart.plotWidth,\n      plotHeight = chart.plotHeight,\n      mouseDownX = this.mouseDownX || 0,\n      mouseDownY = this.mouseDownY || 0,\n      panningEnabled = isObject(chartOptions.panning) ? chartOptions.panning && chartOptions.panning.enabled : chartOptions.panning,\n      panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];\n    let chartX = e.chartX,\n      chartY = e.chartY,\n      clickedInside,\n      selectionMarker = this.selectionMarker;\n    // If the device supports both touch and mouse (like IE11), and we are\n    // touch-dragging inside the plot area, don't handle the mouse event.\n    // #4339.\n    if (selectionMarker && selectionMarker.touch) {\n      return;\n    }\n    // If the mouse is outside the plot area, adjust to coordinates\n    // inside to prevent the selection marker from going outside\n    if (chartX < plotLeft) {\n      chartX = plotLeft;\n    } else if (chartX > plotLeft + plotWidth) {\n      chartX = plotLeft + plotWidth;\n    }\n    if (chartY < plotTop) {\n      chartY = plotTop;\n    } else if (chartY > plotTop + plotHeight) {\n      chartY = plotTop + plotHeight;\n    }\n    // determine if the mouse has moved more than 10px\n    this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) + Math.pow(mouseDownY - chartY, 2));\n    if (this.hasDragged > 10) {\n      clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop, {\n        visiblePlotOnly: true\n      });\n      const {\n        shapeType,\n        attrs\n      } = this.getSelectionMarkerAttrs(chartX, chartY);\n      // make a selection\n      if ((chart.hasCartesianSeries || chart.mapView) && (this.zoomX || this.zoomY) && clickedInside && !panKey) {\n        if (!selectionMarker) {\n          this.selectionMarker = selectionMarker = chart.renderer[shapeType]();\n          selectionMarker.attr({\n            'class': 'highcharts-selection-marker',\n            zIndex: 7\n          }).add();\n          if (!chart.styledMode) {\n            selectionMarker.attr({\n              fill: chartOptions.selectionMarkerFill || color(\"#334eff\" /* Palette.highlightColor80 */).setOpacity(0.25).get()\n            });\n          }\n        }\n      }\n      if (selectionMarker) {\n        selectionMarker.attr(attrs);\n      }\n      // panning\n      if (clickedInside && !selectionMarker && panningEnabled) {\n        chart.pan(e, chartOptions.panning);\n      }\n    }\n  }\n  /**\n   * Start a drag operation.\n   * @private\n   * @function Highcharts.Pointer#dragStart\n   */\n  dragStart(e) {\n    const chart = this.chart;\n    // Record the start position\n    chart.mouseIsDown = e.type;\n    chart.cancelClick = false;\n    chart.mouseDownX = this.mouseDownX = e.chartX;\n    chart.mouseDownY = this.mouseDownY = e.chartY;\n  }\n  /**\n   * Get selection box to calculate extremes\n   * @private\n   * @function Highcharts.Pointer#getSelectionBox\n   * @emits getSelectionBox\n   */\n  getSelectionBox(marker) {\n    const e = {\n      args: {\n        marker\n      },\n      result: {}\n    };\n    fireEvent(this, 'getSelectionBox', e, e => {\n      e.result = {\n        x: marker.attr ? +marker.attr('x') : marker.x,\n        y: marker.attr ? +marker.attr('y') : marker.y,\n        width: marker.attr ? marker.attr('width') : marker.width,\n        height: marker.attr ? marker.attr('height') : marker.height\n      };\n    });\n    return e.result;\n  }\n  /**\n   * On mouse up or touch end across the entire document, drop the selection.\n   * @private\n   * @function Highcharts.Pointer#drop\n   */\n  drop(e) {\n    const pointer = this,\n      chart = this.chart,\n      hasPinched = this.hasPinched;\n    if (this.selectionMarker) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = this.getSelectionBox(this.selectionMarker);\n      const selectionData = {\n        originalEvent: e,\n        xAxis: [],\n        yAxis: [],\n        x,\n        y,\n        width,\n        height\n      };\n      // Start by false runZoom, unless when we have a mapView, in\n      // which case the zoom will be handled in the selection event.\n      let runZoom = Boolean(chart.mapView);\n      // a selection has been made\n      if (this.hasDragged || hasPinched) {\n        // record each axis' min and max\n        chart.axes.forEach(function (axis) {\n          if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{\n            xAxis: 'zoomX',\n            yAxis: 'zoomY'\n          }[axis.coll]]) && isNumber(x) && isNumber(y) && isNumber(width) && isNumber(height)) {\n            // #859, #3569\n            const horiz = axis.horiz,\n              minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0,\n              // #1207, #3075\n              selectionMin = axis.toValue((horiz ? x : y) + minPixelPadding),\n              selectionMax = axis.toValue((horiz ? x + width : y + height) - minPixelPadding);\n            selectionData[axis.coll].push({\n              axis: axis,\n              // Min/max for reversed axes\n              min: Math.min(selectionMin, selectionMax),\n              max: Math.max(selectionMin, selectionMax)\n            });\n            runZoom = true;\n          }\n        });\n        if (runZoom) {\n          fireEvent(chart, 'selection', selectionData, function (args) {\n            chart.zoom(extend(args, hasPinched ? {\n              animation: false\n            } : null));\n          });\n        }\n      }\n      if (isNumber(chart.index)) {\n        this.selectionMarker = this.selectionMarker.destroy();\n      }\n      // Reset scaling preview\n      if (hasPinched) {\n        this.scaleGroups();\n      }\n    }\n    // Reset all. Check isNumber because it may be destroyed on mouse up\n    // (#877)\n    if (chart && isNumber(chart.index)) {\n      css(chart.container, {\n        cursor: chart._cursor\n      });\n      chart.cancelClick = +this.hasDragged > 10; // #370\n      chart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n      this.pinchDown = [];\n    }\n  }\n  /**\n   * Finds the closest point to a set of coordinates, using the k-d-tree\n   * algorithm.\n   *\n   * @function Highcharts.Pointer#findNearestKDPoint\n   *\n   * @param {Array<Highcharts.Series>} series\n   * All the series to search in.\n   *\n   * @param {boolean|undefined} shared\n   * Whether it is a shared tooltip or not.\n   *\n   * @param {Highcharts.PointerEventObject} e\n   * The pointer event object, containing chart coordinates of the pointer.\n   *\n   * @return {Highcharts.Point|undefined}\n   * The point closest to given coordinates.\n   */\n  findNearestKDPoint(series, shared, e) {\n    let closest;\n    /** @private */\n    function sort(p1, p2) {\n      const isCloserX = p1.distX - p2.distX,\n        isCloser = p1.dist - p2.dist,\n        isAbove = (p2.series.group && p2.series.group.zIndex) - (p1.series.group && p1.series.group.zIndex);\n      let result;\n      // We have two points which are not in the same place on xAxis\n      // and shared tooltip:\n      if (isCloserX !== 0 && shared) {\n        // #5721\n        result = isCloserX;\n        // Points are not exactly in the same place on x/yAxis:\n      } else if (isCloser !== 0) {\n        result = isCloser;\n        // The same xAxis and yAxis position, sort by z-index:\n      } else if (isAbove !== 0) {\n        result = isAbove;\n        // The same zIndex, sort by array index:\n      } else {\n        result = p1.series.index > p2.series.index ? -1 : 1;\n      }\n      return result;\n    }\n    series.forEach(function (s) {\n      const noSharedTooltip = s.noSharedTooltip && shared,\n        compareX = !noSharedTooltip && s.options.findNearestPointBy.indexOf('y') < 0,\n        point = s.searchPoint(e, compareX);\n      if (\n      // Check that we actually found a point on the series.\n      isObject(point, true) && point.series && (\n      // Use the new point if it is closer.\n      !isObject(closest, true) || sort(closest, point) > 0)) {\n        closest = point;\n      }\n    });\n    return closest;\n  }\n  /**\n   * @private\n   * @function Highcharts.Pointer#getChartCoordinatesFromPoint\n   */\n  getChartCoordinatesFromPoint(point, inverted) {\n    const series = point.series,\n      xAxis = series.xAxis,\n      yAxis = series.yAxis,\n      shapeArgs = point.shapeArgs;\n    if (xAxis && yAxis) {\n      let x = pick(point.clientX, point.plotX);\n      let y = point.plotY || 0;\n      if (point.isNode && shapeArgs && isNumber(shapeArgs.x) && isNumber(shapeArgs.y)) {\n        x = shapeArgs.x;\n        y = shapeArgs.y;\n      }\n      return inverted ? {\n        chartX: yAxis.len + yAxis.pos - y,\n        chartY: xAxis.len + xAxis.pos - x\n      } : {\n        chartX: x + xAxis.pos,\n        chartY: y + yAxis.pos\n      };\n    }\n    if (shapeArgs && shapeArgs.x && shapeArgs.y) {\n      // E.g. pies do not have axes\n      return {\n        chartX: shapeArgs.x,\n        chartY: shapeArgs.y\n      };\n    }\n  }\n  /**\n   * Return the cached chartPosition if it is available on the Pointer,\n   * otherwise find it. Running offset is quite expensive, so it should be\n   * avoided when we know the chart hasn't moved.\n   *\n   * @function Highcharts.Pointer#getChartPosition\n   *\n   * @return {Highcharts.ChartPositionObject}\n   * The offset of the chart container within the page\n   */\n  getChartPosition() {\n    if (this.chartPosition) {\n      return this.chartPosition;\n    }\n    const {\n      container\n    } = this.chart;\n    const pos = offset(container);\n    this.chartPosition = {\n      left: pos.left,\n      top: pos.top,\n      scaleX: 1,\n      scaleY: 1\n    };\n    const offsetWidth = container.offsetWidth;\n    const offsetHeight = container.offsetHeight;\n    // #13342 - tooltip was not visible in Chrome, when chart\n    // updates height.\n    if (offsetWidth > 2 &&\n    // #13342\n    offsetHeight > 2 // #13342\n    ) {\n      this.chartPosition.scaleX = pos.width / offsetWidth;\n      this.chartPosition.scaleY = pos.height / offsetHeight;\n    }\n    return this.chartPosition;\n  }\n  /**\n   * Get the click position in terms of axis values.\n   *\n   * @function Highcharts.Pointer#getCoordinates\n   *\n   * @param {Highcharts.PointerEventObject} e\n   * Pointer event, extended with `chartX` and `chartY` properties.\n   *\n   * @return {Highcharts.PointerAxisCoordinatesObject}\n   * Axis coordinates.\n   */\n  getCoordinates(e) {\n    const coordinates = {\n      xAxis: [],\n      yAxis: []\n    };\n    this.chart.axes.forEach(function (axis) {\n      coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n        axis: axis,\n        value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n      });\n    });\n    return coordinates;\n  }\n  /**\n   * Calculates what is the current hovered point/points and series.\n   *\n   * @private\n   * @function Highcharts.Pointer#getHoverData\n   *\n   * @param {Highcharts.Point|undefined} existingHoverPoint\n   * The point currently being hovered.\n   *\n   * @param {Highcharts.Series|undefined} existingHoverSeries\n   * The series currently being hovered.\n   *\n   * @param {Array<Highcharts.Series>} series\n   * All the series in the chart.\n   *\n   * @param {boolean} isDirectTouch\n   * Is the pointer directly hovering the point.\n   *\n   * @param {boolean|undefined} shared\n   * Whether it is a shared tooltip or not.\n   *\n   * @param {Highcharts.PointerEventObject} [e]\n   * The triggering event, containing chart coordinates of the pointer.\n   *\n   * @return {Object}\n   * Object containing resulting hover data: hoverPoint, hoverSeries, and\n   * hoverPoints.\n   */\n  getHoverData(existingHoverPoint, existingHoverSeries, series, isDirectTouch, shared, e) {\n    const hoverPoints = [],\n      useExisting = !!(isDirectTouch && existingHoverPoint),\n      filter = function (s) {\n        return s.visible && !(!shared && s.directTouch) &&\n        // #3821\n        pick(s.options.enableMouseTracking, true);\n      };\n    let hoverSeries = existingHoverSeries,\n      // Which series to look in for the hover point\n      searchSeries,\n      // Parameters needed for beforeGetHoverData event.\n      eventArgs = {\n        chartX: e ? e.chartX : void 0,\n        chartY: e ? e.chartY : void 0,\n        shared: shared\n      };\n    // Find chart.hoverPane and update filter method in polar.\n    fireEvent(this, 'beforeGetHoverData', eventArgs);\n    const notSticky = hoverSeries && !hoverSeries.stickyTracking;\n    searchSeries = notSticky ?\n    // Only search on hovered series if it has stickyTracking false\n    [hoverSeries] :\n    // Filter what series to look in.\n    series.filter(s => s.stickyTracking && (eventArgs.filter || filter)(s));\n    // Use existing hovered point or find the one closest to coordinates.\n    const hoverPoint = useExisting || !e ? existingHoverPoint : this.findNearestKDPoint(searchSeries, shared, e);\n    // Assign hover series\n    hoverSeries = hoverPoint && hoverPoint.series;\n    // If we have a hoverPoint, assign hoverPoints.\n    if (hoverPoint) {\n      // When tooltip is shared, it displays more than one point\n      if (shared && !hoverSeries.noSharedTooltip) {\n        searchSeries = series.filter(function (s) {\n          return eventArgs.filter ? eventArgs.filter(s) : filter(s) && !s.noSharedTooltip;\n        });\n        // Get all points with the same x value as the hoverPoint\n        searchSeries.forEach(function (s) {\n          let point = find(s.points, function (p) {\n            return p.x === hoverPoint.x && !p.isNull;\n          });\n          if (isObject(point)) {\n            /*\n            * Boost returns a minimal point. Convert it to a usable\n            * point for tooltip and states.\n            */\n            if (s.boosted && s.boost) {\n              point = s.boost.getPoint(point);\n            }\n            hoverPoints.push(point);\n          }\n        });\n      } else {\n        hoverPoints.push(hoverPoint);\n      }\n    }\n    // Check whether the hoverPoint is inside pane we are hovering over.\n    eventArgs = {\n      hoverPoint: hoverPoint\n    };\n    fireEvent(this, 'afterGetHoverData', eventArgs);\n    return {\n      hoverPoint: eventArgs.hoverPoint,\n      hoverSeries: hoverSeries,\n      hoverPoints: hoverPoints\n    };\n  }\n  /**\n   * @private\n   * @function Highcharts.Pointer#getPointFromEvent\n   */\n  getPointFromEvent(e) {\n    let target = e.target,\n      point;\n    while (target && !point) {\n      point = target.point;\n      target = target.parentNode;\n    }\n    return point;\n  }\n  /**\n   * @private\n   * @function Highcharts.Pointer#onTrackerMouseOut\n   */\n  onTrackerMouseOut(e) {\n    const chart = this.chart;\n    const relatedTarget = e.relatedTarget;\n    const series = chart.hoverSeries;\n    this.isDirectTouch = false;\n    if (series && relatedTarget && !series.stickyTracking && !this.inClass(relatedTarget, 'highcharts-tooltip') && (!this.inClass(relatedTarget, 'highcharts-series-' + series.index) ||\n    // #2499, #4465, #5553\n    !this.inClass(relatedTarget, 'highcharts-tracker'))) {\n      series.onMouseOut();\n    }\n  }\n  /**\n   * Utility to detect whether an element has, or has a parent with, a\n   * specific class name. Used on detection of tracker objects and on deciding\n   * whether hovering the tooltip should cause the active series to mouse out.\n   *\n   * @function Highcharts.Pointer#inClass\n   *\n   * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element\n   * The element to investigate.\n   *\n   * @param {string} className\n   * The class name to look for.\n   *\n   * @return {boolean|undefined}\n   * True if either the element or one of its parents has the given class\n   * name.\n   */\n  inClass(element, className) {\n    let elem = element,\n      elemClassName;\n    while (elem) {\n      elemClassName = attr(elem, 'class');\n      if (elemClassName) {\n        if (elemClassName.indexOf(className) !== -1) {\n          return true;\n        }\n        if (elemClassName.indexOf('highcharts-container') !== -1) {\n          return false;\n        }\n      }\n      elem = elem.parentElement;\n    }\n  }\n  /**\n   * Initialize the Pointer.\n   *\n   * @private\n   * @function Highcharts.Pointer#init\n   *\n   * @param {Highcharts.Chart} chart\n   * The Chart instance.\n   *\n   * @param {Highcharts.Options} options\n   * The root options object. The pointer uses options from the chart and\n   * tooltip structures.\n   */\n  init(chart, options) {\n    // Store references\n    this.options = options;\n    this.chart = chart;\n    // Do we need to handle click on a touch device?\n    this.runChartClick = Boolean(options.chart.events && options.chart.events.click);\n    this.pinchDown = [];\n    this.lastValidTouch = {};\n    this.setDOMEvents();\n    fireEvent(this, 'afterInit');\n  }\n  /**\n   * Takes a browser event object and extends it with custom Highcharts\n   * properties `chartX` and `chartY` in order to work on the internal\n   * coordinate system.\n   *\n   * On map charts, the properties `lon` and `lat` are added to the event\n   * object given that the chart has projection information.\n   *\n   * @function Highcharts.Pointer#normalize\n   *\n   * @param {global.MouseEvent|global.PointerEvent|global.TouchEvent} e\n   * Event object in standard browsers.\n   *\n   * @param {Highcharts.OffsetObject} [chartPosition]\n   * Additional chart offset.\n   *\n   * @return {Highcharts.PointerEventObject}\n   * A browser event with extended properties `chartX` and `chartY`.\n   */\n  normalize(e, chartPosition) {\n    const touches = e.touches;\n    // iOS (#2757)\n    const ePos = touches ? touches.length ? touches.item(0) : pick(\n    // #13534\n    touches.changedTouches, e.changedTouches)[0] : e;\n    // Get mouse position\n    if (!chartPosition) {\n      chartPosition = this.getChartPosition();\n    }\n    let chartX = ePos.pageX - chartPosition.left,\n      chartY = ePos.pageY - chartPosition.top;\n    // #11329 - when there is scaling on a parent element, we need to take\n    // this into account\n    chartX /= chartPosition.scaleX;\n    chartY /= chartPosition.scaleY;\n    return extend(e, {\n      chartX: Math.round(chartX),\n      chartY: Math.round(chartY)\n    });\n  }\n  /**\n   * @private\n   * @function Highcharts.Pointer#onContainerClick\n   */\n  onContainerClick(e) {\n    const chart = this.chart;\n    const hoverPoint = chart.hoverPoint;\n    const pEvt = this.normalize(e);\n    const plotLeft = chart.plotLeft;\n    const plotTop = chart.plotTop;\n    if (!chart.cancelClick) {\n      // On tracker click, fire the series and point events. #783, #1583\n      if (hoverPoint && this.inClass(pEvt.target, 'highcharts-tracker')) {\n        // the series click event\n        fireEvent(hoverPoint.series, 'click', extend(pEvt, {\n          point: hoverPoint\n        }));\n        // the point click event\n        if (chart.hoverPoint) {\n          // it may be destroyed (#1844)\n          hoverPoint.firePointEvent('click', pEvt);\n        }\n        // When clicking outside a tracker, fire a chart event\n      } else {\n        extend(pEvt, this.getCoordinates(pEvt));\n        // fire a click event in the chart\n        if (chart.isInsidePlot(pEvt.chartX - plotLeft, pEvt.chartY - plotTop, {\n          visiblePlotOnly: true\n        })) {\n          fireEvent(chart, 'click', pEvt);\n        }\n      }\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.Pointer#onContainerMouseDown\n   */\n  onContainerMouseDown(e) {\n    const isPrimaryButton = ((e.buttons || e.button) & 1) === 1;\n    e = this.normalize(e);\n    // #11635, Firefox does not reliably fire move event after click scroll\n    if (H.isFirefox && e.button !== 0) {\n      this.onContainerMouseMove(e);\n    }\n    // #11635, limiting to primary button\n    if (typeof e.button === 'undefined' || isPrimaryButton) {\n      this.zoomOption(e);\n      // #295, #13737 solve conflict between container drag and chart zoom\n      if (isPrimaryButton && e.preventDefault) {\n        e.preventDefault();\n      }\n      this.dragStart(e);\n    }\n  }\n  /**\n   * When mouse leaves the container, hide the tooltip.\n   * @private\n   * @function Highcharts.Pointer#onContainerMouseLeave\n   */\n  onContainerMouseLeave(e) {\n    const chart = charts[pick(Pointer.hoverChartIndex, -1)];\n    e = this.normalize(e);\n    this.onContainerMouseMove(e);\n    // #4886, MS Touch end fires mouseleave but with no related target\n    if (chart && e.relatedTarget && !this.inClass(e.relatedTarget, 'highcharts-tooltip')) {\n      chart.pointer.reset();\n      // Also reset the chart position, used in #149 fix\n      chart.pointer.chartPosition = void 0;\n    }\n  }\n  /**\n   * When mouse enters the container, delete pointer's chartPosition.\n   * @private\n   * @function Highcharts.Pointer#onContainerMouseEnter\n   */\n  onContainerMouseEnter(e) {\n    delete this.chartPosition;\n  }\n  /**\n   * The mousemove, touchmove and touchstart event handler\n   * @private\n   * @function Highcharts.Pointer#onContainerMouseMove\n   */\n  onContainerMouseMove(e) {\n    const chart = this.chart,\n      tooltip = chart.tooltip,\n      pEvt = this.normalize(e);\n    this.setHoverChartIndex(e);\n    if (chart.mouseIsDown === 'mousedown' || this.touchSelect(pEvt)) {\n      this.drag(pEvt);\n    }\n    // Show the tooltip and run mouse over events (#977)\n    if (!chart.openMenu && (this.inClass(pEvt.target, 'highcharts-tracker') || chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {\n      visiblePlotOnly: true\n    })) &&\n    // If the tooltip has stickOnContact enabled, do nothing. This\n    // applies regardless of any combinations of the `split` and\n    // `useHTML` options.\n    !(tooltip && tooltip.shouldStickOnContact(pEvt))) {\n      if (this.inClass(pEvt.target, 'highcharts-no-tooltip')) {\n        this.reset(false, 0);\n      } else {\n        this.runPointActions(pEvt);\n      }\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.Pointer#onDocumentTouchEnd\n   */\n  onDocumentTouchEnd(e) {\n    const hoverChart = charts[pick(Pointer.hoverChartIndex, -1)];\n    if (hoverChart) {\n      hoverChart.pointer.drop(e);\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.Pointer#onContainerTouchMove\n   */\n  onContainerTouchMove(e) {\n    if (this.touchSelect(e)) {\n      this.onContainerMouseMove(e);\n    } else {\n      this.touch(e);\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.Pointer#onContainerTouchStart\n   */\n  onContainerTouchStart(e) {\n    if (this.touchSelect(e)) {\n      this.onContainerMouseDown(e);\n    } else {\n      this.zoomOption(e);\n      this.touch(e, true);\n    }\n  }\n  /**\n   * Special handler for mouse move that will hide the tooltip when the mouse\n   * leaves the plotarea. Issue #149 workaround. The mouseleave event does not\n   * always fire.\n   * @private\n   * @function Highcharts.Pointer#onDocumentMouseMove\n   */\n  onDocumentMouseMove(e) {\n    const chart = this.chart;\n    const tooltip = chart.tooltip;\n    const chartPosition = this.chartPosition;\n    const pEvt = this.normalize(e, chartPosition);\n    // If we're outside, hide the tooltip\n    if (chartPosition && !chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {\n      visiblePlotOnly: true\n    }) && !(tooltip && tooltip.shouldStickOnContact(pEvt)) && !this.inClass(pEvt.target, 'highcharts-tracker')) {\n      this.reset();\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.Pointer#onDocumentMouseUp\n   */\n  onDocumentMouseUp(e) {\n    const chart = charts[pick(Pointer.hoverChartIndex, -1)];\n    if (chart) {\n      chart.pointer.drop(e);\n    }\n  }\n  /**\n   * Handle touch events with two touches\n   * @private\n   * @function Highcharts.Pointer#pinch\n   */\n  pinch(e) {\n    const self = this,\n      chart = self.chart,\n      pinchDown = self.pinchDown,\n      touches = e.touches || [],\n      touchesLength = touches.length,\n      lastValidTouch = self.lastValidTouch,\n      hasZoom = self.hasZoom,\n      transform = {},\n      fireClickEvent = touchesLength === 1 && (self.inClass(e.target, 'highcharts-tracker') && chart.runTrackerClick || self.runChartClick),\n      clip = {},\n      tooltip = self.chart.tooltip,\n      followTouchMove = touchesLength === 1 && pick(tooltip && tooltip.options.followTouchMove, true);\n    let selectionMarker = self.selectionMarker;\n    // Don't initiate panning until the user has pinched. This prevents us\n    // from blocking page scrolling as users scroll down a long page\n    // (#4210).\n    if (touchesLength > 1) {\n      self.initiated = true;\n    } else if (followTouchMove) {\n      // #16119: Prevent blocking scroll when single-finger panning is\n      // not enabled\n      self.initiated = false;\n    }\n    // On touch devices, only proceed to trigger click if a handler is\n    // defined\n    if (hasZoom && self.initiated && !fireClickEvent && e.cancelable !== false) {\n      e.preventDefault();\n    }\n    // Normalize each touch\n    [].map.call(touches, function (e) {\n      return self.normalize(e);\n    });\n    // Register the touch start position\n    if (e.type === 'touchstart') {\n      [].forEach.call(touches, function (e, i) {\n        pinchDown[i] = {\n          chartX: e.chartX,\n          chartY: e.chartY\n        };\n      });\n      lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];\n      lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];\n      // Identify the data bounds in pixels\n      chart.axes.forEach(function (axis) {\n        if (axis.zoomEnabled) {\n          const bounds = chart.bounds[axis.horiz ? 'h' : 'v'],\n            minPixelPadding = axis.minPixelPadding,\n            min = axis.toPixels(Math.min(pick(axis.options.min, axis.dataMin), axis.dataMin)),\n            max = axis.toPixels(Math.max(pick(axis.options.max, axis.dataMax), axis.dataMax)),\n            absMin = Math.min(min, max),\n            absMax = Math.max(min, max);\n          // Store the bounds for use in the touchmove handler\n          bounds.min = Math.min(axis.pos, absMin - minPixelPadding);\n          bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);\n        }\n      });\n      self.res = true; // reset on next move\n      // Optionally move the tooltip on touchmove\n    } else if (followTouchMove) {\n      this.runPointActions(self.normalize(e));\n      // Event type is touchmove, handle panning and pinching\n    } else if (pinchDown.length) {\n      // can be 0 when releasing, if touchend\n      // fires first\n      fireEvent(chart, 'touchpan', {\n        originalEvent: e\n      }, () => {\n        // Set the marker\n        if (!selectionMarker) {\n          // @todo It's a mock object, so maybe we need a separate\n          // interface\n          self.selectionMarker = selectionMarker = extend({\n            destroy: noop,\n            touch: true\n          }, chart.plotBox);\n        }\n        self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n        self.hasPinched = hasZoom;\n        // Scale and translate the groups to provide visual feedback\n        // during pinching\n        self.scaleGroups(transform, clip);\n      });\n      if (self.res) {\n        self.res = false;\n        this.reset(false, 0);\n      }\n    }\n  }\n  /**\n   * Run translation operations\n   * @private\n   * @function Highcharts.Pointer#pinchTranslate\n   */\n  pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n    if (this.zoomHor) {\n      this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n    }\n    if (this.zoomVert) {\n      this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n    }\n  }\n  /**\n   * Run translation operations for each direction (horizontal and vertical)\n   * independently.\n   * @private\n   * @function Highcharts.Pointer#pinchTranslateDirection\n   */\n  pinchTranslateDirection(horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {\n    const chart = this.chart,\n      xy = horiz ? 'x' : 'y',\n      XY = horiz ? 'X' : 'Y',\n      sChartXY = 'chart' + XY,\n      wh = horiz ? 'width' : 'height',\n      plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],\n      inverted = chart.inverted,\n      bounds = chart.bounds[horiz ? 'h' : 'v'],\n      singleTouch = pinchDown.length === 1,\n      touch0Start = pinchDown[0][sChartXY],\n      touch1Start = !singleTouch && pinchDown[1][sChartXY],\n      setScale = function () {\n        // Don't zoom if fingers are too close on this axis\n        if (typeof touch1Now === 'number' && Math.abs(touch0Start - touch1Start) > 20) {\n          scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start);\n        }\n        clipXY = (plotLeftTop - touch0Now) / scale + touch0Start;\n        selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;\n      };\n    let selectionWH,\n      selectionXY,\n      clipXY,\n      scale = forcedScale || 1,\n      touch0Now = touches[0][sChartXY],\n      touch1Now = !singleTouch && touches[1][sChartXY],\n      outOfBounds;\n    // Set the scale, first pass\n    setScale();\n    // The clip position (x or y) is altered if out of bounds, the selection\n    // position is not\n    selectionXY = clipXY;\n    // Out of bounds\n    if (selectionXY < bounds.min) {\n      selectionXY = bounds.min;\n      outOfBounds = true;\n    } else if (selectionXY + selectionWH > bounds.max) {\n      selectionXY = bounds.max - selectionWH;\n      outOfBounds = true;\n    }\n    // Is the chart dragged off its bounds, determined by dataMin and\n    // dataMax?\n    if (outOfBounds) {\n      // Modify the touchNow position in order to create an elastic drag\n      // movement. This indicates to the user that the chart is responsive\n      // but can't be dragged further.\n      touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);\n      if (typeof touch1Now === 'number') {\n        touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);\n      }\n      // Set the scale, second pass to adapt to the modified touchNow\n      // positions\n      setScale();\n    } else {\n      lastValidTouch[xy] = [touch0Now, touch1Now];\n    }\n    // Set geometry for clipping, selection and transformation\n    if (!inverted) {\n      clip[xy] = clipXY - plotLeftTop;\n      clip[wh] = selectionWH;\n    }\n    const scaleKey = inverted ? horiz ? 'scaleY' : 'scaleX' : 'scale' + XY;\n    const transformScale = inverted ? 1 / scale : scale;\n    selectionMarker[wh] = selectionWH;\n    selectionMarker[xy] = selectionXY;\n    // Invert scale if needed (#19217)\n    transform[scaleKey] = scale * (inverted && !horiz ? -1 : 1);\n    transform['translate' + XY] = transformScale * plotLeftTop + (touch0Now - transformScale * touch0Start);\n  }\n  /**\n   * Reset the tracking by hiding the tooltip, the hover series state and the\n   * hover point\n   *\n   * @function Highcharts.Pointer#reset\n   *\n   * @param {boolean} [allowMove]\n   * Instead of destroying the tooltip altogether, allow moving it if\n   * possible.\n   *\n   * @param {number} [delay]\n   */\n  reset(allowMove, delay) {\n    const pointer = this,\n      chart = pointer.chart,\n      hoverSeries = chart.hoverSeries,\n      hoverPoint = chart.hoverPoint,\n      hoverPoints = chart.hoverPoints,\n      tooltip = chart.tooltip,\n      tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;\n    // Check if the points have moved outside the plot area (#1003, #4736,\n    // #5101)\n    if (allowMove && tooltipPoints) {\n      splat(tooltipPoints).forEach(function (point) {\n        if (point.series.isCartesian && typeof point.plotX === 'undefined') {\n          allowMove = false;\n        }\n      });\n    }\n    // Just move the tooltip, #349\n    if (allowMove) {\n      if (tooltip && tooltipPoints && splat(tooltipPoints).length) {\n        tooltip.refresh(tooltipPoints);\n        if (tooltip.shared && hoverPoints) {\n          // #8284\n          hoverPoints.forEach(function (point) {\n            point.setState(point.state, true);\n            if (point.series.isCartesian) {\n              if (point.series.xAxis.crosshair) {\n                point.series.xAxis.drawCrosshair(null, point);\n              }\n              if (point.series.yAxis.crosshair) {\n                point.series.yAxis.drawCrosshair(null, point);\n              }\n            }\n          });\n        } else if (hoverPoint) {\n          // #2500\n          hoverPoint.setState(hoverPoint.state, true);\n          chart.axes.forEach(function (axis) {\n            if (axis.crosshair && hoverPoint.series[axis.coll] === axis) {\n              axis.drawCrosshair(null, hoverPoint);\n            }\n          });\n        }\n      }\n      // Full reset\n    } else {\n      if (hoverPoint) {\n        hoverPoint.onMouseOut();\n      }\n      if (hoverPoints) {\n        hoverPoints.forEach(function (point) {\n          point.setState();\n        });\n      }\n      if (hoverSeries) {\n        hoverSeries.onMouseOut();\n      }\n      if (tooltip) {\n        tooltip.hide(delay);\n      }\n      if (pointer.unDocMouseMove) {\n        pointer.unDocMouseMove = pointer.unDocMouseMove();\n      }\n      // Remove crosshairs\n      chart.axes.forEach(function (axis) {\n        axis.hideCrosshair();\n      });\n      pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;\n    }\n  }\n  /**\n   * With line type charts with a single tracker, get the point closest to the\n   * mouse. Run Point.onMouseOver and display tooltip for the point or points.\n   *\n   * @private\n   * @function Highcharts.Pointer#runPointActions\n   *\n   * @emits Highcharts.Point#event:mouseOut\n   * @emits Highcharts.Point#event:mouseOver\n   */\n  runPointActions(e, p, force) {\n    const pointer = this,\n      chart = pointer.chart,\n      series = chart.series,\n      tooltip = chart.tooltip && chart.tooltip.options.enabled ? chart.tooltip : void 0,\n      shared = tooltip ? tooltip.shared : false;\n    let hoverPoint = p || chart.hoverPoint,\n      hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries;\n    const\n      // onMouseOver or already hovering a series with directTouch\n      isDirectTouch = (!e || e.type !== 'touchmove') && (!!p || hoverSeries && hoverSeries.directTouch && pointer.isDirectTouch),\n      hoverData = this.getHoverData(hoverPoint, hoverSeries, series, isDirectTouch, shared, e);\n    // Update variables from hoverData.\n    hoverPoint = hoverData.hoverPoint;\n    hoverSeries = hoverData.hoverSeries;\n    const points = hoverData.hoverPoints,\n      followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer && !hoverSeries.tooltipOptions.split,\n      useSharedTooltip = shared && hoverSeries && !hoverSeries.noSharedTooltip;\n    // Refresh tooltip for kdpoint if new hover point or tooltip was hidden\n    // #3926, #4200\n    if (hoverPoint && (force || hoverPoint !== chart.hoverPoint || tooltip && tooltip.isHidden)) {\n      (chart.hoverPoints || []).forEach(function (p) {\n        if (points.indexOf(p) === -1) {\n          p.setState();\n        }\n      });\n      // Set normal state to previous series\n      if (chart.hoverSeries !== hoverSeries) {\n        hoverSeries.onMouseOver();\n      }\n      pointer.applyInactiveState(points);\n      // Do mouseover on all points (#3919, #3985, #4410, #5622)\n      (points || []).forEach(function (p) {\n        p.setState('hover');\n      });\n      // If tracking is on series in stead of on each point,\n      // fire mouseOver on hover point. // #4448\n      if (chart.hoverPoint) {\n        chart.hoverPoint.firePointEvent('mouseOut');\n      }\n      // Hover point may have been destroyed in the event handlers (#7127)\n      if (!hoverPoint.series) {\n        return;\n      }\n      /**\n       * Contains all hovered points.\n       *\n       * @name Highcharts.Chart#hoverPoints\n       * @type {Array<Highcharts.Point>|null}\n       */\n      chart.hoverPoints = points;\n      /**\n       * Contains the original hovered point.\n       *\n       * @name Highcharts.Chart#hoverPoint\n       * @type {Highcharts.Point|null}\n       */\n      chart.hoverPoint = hoverPoint;\n      /**\n       * Hover state should not be lost when axis is updated (#12569)\n       * Axis.update runs pointer.reset which uses chart.hoverPoint.state\n       * to apply state which does not exist in hoverPoint yet.\n       * The mouseOver event should be triggered when hoverPoint\n       * is correct.\n       */\n      hoverPoint.firePointEvent('mouseOver', void 0, () => {\n        // Draw tooltip if necessary\n        if (tooltip && hoverPoint) {\n          tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);\n        }\n      });\n      // Update positions (regardless of kdpoint or hoverPoint)\n    } else if (followPointer && tooltip && !tooltip.isHidden) {\n      const anchor = tooltip.getAnchor([{}], e);\n      if (chart.isInsidePlot(anchor[0], anchor[1], {\n        visiblePlotOnly: true\n      })) {\n        tooltip.updatePosition({\n          plotX: anchor[0],\n          plotY: anchor[1]\n        });\n      }\n    }\n    // Start the event listener to pick up the tooltip and crosshairs\n    if (!pointer.unDocMouseMove) {\n      pointer.unDocMouseMove = addEvent(chart.container.ownerDocument, 'mousemove', function (e) {\n        const chart = charts[Pointer.hoverChartIndex];\n        if (chart) {\n          chart.pointer.onDocumentMouseMove(e);\n        }\n      });\n      pointer.eventsToUnbind.push(pointer.unDocMouseMove);\n    }\n    // Issues related to crosshair #4927, #5269 #5066, #5658\n    chart.axes.forEach(function drawAxisCrosshair(axis) {\n      const snap = pick((axis.crosshair || {}).snap, true);\n      let point;\n      if (snap) {\n        point = chart.hoverPoint; // #13002\n        if (!point || point.series[axis.coll] !== axis) {\n          point = find(points, p => p.series && p.series[axis.coll] === axis);\n        }\n      }\n      // Axis has snapping crosshairs, and one of the hover points belongs\n      // to axis. Always call drawCrosshair when it is not snap.\n      if (point || !snap) {\n        axis.drawCrosshair(e, point);\n        // Axis has snapping crosshairs, but no hover point belongs to axis\n      } else {\n        axis.hideCrosshair();\n      }\n    });\n  }\n  /**\n   * Scale series groups to a certain scale and translation.\n   * @private\n   * @function Highcharts.Pointer#scaleGroups\n   */\n  scaleGroups(attribs, clip) {\n    const chart = this.chart;\n    // Scale each series\n    chart.series.forEach(function (series) {\n      const seriesAttribs = attribs || series.getPlotBox('series'); // #1701 and #19217\n      if (series.group && (series.xAxis && series.xAxis.zoomEnabled || chart.mapView)) {\n        series.group.attr(seriesAttribs);\n        if (series.markerGroup) {\n          series.markerGroup.attr(\n          // #20018\n          attribs || series.getPlotBox('marker'));\n          series.markerGroup.clip(clip ? chart.clipRect : null);\n        }\n        if (series.dataLabelsGroup) {\n          series.dataLabelsGroup.attr(seriesAttribs);\n        }\n      }\n    });\n    // Clip\n    chart.clipRect.attr(clip || chart.clipBox);\n  }\n  /**\n   * Set the JS DOM events on the container and document. This method should\n   * contain a one-to-one assignment between methods and their handlers. Any\n   * advanced logic should be moved to the handler reflecting the event's\n   * name.\n   * @private\n   * @function Highcharts.Pointer#setDOMEvents\n   */\n  setDOMEvents() {\n    const container = this.chart.container,\n      ownerDoc = container.ownerDocument;\n    container.onmousedown = this.onContainerMouseDown.bind(this);\n    container.onmousemove = this.onContainerMouseMove.bind(this);\n    container.onclick = this.onContainerClick.bind(this);\n    this.eventsToUnbind.push(addEvent(container, 'mouseenter', this.onContainerMouseEnter.bind(this)));\n    this.eventsToUnbind.push(addEvent(container, 'mouseleave', this.onContainerMouseLeave.bind(this)));\n    if (!Pointer.unbindDocumentMouseUp) {\n      Pointer.unbindDocumentMouseUp = addEvent(ownerDoc, 'mouseup', this.onDocumentMouseUp.bind(this));\n    }\n    // In case we are dealing with overflow, reset the chart position when\n    // scrolling parent elements\n    let parent = this.chart.renderTo.parentElement;\n    while (parent && parent.tagName !== 'BODY') {\n      this.eventsToUnbind.push(addEvent(parent, 'scroll', () => {\n        delete this.chartPosition;\n      }));\n      parent = parent.parentElement;\n    }\n    if (H.hasTouch) {\n      this.eventsToUnbind.push(addEvent(container, 'touchstart', this.onContainerTouchStart.bind(this), {\n        passive: false\n      }));\n      this.eventsToUnbind.push(addEvent(container, 'touchmove', this.onContainerTouchMove.bind(this), {\n        passive: false\n      }));\n      if (!Pointer.unbindDocumentTouchEnd) {\n        Pointer.unbindDocumentTouchEnd = addEvent(ownerDoc, 'touchend', this.onDocumentTouchEnd.bind(this), {\n          passive: false\n        });\n      }\n    }\n  }\n  /**\n   * Sets the index of the hovered chart and leaves the previous hovered\n   * chart, to reset states like tooltip.\n   * @private\n   * @function Highcharts.Pointer#setHoverChartIndex\n   */\n  setHoverChartIndex(e) {\n    const chart = this.chart;\n    const hoverChart = H.charts[pick(Pointer.hoverChartIndex, -1)];\n    if (hoverChart && hoverChart !== chart) {\n      hoverChart.pointer.onContainerMouseLeave(e || {\n        relatedTarget: chart.container\n      });\n    }\n    if (!hoverChart || !hoverChart.mouseIsDown) {\n      Pointer.hoverChartIndex = chart.index;\n    }\n  }\n  /**\n   * General touch handler shared by touchstart and touchmove.\n   * @private\n   * @function Highcharts.Pointer#touch\n   */\n  touch(e, start) {\n    const chart = this.chart;\n    let hasMoved, pinchDown, isInside;\n    this.setHoverChartIndex();\n    if (e.touches.length === 1) {\n      e = this.normalize(e);\n      isInside = chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop, {\n        visiblePlotOnly: true\n      });\n      if (isInside && !chart.openMenu) {\n        // Run mouse events and display tooltip etc\n        if (start) {\n          this.runPointActions(e);\n        }\n        // Android fires touchmove events after the touchstart even if\n        // the finger hasn't moved, or moved only a pixel or two. In iOS\n        // however, the touchmove doesn't fire unless the finger moves\n        // more than ~4px. So we emulate this behaviour in Android by\n        // checking how much it moved, and cancelling on small\n        // distances. #3450.\n        if (e.type === 'touchmove') {\n          pinchDown = this.pinchDown;\n          hasMoved = pinchDown[0] ? Math.sqrt(\n          // #5266\n          Math.pow(pinchDown[0].chartX - e.chartX, 2) + Math.pow(pinchDown[0].chartY - e.chartY, 2)) >= 4 : false;\n        }\n        if (pick(hasMoved, true)) {\n          this.pinch(e);\n        }\n      } else if (start) {\n        // Hide the tooltip on touching outside the plot area (#1203)\n        this.reset();\n      }\n    } else if (e.touches.length === 2) {\n      this.pinch(e);\n    }\n  }\n  /**\n   * Returns true if the chart is set up for zooming by single touch and the\n   * event is capable\n   * @private\n   * @function Highcharts.Pointer#touchSelect\n   */\n  touchSelect(e) {\n    return Boolean(this.chart.zooming.singleTouch && e.touches && e.touches.length === 1);\n  }\n  /**\n   * Resolve the zoomType option, this is reset on all touch start and mouse\n   * down events.\n   * @private\n   * @function Highcharts.Pointer#zoomOption\n   */\n  zoomOption(e) {\n    const chart = this.chart,\n      options = chart.options.chart,\n      inverted = chart.inverted;\n    let zoomType = chart.zooming.type || '',\n      zoomX,\n      zoomY;\n    // Look for the pinchType option\n    if (/touch/.test(e.type)) {\n      zoomType = pick(chart.zooming.pinchType, zoomType);\n    }\n    this.zoomX = zoomX = /x/.test(zoomType);\n    this.zoomY = zoomY = /y/.test(zoomType);\n    this.zoomHor = zoomX && !inverted || zoomY && inverted;\n    this.zoomVert = zoomY && !inverted || zoomX && inverted;\n    this.hasZoom = zoomX || zoomY;\n  }\n}\n/* *\n *\n *  Class Namespace\n *\n * */\n(function (Pointer) {\n  /* *\n   *\n   *  Declarations\n   *\n   * */\n  /* *\n   *\n   *  Constants\n   *\n   * */\n  const composedEvents = [];\n  const composedMembers = [];\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * @private\n   */\n  function compose(ChartClass) {\n    if (U.pushUnique(composedMembers, ChartClass)) {\n      addEvent(ChartClass, 'beforeRender', function () {\n        /**\n         * The Pointer that keeps track of mouse and touch\n         * interaction.\n         *\n         * @memberof Highcharts.Chart\n         * @name pointer\n         * @type {Highcharts.Pointer}\n         * @instance\n         */\n        this.pointer = new Pointer(this, this.options);\n      });\n    }\n  }\n  Pointer.compose = compose;\n  /**\n   * @private\n   */\n  function dissolve() {\n    for (let i = 0, iEnd = composedEvents.length; i < iEnd; ++i) {\n      composedEvents[i]();\n    }\n    composedEvents.length = 0;\n  }\n  Pointer.dissolve = dissolve;\n})(Pointer || (Pointer = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default Pointer;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Chart position and scale.\n *\n * @interface Highcharts.ChartPositionObject\n */ /**\n    * @name Highcharts.ChartPositionObject#left\n    * @type {number}\n    */ /**\n       * @name Highcharts.ChartPositionObject#scaleX\n       * @type {number}\n       */ /**\n          * @name Highcharts.ChartPositionObject#scaleY\n          * @type {number}\n          */ /**\n             * @name Highcharts.ChartPositionObject#top\n             * @type {number}\n             */\n/**\n * One position in relation to an axis.\n *\n * @interface Highcharts.PointerAxisCoordinateObject\n */ /**\n    * Related axis.\n    *\n    * @name Highcharts.PointerAxisCoordinateObject#axis\n    * @type {Highcharts.Axis}\n    */ /**\n       * Axis value.\n       *\n       * @name Highcharts.PointerAxisCoordinateObject#value\n       * @type {number}\n       */\n/**\n * Positions in terms of axis values.\n *\n * @interface Highcharts.PointerAxisCoordinatesObject\n */ /**\n    * Positions on the x-axis.\n    * @name Highcharts.PointerAxisCoordinatesObject#xAxis\n    * @type {Array<Highcharts.PointerAxisCoordinateObject>}\n    */ /**\n       * Positions on the y-axis.\n       * @name Highcharts.PointerAxisCoordinatesObject#yAxis\n       * @type {Array<Highcharts.PointerAxisCoordinateObject>}\n       */\n/**\n * Pointer coordinates.\n *\n * @interface Highcharts.PointerCoordinatesObject\n */ /**\n    * @name Highcharts.PointerCoordinatesObject#chartX\n    * @type {number}\n    */ /**\n       * @name Highcharts.PointerCoordinatesObject#chartY\n       * @type {number}\n       */\n/**\n * A native browser mouse or touch event, extended with position information\n * relative to the {@link Chart.container}.\n *\n * @interface Highcharts.PointerEventObject\n * @extends global.PointerEvent\n */ /**\n    * The X coordinate of the pointer interaction relative to the chart.\n    *\n    * @name Highcharts.PointerEventObject#chartX\n    * @type {number}\n    */ /**\n       * The Y coordinate of the pointer interaction relative to the chart.\n       *\n       * @name Highcharts.PointerEventObject#chartY\n       * @type {number}\n       */\n/**\n * Axis-specific data of a selection.\n *\n * @interface Highcharts.SelectDataObject\n */ /**\n    * The selected Axis.\n    * @name Highcharts.SelectDataObject#axis\n    * @type {Highcharts.Axis}\n    */ /**\n       * The maximum axis value, either automatic or set manually.\n       * @name Highcharts.SelectDataObject#max\n       * @type {number}\n       */ /**\n          * The minimum axis value, either automatic or set manually.\n          * @name Highcharts.SelectDataObject#min\n          * @type {number}\n          */\n/**\n * Object for select events.\n * The primary axes are `xAxis[0]` and `yAxis[0]`. Remember the unit of a\n * datetime axis is milliseconds since 1970-01-01 00:00:00.\n *\n * @interface Highcharts.SelectEventObject\n */ /**\n    * The related browser event.\n    * @name Highcharts.SelectEventObject#originalEvent\n    * @type {global.Event}\n    */ /**\n       * Indicates a reset event to restore default state.\n       * @name Highcharts.SelectEventObject#resetSelection\n       * @type {boolean|undefined}\n       */ /**\n          * Arrays containing the axes of each dimension and each axis' min and max\n          * values.\n          * @name Highcharts.SelectEventObject#xAxis\n          * @type {Array<Highcharts.SelectDataObject>}\n          */ /**\n             * Arrays containing the axes of each dimension and each axis' min and max\n             * values.\n             * @name Highcharts.SelectEventObject#yAxis\n             * @type {Array<Highcharts.SelectDataObject>}\n             */\n''; // keeps doclets above in JS file","map":{"version":3,"names":["Color","parse","color","H","charts","noop","U","addEvent","attr","css","defined","extend","find","fireEvent","isNumber","isObject","objectEach","offset","pick","splat","Pointer","constructor","chart","options","lastValidTouch","pinchDown","runChartClick","eventsToUnbind","hasDragged","init","applyInactiveState","points","activeSeries","series","forEach","item","push","linkedParent","linkedSeries","concat","navigatorSeries","inactiveSeries","indexOf","setState","inactiveOtherPoints","setAllPointsToState","destroy","pointer","unbind","chartCount","unbindDocumentMouseUp","unbindDocumentTouchEnd","clearInterval","tooltipTimeout","_val","prop","getSelectionMarkerAttrs","chartX","chartY","e","args","attrs","shapeType","mouseDownX","mouseDownY","zoomHor","zoomVert","size","x","plotLeft","y","plotTop","width","plotWidth","height","plotHeight","Math","abs","drag","chartOptions","panningEnabled","panning","enabled","panKey","clickedInside","selectionMarker","touch","sqrt","pow","isInsidePlot","visiblePlotOnly","hasCartesianSeries","mapView","zoomX","zoomY","renderer","zIndex","add","styledMode","fill","selectionMarkerFill","setOpacity","get","pan","dragStart","mouseIsDown","type","cancelClick","getSelectionBox","marker","result","drop","hasPinched","selectionData","originalEvent","xAxis","yAxis","runZoom","Boolean","axes","axis","zoomEnabled","min","coll","horiz","minPixelPadding","selectionMin","toValue","selectionMax","max","zoom","animation","index","scaleGroups","container","cursor","_cursor","findNearestKDPoint","shared","closest","sort","p1","p2","isCloserX","distX","isCloser","dist","isAbove","group","s","noSharedTooltip","compareX","findNearestPointBy","point","searchPoint","getChartCoordinatesFromPoint","inverted","shapeArgs","clientX","plotX","plotY","isNode","len","pos","getChartPosition","chartPosition","left","top","scaleX","scaleY","offsetWidth","offsetHeight","getCoordinates","coordinates","isXAxis","value","getHoverData","existingHoverPoint","existingHoverSeries","isDirectTouch","hoverPoints","useExisting","filter","visible","directTouch","enableMouseTracking","hoverSeries","searchSeries","eventArgs","notSticky","stickyTracking","hoverPoint","p","isNull","boosted","boost","getPoint","getPointFromEvent","target","parentNode","onTrackerMouseOut","relatedTarget","inClass","onMouseOut","element","className","elem","elemClassName","parentElement","events","click","setDOMEvents","normalize","touches","ePos","length","changedTouches","pageX","pageY","round","onContainerClick","pEvt","firePointEvent","onContainerMouseDown","isPrimaryButton","buttons","button","isFirefox","onContainerMouseMove","zoomOption","preventDefault","onContainerMouseLeave","hoverChartIndex","reset","onContainerMouseEnter","tooltip","setHoverChartIndex","touchSelect","openMenu","shouldStickOnContact","runPointActions","onDocumentTouchEnd","hoverChart","onContainerTouchMove","onContainerTouchStart","onDocumentMouseMove","onDocumentMouseUp","pinch","self","touchesLength","hasZoom","transform","fireClickEvent","runTrackerClick","clip","followTouchMove","initiated","cancelable","map","call","i","bounds","toPixels","dataMin","dataMax","absMin","absMax","res","plotBox","pinchTranslate","pinchTranslateDirection","forcedScale","xy","XY","sChartXY","wh","plotLeftTop","singleTouch","touch0Start","touch1Start","setScale","touch1Now","scale","touch0Now","clipXY","selectionWH","selectionXY","outOfBounds","scaleKey","transformScale","allowMove","delay","tooltipPoints","isCartesian","refresh","state","crosshair","drawCrosshair","hide","unDocMouseMove","hideCrosshair","hoverX","force","hoverData","followPointer","tooltipOptions","split","useSharedTooltip","isHidden","onMouseOver","anchor","getAnchor","updatePosition","ownerDocument","drawAxisCrosshair","snap","attribs","seriesAttribs","getPlotBox","markerGroup","clipRect","dataLabelsGroup","clipBox","ownerDoc","onmousedown","bind","onmousemove","onclick","parent","renderTo","tagName","hasTouch","passive","start","hasMoved","isInside","zooming","zoomType","test","pinchType","composedEvents","composedMembers","compose","ChartClass","pushUnique","dissolve","iEnd"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Pointer.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport Color from './Color/Color.js';\nconst { parse: color } = Color;\nimport H from './Globals.js';\nconst { charts, noop } = H;\nimport U from './Utilities.js';\nconst { addEvent, attr, css, defined, extend, find, fireEvent, isNumber, isObject, objectEach, offset, pick, splat } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * The mouse and touch tracker object. Each {@link Chart} item has one\n * associated Pointer item that can be accessed from the  {@link Chart.pointer}\n * property.\n *\n * @class\n * @name Highcharts.Pointer\n *\n * @param {Highcharts.Chart} chart\n * The chart instance.\n *\n * @param {Highcharts.Options} options\n * The root options object. The pointer uses options from the chart and tooltip\n * structures.\n */\nclass Pointer {\n    /* *\n     *\n     *  Constructors\n     *\n     * */\n    constructor(chart, options) {\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = false;\n        this.eventsToUnbind = [];\n        this.chart = chart;\n        this.hasDragged = false;\n        this.options = options;\n        this.init(chart, options);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Set inactive state to all series that are not currently hovered,\n     * or, if `inactiveOtherPoints` is set to true, set inactive state to\n     * all points within that series.\n     *\n     * @private\n     * @function Highcharts.Pointer#applyInactiveState\n     *\n     * @param {Array<Highcharts.Point>} points\n     * Currently hovered points\n     */\n    applyInactiveState(points) {\n        let activeSeries = [], series;\n        // Get all active series from the hovered points\n        (points || []).forEach(function (item) {\n            series = item.series;\n            // Include itself\n            activeSeries.push(series);\n            // Include parent series\n            if (series.linkedParent) {\n                activeSeries.push(series.linkedParent);\n            }\n            // Include all child series\n            if (series.linkedSeries) {\n                activeSeries = activeSeries.concat(series.linkedSeries);\n            }\n            // Include navigator series\n            if (series.navigatorSeries) {\n                activeSeries.push(series.navigatorSeries);\n            }\n        });\n        // Now loop over all series, filtering out active series\n        this.chart.series.forEach(function (inactiveSeries) {\n            if (activeSeries.indexOf(inactiveSeries) === -1) {\n                // Inactive series\n                inactiveSeries.setState('inactive', true);\n            }\n            else if (inactiveSeries.options.inactiveOtherPoints) {\n                // Active series, but other points should be inactivated\n                inactiveSeries.setAllPointsToState('inactive');\n            }\n        });\n    }\n    /**\n     * Destroys the Pointer object and disconnects DOM events.\n     *\n     * @function Highcharts.Pointer#destroy\n     */\n    destroy() {\n        const pointer = this;\n        this.eventsToUnbind.forEach((unbind) => unbind());\n        this.eventsToUnbind = [];\n        if (!H.chartCount) {\n            if (Pointer.unbindDocumentMouseUp) {\n                Pointer.unbindDocumentMouseUp = Pointer.unbindDocumentMouseUp();\n            }\n            if (Pointer.unbindDocumentTouchEnd) {\n                Pointer.unbindDocumentTouchEnd = (Pointer.unbindDocumentTouchEnd());\n            }\n        }\n        // memory and CPU leak\n        clearInterval(pointer.tooltipTimeout);\n        objectEach(pointer, function (_val, prop) {\n            pointer[prop] = void 0;\n        });\n    }\n    /**\n     * Calculate attrs for selection marker.\n     * @private\n     * @function Highcharts.Pointer#getSelectionMarkerAttrs\n     * @emits getSelectionMarkerAttrs\n     */\n    getSelectionMarkerAttrs(chartX, chartY) {\n        const e = {\n            args: { chartX, chartY },\n            attrs: {},\n            shapeType: 'rect'\n        };\n        fireEvent(this, 'getSelectionMarkerAttrs', e, (e) => {\n            const { chart, mouseDownX = 0, mouseDownY = 0, zoomHor, zoomVert } = this, attrs = e.attrs;\n            let size;\n            attrs.x = chart.plotLeft;\n            attrs.y = chart.plotTop;\n            attrs.width = zoomHor ? 1 : chart.plotWidth;\n            attrs.height = zoomVert ? 1 : chart.plotHeight;\n            // Adjust the width of the selection marker\n            if (zoomHor) {\n                size = chartX - mouseDownX;\n                attrs.width = Math.abs(size);\n                attrs.x = (size > 0 ? 0 : size) + mouseDownX;\n            }\n            // Adjust the height of the selection marker\n            if (zoomVert) {\n                size = chartY - mouseDownY;\n                attrs.height = Math.abs(size);\n                attrs.y = (size > 0 ? 0 : size) + mouseDownY;\n            }\n        });\n        return e;\n    }\n    /**\n     * Perform a drag operation in response to a mousemove event while the mouse\n     * is down.\n     * @private\n     * @function Highcharts.Pointer#drag\n     */\n    drag(e) {\n        const chart = this.chart, chartOptions = chart.options.chart, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, mouseDownX = (this.mouseDownX || 0), mouseDownY = (this.mouseDownY || 0), panningEnabled = isObject(chartOptions.panning) ?\n            chartOptions.panning && chartOptions.panning.enabled :\n            chartOptions.panning, panKey = (chartOptions.panKey && e[chartOptions.panKey + 'Key']);\n        let chartX = e.chartX, chartY = e.chartY, clickedInside, selectionMarker = this.selectionMarker;\n        // If the device supports both touch and mouse (like IE11), and we are\n        // touch-dragging inside the plot area, don't handle the mouse event.\n        // #4339.\n        if (selectionMarker && selectionMarker.touch) {\n            return;\n        }\n        // If the mouse is outside the plot area, adjust to coordinates\n        // inside to prevent the selection marker from going outside\n        if (chartX < plotLeft) {\n            chartX = plotLeft;\n        }\n        else if (chartX > plotLeft + plotWidth) {\n            chartX = plotLeft + plotWidth;\n        }\n        if (chartY < plotTop) {\n            chartY = plotTop;\n        }\n        else if (chartY > plotTop + plotHeight) {\n            chartY = plotTop + plotHeight;\n        }\n        // determine if the mouse has moved more than 10px\n        this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) +\n            Math.pow(mouseDownY - chartY, 2));\n        if (this.hasDragged > 10) {\n            clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop, {\n                visiblePlotOnly: true\n            });\n            const { shapeType, attrs } = this.getSelectionMarkerAttrs(chartX, chartY);\n            // make a selection\n            if ((chart.hasCartesianSeries || chart.mapView) &&\n                (this.zoomX || this.zoomY) &&\n                clickedInside &&\n                !panKey) {\n                if (!selectionMarker) {\n                    this.selectionMarker = selectionMarker =\n                        chart.renderer[shapeType]();\n                    selectionMarker\n                        .attr({\n                        'class': 'highcharts-selection-marker',\n                        zIndex: 7\n                    })\n                        .add();\n                    if (!chart.styledMode) {\n                        selectionMarker.attr({\n                            fill: chartOptions.selectionMarkerFill ||\n                                color(\"#334eff\" /* Palette.highlightColor80 */)\n                                    .setOpacity(0.25).get()\n                        });\n                    }\n                }\n            }\n            if (selectionMarker) {\n                selectionMarker.attr(attrs);\n            }\n            // panning\n            if (clickedInside &&\n                !selectionMarker &&\n                panningEnabled) {\n                chart.pan(e, chartOptions.panning);\n            }\n        }\n    }\n    /**\n     * Start a drag operation.\n     * @private\n     * @function Highcharts.Pointer#dragStart\n     */\n    dragStart(e) {\n        const chart = this.chart;\n        // Record the start position\n        chart.mouseIsDown = e.type;\n        chart.cancelClick = false;\n        chart.mouseDownX = this.mouseDownX = e.chartX;\n        chart.mouseDownY = this.mouseDownY = e.chartY;\n    }\n    /**\n     * Get selection box to calculate extremes\n     * @private\n     * @function Highcharts.Pointer#getSelectionBox\n     * @emits getSelectionBox\n     */\n    getSelectionBox(marker) {\n        const e = {\n            args: { marker },\n            result: {}\n        };\n        fireEvent(this, 'getSelectionBox', e, (e) => {\n            e.result = {\n                x: marker.attr ? +marker.attr('x') : marker.x,\n                y: marker.attr ? +marker.attr('y') : marker.y,\n                width: marker.attr ? marker.attr('width') : marker.width,\n                height: marker.attr ? marker.attr('height') : marker.height\n            };\n        });\n        return e.result;\n    }\n    /**\n     * On mouse up or touch end across the entire document, drop the selection.\n     * @private\n     * @function Highcharts.Pointer#drop\n     */\n    drop(e) {\n        const pointer = this, chart = this.chart, hasPinched = this.hasPinched;\n        if (this.selectionMarker) {\n            const { x, y, width, height } = this.getSelectionBox(this.selectionMarker);\n            const selectionData = {\n                originalEvent: e,\n                xAxis: [],\n                yAxis: [],\n                x,\n                y,\n                width,\n                height\n            };\n            // Start by false runZoom, unless when we have a mapView, in\n            // which case the zoom will be handled in the selection event.\n            let runZoom = Boolean(chart.mapView);\n            // a selection has been made\n            if (this.hasDragged || hasPinched) {\n                // record each axis' min and max\n                chart.axes.forEach(function (axis) {\n                    if (axis.zoomEnabled &&\n                        defined(axis.min) &&\n                        (hasPinched ||\n                            pointer[{\n                                xAxis: 'zoomX',\n                                yAxis: 'zoomY'\n                            }[axis.coll]]) &&\n                        isNumber(x) &&\n                        isNumber(y) &&\n                        isNumber(width) &&\n                        isNumber(height)) { // #859, #3569\n                        const horiz = axis.horiz, minPixelPadding = e.type === 'touchend' ?\n                            axis.minPixelPadding :\n                            0, // #1207, #3075\n                        selectionMin = axis.toValue((horiz ? x : y) + minPixelPadding), selectionMax = axis.toValue((horiz ? x + width : y + height) -\n                            minPixelPadding);\n                        selectionData[axis.coll].push({\n                            axis: axis,\n                            // Min/max for reversed axes\n                            min: Math.min(selectionMin, selectionMax),\n                            max: Math.max(selectionMin, selectionMax)\n                        });\n                        runZoom = true;\n                    }\n                });\n                if (runZoom) {\n                    fireEvent(chart, 'selection', selectionData, function (args) {\n                        chart.zoom(extend(args, hasPinched ?\n                            { animation: false } :\n                            null));\n                    });\n                }\n            }\n            if (isNumber(chart.index)) {\n                this.selectionMarker = this.selectionMarker.destroy();\n            }\n            // Reset scaling preview\n            if (hasPinched) {\n                this.scaleGroups();\n            }\n        }\n        // Reset all. Check isNumber because it may be destroyed on mouse up\n        // (#877)\n        if (chart && isNumber(chart.index)) {\n            css(chart.container, { cursor: chart._cursor });\n            chart.cancelClick = +this.hasDragged > 10; // #370\n            chart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n            this.pinchDown = [];\n        }\n    }\n    /**\n     * Finds the closest point to a set of coordinates, using the k-d-tree\n     * algorithm.\n     *\n     * @function Highcharts.Pointer#findNearestKDPoint\n     *\n     * @param {Array<Highcharts.Series>} series\n     * All the series to search in.\n     *\n     * @param {boolean|undefined} shared\n     * Whether it is a shared tooltip or not.\n     *\n     * @param {Highcharts.PointerEventObject} e\n     * The pointer event object, containing chart coordinates of the pointer.\n     *\n     * @return {Highcharts.Point|undefined}\n     * The point closest to given coordinates.\n     */\n    findNearestKDPoint(series, shared, e) {\n        let closest;\n        /** @private */\n        function sort(p1, p2) {\n            const isCloserX = p1.distX - p2.distX, isCloser = p1.dist - p2.dist, isAbove = ((p2.series.group && p2.series.group.zIndex) -\n                (p1.series.group && p1.series.group.zIndex));\n            let result;\n            // We have two points which are not in the same place on xAxis\n            // and shared tooltip:\n            if (isCloserX !== 0 && shared) { // #5721\n                result = isCloserX;\n                // Points are not exactly in the same place on x/yAxis:\n            }\n            else if (isCloser !== 0) {\n                result = isCloser;\n                // The same xAxis and yAxis position, sort by z-index:\n            }\n            else if (isAbove !== 0) {\n                result = isAbove;\n                // The same zIndex, sort by array index:\n            }\n            else {\n                result =\n                    p1.series.index > p2.series.index ?\n                        -1 :\n                        1;\n            }\n            return result;\n        }\n        series.forEach(function (s) {\n            const noSharedTooltip = s.noSharedTooltip && shared, compareX = (!noSharedTooltip &&\n                s.options.findNearestPointBy.indexOf('y') < 0), point = s.searchPoint(e, compareX);\n            if ( // Check that we actually found a point on the series.\n            isObject(point, true) && point.series &&\n                // Use the new point if it is closer.\n                (!isObject(closest, true) ||\n                    (sort(closest, point) > 0))) {\n                closest = point;\n            }\n        });\n        return closest;\n    }\n    /**\n     * @private\n     * @function Highcharts.Pointer#getChartCoordinatesFromPoint\n     */\n    getChartCoordinatesFromPoint(point, inverted) {\n        const series = point.series, xAxis = series.xAxis, yAxis = series.yAxis, shapeArgs = point.shapeArgs;\n        if (xAxis && yAxis) {\n            let x = pick(point.clientX, point.plotX);\n            let y = point.plotY || 0;\n            if (point.isNode &&\n                shapeArgs &&\n                isNumber(shapeArgs.x) &&\n                isNumber(shapeArgs.y)) {\n                x = shapeArgs.x;\n                y = shapeArgs.y;\n            }\n            return inverted ? {\n                chartX: yAxis.len + yAxis.pos - y,\n                chartY: xAxis.len + xAxis.pos - x\n            } : {\n                chartX: x + xAxis.pos,\n                chartY: y + yAxis.pos\n            };\n        }\n        if (shapeArgs && shapeArgs.x && shapeArgs.y) {\n            // E.g. pies do not have axes\n            return {\n                chartX: shapeArgs.x,\n                chartY: shapeArgs.y\n            };\n        }\n    }\n    /**\n     * Return the cached chartPosition if it is available on the Pointer,\n     * otherwise find it. Running offset is quite expensive, so it should be\n     * avoided when we know the chart hasn't moved.\n     *\n     * @function Highcharts.Pointer#getChartPosition\n     *\n     * @return {Highcharts.ChartPositionObject}\n     * The offset of the chart container within the page\n     */\n    getChartPosition() {\n        if (this.chartPosition) {\n            return this.chartPosition;\n        }\n        const { container } = this.chart;\n        const pos = offset(container);\n        this.chartPosition = {\n            left: pos.left,\n            top: pos.top,\n            scaleX: 1,\n            scaleY: 1\n        };\n        const offsetWidth = container.offsetWidth;\n        const offsetHeight = container.offsetHeight;\n        // #13342 - tooltip was not visible in Chrome, when chart\n        // updates height.\n        if (offsetWidth > 2 && // #13342\n            offsetHeight > 2 // #13342\n        ) {\n            this.chartPosition.scaleX = pos.width / offsetWidth;\n            this.chartPosition.scaleY = pos.height / offsetHeight;\n        }\n        return this.chartPosition;\n    }\n    /**\n     * Get the click position in terms of axis values.\n     *\n     * @function Highcharts.Pointer#getCoordinates\n     *\n     * @param {Highcharts.PointerEventObject} e\n     * Pointer event, extended with `chartX` and `chartY` properties.\n     *\n     * @return {Highcharts.PointerAxisCoordinatesObject}\n     * Axis coordinates.\n     */\n    getCoordinates(e) {\n        const coordinates = {\n            xAxis: [],\n            yAxis: []\n        };\n        this.chart.axes.forEach(function (axis) {\n            coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n                axis: axis,\n                value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n            });\n        });\n        return coordinates;\n    }\n    /**\n     * Calculates what is the current hovered point/points and series.\n     *\n     * @private\n     * @function Highcharts.Pointer#getHoverData\n     *\n     * @param {Highcharts.Point|undefined} existingHoverPoint\n     * The point currently being hovered.\n     *\n     * @param {Highcharts.Series|undefined} existingHoverSeries\n     * The series currently being hovered.\n     *\n     * @param {Array<Highcharts.Series>} series\n     * All the series in the chart.\n     *\n     * @param {boolean} isDirectTouch\n     * Is the pointer directly hovering the point.\n     *\n     * @param {boolean|undefined} shared\n     * Whether it is a shared tooltip or not.\n     *\n     * @param {Highcharts.PointerEventObject} [e]\n     * The triggering event, containing chart coordinates of the pointer.\n     *\n     * @return {Object}\n     * Object containing resulting hover data: hoverPoint, hoverSeries, and\n     * hoverPoints.\n     */\n    getHoverData(existingHoverPoint, existingHoverSeries, series, isDirectTouch, shared, e) {\n        const hoverPoints = [], useExisting = !!(isDirectTouch && existingHoverPoint), filter = function (s) {\n            return (s.visible &&\n                !(!shared && s.directTouch) && // #3821\n                pick(s.options.enableMouseTracking, true));\n        };\n        let hoverSeries = existingHoverSeries, \n        // Which series to look in for the hover point\n        searchSeries, \n        // Parameters needed for beforeGetHoverData event.\n        eventArgs = {\n            chartX: e ? e.chartX : void 0,\n            chartY: e ? e.chartY : void 0,\n            shared: shared\n        };\n        // Find chart.hoverPane and update filter method in polar.\n        fireEvent(this, 'beforeGetHoverData', eventArgs);\n        const notSticky = hoverSeries && !hoverSeries.stickyTracking;\n        searchSeries = notSticky ?\n            // Only search on hovered series if it has stickyTracking false\n            [hoverSeries] :\n            // Filter what series to look in.\n            series.filter((s) => s.stickyTracking &&\n                (eventArgs.filter || filter)(s));\n        // Use existing hovered point or find the one closest to coordinates.\n        const hoverPoint = useExisting || !e ?\n            existingHoverPoint :\n            this.findNearestKDPoint(searchSeries, shared, e);\n        // Assign hover series\n        hoverSeries = hoverPoint && hoverPoint.series;\n        // If we have a hoverPoint, assign hoverPoints.\n        if (hoverPoint) {\n            // When tooltip is shared, it displays more than one point\n            if (shared && !hoverSeries.noSharedTooltip) {\n                searchSeries = series.filter(function (s) {\n                    return eventArgs.filter ?\n                        eventArgs.filter(s) : filter(s) && !s.noSharedTooltip;\n                });\n                // Get all points with the same x value as the hoverPoint\n                searchSeries.forEach(function (s) {\n                    let point = find(s.points, function (p) {\n                        return p.x === hoverPoint.x && !p.isNull;\n                    });\n                    if (isObject(point)) {\n                        /*\n                        * Boost returns a minimal point. Convert it to a usable\n                        * point for tooltip and states.\n                        */\n                        if (s.boosted && s.boost) {\n                            point = s.boost.getPoint(point);\n                        }\n                        hoverPoints.push(point);\n                    }\n                });\n            }\n            else {\n                hoverPoints.push(hoverPoint);\n            }\n        }\n        // Check whether the hoverPoint is inside pane we are hovering over.\n        eventArgs = { hoverPoint: hoverPoint };\n        fireEvent(this, 'afterGetHoverData', eventArgs);\n        return {\n            hoverPoint: eventArgs.hoverPoint,\n            hoverSeries: hoverSeries,\n            hoverPoints: hoverPoints\n        };\n    }\n    /**\n     * @private\n     * @function Highcharts.Pointer#getPointFromEvent\n     */\n    getPointFromEvent(e) {\n        let target = e.target, point;\n        while (target && !point) {\n            point = target.point;\n            target = target.parentNode;\n        }\n        return point;\n    }\n    /**\n     * @private\n     * @function Highcharts.Pointer#onTrackerMouseOut\n     */\n    onTrackerMouseOut(e) {\n        const chart = this.chart;\n        const relatedTarget = e.relatedTarget;\n        const series = chart.hoverSeries;\n        this.isDirectTouch = false;\n        if (series &&\n            relatedTarget &&\n            !series.stickyTracking &&\n            !this.inClass(relatedTarget, 'highcharts-tooltip') &&\n            (!this.inClass(relatedTarget, 'highcharts-series-' + series.index) || // #2499, #4465, #5553\n                !this.inClass(relatedTarget, 'highcharts-tracker'))) {\n            series.onMouseOut();\n        }\n    }\n    /**\n     * Utility to detect whether an element has, or has a parent with, a\n     * specific class name. Used on detection of tracker objects and on deciding\n     * whether hovering the tooltip should cause the active series to mouse out.\n     *\n     * @function Highcharts.Pointer#inClass\n     *\n     * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element\n     * The element to investigate.\n     *\n     * @param {string} className\n     * The class name to look for.\n     *\n     * @return {boolean|undefined}\n     * True if either the element or one of its parents has the given class\n     * name.\n     */\n    inClass(element, className) {\n        let elem = element, elemClassName;\n        while (elem) {\n            elemClassName = attr(elem, 'class');\n            if (elemClassName) {\n                if (elemClassName.indexOf(className) !== -1) {\n                    return true;\n                }\n                if (elemClassName.indexOf('highcharts-container') !== -1) {\n                    return false;\n                }\n            }\n            elem = elem.parentElement;\n        }\n    }\n    /**\n     * Initialize the Pointer.\n     *\n     * @private\n     * @function Highcharts.Pointer#init\n     *\n     * @param {Highcharts.Chart} chart\n     * The Chart instance.\n     *\n     * @param {Highcharts.Options} options\n     * The root options object. The pointer uses options from the chart and\n     * tooltip structures.\n     */\n    init(chart, options) {\n        // Store references\n        this.options = options;\n        this.chart = chart;\n        // Do we need to handle click on a touch device?\n        this.runChartClick = Boolean(options.chart.events && options.chart.events.click);\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        this.setDOMEvents();\n        fireEvent(this, 'afterInit');\n    }\n    /**\n     * Takes a browser event object and extends it with custom Highcharts\n     * properties `chartX` and `chartY` in order to work on the internal\n     * coordinate system.\n     *\n     * On map charts, the properties `lon` and `lat` are added to the event\n     * object given that the chart has projection information.\n     *\n     * @function Highcharts.Pointer#normalize\n     *\n     * @param {global.MouseEvent|global.PointerEvent|global.TouchEvent} e\n     * Event object in standard browsers.\n     *\n     * @param {Highcharts.OffsetObject} [chartPosition]\n     * Additional chart offset.\n     *\n     * @return {Highcharts.PointerEventObject}\n     * A browser event with extended properties `chartX` and `chartY`.\n     */\n    normalize(e, chartPosition) {\n        const touches = e.touches;\n        // iOS (#2757)\n        const ePos = (touches ?\n            touches.length ?\n                touches.item(0) :\n                (pick(// #13534\n                touches.changedTouches, e.changedTouches))[0] :\n            e);\n        // Get mouse position\n        if (!chartPosition) {\n            chartPosition = this.getChartPosition();\n        }\n        let chartX = ePos.pageX - chartPosition.left, chartY = ePos.pageY - chartPosition.top;\n        // #11329 - when there is scaling on a parent element, we need to take\n        // this into account\n        chartX /= chartPosition.scaleX;\n        chartY /= chartPosition.scaleY;\n        return extend(e, {\n            chartX: Math.round(chartX),\n            chartY: Math.round(chartY)\n        });\n    }\n    /**\n     * @private\n     * @function Highcharts.Pointer#onContainerClick\n     */\n    onContainerClick(e) {\n        const chart = this.chart;\n        const hoverPoint = chart.hoverPoint;\n        const pEvt = this.normalize(e);\n        const plotLeft = chart.plotLeft;\n        const plotTop = chart.plotTop;\n        if (!chart.cancelClick) {\n            // On tracker click, fire the series and point events. #783, #1583\n            if (hoverPoint &&\n                this.inClass(pEvt.target, 'highcharts-tracker')) {\n                // the series click event\n                fireEvent(hoverPoint.series, 'click', extend(pEvt, {\n                    point: hoverPoint\n                }));\n                // the point click event\n                if (chart.hoverPoint) { // it may be destroyed (#1844)\n                    hoverPoint.firePointEvent('click', pEvt);\n                }\n                // When clicking outside a tracker, fire a chart event\n            }\n            else {\n                extend(pEvt, this.getCoordinates(pEvt));\n                // fire a click event in the chart\n                if (chart.isInsidePlot(pEvt.chartX - plotLeft, pEvt.chartY - plotTop, {\n                    visiblePlotOnly: true\n                })) {\n                    fireEvent(chart, 'click', pEvt);\n                }\n            }\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.Pointer#onContainerMouseDown\n     */\n    onContainerMouseDown(e) {\n        const isPrimaryButton = ((e.buttons || e.button) & 1) === 1;\n        e = this.normalize(e);\n        // #11635, Firefox does not reliably fire move event after click scroll\n        if (H.isFirefox &&\n            e.button !== 0) {\n            this.onContainerMouseMove(e);\n        }\n        // #11635, limiting to primary button\n        if (typeof e.button === 'undefined' ||\n            isPrimaryButton) {\n            this.zoomOption(e);\n            // #295, #13737 solve conflict between container drag and chart zoom\n            if (isPrimaryButton &&\n                e.preventDefault) {\n                e.preventDefault();\n            }\n            this.dragStart(e);\n        }\n    }\n    /**\n     * When mouse leaves the container, hide the tooltip.\n     * @private\n     * @function Highcharts.Pointer#onContainerMouseLeave\n     */\n    onContainerMouseLeave(e) {\n        const chart = charts[pick(Pointer.hoverChartIndex, -1)];\n        e = this.normalize(e);\n        this.onContainerMouseMove(e);\n        // #4886, MS Touch end fires mouseleave but with no related target\n        if (chart &&\n            e.relatedTarget &&\n            !this.inClass(e.relatedTarget, 'highcharts-tooltip')) {\n            chart.pointer.reset();\n            // Also reset the chart position, used in #149 fix\n            chart.pointer.chartPosition = void 0;\n        }\n    }\n    /**\n     * When mouse enters the container, delete pointer's chartPosition.\n     * @private\n     * @function Highcharts.Pointer#onContainerMouseEnter\n     */\n    onContainerMouseEnter(e) {\n        delete this.chartPosition;\n    }\n    /**\n     * The mousemove, touchmove and touchstart event handler\n     * @private\n     * @function Highcharts.Pointer#onContainerMouseMove\n     */\n    onContainerMouseMove(e) {\n        const chart = this.chart, tooltip = chart.tooltip, pEvt = this.normalize(e);\n        this.setHoverChartIndex(e);\n        if (chart.mouseIsDown === 'mousedown' || this.touchSelect(pEvt)) {\n            this.drag(pEvt);\n        }\n        // Show the tooltip and run mouse over events (#977)\n        if (!chart.openMenu &&\n            (this.inClass(pEvt.target, 'highcharts-tracker') ||\n                chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {\n                    visiblePlotOnly: true\n                })) &&\n            // If the tooltip has stickOnContact enabled, do nothing. This\n            // applies regardless of any combinations of the `split` and\n            // `useHTML` options.\n            !(tooltip &&\n                tooltip.shouldStickOnContact(pEvt))) {\n            if (this.inClass(pEvt.target, 'highcharts-no-tooltip')) {\n                this.reset(false, 0);\n            }\n            else {\n                this.runPointActions(pEvt);\n            }\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.Pointer#onDocumentTouchEnd\n     */\n    onDocumentTouchEnd(e) {\n        const hoverChart = charts[pick(Pointer.hoverChartIndex, -1)];\n        if (hoverChart) {\n            hoverChart.pointer.drop(e);\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.Pointer#onContainerTouchMove\n     */\n    onContainerTouchMove(e) {\n        if (this.touchSelect(e)) {\n            this.onContainerMouseMove(e);\n        }\n        else {\n            this.touch(e);\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.Pointer#onContainerTouchStart\n     */\n    onContainerTouchStart(e) {\n        if (this.touchSelect(e)) {\n            this.onContainerMouseDown(e);\n        }\n        else {\n            this.zoomOption(e);\n            this.touch(e, true);\n        }\n    }\n    /**\n     * Special handler for mouse move that will hide the tooltip when the mouse\n     * leaves the plotarea. Issue #149 workaround. The mouseleave event does not\n     * always fire.\n     * @private\n     * @function Highcharts.Pointer#onDocumentMouseMove\n     */\n    onDocumentMouseMove(e) {\n        const chart = this.chart;\n        const tooltip = chart.tooltip;\n        const chartPosition = this.chartPosition;\n        const pEvt = this.normalize(e, chartPosition);\n        // If we're outside, hide the tooltip\n        if (chartPosition &&\n            !chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {\n                visiblePlotOnly: true\n            }) &&\n            !(tooltip &&\n                tooltip.shouldStickOnContact(pEvt)) &&\n            !this.inClass(pEvt.target, 'highcharts-tracker')) {\n            this.reset();\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.Pointer#onDocumentMouseUp\n     */\n    onDocumentMouseUp(e) {\n        const chart = charts[pick(Pointer.hoverChartIndex, -1)];\n        if (chart) {\n            chart.pointer.drop(e);\n        }\n    }\n    /**\n     * Handle touch events with two touches\n     * @private\n     * @function Highcharts.Pointer#pinch\n     */\n    pinch(e) {\n        const self = this, chart = self.chart, pinchDown = self.pinchDown, touches = (e.touches || []), touchesLength = touches.length, lastValidTouch = self.lastValidTouch, hasZoom = self.hasZoom, transform = {}, fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, 'highcharts-tracker') &&\n            chart.runTrackerClick) ||\n            self.runChartClick), clip = {}, tooltip = self.chart.tooltip, followTouchMove = touchesLength === 1 &&\n            pick((tooltip && tooltip.options.followTouchMove), true);\n        let selectionMarker = self.selectionMarker;\n        // Don't initiate panning until the user has pinched. This prevents us\n        // from blocking page scrolling as users scroll down a long page\n        // (#4210).\n        if (touchesLength > 1) {\n            self.initiated = true;\n        }\n        else if (followTouchMove) {\n            // #16119: Prevent blocking scroll when single-finger panning is\n            // not enabled\n            self.initiated = false;\n        }\n        // On touch devices, only proceed to trigger click if a handler is\n        // defined\n        if (hasZoom &&\n            self.initiated &&\n            !fireClickEvent &&\n            e.cancelable !== false) {\n            e.preventDefault();\n        }\n        // Normalize each touch\n        [].map.call(touches, function (e) {\n            return self.normalize(e);\n        });\n        // Register the touch start position\n        if (e.type === 'touchstart') {\n            [].forEach.call(touches, function (e, i) {\n                pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };\n            });\n            lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] &&\n                    pinchDown[1].chartX];\n            lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] &&\n                    pinchDown[1].chartY];\n            // Identify the data bounds in pixels\n            chart.axes.forEach(function (axis) {\n                if (axis.zoomEnabled) {\n                    const bounds = chart.bounds[axis.horiz ? 'h' : 'v'], minPixelPadding = axis.minPixelPadding, min = axis.toPixels(Math.min(pick(axis.options.min, axis.dataMin), axis.dataMin)), max = axis.toPixels(Math.max(pick(axis.options.max, axis.dataMax), axis.dataMax)), absMin = Math.min(min, max), absMax = Math.max(min, max);\n                    // Store the bounds for use in the touchmove handler\n                    bounds.min = Math.min(axis.pos, absMin - minPixelPadding);\n                    bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);\n                }\n            });\n            self.res = true; // reset on next move\n            // Optionally move the tooltip on touchmove\n        }\n        else if (followTouchMove) {\n            this.runPointActions(self.normalize(e));\n            // Event type is touchmove, handle panning and pinching\n        }\n        else if (pinchDown.length) { // can be 0 when releasing, if touchend\n            // fires first\n            fireEvent(chart, 'touchpan', { originalEvent: e }, () => {\n                // Set the marker\n                if (!selectionMarker) {\n                    // @todo It's a mock object, so maybe we need a separate\n                    // interface\n                    self.selectionMarker = selectionMarker = extend({\n                        destroy: noop,\n                        touch: true\n                    }, chart.plotBox);\n                }\n                self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n                self.hasPinched = hasZoom;\n                // Scale and translate the groups to provide visual feedback\n                // during pinching\n                self.scaleGroups(transform, clip);\n            });\n            if (self.res) {\n                self.res = false;\n                this.reset(false, 0);\n            }\n        }\n    }\n    /**\n     * Run translation operations\n     * @private\n     * @function Highcharts.Pointer#pinchTranslate\n     */\n    pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n        if (this.zoomHor) {\n            this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n        }\n        if (this.zoomVert) {\n            this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n        }\n    }\n    /**\n     * Run translation operations for each direction (horizontal and vertical)\n     * independently.\n     * @private\n     * @function Highcharts.Pointer#pinchTranslateDirection\n     */\n    pinchTranslateDirection(horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {\n        const chart = this.chart, xy = horiz ? 'x' : 'y', XY = horiz ? 'X' : 'Y', sChartXY = ('chart' + XY), wh = horiz ? 'width' : 'height', plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')], inverted = chart.inverted, bounds = chart.bounds[horiz ? 'h' : 'v'], singleTouch = pinchDown.length === 1, touch0Start = pinchDown[0][sChartXY], touch1Start = !singleTouch && pinchDown[1][sChartXY], setScale = function () {\n            // Don't zoom if fingers are too close on this axis\n            if (typeof touch1Now === 'number' &&\n                Math.abs(touch0Start - touch1Start) > 20) {\n                scale = forcedScale ||\n                    Math.abs(touch0Now - touch1Now) /\n                        Math.abs(touch0Start - touch1Start);\n            }\n            clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;\n            selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;\n        };\n        let selectionWH, selectionXY, clipXY, scale = forcedScale || 1, touch0Now = touches[0][sChartXY], touch1Now = !singleTouch && touches[1][sChartXY], outOfBounds;\n        // Set the scale, first pass\n        setScale();\n        // The clip position (x or y) is altered if out of bounds, the selection\n        // position is not\n        selectionXY = clipXY;\n        // Out of bounds\n        if (selectionXY < bounds.min) {\n            selectionXY = bounds.min;\n            outOfBounds = true;\n        }\n        else if (selectionXY + selectionWH > bounds.max) {\n            selectionXY = bounds.max - selectionWH;\n            outOfBounds = true;\n        }\n        // Is the chart dragged off its bounds, determined by dataMin and\n        // dataMax?\n        if (outOfBounds) {\n            // Modify the touchNow position in order to create an elastic drag\n            // movement. This indicates to the user that the chart is responsive\n            // but can't be dragged further.\n            touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);\n            if (typeof touch1Now === 'number') {\n                touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);\n            }\n            // Set the scale, second pass to adapt to the modified touchNow\n            // positions\n            setScale();\n        }\n        else {\n            lastValidTouch[xy] = [touch0Now, touch1Now];\n        }\n        // Set geometry for clipping, selection and transformation\n        if (!inverted) {\n            clip[xy] = clipXY - plotLeftTop;\n            clip[wh] = selectionWH;\n        }\n        const scaleKey = inverted ?\n            (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;\n        const transformScale = inverted ? 1 / scale : scale;\n        selectionMarker[wh] = selectionWH;\n        selectionMarker[xy] = selectionXY;\n        // Invert scale if needed (#19217)\n        transform[scaleKey] = scale * (inverted && !horiz ? -1 : 1);\n        transform['translate' + XY] = (transformScale * plotLeftTop) +\n            (touch0Now - (transformScale * touch0Start));\n    }\n    /**\n     * Reset the tracking by hiding the tooltip, the hover series state and the\n     * hover point\n     *\n     * @function Highcharts.Pointer#reset\n     *\n     * @param {boolean} [allowMove]\n     * Instead of destroying the tooltip altogether, allow moving it if\n     * possible.\n     *\n     * @param {number} [delay]\n     */\n    reset(allowMove, delay) {\n        const pointer = this, chart = pointer.chart, hoverSeries = chart.hoverSeries, hoverPoint = chart.hoverPoint, hoverPoints = chart.hoverPoints, tooltip = chart.tooltip, tooltipPoints = tooltip && tooltip.shared ?\n            hoverPoints :\n            hoverPoint;\n        // Check if the points have moved outside the plot area (#1003, #4736,\n        // #5101)\n        if (allowMove && tooltipPoints) {\n            splat(tooltipPoints).forEach(function (point) {\n                if (point.series.isCartesian &&\n                    typeof point.plotX === 'undefined') {\n                    allowMove = false;\n                }\n            });\n        }\n        // Just move the tooltip, #349\n        if (allowMove) {\n            if (tooltip && tooltipPoints && splat(tooltipPoints).length) {\n                tooltip.refresh(tooltipPoints);\n                if (tooltip.shared && hoverPoints) { // #8284\n                    hoverPoints.forEach(function (point) {\n                        point.setState(point.state, true);\n                        if (point.series.isCartesian) {\n                            if (point.series.xAxis.crosshair) {\n                                point.series.xAxis\n                                    .drawCrosshair(null, point);\n                            }\n                            if (point.series.yAxis.crosshair) {\n                                point.series.yAxis\n                                    .drawCrosshair(null, point);\n                            }\n                        }\n                    });\n                }\n                else if (hoverPoint) { // #2500\n                    hoverPoint.setState(hoverPoint.state, true);\n                    chart.axes.forEach(function (axis) {\n                        if (axis.crosshair &&\n                            hoverPoint.series[axis.coll] === axis) {\n                            axis.drawCrosshair(null, hoverPoint);\n                        }\n                    });\n                }\n            }\n            // Full reset\n        }\n        else {\n            if (hoverPoint) {\n                hoverPoint.onMouseOut();\n            }\n            if (hoverPoints) {\n                hoverPoints.forEach(function (point) {\n                    point.setState();\n                });\n            }\n            if (hoverSeries) {\n                hoverSeries.onMouseOut();\n            }\n            if (tooltip) {\n                tooltip.hide(delay);\n            }\n            if (pointer.unDocMouseMove) {\n                pointer.unDocMouseMove = pointer.unDocMouseMove();\n            }\n            // Remove crosshairs\n            chart.axes.forEach(function (axis) {\n                axis.hideCrosshair();\n            });\n            pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;\n        }\n    }\n    /**\n     * With line type charts with a single tracker, get the point closest to the\n     * mouse. Run Point.onMouseOver and display tooltip for the point or points.\n     *\n     * @private\n     * @function Highcharts.Pointer#runPointActions\n     *\n     * @emits Highcharts.Point#event:mouseOut\n     * @emits Highcharts.Point#event:mouseOver\n     */\n    runPointActions(e, p, force) {\n        const pointer = this, chart = pointer.chart, series = chart.series, tooltip = (chart.tooltip && chart.tooltip.options.enabled ?\n            chart.tooltip :\n            void 0), shared = (tooltip ?\n            tooltip.shared :\n            false);\n        let hoverPoint = p || chart.hoverPoint, hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries;\n        const // onMouseOver or already hovering a series with directTouch\n        isDirectTouch = (!e || e.type !== 'touchmove') && (!!p || ((hoverSeries && hoverSeries.directTouch) &&\n            pointer.isDirectTouch)), hoverData = this.getHoverData(hoverPoint, hoverSeries, series, isDirectTouch, shared, e);\n        // Update variables from hoverData.\n        hoverPoint = hoverData.hoverPoint;\n        hoverSeries = hoverData.hoverSeries;\n        const points = hoverData.hoverPoints, followPointer = hoverSeries &&\n            hoverSeries.tooltipOptions.followPointer &&\n            !hoverSeries.tooltipOptions.split, useSharedTooltip = (shared &&\n            hoverSeries &&\n            !hoverSeries.noSharedTooltip);\n        // Refresh tooltip for kdpoint if new hover point or tooltip was hidden\n        // #3926, #4200\n        if (hoverPoint &&\n            (force ||\n                hoverPoint !== chart.hoverPoint ||\n                (tooltip && tooltip.isHidden))) {\n            (chart.hoverPoints || []).forEach(function (p) {\n                if (points.indexOf(p) === -1) {\n                    p.setState();\n                }\n            });\n            // Set normal state to previous series\n            if (chart.hoverSeries !== hoverSeries) {\n                hoverSeries.onMouseOver();\n            }\n            pointer.applyInactiveState(points);\n            // Do mouseover on all points (#3919, #3985, #4410, #5622)\n            (points || []).forEach(function (p) {\n                p.setState('hover');\n            });\n            // If tracking is on series in stead of on each point,\n            // fire mouseOver on hover point. // #4448\n            if (chart.hoverPoint) {\n                chart.hoverPoint.firePointEvent('mouseOut');\n            }\n            // Hover point may have been destroyed in the event handlers (#7127)\n            if (!hoverPoint.series) {\n                return;\n            }\n            /**\n             * Contains all hovered points.\n             *\n             * @name Highcharts.Chart#hoverPoints\n             * @type {Array<Highcharts.Point>|null}\n             */\n            chart.hoverPoints = points;\n            /**\n             * Contains the original hovered point.\n             *\n             * @name Highcharts.Chart#hoverPoint\n             * @type {Highcharts.Point|null}\n             */\n            chart.hoverPoint = hoverPoint;\n            /**\n             * Hover state should not be lost when axis is updated (#12569)\n             * Axis.update runs pointer.reset which uses chart.hoverPoint.state\n             * to apply state which does not exist in hoverPoint yet.\n             * The mouseOver event should be triggered when hoverPoint\n             * is correct.\n             */\n            hoverPoint.firePointEvent('mouseOver', void 0, () => {\n                // Draw tooltip if necessary\n                if (tooltip && hoverPoint) {\n                    tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);\n                }\n            });\n            // Update positions (regardless of kdpoint or hoverPoint)\n        }\n        else if (followPointer && tooltip && !tooltip.isHidden) {\n            const anchor = tooltip.getAnchor([{}], e);\n            if (chart.isInsidePlot(anchor[0], anchor[1], {\n                visiblePlotOnly: true\n            })) {\n                tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });\n            }\n        }\n        // Start the event listener to pick up the tooltip and crosshairs\n        if (!pointer.unDocMouseMove) {\n            pointer.unDocMouseMove = addEvent(chart.container.ownerDocument, 'mousemove', function (e) {\n                const chart = charts[Pointer.hoverChartIndex];\n                if (chart) {\n                    chart.pointer.onDocumentMouseMove(e);\n                }\n            });\n            pointer.eventsToUnbind.push(pointer.unDocMouseMove);\n        }\n        // Issues related to crosshair #4927, #5269 #5066, #5658\n        chart.axes.forEach(function drawAxisCrosshair(axis) {\n            const snap = pick((axis.crosshair || {}).snap, true);\n            let point;\n            if (snap) {\n                point = chart.hoverPoint; // #13002\n                if (!point || point.series[axis.coll] !== axis) {\n                    point = find(points, (p) => p.series && p.series[axis.coll] === axis);\n                }\n            }\n            // Axis has snapping crosshairs, and one of the hover points belongs\n            // to axis. Always call drawCrosshair when it is not snap.\n            if (point || !snap) {\n                axis.drawCrosshair(e, point);\n                // Axis has snapping crosshairs, but no hover point belongs to axis\n            }\n            else {\n                axis.hideCrosshair();\n            }\n        });\n    }\n    /**\n     * Scale series groups to a certain scale and translation.\n     * @private\n     * @function Highcharts.Pointer#scaleGroups\n     */\n    scaleGroups(attribs, clip) {\n        const chart = this.chart;\n        // Scale each series\n        chart.series.forEach(function (series) {\n            const seriesAttribs = attribs || series.getPlotBox('series'); // #1701 and #19217\n            if (series.group &&\n                ((series.xAxis && series.xAxis.zoomEnabled) ||\n                    chart.mapView)) {\n                series.group.attr(seriesAttribs);\n                if (series.markerGroup) {\n                    series.markerGroup.attr(\n                    // #20018\n                    attribs || series.getPlotBox('marker'));\n                    series.markerGroup.clip(clip ? chart.clipRect : null);\n                }\n                if (series.dataLabelsGroup) {\n                    series.dataLabelsGroup.attr(seriesAttribs);\n                }\n            }\n        });\n        // Clip\n        chart.clipRect.attr(clip || chart.clipBox);\n    }\n    /**\n     * Set the JS DOM events on the container and document. This method should\n     * contain a one-to-one assignment between methods and their handlers. Any\n     * advanced logic should be moved to the handler reflecting the event's\n     * name.\n     * @private\n     * @function Highcharts.Pointer#setDOMEvents\n     */\n    setDOMEvents() {\n        const container = this.chart.container, ownerDoc = container.ownerDocument;\n        container.onmousedown = this.onContainerMouseDown.bind(this);\n        container.onmousemove = this.onContainerMouseMove.bind(this);\n        container.onclick = this.onContainerClick.bind(this);\n        this.eventsToUnbind.push(addEvent(container, 'mouseenter', this.onContainerMouseEnter.bind(this)));\n        this.eventsToUnbind.push(addEvent(container, 'mouseleave', this.onContainerMouseLeave.bind(this)));\n        if (!Pointer.unbindDocumentMouseUp) {\n            Pointer.unbindDocumentMouseUp = addEvent(ownerDoc, 'mouseup', this.onDocumentMouseUp.bind(this));\n        }\n        // In case we are dealing with overflow, reset the chart position when\n        // scrolling parent elements\n        let parent = this.chart.renderTo.parentElement;\n        while (parent && parent.tagName !== 'BODY') {\n            this.eventsToUnbind.push(addEvent(parent, 'scroll', () => {\n                delete this.chartPosition;\n            }));\n            parent = parent.parentElement;\n        }\n        if (H.hasTouch) {\n            this.eventsToUnbind.push(addEvent(container, 'touchstart', this.onContainerTouchStart.bind(this), { passive: false }));\n            this.eventsToUnbind.push(addEvent(container, 'touchmove', this.onContainerTouchMove.bind(this), { passive: false }));\n            if (!Pointer.unbindDocumentTouchEnd) {\n                Pointer.unbindDocumentTouchEnd = addEvent(ownerDoc, 'touchend', this.onDocumentTouchEnd.bind(this), { passive: false });\n            }\n        }\n    }\n    /**\n     * Sets the index of the hovered chart and leaves the previous hovered\n     * chart, to reset states like tooltip.\n     * @private\n     * @function Highcharts.Pointer#setHoverChartIndex\n     */\n    setHoverChartIndex(e) {\n        const chart = this.chart;\n        const hoverChart = H.charts[pick(Pointer.hoverChartIndex, -1)];\n        if (hoverChart &&\n            hoverChart !== chart) {\n            hoverChart.pointer.onContainerMouseLeave(e || { relatedTarget: chart.container });\n        }\n        if (!hoverChart ||\n            !hoverChart.mouseIsDown) {\n            Pointer.hoverChartIndex = chart.index;\n        }\n    }\n    /**\n     * General touch handler shared by touchstart and touchmove.\n     * @private\n     * @function Highcharts.Pointer#touch\n     */\n    touch(e, start) {\n        const chart = this.chart;\n        let hasMoved, pinchDown, isInside;\n        this.setHoverChartIndex();\n        if (e.touches.length === 1) {\n            e = this.normalize(e);\n            isInside = chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop, {\n                visiblePlotOnly: true\n            });\n            if (isInside && !chart.openMenu) {\n                // Run mouse events and display tooltip etc\n                if (start) {\n                    this.runPointActions(e);\n                }\n                // Android fires touchmove events after the touchstart even if\n                // the finger hasn't moved, or moved only a pixel or two. In iOS\n                // however, the touchmove doesn't fire unless the finger moves\n                // more than ~4px. So we emulate this behaviour in Android by\n                // checking how much it moved, and cancelling on small\n                // distances. #3450.\n                if (e.type === 'touchmove') {\n                    pinchDown = this.pinchDown;\n                    hasMoved = pinchDown[0] ? Math.sqrt(// #5266\n                    Math.pow(pinchDown[0].chartX - e.chartX, 2) +\n                        Math.pow(pinchDown[0].chartY - e.chartY, 2)) >= 4 : false;\n                }\n                if (pick(hasMoved, true)) {\n                    this.pinch(e);\n                }\n            }\n            else if (start) {\n                // Hide the tooltip on touching outside the plot area (#1203)\n                this.reset();\n            }\n        }\n        else if (e.touches.length === 2) {\n            this.pinch(e);\n        }\n    }\n    /**\n     * Returns true if the chart is set up for zooming by single touch and the\n     * event is capable\n     * @private\n     * @function Highcharts.Pointer#touchSelect\n     */\n    touchSelect(e) {\n        return Boolean(this.chart.zooming.singleTouch &&\n            e.touches &&\n            e.touches.length === 1);\n    }\n    /**\n     * Resolve the zoomType option, this is reset on all touch start and mouse\n     * down events.\n     * @private\n     * @function Highcharts.Pointer#zoomOption\n     */\n    zoomOption(e) {\n        const chart = this.chart, options = chart.options.chart, inverted = chart.inverted;\n        let zoomType = chart.zooming.type || '', zoomX, zoomY;\n        // Look for the pinchType option\n        if (/touch/.test(e.type)) {\n            zoomType = pick(chart.zooming.pinchType, zoomType);\n        }\n        this.zoomX = zoomX = /x/.test(zoomType);\n        this.zoomY = zoomY = /y/.test(zoomType);\n        this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);\n        this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);\n        this.hasZoom = zoomX || zoomY;\n    }\n}\n/* *\n *\n *  Class Namespace\n *\n * */\n(function (Pointer) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Constants\n     *\n     * */\n    const composedEvents = [];\n    const composedMembers = [];\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * @private\n     */\n    function compose(ChartClass) {\n        if (U.pushUnique(composedMembers, ChartClass)) {\n            addEvent(ChartClass, 'beforeRender', function () {\n                /**\n                 * The Pointer that keeps track of mouse and touch\n                 * interaction.\n                 *\n                 * @memberof Highcharts.Chart\n                 * @name pointer\n                 * @type {Highcharts.Pointer}\n                 * @instance\n                 */\n                this.pointer = new Pointer(this, this.options);\n            });\n        }\n    }\n    Pointer.compose = compose;\n    /**\n     * @private\n     */\n    function dissolve() {\n        for (let i = 0, iEnd = composedEvents.length; i < iEnd; ++i) {\n            composedEvents[i]();\n        }\n        composedEvents.length = 0;\n    }\n    Pointer.dissolve = dissolve;\n})(Pointer || (Pointer = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default Pointer;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Chart position and scale.\n *\n * @interface Highcharts.ChartPositionObject\n */ /**\n* @name Highcharts.ChartPositionObject#left\n* @type {number}\n*/ /**\n* @name Highcharts.ChartPositionObject#scaleX\n* @type {number}\n*/ /**\n* @name Highcharts.ChartPositionObject#scaleY\n* @type {number}\n*/ /**\n* @name Highcharts.ChartPositionObject#top\n* @type {number}\n*/\n/**\n * One position in relation to an axis.\n *\n * @interface Highcharts.PointerAxisCoordinateObject\n */ /**\n* Related axis.\n*\n* @name Highcharts.PointerAxisCoordinateObject#axis\n* @type {Highcharts.Axis}\n*/ /**\n* Axis value.\n*\n* @name Highcharts.PointerAxisCoordinateObject#value\n* @type {number}\n*/\n/**\n * Positions in terms of axis values.\n *\n * @interface Highcharts.PointerAxisCoordinatesObject\n */ /**\n* Positions on the x-axis.\n* @name Highcharts.PointerAxisCoordinatesObject#xAxis\n* @type {Array<Highcharts.PointerAxisCoordinateObject>}\n*/ /**\n* Positions on the y-axis.\n* @name Highcharts.PointerAxisCoordinatesObject#yAxis\n* @type {Array<Highcharts.PointerAxisCoordinateObject>}\n*/\n/**\n * Pointer coordinates.\n *\n * @interface Highcharts.PointerCoordinatesObject\n */ /**\n* @name Highcharts.PointerCoordinatesObject#chartX\n* @type {number}\n*/ /**\n* @name Highcharts.PointerCoordinatesObject#chartY\n* @type {number}\n*/\n/**\n * A native browser mouse or touch event, extended with position information\n * relative to the {@link Chart.container}.\n *\n * @interface Highcharts.PointerEventObject\n * @extends global.PointerEvent\n */ /**\n* The X coordinate of the pointer interaction relative to the chart.\n*\n* @name Highcharts.PointerEventObject#chartX\n* @type {number}\n*/ /**\n* The Y coordinate of the pointer interaction relative to the chart.\n*\n* @name Highcharts.PointerEventObject#chartY\n* @type {number}\n*/\n/**\n * Axis-specific data of a selection.\n *\n * @interface Highcharts.SelectDataObject\n */ /**\n* The selected Axis.\n* @name Highcharts.SelectDataObject#axis\n* @type {Highcharts.Axis}\n*/ /**\n* The maximum axis value, either automatic or set manually.\n* @name Highcharts.SelectDataObject#max\n* @type {number}\n*/ /**\n* The minimum axis value, either automatic or set manually.\n* @name Highcharts.SelectDataObject#min\n* @type {number}\n*/\n/**\n * Object for select events.\n * The primary axes are `xAxis[0]` and `yAxis[0]`. Remember the unit of a\n * datetime axis is milliseconds since 1970-01-01 00:00:00.\n *\n * @interface Highcharts.SelectEventObject\n */ /**\n* The related browser event.\n* @name Highcharts.SelectEventObject#originalEvent\n* @type {global.Event}\n*/ /**\n* Indicates a reset event to restore default state.\n* @name Highcharts.SelectEventObject#resetSelection\n* @type {boolean|undefined}\n*/ /**\n* Arrays containing the axes of each dimension and each axis' min and max\n* values.\n* @name Highcharts.SelectEventObject#xAxis\n* @type {Array<Highcharts.SelectDataObject>}\n*/ /**\n* Arrays containing the axes of each dimension and each axis' min and max\n* values.\n* @name Highcharts.SelectEventObject#yAxis\n* @type {Array<Highcharts.SelectDataObject>}\n*/\n''; // keeps doclets above in JS file\n"],"mappings":"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,MAAMC,eAAe,GAAG,EAAE;EAC1B;AACJ;AACA;AACA;AACA;EACI;AACJ;AACA;EACI,SAASC,OAAOA,CAACC,UAAU,EAAE;IACzB,IAAIjV,CAAC,CAACkV,UAAU,CAACH,eAAe,EAAEE,UAAU,CAAC,EAAE;MAC3ChV,QAAQ,CAACgV,UAAU,EAAE,cAAc,EAAE,YAAY;QAC7C;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;QACgB,IAAI,CAACxS,OAAO,GAAG,IAAI3B,OAAO,CAAC,IAAI,EAAE,IAAI,CAACG,OAAO,CAAC;MAClD,CAAC,CAAC;IACN;EACJ;EACAH,OAAO,CAACkU,OAAO,GAAGA,OAAO;EACzB;AACJ;AACA;EACI,SAASG,QAAQA,CAAA,EAAG;IAChB,KAAK,IAAIrF,CAAC,GAAG,CAAC,EAAEsF,IAAI,GAAGN,cAAc,CAAC7H,MAAM,EAAE6C,CAAC,GAAGsF,IAAI,EAAE,EAAEtF,CAAC,EAAE;MACzDgF,cAAc,CAAChF,CAAC,CAAC,CAAC,CAAC;IACvB;IACAgF,cAAc,CAAC7H,MAAM,GAAG,CAAC;EAC7B;EACAnM,OAAO,CAACqU,QAAQ,GAAGA,QAAQ;AAC/B,CAAC,EAAErU,OAAO,KAAKA,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7B;AACA;AACA;AACA;AACA;AACA,eAAeA,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA,MAHI,CAGD;AACH;AACA;AACA,SAHG,CAGA;AACH;AACA;AACA,YAHG,CAGA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA;AACA;AACA,MALI,CAKD;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA,MAHI,CAGD;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GANA,CAMI;AACJ;AACA;AACA;AACA;AACA,MALI,CAKD;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA,SAJG,CAIA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GANA,CAMI;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA,SAJG,CAIA;AACH;AACA;AACA;AACA;AACA,YALG,CAKA;AACH;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}