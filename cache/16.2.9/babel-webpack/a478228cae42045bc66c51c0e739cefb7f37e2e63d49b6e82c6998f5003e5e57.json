{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst {\n  line: LineSeries\n} = SeriesRegistry.seriesTypes;\nimport U from '../../Core/Utilities.js';\nconst {\n  merge,\n  pick\n} = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * Spline series type.\n *\n * @private\n */\nclass SplineSeries extends LineSeries {\n  constructor() {\n    /* *\n     *\n     *  Static Properties\n     *\n     * */\n    super(...arguments);\n    /* *\n     *\n     *  Properties\n     *\n     * */\n    this.data = void 0;\n    this.options = void 0;\n    this.points = void 0;\n    /* eslint-enable valid-jsdoc */\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Get the spline segment from a given point's previous neighbour to the\n   * given point.\n   *\n   * @private\n   * @function Highcharts.seriesTypes.spline#getPointSpline\n   */\n  getPointSpline(points, point, i) {\n    const\n      // 1 means control points midway between points, 2 means 1/3\n      // from the point, 3 is 1/4 etc\n      smoothing = 1.5,\n      denom = smoothing + 1,\n      plotX = point.plotX || 0,\n      plotY = point.plotY || 0,\n      lastPoint = points[i - 1],\n      nextPoint = points[i + 1];\n    let leftContX, leftContY, rightContX, rightContY;\n    /**\n     * @private\n     */\n    function doCurve(otherPoint) {\n      return otherPoint && !otherPoint.isNull && otherPoint.doCurve !== false &&\n      // #6387, area splines next to null:\n      !point.isCliff;\n    }\n    // Find control points\n    if (doCurve(lastPoint) && doCurve(nextPoint)) {\n      const lastX = lastPoint.plotX || 0,\n        lastY = lastPoint.plotY || 0,\n        nextX = nextPoint.plotX || 0,\n        nextY = nextPoint.plotY || 0;\n      let correction = 0;\n      leftContX = (smoothing * plotX + lastX) / denom;\n      leftContY = (smoothing * plotY + lastY) / denom;\n      rightContX = (smoothing * plotX + nextX) / denom;\n      rightContY = (smoothing * plotY + nextY) / denom;\n      // Have the two control points make a straight line through main\n      // point\n      if (rightContX !== leftContX) {\n        // #5016, division by zero\n        correction = (rightContY - leftContY) * (rightContX - plotX) / (rightContX - leftContX) + plotY - rightContY;\n      }\n      leftContY += correction;\n      rightContY += correction;\n      // to prevent false extremes, check that control points are\n      // between neighbouring points' y values\n      if (leftContY > lastY && leftContY > plotY) {\n        leftContY = Math.max(lastY, plotY);\n        // mirror of left control point\n        rightContY = 2 * plotY - leftContY;\n      } else if (leftContY < lastY && leftContY < plotY) {\n        leftContY = Math.min(lastY, plotY);\n        rightContY = 2 * plotY - leftContY;\n      }\n      if (rightContY > nextY && rightContY > plotY) {\n        rightContY = Math.max(nextY, plotY);\n        leftContY = 2 * plotY - rightContY;\n      } else if (rightContY < nextY && rightContY < plotY) {\n        rightContY = Math.min(nextY, plotY);\n        leftContY = 2 * plotY - rightContY;\n      }\n      // record for drawing in next point\n      point.rightContX = rightContX;\n      point.rightContY = rightContY;\n      // Visualize control points for debugging\n      /*\n      if (leftContX) {\n          this.chart.renderer\n              .circle(\n                  leftContX + this.chart.plotLeft,\n                  leftContY + this.chart.plotTop,\n                  2\n              )\n              .attr({\n                  stroke: 'red',\n                  'stroke-width': 2,\n                  fill: 'none',\n                  zIndex: 9\n              })\n              .add();\n          this.chart.renderer\n              .path([['M', leftContX + this.chart.plotLeft,\n                  leftContY + this.chart.plotTop\n              ], ['L', plotX + this.chart.plotLeft,\n                  plotY + this.chart.plotTop\n              ]])\n              .attr({\n                  stroke: 'red',\n                  'stroke-width': 2,\n                  zIndex: 9\n              })\n              .add();\n      }\n      if (rightContX) {\n          this.chart.renderer\n              .circle(\n                  rightContX + this.chart.plotLeft,\n                  rightContY + this.chart.plotTop,\n                  2\n              )\n              .attr({\n                  stroke: 'green',\n                  'stroke-width': 2,\n                  fill: 'none',\n                  zIndex: 9\n              })\n              .add();\n          this.chart.renderer\n              .path([[\n                  'M', rightContX + this.chart.plotLeft,\n                  rightContY + this.chart.plotTop\n              ], [\n                  'L', plotX + this.chart.plotLeft,\n                  plotY + this.chart.plotTop\n              ]])\n              .attr({\n                  stroke: 'green',\n                  'stroke-width': 2,\n                  zIndex: 9\n              })\n              .add();\n      }\n      // */\n      point.controlPoints = {\n        low: [leftContX, leftContY],\n        high: [rightContX, rightContY]\n      };\n    }\n    const ret = ['C', pick(lastPoint.rightContX, lastPoint.plotX, 0), pick(lastPoint.rightContY, lastPoint.plotY, 0), pick(leftContX, plotX, 0), pick(leftContY, plotY, 0), plotX, plotY];\n    // reset for updating series later\n    lastPoint.rightContX = lastPoint.rightContY = void 0;\n    return ret;\n  }\n}\n/**\n * A spline series is a special type of line series, where the segments\n * between the data points are smoothed.\n *\n * @sample {highcharts} highcharts/demo/spline-irregular-time/\n *         Spline chart\n * @sample {highstock} stock/demo/spline/\n *         Spline chart\n *\n * @extends      plotOptions.series\n * @excluding    step, boostThreshold, boostBlending\n * @product      highcharts highstock\n * @optionparent plotOptions.spline\n */\nSplineSeries.defaultOptions = merge(LineSeries.defaultOptions);\nSeriesRegistry.registerSeriesType('spline', SplineSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default SplineSeries;\n/* *\n *\n *  API Options\n *\n * */\n/**\n * A `spline` series. If the [type](#series.spline.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.spline\n * @excluding dataParser, dataURL, step, boostThreshold, boostBlending\n * @product   highcharts highstock\n * @apioption series.spline\n */\n/**\n * An array of data points for the series. For the `spline` series type,\n * points can be given in the following ways:\n *\n * 1. An array of numerical values. In this case, the numerical values will be\n *    interpreted as `y` options. The `x` values will be automatically\n *    calculated, either starting at 0 and incremented by 1, or from\n *    `pointStart` and `pointInterval` given in the series options. If the axis\n *    has categories, these will be used. Example:\n *    ```js\n *    data: [0, 5, 3, 5]\n *    ```\n *\n * 2. An array of arrays with 2 values. In this case, the values correspond to\n *    `x,y`. If the first value is a string, it is applied as the name of the\n *    point, and the `x` value is inferred.\n *    ```js\n *    data: [\n *        [0, 9],\n *        [1, 2],\n *        [2, 8]\n *    ]\n *    ```\n *\n * 3. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.spline.turboThreshold),\n *    this option is not available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        y: 9,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        y: 0,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n * @extends   series.line.data\n * @product   highcharts highstock\n * @apioption series.spline.data\n */\n''; // adds doclets above intro transpilat","map":{"version":3,"names":["SeriesRegistry","line","LineSeries","seriesTypes","U","merge","pick","SplineSeries","constructor","arguments","data","options","points","getPointSpline","point","i","smoothing","denom","plotX","plotY","lastPoint","nextPoint","leftContX","leftContY","rightContX","rightContY","doCurve","otherPoint","isNull","isCliff","lastX","lastY","nextX","nextY","correction","Math","max","min","controlPoints","low","high","ret","defaultOptions","registerSeriesType"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Series/Spline/SplineSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { line: LineSeries } = SeriesRegistry.seriesTypes;\nimport U from '../../Core/Utilities.js';\nconst { merge, pick } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * Spline series type.\n *\n * @private\n */\nclass SplineSeries extends LineSeries {\n    constructor() {\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        super(...arguments);\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        this.data = void 0;\n        this.options = void 0;\n        this.points = void 0;\n        /* eslint-enable valid-jsdoc */\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Get the spline segment from a given point's previous neighbour to the\n     * given point.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.spline#getPointSpline\n     */\n    getPointSpline(points, point, i) {\n        const \n        // 1 means control points midway between points, 2 means 1/3\n        // from the point, 3 is 1/4 etc\n        smoothing = 1.5, denom = smoothing + 1, plotX = point.plotX || 0, plotY = point.plotY || 0, lastPoint = points[i - 1], nextPoint = points[i + 1];\n        let leftContX, leftContY, rightContX, rightContY;\n        /**\n         * @private\n         */\n        function doCurve(otherPoint) {\n            return otherPoint &&\n                !otherPoint.isNull &&\n                otherPoint.doCurve !== false &&\n                // #6387, area splines next to null:\n                !point.isCliff;\n        }\n        // Find control points\n        if (doCurve(lastPoint) && doCurve(nextPoint)) {\n            const lastX = lastPoint.plotX || 0, lastY = lastPoint.plotY || 0, nextX = nextPoint.plotX || 0, nextY = nextPoint.plotY || 0;\n            let correction = 0;\n            leftContX = (smoothing * plotX + lastX) / denom;\n            leftContY = (smoothing * plotY + lastY) / denom;\n            rightContX = (smoothing * plotX + nextX) / denom;\n            rightContY = (smoothing * plotY + nextY) / denom;\n            // Have the two control points make a straight line through main\n            // point\n            if (rightContX !== leftContX) { // #5016, division by zero\n                correction = (((rightContY - leftContY) *\n                    (rightContX - plotX)) /\n                    (rightContX - leftContX) + plotY - rightContY);\n            }\n            leftContY += correction;\n            rightContY += correction;\n            // to prevent false extremes, check that control points are\n            // between neighbouring points' y values\n            if (leftContY > lastY && leftContY > plotY) {\n                leftContY = Math.max(lastY, plotY);\n                // mirror of left control point\n                rightContY = 2 * plotY - leftContY;\n            }\n            else if (leftContY < lastY && leftContY < plotY) {\n                leftContY = Math.min(lastY, plotY);\n                rightContY = 2 * plotY - leftContY;\n            }\n            if (rightContY > nextY && rightContY > plotY) {\n                rightContY = Math.max(nextY, plotY);\n                leftContY = 2 * plotY - rightContY;\n            }\n            else if (rightContY < nextY && rightContY < plotY) {\n                rightContY = Math.min(nextY, plotY);\n                leftContY = 2 * plotY - rightContY;\n            }\n            // record for drawing in next point\n            point.rightContX = rightContX;\n            point.rightContY = rightContY;\n            // Visualize control points for debugging\n            /*\n            if (leftContX) {\n                this.chart.renderer\n                    .circle(\n                        leftContX + this.chart.plotLeft,\n                        leftContY + this.chart.plotTop,\n                        2\n                    )\n                    .attr({\n                        stroke: 'red',\n                        'stroke-width': 2,\n                        fill: 'none',\n                        zIndex: 9\n                    })\n                    .add();\n                this.chart.renderer\n                    .path([['M', leftContX + this.chart.plotLeft,\n                        leftContY + this.chart.plotTop\n                    ], ['L', plotX + this.chart.plotLeft,\n                        plotY + this.chart.plotTop\n                    ]])\n                    .attr({\n                        stroke: 'red',\n                        'stroke-width': 2,\n                        zIndex: 9\n                    })\n                    .add();\n            }\n            if (rightContX) {\n                this.chart.renderer\n                    .circle(\n                        rightContX + this.chart.plotLeft,\n                        rightContY + this.chart.plotTop,\n                        2\n                    )\n                    .attr({\n                        stroke: 'green',\n                        'stroke-width': 2,\n                        fill: 'none',\n                        zIndex: 9\n                    })\n                    .add();\n                this.chart.renderer\n                    .path([[\n                        'M', rightContX + this.chart.plotLeft,\n                        rightContY + this.chart.plotTop\n                    ], [\n                        'L', plotX + this.chart.plotLeft,\n                        plotY + this.chart.plotTop\n                    ]])\n                    .attr({\n                        stroke: 'green',\n                        'stroke-width': 2,\n                        zIndex: 9\n                    })\n                    .add();\n            }\n            // */\n            point.controlPoints = {\n                low: [leftContX, leftContY],\n                high: [rightContX, rightContY]\n            };\n        }\n        const ret = [\n            'C',\n            pick(lastPoint.rightContX, lastPoint.plotX, 0),\n            pick(lastPoint.rightContY, lastPoint.plotY, 0),\n            pick(leftContX, plotX, 0),\n            pick(leftContY, plotY, 0),\n            plotX,\n            plotY\n        ];\n        // reset for updating series later\n        lastPoint.rightContX = lastPoint.rightContY = void 0;\n        return ret;\n    }\n}\n/**\n * A spline series is a special type of line series, where the segments\n * between the data points are smoothed.\n *\n * @sample {highcharts} highcharts/demo/spline-irregular-time/\n *         Spline chart\n * @sample {highstock} stock/demo/spline/\n *         Spline chart\n *\n * @extends      plotOptions.series\n * @excluding    step, boostThreshold, boostBlending\n * @product      highcharts highstock\n * @optionparent plotOptions.spline\n */\nSplineSeries.defaultOptions = merge(LineSeries.defaultOptions);\nSeriesRegistry.registerSeriesType('spline', SplineSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default SplineSeries;\n/* *\n *\n *  API Options\n *\n * */\n/**\n * A `spline` series. If the [type](#series.spline.type) option is\n * not specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.spline\n * @excluding dataParser, dataURL, step, boostThreshold, boostBlending\n * @product   highcharts highstock\n * @apioption series.spline\n */\n/**\n * An array of data points for the series. For the `spline` series type,\n * points can be given in the following ways:\n *\n * 1. An array of numerical values. In this case, the numerical values will be\n *    interpreted as `y` options. The `x` values will be automatically\n *    calculated, either starting at 0 and incremented by 1, or from\n *    `pointStart` and `pointInterval` given in the series options. If the axis\n *    has categories, these will be used. Example:\n *    ```js\n *    data: [0, 5, 3, 5]\n *    ```\n *\n * 2. An array of arrays with 2 values. In this case, the values correspond to\n *    `x,y`. If the first value is a string, it is applied as the name of the\n *    point, and the `x` value is inferred.\n *    ```js\n *    data: [\n *        [0, 9],\n *        [1, 2],\n *        [2, 8]\n *    ]\n *    ```\n *\n * 3. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.spline.turboThreshold),\n *    this option is not available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        y: 9,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        y: 0,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n * @extends   series.line.data\n * @product   highcharts highstock\n * @apioption series.spline.data\n */\n''; // adds doclets above intro transpilat\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AACZ,OAAOA,cAAc,MAAM,qCAAqC;AAChE,MAAM;EAAEC,IAAI,EAAEC;AAAW,CAAC,GAAGF,cAAc,CAACG,WAAW;AACvD,OAAOC,CAAC,MAAM,yBAAyB;AACvC,MAAM;EAAEC,KAAK;EAAEC;AAAK,CAAC,GAAGF,CAAC;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,YAAY,SAASL,UAAU,CAAC;EAClCM,WAAWA,CAAA,EAAG;IACV;AACR;AACA;AACA;AACA;IACQ,KAAK,CAAC,GAAGC,SAAS,CAAC;IACnB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,IAAI,GAAG,KAAK,CAAC;IAClB,IAAI,CAACC,OAAO,GAAG,KAAK,CAAC;IACrB,IAAI,CAACC,MAAM,GAAG,KAAK,CAAC;IACpB;EACJ;EACA;AACJ;AACA;AACA;AACA;EACI;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,cAAcA,CAACD,MAAM,EAAEE,KAAK,EAAEC,CAAC,EAAE;IAC7B;MACA;MACA;MACAC,SAAS,GAAG,GAAG;MAAEC,KAAK,GAAGD,SAAS,GAAG,CAAC;MAAEE,KAAK,GAAGJ,KAAK,CAACI,KAAK,IAAI,CAAC;MAAEC,KAAK,GAAGL,KAAK,CAACK,KAAK,IAAI,CAAC;MAAEC,SAAS,GAAGR,MAAM,CAACG,CAAC,GAAG,CAAC,CAAC;MAAEM,SAAS,GAAGT,MAAM,CAACG,CAAC,GAAG,CAAC,CAAC;IAChJ,IAAIO,SAAS,EAAEC,SAAS,EAAEC,UAAU,EAAEC,UAAU;IAChD;AACR;AACA;IACQ,SAASC,OAAOA,CAACC,UAAU,EAAE;MACzB,OAAOA,UAAU,IACb,CAACA,UAAU,CAACC,MAAM,IAClBD,UAAU,CAACD,OAAO,KAAK,KAAK;MAC5B;MACA,CAACZ,KAAK,CAACe,OAAO;IACtB;IACA;IACA,IAAIH,OAAO,CAACN,SAAS,CAAC,IAAIM,OAAO,CAACL,SAAS,CAAC,EAAE;MAC1C,MAAMS,KAAK,GAAGV,SAAS,CAACF,KAAK,IAAI,CAAC;QAAEa,KAAK,GAAGX,SAAS,CAACD,KAAK,IAAI,CAAC;QAAEa,KAAK,GAAGX,SAAS,CAACH,KAAK,IAAI,CAAC;QAAEe,KAAK,GAAGZ,SAAS,CAACF,KAAK,IAAI,CAAC;MAC5H,IAAIe,UAAU,GAAG,CAAC;MAClBZ,SAAS,GAAG,CAACN,SAAS,GAAGE,KAAK,GAAGY,KAAK,IAAIb,KAAK;MAC/CM,SAAS,GAAG,CAACP,SAAS,GAAGG,KAAK,GAAGY,KAAK,IAAId,KAAK;MAC/CO,UAAU,GAAG,CAACR,SAAS,GAAGE,KAAK,GAAGc,KAAK,IAAIf,KAAK;MAChDQ,UAAU,GAAG,CAACT,SAAS,GAAGG,KAAK,GAAGc,KAAK,IAAIhB,KAAK;MAChD;MACA;MACA,IAAIO,UAAU,KAAKF,SAAS,EAAE;QAAE;QAC5BY,UAAU,GAAK,CAACT,UAAU,GAAGF,SAAS,KACjCC,UAAU,GAAGN,KAAK,CAAC,IACnBM,UAAU,GAAGF,SAAS,CAAC,GAAGH,KAAK,GAAGM,UAAW;MACtD;MACAF,SAAS,IAAIW,UAAU;MACvBT,UAAU,IAAIS,UAAU;MACxB;MACA;MACA,IAAIX,SAAS,GAAGQ,KAAK,IAAIR,SAAS,GAAGJ,KAAK,EAAE;QACxCI,SAAS,GAAGY,IAAI,CAACC,GAAG,CAACL,KAAK,EAAEZ,KAAK,CAAC;QAClC;QACAM,UAAU,GAAG,CAAC,GAAGN,KAAK,GAAGI,SAAS;MACtC,CAAC,MACI,IAAIA,SAAS,GAAGQ,KAAK,IAAIR,SAAS,GAAGJ,KAAK,EAAE;QAC7CI,SAAS,GAAGY,IAAI,CAACE,GAAG,CAACN,KAAK,EAAEZ,KAAK,CAAC;QAClCM,UAAU,GAAG,CAAC,GAAGN,KAAK,GAAGI,SAAS;MACtC;MACA,IAAIE,UAAU,GAAGQ,KAAK,IAAIR,UAAU,GAAGN,KAAK,EAAE;QAC1CM,UAAU,GAAGU,IAAI,CAACC,GAAG,CAACH,KAAK,EAAEd,KAAK,CAAC;QACnCI,SAAS,GAAG,CAAC,GAAGJ,KAAK,GAAGM,UAAU;MACtC,CAAC,MACI,IAAIA,UAAU,GAAGQ,KAAK,IAAIR,UAAU,GAAGN,KAAK,EAAE;QAC/CM,UAAU,GAAGU,IAAI,CAACE,GAAG,CAACJ,KAAK,EAAEd,KAAK,CAAC;QACnCI,SAAS,GAAG,CAAC,GAAGJ,KAAK,GAAGM,UAAU;MACtC;MACA;MACAX,KAAK,CAACU,UAAU,GAAGA,UAAU;MAC7BV,KAAK,CAACW,UAAU,GAAGA,UAAU;MAC7B;MACA;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACYX,KAAK,CAACwB,aAAa,GAAG;QAClBC,GAAG,EAAE,CAACjB,SAAS,EAAEC,SAAS,CAAC;QAC3BiB,IAAI,EAAE,CAAChB,UAAU,EAAEC,UAAU;MACjC,CAAC;IACL;IACA,MAAMgB,GAAG,GAAG,CACR,GAAG,EACHnC,IAAI,CAACc,SAAS,CAACI,UAAU,EAAEJ,SAAS,CAACF,KAAK,EAAE,CAAC,CAAC,EAC9CZ,IAAI,CAACc,SAAS,CAACK,UAAU,EAAEL,SAAS,CAACD,KAAK,EAAE,CAAC,CAAC,EAC9Cb,IAAI,CAACgB,SAAS,EAAEJ,KAAK,EAAE,CAAC,CAAC,EACzBZ,IAAI,CAACiB,SAAS,EAAEJ,KAAK,EAAE,CAAC,CAAC,EACzBD,KAAK,EACLC,KAAK,CACR;IACD;IACAC,SAAS,CAACI,UAAU,GAAGJ,SAAS,CAACK,UAAU,GAAG,KAAK,CAAC;IACpD,OAAOgB,GAAG;EACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlC,YAAY,CAACmC,cAAc,GAAGrC,KAAK,CAACH,UAAU,CAACwC,cAAc,CAAC;AAC9D1C,cAAc,CAAC2C,kBAAkB,CAAC,QAAQ,EAAEpC,YAAY,CAAC;AACzD;AACA;AACA;AACA;AACA;AACA,eAAeA,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}