{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport A from '../Animation/AnimationUtilities.js';\nconst {\n  animObject\n} = A;\nimport AxisDefaults from './AxisDefaults.js';\nimport Color from '../Color/Color.js';\nimport D from '../Defaults.js';\nconst {\n  defaultOptions\n} = D;\nimport F from '../Foundation.js';\nconst {\n  registerEventOptions\n} = F;\nimport H from '../Globals.js';\nconst {\n  deg2rad\n} = H;\nimport Tick from './Tick.js';\nimport U from '../Utilities.js';\nconst {\n  arrayMax,\n  arrayMin,\n  clamp,\n  correctFloat,\n  defined,\n  destroyObjectProperties,\n  erase,\n  error,\n  extend,\n  fireEvent,\n  getClosestDistance,\n  insertItem,\n  isArray,\n  isNumber,\n  isString,\n  merge,\n  normalizeTickInterval,\n  objectEach,\n  pick,\n  relativeLength,\n  removeEvent,\n  splat,\n  syncTimeout\n} = U;\nconst getNormalizedTickInterval = (axis, tickInterval) => normalizeTickInterval(tickInterval, void 0, void 0, pick(axis.options.allowDecimals,\n// If the tick interval is greather than 0.5, avoid decimals, as\n// linear axes are often used to render discrete values (#3363). If\n// a tick amount is set, allow decimals by default, as it increases\n// the chances for a good fit.\ntickInterval < 0.5 || axis.tickAmount !== void 0), !!axis.tickAmount);\n/* *\n *\n *  Class\n *\n * */\n/**\n * Create a new axis object. Called internally when instanciating a new chart or\n * adding axes by {@link Highcharts.Chart#addAxis}.\n *\n * A chart can have from 0 axes (pie chart) to multiples. In a normal, single\n * series cartesian chart, there is one X axis and one Y axis.\n *\n * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is\n * an array of Axis objects. If there is only one axis, it can be referenced\n * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same\n * pattern goes for Y axes.\n *\n * If you need to get the axes from a series object, use the `series.xAxis` and\n * `series.yAxis` properties. These are not arrays, as one series can only be\n * associated to one X and one Y axis.\n *\n * A third way to reference the axis programmatically is by `id`. Add an `id` in\n * the axis configuration options, and get the axis by\n * {@link Highcharts.Chart#get}.\n *\n * Configuration options for the axes are given in options.xAxis and\n * options.yAxis.\n *\n * @class\n * @name Highcharts.Axis\n *\n * @param {Highcharts.Chart} chart\n * The Chart instance to apply the axis on.\n *\n * @param {Highcharts.AxisOptions} userOptions\n * Axis options\n */\nclass Axis {\n  /* *\n   *\n   *  Constructors\n   *\n   * */\n  constructor(chart, userOptions, coll) {\n    this.alternateBands = void 0;\n    this.bottom = void 0;\n    this.chart = void 0;\n    this.closestPointRange = void 0;\n    this.coll = void 0;\n    this.eventOptions = void 0;\n    this.hasNames = void 0;\n    this.hasVisibleSeries = void 0;\n    this.height = void 0;\n    this.index = void 0;\n    this.isLinked = void 0;\n    this.labelEdge = void 0; // @todo\n    this.labelFormatter = void 0;\n    this.left = void 0;\n    this.len = void 0;\n    this.max = void 0;\n    this.maxLabelLength = void 0;\n    this.min = void 0;\n    this.minorTickInterval = void 0;\n    this.minorTicks = void 0;\n    this.minPixelPadding = void 0;\n    this.names = void 0;\n    this.offset = void 0;\n    this.options = void 0;\n    this.overlap = void 0;\n    this.paddedTicks = void 0;\n    this.plotLinesAndBands = void 0;\n    this.plotLinesAndBandsGroups = void 0;\n    this.pointRange = void 0;\n    this.pointRangePadding = void 0;\n    this.pos = void 0;\n    this.positiveValuesOnly = void 0;\n    this.right = void 0;\n    this.series = void 0;\n    this.side = void 0;\n    this.tickAmount = void 0;\n    this.tickInterval = void 0;\n    this.tickmarkOffset = void 0;\n    this.tickPositions = void 0;\n    this.tickRotCorr = void 0;\n    this.ticks = void 0;\n    this.top = void 0;\n    this.transA = void 0;\n    this.transB = void 0;\n    this.translationSlope = void 0;\n    this.userOptions = void 0;\n    this.visible = void 0;\n    this.width = void 0;\n    this.zoomEnabled = void 0;\n    this.init(chart, userOptions, coll);\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * Overrideable function to initialize the axis.\n   *\n   * @see {@link Axis}\n   *\n   * @function Highcharts.Axis#init\n   *\n   * @param {Highcharts.Chart} chart\n   * The Chart instance to apply the axis on.\n   *\n   * @param {AxisOptions} userOptions\n   * Axis options.\n   *\n   * @emits Highcharts.Axis#event:afterInit\n   * @emits Highcharts.Axis#event:init\n   */\n  init(chart, userOptions, coll = this.coll) {\n    const isXAxis = coll === 'xAxis',\n      axis = this;\n    /**\n     * The Chart that the axis belongs to.\n     *\n     * @name Highcharts.Axis#chart\n     * @type {Highcharts.Chart}\n     */\n    axis.chart = chart;\n    /**\n     * Whether the axis is horizontal.\n     *\n     * @name Highcharts.Axis#horiz\n     * @type {boolean|undefined}\n     */\n    axis.horiz = axis.isZAxis || (chart.inverted ? !isXAxis : isXAxis);\n    /**\n     * Whether the axis is the x-axis.\n     *\n     * @name Highcharts.Axis#isXAxis\n     * @type {boolean|undefined}\n     */\n    axis.isXAxis = isXAxis;\n    /**\n     * The collection where the axis belongs, for example `xAxis`, `yAxis`\n     * or `colorAxis`. Corresponds to properties on Chart, for example\n     * {@link Chart.xAxis}.\n     *\n     * @name Highcharts.Axis#coll\n     * @type {string}\n     */\n    axis.coll = coll;\n    fireEvent(this, 'init', {\n      userOptions: userOptions\n    });\n    // Needed in setOptions\n    axis.opposite = pick(userOptions.opposite, axis.opposite);\n    /**\n     * The side on which the axis is rendered. 0 is top, 1 is right, 2\n     * is bottom and 3 is left.\n     *\n     * @name Highcharts.Axis#side\n     * @type {number}\n     */\n    axis.side = pick(userOptions.side, axis.side, axis.horiz ? axis.opposite ? 0 : 2 :\n    // top : bottom\n    axis.opposite ? 1 : 3 // right : left\n    );\n    /**\n     * Current options for the axis after merge of defaults and user's\n     * options.\n     *\n     * @name Highcharts.Axis#options\n     * @type {Highcharts.AxisOptions}\n     */\n    axis.setOptions(userOptions);\n    const options = this.options,\n      labelsOptions = options.labels,\n      type = options.type;\n    /**\n     * User's options for this axis without defaults.\n     *\n     * @name Highcharts.Axis#userOptions\n     * @type {Highcharts.AxisOptions}\n     */\n    axis.userOptions = userOptions;\n    axis.minPixelPadding = 0;\n    /**\n     * Whether the axis is reversed. Based on the `axis.reversed`,\n     * option, but inverted charts have reversed xAxis by default.\n     *\n     * @name Highcharts.Axis#reversed\n     * @type {boolean}\n     */\n    axis.reversed = pick(options.reversed, axis.reversed);\n    axis.visible = options.visible;\n    axis.zoomEnabled = options.zoomEnabled;\n    // Initial categories\n    axis.hasNames = type === 'category' || options.categories === true;\n    /**\n     * If categories are present for the axis, names are used instead of\n     * numbers for that axis.\n     *\n     * Since Highcharts 3.0, categories can also be extracted by giving each\n     * point a name and setting axis type to `category`. However, if you\n     * have multiple series, best practice remains defining the `categories`\n     * array.\n     *\n     * @see [xAxis.categories](/highcharts/xAxis.categories)\n     *\n     * @name Highcharts.Axis#categories\n     * @type {Array<string>}\n     * @readonly\n     */\n    axis.categories = options.categories || (axis.hasNames ? [] : void 0);\n    if (!axis.names) {\n      // Preserve on update (#3830)\n      axis.names = [];\n      axis.names.keys = {};\n    }\n    // Placeholder for plotlines and plotbands groups\n    axis.plotLinesAndBandsGroups = {};\n    // Shorthand types\n    axis.positiveValuesOnly = !!axis.logarithmic;\n    // Flag, if axis is linked to another axis\n    axis.isLinked = defined(options.linkedTo);\n    /**\n     * List of major ticks mapped by postition on axis.\n     *\n     * @see {@link Highcharts.Tick}\n     *\n     * @name Highcharts.Axis#ticks\n     * @type {Highcharts.Dictionary<Highcharts.Tick>}\n     */\n    axis.ticks = {};\n    axis.labelEdge = [];\n    /**\n     * List of minor ticks mapped by position on the axis.\n     *\n     * @see {@link Highcharts.Tick}\n     *\n     * @name Highcharts.Axis#minorTicks\n     * @type {Highcharts.Dictionary<Highcharts.Tick>}\n     */\n    axis.minorTicks = {};\n    // List of plotLines/Bands\n    axis.plotLinesAndBands = [];\n    // Alternate bands\n    axis.alternateBands = {};\n    // Axis metrics\n    axis.len = 0;\n    axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n    axis.range = options.range;\n    axis.offset = options.offset || 0;\n    /**\n     * The maximum value of the axis. In a logarithmic axis, this is the\n     * logarithm of the real value, and the real value can be obtained from\n     * {@link Axis#getExtremes}.\n     *\n     * @name Highcharts.Axis#max\n     * @type {number|null}\n     */\n    axis.max = null;\n    /**\n     * The minimum value of the axis. In a logarithmic axis, this is the\n     * logarithm of the real value, and the real value can be obtained from\n     * {@link Axis#getExtremes}.\n     *\n     * @name Highcharts.Axis#min\n     * @type {number|null}\n     */\n    axis.min = null;\n    /**\n     * The processed crosshair options.\n     *\n     * @name Highcharts.Axis#crosshair\n     * @type {boolean|Highcharts.AxisCrosshairOptions}\n     */\n    const crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1]);\n    axis.crosshair = crosshair === true ? {} : crosshair;\n    // Register. Don't add it again on Axis.update().\n    if (chart.axes.indexOf(axis) === -1) {\n      //\n      if (isXAxis) {\n        // #2713\n        chart.axes.splice(chart.xAxis.length, 0, axis);\n      } else {\n        chart.axes.push(axis);\n      }\n      insertItem(this, chart[this.coll]);\n    }\n    chart.orderItems(axis.coll);\n    /**\n     * All series associated to the axis.\n     *\n     * @name Highcharts.Axis#series\n     * @type {Array<Highcharts.Series>}\n     */\n    axis.series = axis.series || []; // populated by Series\n    // Reversed axis\n    if (chart.inverted && !axis.isZAxis && isXAxis && typeof axis.reversed === 'undefined') {\n      axis.reversed = true;\n    }\n    axis.labelRotation = isNumber(labelsOptions.rotation) ? labelsOptions.rotation : void 0;\n    // Register event listeners\n    registerEventOptions(axis, options);\n    fireEvent(this, 'afterInit');\n  }\n  /**\n   * Merge and set options.\n   *\n   * @private\n   * @function Highcharts.Axis#setOptions\n   *\n   * @param {Highcharts.AxisOptions} userOptions\n   * Axis options.\n   *\n   * @emits Highcharts.Axis#event:afterSetOptions\n   */\n  setOptions(userOptions) {\n    this.options = merge(AxisDefaults.defaultXAxisOptions, this.coll === 'yAxis' && AxisDefaults.defaultYAxisOptions, [AxisDefaults.defaultTopAxisOptions, AxisDefaults.defaultRightAxisOptions, AxisDefaults.defaultBottomAxisOptions, AxisDefaults.defaultLeftAxisOptions][this.side], merge(\n    // if set in setOptions (#1053):\n    defaultOptions[this.coll], userOptions));\n    fireEvent(this, 'afterSetOptions', {\n      userOptions: userOptions\n    });\n  }\n  /**\n   * The default label formatter. The context is a special config object for\n   * the label. In apps, use the\n   * [labels.formatter](https://api.highcharts.com/highcharts/xAxis.labels.formatter)\n   * instead, except when a modification is needed.\n   *\n   * @function Highcharts.Axis#defaultLabelFormatter\n   *\n   * @param {Highcharts.AxisLabelsFormatterContextObject} this\n   * Formatter context of axis label.\n   *\n   * @param {Highcharts.AxisLabelsFormatterContextObject} [ctx]\n   * Formatter context of axis label.\n   *\n   * @return {string}\n   * The formatted label content.\n   */\n  defaultLabelFormatter(ctx) {\n    const axis = this.axis,\n      chart = this.chart,\n      {\n        numberFormatter\n      } = chart,\n      value = isNumber(this.value) ? this.value : NaN,\n      time = axis.chart.time,\n      categories = axis.categories,\n      dateTimeLabelFormat = this.dateTimeLabelFormat,\n      lang = defaultOptions.lang,\n      numericSymbols = lang.numericSymbols,\n      numSymMagnitude = lang.numericSymbolMagnitude || 1000,\n      // make sure the same symbol is added for all labels on a linear\n      // axis\n      numericSymbolDetector = axis.logarithmic ? Math.abs(value) : axis.tickInterval;\n    let i = numericSymbols && numericSymbols.length,\n      multi,\n      ret;\n    if (categories) {\n      ret = `${this.value}`;\n    } else if (dateTimeLabelFormat) {\n      // datetime axis\n      ret = time.dateFormat(dateTimeLabelFormat, value);\n    } else if (i && numericSymbolDetector >= 1000) {\n      // Decide whether we should add a numeric symbol like k (thousands)\n      // or M (millions). If we are to enable this in tooltip or other\n      // places as well, we can move this logic to the numberFormatter and\n      // enable it by a parameter.\n      while (i-- && typeof ret === 'undefined') {\n        multi = Math.pow(numSymMagnitude, i + 1);\n        if (\n        // Only accept a numeric symbol when the distance is more\n        // than a full unit. So for example if the symbol is k, we\n        // don't accept numbers like 0.5k.\n        numericSymbolDetector >= multi &&\n        // Accept one decimal before the symbol. Accepts 0.5k but\n        // not 0.25k. How does this work with the previous?\n        value * 10 % multi === 0 && numericSymbols[i] !== null && value !== 0) {\n          // #5480\n          ret = numberFormatter(value / multi, -1) + numericSymbols[i];\n        }\n      }\n    }\n    if (typeof ret === 'undefined') {\n      if (Math.abs(value) >= 10000) {\n        // add thousands separators\n        ret = numberFormatter(value, -1);\n      } else {\n        // small numbers\n        ret = numberFormatter(value, -1, void 0, ''); // #2466\n      }\n    }\n\n    return ret;\n  }\n  /**\n   * Get the minimum and maximum for the series of each axis. The function\n   * analyzes the axis series and updates `this.dataMin` and `this.dataMax`.\n   *\n   * @private\n   * @function Highcharts.Axis#getSeriesExtremes\n   *\n   * @emits Highcharts.Axis#event:afterGetSeriesExtremes\n   * @emits Highcharts.Axis#event:getSeriesExtremes\n   */\n  getSeriesExtremes() {\n    const axis = this,\n      chart = axis.chart;\n    let xExtremes;\n    fireEvent(this, 'getSeriesExtremes', null, function () {\n      axis.hasVisibleSeries = false;\n      // Reset properties in case we're redrawing (#3353)\n      axis.dataMin = axis.dataMax = axis.threshold = null;\n      axis.softThreshold = !axis.isXAxis;\n      // Loop through this axis' series\n      axis.series.forEach(function (series) {\n        if (series.reserveSpace()) {\n          const seriesOptions = series.options;\n          let xData,\n            threshold = seriesOptions.threshold,\n            seriesDataMin,\n            seriesDataMax;\n          axis.hasVisibleSeries = true;\n          // Validate threshold in logarithmic axes\n          if (axis.positiveValuesOnly && threshold <= 0) {\n            threshold = null;\n          }\n          // Get dataMin and dataMax for X axes\n          if (axis.isXAxis) {\n            xData = series.xData;\n            if (xData && xData.length) {\n              xData = axis.logarithmic ? xData.filter(x => x > 0) : xData;\n              xExtremes = series.getXExtremes(xData);\n              // If xData contains values which is not numbers,\n              // then filter them out. To prevent performance hit,\n              // we only do this after we have already found\n              // seriesDataMin because in most cases all data is\n              // valid. #5234.\n              seriesDataMin = xExtremes.min;\n              seriesDataMax = xExtremes.max;\n              if (!isNumber(seriesDataMin) &&\n              // #5010:\n              !(seriesDataMin instanceof Date)) {\n                xData = xData.filter(isNumber);\n                xExtremes = series.getXExtremes(xData);\n                // Do it again with valid data\n                seriesDataMin = xExtremes.min;\n                seriesDataMax = xExtremes.max;\n              }\n              if (xData.length) {\n                axis.dataMin = Math.min(pick(axis.dataMin, seriesDataMin), seriesDataMin);\n                axis.dataMax = Math.max(pick(axis.dataMax, seriesDataMax), seriesDataMax);\n              }\n            }\n            // Get dataMin and dataMax for Y axes, as well as handle\n            // stacking and processed data\n          } else {\n            // Get this particular series extremes\n            const dataExtremes = series.applyExtremes();\n            // Get the dataMin and dataMax so far. If percentage is\n            // used, the min and max are always 0 and 100. If\n            // seriesDataMin and seriesDataMax is null, then series\n            // doesn't have active y data, we continue with nulls\n            if (isNumber(dataExtremes.dataMin)) {\n              seriesDataMin = dataExtremes.dataMin;\n              axis.dataMin = Math.min(pick(axis.dataMin, seriesDataMin), seriesDataMin);\n            }\n            if (isNumber(dataExtremes.dataMax)) {\n              seriesDataMax = dataExtremes.dataMax;\n              axis.dataMax = Math.max(pick(axis.dataMax, seriesDataMax), seriesDataMax);\n            }\n            // Adjust to threshold\n            if (defined(threshold)) {\n              axis.threshold = threshold;\n            }\n            // If any series has a hard threshold, it takes\n            // precedence\n            if (!seriesOptions.softThreshold || axis.positiveValuesOnly) {\n              axis.softThreshold = false;\n            }\n          }\n        }\n      });\n    });\n    fireEvent(this, 'afterGetSeriesExtremes');\n  }\n  /**\n   * Translate from axis value to pixel position on the chart, or back. Use\n   * the `toPixels` and `toValue` functions in applications.\n   *\n   * @private\n   * @function Highcharts.Axis#translate\n   */\n  translate(val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n    const axis = this.linkedParent || this,\n      // #1417\n      localMin = old && axis.old ? axis.old.min : axis.min;\n    if (!isNumber(localMin)) {\n      return NaN;\n    }\n    const minPixelPadding = axis.minPixelPadding,\n      doPostTranslate = (axis.isOrdinal || axis.brokenAxis && axis.brokenAxis.hasBreaks || axis.logarithmic && handleLog) && axis.lin2val;\n    let sign = 1,\n      cvsOffset = 0,\n      localA = old && axis.old ? axis.old.transA : axis.transA,\n      returnValue = 0;\n    if (!localA) {\n      localA = axis.transA;\n    }\n    // In vertical axes, the canvas coordinates start from 0 at the top like\n    // in SVG.\n    if (cvsCoord) {\n      sign *= -1; // canvas coordinates inverts the value\n      cvsOffset = axis.len;\n    }\n    // Handle reversed axis\n    if (axis.reversed) {\n      sign *= -1;\n      cvsOffset -= sign * (axis.sector || axis.len);\n    }\n    // From pixels to value\n    if (backwards) {\n      // reverse translation\n      val = val * sign + cvsOffset;\n      val -= minPixelPadding;\n      // from chart pixel to value:\n      returnValue = val / localA + localMin;\n      if (doPostTranslate) {\n        // log, ordinal and broken axis\n        returnValue = axis.lin2val(returnValue);\n      }\n      // From value to pixels\n    } else {\n      if (doPostTranslate) {\n        // log, ordinal and broken axis\n        val = axis.val2lin(val);\n      }\n      const value = sign * (val - localMin) * localA;\n      returnValue = (!axis.isRadial ? correctFloat(value) : value) + cvsOffset + sign * minPixelPadding + (isNumber(pointPlacement) ? localA * pointPlacement : 0);\n    }\n    return returnValue;\n  }\n  /**\n   * Translate a value in terms of axis units into pixels within the chart.\n   *\n   * @function Highcharts.Axis#toPixels\n   *\n   * @param {number} value\n   * A value in terms of axis units.\n   *\n   * @param {boolean} paneCoordinates\n   * Whether to return the pixel coordinate relative to the chart or just the\n   * axis/pane itself.\n   *\n   * @return {number}\n   * Pixel position of the value on the chart or axis.\n   */\n  toPixels(value, paneCoordinates) {\n    return this.translate(value, false, !this.horiz, void 0, true) + (paneCoordinates ? 0 : this.pos);\n  }\n  /**\n   * Translate a pixel position along the axis to a value in terms of axis\n   * units.\n   *\n   * @function Highcharts.Axis#toValue\n   *\n   * @param {number} pixel\n   * The pixel value coordinate.\n   *\n   * @param {boolean} [paneCoordinates=false]\n   * Whether the input pixel is relative to the chart or just the axis/pane\n   * itself.\n   *\n   * @return {number}\n   * The axis value.\n   */\n  toValue(pixel, paneCoordinates) {\n    return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, void 0, true);\n  }\n  /**\n   * Create the path for a plot line that goes from the given value on\n   * this axis, across the plot to the opposite side. Also used internally for\n   * grid lines and crosshairs.\n   *\n   * @function Highcharts.Axis#getPlotLinePath\n   *\n   * @param {Highcharts.AxisPlotLinePathOptionsObject} options\n   * Options for the path.\n   *\n   * @return {Highcharts.SVGPathArray|null}\n   * The SVG path definition for the plot line.\n   */\n  getPlotLinePath(options) {\n    const axis = this,\n      chart = axis.chart,\n      axisLeft = axis.left,\n      axisTop = axis.top,\n      old = options.old,\n      value = options.value,\n      lineWidth = options.lineWidth,\n      cHeight = old && chart.oldChartHeight || chart.chartHeight,\n      cWidth = old && chart.oldChartWidth || chart.chartWidth,\n      transB = axis.transB;\n    let translatedValue = options.translatedValue,\n      force = options.force,\n      x1,\n      y1,\n      x2,\n      y2,\n      skip;\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * Check if x is between a and b. If not, either move to a/b\n     * or skip, depending on the force parameter.\n     * @private\n     */\n    function between(x, a, b) {\n      if (force !== 'pass' && (x < a || x > b)) {\n        if (force) {\n          x = clamp(x, a, b);\n        } else {\n          skip = true;\n        }\n      }\n      return x;\n    }\n    const evt = {\n      value: value,\n      lineWidth: lineWidth,\n      old: old,\n      force: force,\n      acrossPanes: options.acrossPanes,\n      translatedValue: translatedValue\n    };\n    fireEvent(this, 'getPlotLinePath', evt, function (e) {\n      translatedValue = pick(translatedValue, axis.translate(value, void 0, void 0, old));\n      // Keep the translated value within sane bounds, and avoid Infinity\n      // to fail the isNumber test (#7709).\n      translatedValue = clamp(translatedValue, -1e5, 1e5);\n      x1 = x2 = Math.round(translatedValue + transB);\n      y1 = y2 = Math.round(cHeight - translatedValue - transB);\n      if (!isNumber(translatedValue)) {\n        // no min or max\n        skip = true;\n        force = false; // #7175, don't force it when path is invalid\n      } else if (axis.horiz) {\n        y1 = axisTop;\n        y2 = cHeight - axis.bottom;\n        x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n      } else {\n        x1 = axisLeft;\n        x2 = cWidth - axis.right;\n        y1 = y2 = between(y1, axisTop, axisTop + axis.height);\n      }\n      e.path = skip && !force ? void 0 : chart.renderer.crispLine([['M', x1, y1], ['L', x2, y2]], lineWidth || 1);\n    });\n    return evt.path || null;\n  }\n  /**\n   * Internal function to get the tick positions of a linear axis to round\n   * values like whole tens or every five.\n   *\n   * @function Highcharts.Axis#getLinearTickPositions\n   *\n   * @param {number} tickInterval\n   * The normalized tick interval.\n   *\n   * @param {number} min\n   * Axis minimum.\n   *\n   * @param {number} max\n   * Axis maximum.\n   *\n   * @return {Array<number>}\n   * An array of axis values where ticks should be placed.\n   */\n  getLinearTickPositions(tickInterval, min, max) {\n    const roundedMin = correctFloat(Math.floor(min / tickInterval) * tickInterval),\n      roundedMax = correctFloat(Math.ceil(max / tickInterval) * tickInterval),\n      tickPositions = [];\n    let pos, lastPos, precision;\n    // When the precision is higher than what we filter out in\n    // correctFloat, skip it (#6183).\n    if (correctFloat(roundedMin + tickInterval) === roundedMin) {\n      precision = 20;\n    }\n    // For single points, add a tick regardless of the relative position\n    // (#2662, #6274)\n    if (this.single) {\n      return [min];\n    }\n    // Populate the intermediate values\n    pos = roundedMin;\n    while (pos <= roundedMax) {\n      // Place the tick on the rounded value\n      tickPositions.push(pos);\n      // Always add the raw tickInterval, not the corrected one.\n      pos = correctFloat(pos + tickInterval, precision);\n      // If the interval is not big enough in the current min - max range\n      // to actually increase the loop variable, we need to break out to\n      // prevent endless loop. Issue #619\n      if (pos === lastPos) {\n        break;\n      }\n      // Record the last value\n      lastPos = pos;\n    }\n    return tickPositions;\n  }\n  /**\n   * Resolve the new minorTicks/minorTickInterval options into the legacy\n   * loosely typed minorTickInterval option.\n   *\n   * @function Highcharts.Axis#getMinorTickInterval\n   *\n   * @return {number|\"auto\"|null}\n   * Legacy option\n   */\n  getMinorTickInterval() {\n    const options = this.options;\n    if (options.minorTicks === true) {\n      return pick(options.minorTickInterval, 'auto');\n    }\n    if (options.minorTicks === false) {\n      return null;\n    }\n    return options.minorTickInterval;\n  }\n  /**\n   * Internal function to return the minor tick positions. For logarithmic\n   * axes, the same logic as for major ticks is reused.\n   *\n   * @function Highcharts.Axis#getMinorTickPositions\n   *\n   * @return {Array<number>}\n   * An array of axis values where ticks should be placed.\n   */\n  getMinorTickPositions() {\n    const axis = this,\n      options = axis.options,\n      tickPositions = axis.tickPositions,\n      minorTickInterval = axis.minorTickInterval,\n      pointRangePadding = axis.pointRangePadding || 0,\n      min = axis.min - pointRangePadding,\n      // #1498\n      max = axis.max + pointRangePadding,\n      // #1498\n      range = max - min;\n    let minorTickPositions = [],\n      pos;\n    // If minor ticks get too dense, they are hard to read, and may cause\n    // long running script. So we don't draw them.\n    if (range && range / minorTickInterval < axis.len / 3) {\n      // #3875\n      const logarithmic = axis.logarithmic;\n      if (logarithmic) {\n        // For each interval in the major ticks, compute the minor ticks\n        // separately.\n        this.paddedTicks.forEach(function (_pos, i, paddedTicks) {\n          if (i) {\n            minorTickPositions.push.apply(minorTickPositions, logarithmic.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));\n          }\n        });\n      } else if (axis.dateTime && this.getMinorTickInterval() === 'auto') {\n        // #1314\n        minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(minorTickInterval), min, max, options.startOfWeek));\n      } else {\n        for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {\n          // Very, very, tight grid lines (#5771)\n          if (pos === minorTickPositions[0]) {\n            break;\n          }\n          minorTickPositions.push(pos);\n        }\n      }\n    }\n    if (minorTickPositions.length !== 0) {\n      axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330\n    }\n\n    return minorTickPositions;\n  }\n  /**\n   * Adjust the min and max for the minimum range. Keep in mind that the\n   * series data is not yet processed, so we don't have information on data\n   * cropping and grouping, or updated `axis.pointRange` or\n   * `series.pointRange`. The data can't be processed until we have finally\n   * established min and max.\n   *\n   * @private\n   * @function Highcharts.Axis#adjustForMinRange\n   */\n  adjustForMinRange() {\n    const axis = this,\n      options = axis.options,\n      logarithmic = axis.logarithmic;\n    let min = axis.min,\n      max = axis.max,\n      zoomOffset,\n      spaceAvailable,\n      closestDataRange,\n      minArgs,\n      maxArgs,\n      minRange;\n    // Set the automatic minimum range based on the closest point distance\n    if (axis.isXAxis && typeof axis.minRange === 'undefined' && !logarithmic) {\n      if (defined(options.min) || defined(options.max) || defined(options.floor) || defined(options.ceiling)) {\n        axis.minRange = null; // don't do this again\n      } else {\n        // Find the closest distance between raw data points, as opposed\n        // to closestPointRange that applies to processed points\n        // (cropped and grouped)\n        closestDataRange = getClosestDistance(axis.series.map(s =>\n        // If xIncrement, we only need to measure the two first\n        // points to get the distance. Saves processing time.\n        (s.xIncrement ? s.xData?.slice(0, 2) : s.xData) || [])) || 0;\n        axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);\n      }\n    }\n    // if minRange is exceeded, adjust\n    if (max - min < axis.minRange) {\n      spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;\n      minRange = axis.minRange;\n      zoomOffset = (minRange - max + min) / 2;\n      // if min and max options have been set, don't go beyond it\n      minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];\n      // If space is available, stay within the data range\n      if (spaceAvailable) {\n        minArgs[2] = logarithmic ? logarithmic.log2lin(axis.dataMin) : axis.dataMin;\n      }\n      min = arrayMax(minArgs);\n      maxArgs = [min + minRange, pick(options.max, min + minRange)];\n      // If space is availabe, stay within the data range\n      if (spaceAvailable) {\n        maxArgs[2] = logarithmic ? logarithmic.log2lin(axis.dataMax) : axis.dataMax;\n      }\n      max = arrayMin(maxArgs);\n      // now if the max is adjusted, adjust the min back\n      if (max - min < minRange) {\n        minArgs[0] = max - minRange;\n        minArgs[1] = pick(options.min, max - minRange);\n        min = arrayMax(minArgs);\n      }\n    }\n    // Record modified extremes\n    axis.min = min;\n    axis.max = max;\n  }\n  /**\n   * Find the closestPointRange across all series, including the single data\n   * series.\n   *\n   * @private\n   * @function Highcharts.Axis#getClosest\n   */\n  getClosest() {\n    let closestSingleDistance, closestDistance;\n    if (this.categories) {\n      closestDistance = 1;\n    } else {\n      const singleXs = [];\n      this.series.forEach(function (series) {\n        const seriesClosest = series.closestPointRange;\n        if (series.xData?.length === 1) {\n          singleXs.push(series.xData[0]);\n        } else if (!series.noSharedTooltip && defined(seriesClosest) && series.reserveSpace()) {\n          closestDistance = defined(closestDistance) ? Math.min(closestDistance, seriesClosest) : seriesClosest;\n        }\n      });\n      if (singleXs.length) {\n        singleXs.sort((a, b) => a - b);\n        closestSingleDistance = getClosestDistance([singleXs]);\n      }\n    }\n    if (closestSingleDistance && closestDistance) {\n      return Math.min(closestSingleDistance, closestDistance);\n    }\n    return closestSingleDistance || closestDistance;\n  }\n  /**\n   * When a point name is given and no x, search for the name in the existing\n   * categories, or if categories aren't provided, search names or create a\n   * new category (#2522).\n   *\n   * @private\n   * @function Highcharts.Axis#nameToX\n   *\n   * @param {Highcharts.Point} point\n   * The point to inspect.\n   *\n   * @return {number}\n   * The X value that the point is given.\n   */\n  nameToX(point) {\n    const explicitCategories = isArray(this.options.categories),\n      names = explicitCategories ? this.categories : this.names;\n    let nameX = point.options.x,\n      x;\n    point.series.requireSorting = false;\n    if (!defined(nameX)) {\n      nameX = this.options.uniqueNames && names ? explicitCategories ? names.indexOf(point.name) : pick(names.keys[point.name], -1) : point.series.autoIncrement();\n    }\n    if (nameX === -1) {\n      // Not found in currenct categories\n      if (!explicitCategories && names) {\n        x = names.length;\n      }\n    } else {\n      x = nameX;\n    }\n    // Write the last point's name to the names array\n    if (typeof x !== 'undefined') {\n      this.names[x] = point.name;\n      // Backwards mapping is much faster than array searching (#7725)\n      this.names.keys[point.name] = x;\n    } else if (point.x) {\n      x = point.x; // #17438\n    }\n\n    return x;\n  }\n  /**\n   * When changes have been done to series data, update the axis.names.\n   *\n   * @private\n   * @function Highcharts.Axis#updateNames\n   */\n  updateNames() {\n    const axis = this,\n      names = this.names,\n      i = names.length;\n    if (i > 0) {\n      Object.keys(names.keys).forEach(function (key) {\n        delete names.keys[key];\n      });\n      names.length = 0;\n      this.minRange = this.userMinRange; // Reset\n      (this.series || []).forEach(function (series) {\n        // Reset incrementer (#5928)\n        series.xIncrement = null;\n        // When adding a series, points are not yet generated\n        if (!series.points || series.isDirtyData) {\n          // When we're updating the series with data that is longer\n          // than it was, and cropThreshold is passed, we need to make\n          // sure that the axis.max is increased _before_ running the\n          // premature processData. Otherwise this early iteration of\n          // processData will crop the points to axis.max, and the\n          // names array will be too short (#5857).\n          axis.max = Math.max(axis.max, series.xData.length - 1);\n          series.processData();\n          series.generatePoints();\n        }\n        series.data.forEach(function (point, i) {\n          let x;\n          if (point && point.options && typeof point.name !== 'undefined' // #9562\n          ) {\n            x = axis.nameToX(point);\n            if (typeof x !== 'undefined' && x !== point.x) {\n              point.x = x;\n              series.xData[i] = x;\n            }\n          }\n        });\n      });\n    }\n  }\n  /**\n   * Update translation information.\n   *\n   * @private\n   * @function Highcharts.Axis#setAxisTranslation\n   *\n   * @emits Highcharts.Axis#event:afterSetAxisTranslation\n   */\n  setAxisTranslation() {\n    const axis = this,\n      range = axis.max - axis.min,\n      linkedParent = axis.linkedParent,\n      hasCategories = !!axis.categories,\n      isXAxis = axis.isXAxis;\n    let pointRange = axis.axisPointRange || 0,\n      closestPointRange,\n      minPointOffset = 0,\n      pointRangePadding = 0,\n      ordinalCorrection,\n      transA = axis.transA;\n    // Adjust translation for padding. Y axis with categories need to go\n    // through the same (#1784).\n    if (isXAxis || hasCategories || pointRange) {\n      // Get the closest points\n      closestPointRange = axis.getClosest();\n      if (linkedParent) {\n        minPointOffset = linkedParent.minPointOffset;\n        pointRangePadding = linkedParent.pointRangePadding;\n      } else {\n        axis.series.forEach(function (series) {\n          const seriesPointRange = hasCategories ? 1 : isXAxis ? pick(series.options.pointRange, closestPointRange, 0) : axis.axisPointRange || 0,\n            // #2806\n            pointPlacement = series.options.pointPlacement;\n          pointRange = Math.max(pointRange, seriesPointRange);\n          if (!axis.single || hasCategories) {\n            // TODO: series should internally set x- and y-\n            // pointPlacement to simplify this logic.\n            const isPointPlacementAxis = series.is('xrange') ? !isXAxis : isXAxis;\n            // minPointOffset is the value padding to the left of\n            // the axis in order to make room for points with a\n            // pointRange, typically columns. When the\n            // pointPlacement option is 'between' or 'on', this\n            // padding does not apply.\n            minPointOffset = Math.max(minPointOffset, isPointPlacementAxis && isString(pointPlacement) ? 0 : seriesPointRange / 2);\n            // Determine the total padding needed to the length of\n            // the axis to make room for the pointRange. If the\n            // series' pointPlacement is 'on', no padding is added.\n            pointRangePadding = Math.max(pointRangePadding, isPointPlacementAxis && pointPlacement === 'on' ? 0 : seriesPointRange);\n          }\n        });\n      }\n      // Record minPointOffset and pointRangePadding\n      ordinalCorrection = axis.ordinal && axis.ordinal.slope && closestPointRange ? axis.ordinal.slope / closestPointRange : 1; // #988, #1853\n      axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;\n      axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;\n      // pointRange means the width reserved for each point, like in a\n      // column chart\n      axis.pointRange = Math.min(pointRange, axis.single && hasCategories ? 1 : range);\n      // closestPointRange means the closest distance between points. In\n      // columns it is mostly equal to pointRange, but in lines pointRange\n      // is 0 while closestPointRange is some other value\n      if (isXAxis && closestPointRange) {\n        axis.closestPointRange = closestPointRange;\n      }\n    }\n    // Secondary values\n    axis.translationSlope = axis.transA = transA = axis.staticScale || axis.len / (range + pointRangePadding || 1);\n    // Translation addend\n    axis.transB = axis.horiz ? axis.left : axis.bottom;\n    axis.minPixelPadding = transA * minPointOffset;\n    fireEvent(this, 'afterSetAxisTranslation');\n  }\n  /**\n   * @private\n   * @function Highcharts.Axis#minFromRange\n   */\n  minFromRange() {\n    const axis = this;\n    return axis.max - axis.range;\n  }\n  /**\n   * Set the tick positions to round values and optionally extend the extremes\n   * to the nearest tick.\n   *\n   * @private\n   * @function Highcharts.Axis#setTickInterval\n   *\n   * @param {boolean} secondPass\n   * TO-DO: parameter description\n   *\n   * @emits Highcharts.Axis#event:foundExtremes\n   */\n  setTickInterval(secondPass) {\n    const axis = this,\n      chart = axis.chart,\n      log = axis.logarithmic,\n      options = axis.options,\n      isXAxis = axis.isXAxis,\n      isLinked = axis.isLinked,\n      tickPixelIntervalOption = options.tickPixelInterval,\n      categories = axis.categories,\n      softThreshold = axis.softThreshold;\n    let maxPadding = options.maxPadding,\n      minPadding = options.minPadding,\n      length,\n      linkedParentExtremes,\n      // Only non-negative tickInterval is valid, #12961\n      tickIntervalOption = isNumber(options.tickInterval) && options.tickInterval >= 0 ? options.tickInterval : void 0,\n      threshold = isNumber(axis.threshold) ? axis.threshold : null,\n      thresholdMin,\n      thresholdMax,\n      hardMin,\n      hardMax;\n    if (!axis.dateTime && !categories && !isLinked) {\n      this.getTickAmount();\n    }\n    // Min or max set either by zooming/setExtremes or initial options\n    hardMin = pick(axis.userMin, options.min);\n    hardMax = pick(axis.userMax, options.max);\n    // Linked axis gets the extremes from the parent axis\n    if (isLinked) {\n      axis.linkedParent = chart[axis.coll][options.linkedTo];\n      linkedParentExtremes = axis.linkedParent.getExtremes();\n      axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n      axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n      if (options.type !== axis.linkedParent.options.type) {\n        // Can't link axes of different type\n        error(11, 1, chart);\n      }\n      // Initial min and max from the extreme data values\n    } else {\n      // Adjust to hard threshold\n      if (softThreshold && defined(threshold)) {\n        if (axis.dataMin >= threshold) {\n          thresholdMin = threshold;\n          minPadding = 0;\n        } else if (axis.dataMax <= threshold) {\n          thresholdMax = threshold;\n          maxPadding = 0;\n        }\n      }\n      axis.min = pick(hardMin, thresholdMin, axis.dataMin);\n      axis.max = pick(hardMax, thresholdMax, axis.dataMax);\n    }\n    if (log) {\n      if (axis.positiveValuesOnly && !secondPass && Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0) {\n        // #978\n        // Can't plot negative values on log axis\n        error(10, 1, chart);\n      }\n      // The correctFloat cures #934, float errors on full tens. But it\n      // was too aggressive for #4360 because of conversion back to lin,\n      // therefore use precision 15.\n      axis.min = correctFloat(log.log2lin(axis.min), 16);\n      axis.max = correctFloat(log.log2lin(axis.max), 16);\n    }\n    // handle zoomed range\n    if (axis.range && defined(axis.max)) {\n      // #618, #6773:\n      axis.userMin = axis.min = hardMin = Math.max(axis.dataMin, axis.minFromRange());\n      axis.userMax = hardMax = axis.max;\n      axis.range = null; // don't use it when running setExtremes\n    }\n    // Hook for Highcharts Stock Scroller.\n    // Consider combining with beforePadding.\n    fireEvent(axis, 'foundExtremes');\n    // Hook for adjusting this.min and this.max. Used by bubble series.\n    if (axis.beforePadding) {\n      axis.beforePadding();\n    }\n    // Adjust min and max for the minimum range\n    axis.adjustForMinRange();\n    // Handle options for floor, ceiling, softMin and softMax (#6359)\n    if (!isNumber(axis.userMin)) {\n      if (isNumber(options.softMin) && options.softMin < axis.min) {\n        axis.min = hardMin = options.softMin; // #6894\n      }\n    }\n\n    if (!isNumber(axis.userMax)) {\n      if (isNumber(options.softMax) && options.softMax > axis.max) {\n        axis.max = hardMax = options.softMax; // #6894\n      }\n    }\n    // Pad the values to get clear of the chart's edges. To avoid\n    // tickInterval taking the padding into account, we do this after\n    // computing tick interval (#1337).\n    if (!categories && !axis.axisPointRange && !(axis.stacking && axis.stacking.usePercentage) && !isLinked && defined(axis.min) && defined(axis.max)) {\n      length = axis.max - axis.min;\n      if (length) {\n        if (!defined(hardMin) && minPadding) {\n          axis.min -= length * minPadding;\n        }\n        if (!defined(hardMax) && maxPadding) {\n          axis.max += length * maxPadding;\n        }\n      }\n    }\n    if (!isNumber(axis.userMin) && isNumber(options.floor)) {\n      axis.min = Math.max(axis.min, options.floor);\n    }\n    if (!isNumber(axis.userMax) && isNumber(options.ceiling)) {\n      axis.max = Math.min(axis.max, options.ceiling);\n    }\n    // When the threshold is soft, adjust the extreme value only if the data\n    // extreme and the padded extreme land on either side of the threshold.\n    // For example, a series of [0, 1, 2, 3] would make the yAxis add a tick\n    // for -1 because of the default minPadding and startOnTick options.\n    // This is prevented by the softThreshold option.\n    if (softThreshold && defined(axis.dataMin)) {\n      threshold = threshold || 0;\n      if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {\n        axis.min = axis.options.minRange ? Math.min(threshold, axis.max - axis.minRange) : threshold;\n      } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {\n        axis.max = axis.options.minRange ? Math.max(threshold, axis.min + axis.minRange) : threshold;\n      }\n    }\n    // If min is bigger than highest, or if max less than lowest value, the\n    // chart should not render points. (#14417)\n    if (isNumber(axis.min) && isNumber(axis.max) && !this.chart.polar && axis.min > axis.max) {\n      if (defined(axis.options.min)) {\n        axis.max = axis.min;\n      } else if (defined(axis.options.max)) {\n        axis.min = axis.max;\n      }\n    }\n    // get tickInterval\n    if (axis.min === axis.max || typeof axis.min === 'undefined' || typeof axis.max === 'undefined') {\n      axis.tickInterval = 1;\n    } else if (isLinked && axis.linkedParent && !tickIntervalOption && tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {\n      axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;\n    } else {\n      axis.tickInterval = pick(tickIntervalOption, this.tickAmount ? (axis.max - axis.min) / Math.max(this.tickAmount - 1, 1) : void 0,\n      // For categoried axis, 1 is default, for linear axis use\n      // tickPix\n      categories ? 1 :\n      // don't let it be more than the data range\n      (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption));\n    }\n    // Now we're finished detecting min and max, crop and group series data.\n    // This is in turn needed in order to find tick positions in ordinal\n    // axes.\n    if (isXAxis && !secondPass) {\n      const hasExtremesChanged = axis.min !== (axis.old && axis.old.min) || axis.max !== (axis.old && axis.old.max);\n      // First process all series assigned to that axis.\n      axis.series.forEach(function (series) {\n        // Allows filtering out points outside the plot area.\n        series.forceCrop = series.forceCropping && series.forceCropping();\n        series.processData(hasExtremesChanged);\n      });\n      // Then apply grouping if needed. The hasExtremesChanged helps to\n      // decide if the data grouping should be skipped in the further\n      // calculations #16319.\n      fireEvent(this, 'postProcessData', {\n        hasExtremesChanged\n      });\n    }\n    // set the translation factor used in translate function\n    axis.setAxisTranslation();\n    // hook for ordinal axes and radial axes\n    fireEvent(this, 'initialAxisTranslation');\n    // In column-like charts, don't cramp in more ticks than there are\n    // points (#1943, #4184)\n    if (axis.pointRange && !tickIntervalOption) {\n      axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);\n    }\n    // Before normalizing the tick interval, handle minimum tick interval.\n    // This applies only if tickInterval is not defined.\n    const minTickInterval = pick(options.minTickInterval,\n    // In datetime axes, don't go below the data interval, except when\n    // there are scatter-like series involved (#13369).\n    axis.dateTime && !axis.series.some(s => s.noSharedTooltip) ? axis.closestPointRange : 0);\n    if (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n      axis.tickInterval = minTickInterval;\n    }\n    // For linear axes, normalize the interval\n    if (!axis.dateTime && !axis.logarithmic && !tickIntervalOption) {\n      axis.tickInterval = getNormalizedTickInterval(axis, axis.tickInterval);\n    }\n    // Prevent ticks from getting so close that we can't draw the labels\n    if (!this.tickAmount) {\n      axis.tickInterval = axis.unsquish();\n    }\n    this.setTickPositions();\n  }\n  /**\n   * Now we have computed the normalized tickInterval, get the tick positions.\n   *\n   * @private\n   * @function Highcharts.Axis#setTickPositions\n   *\n   * @emits Highcharts.Axis#event:afterSetTickPositions\n   */\n  setTickPositions() {\n    const axis = this,\n      options = this.options,\n      tickPositionsOption = options.tickPositions,\n      tickPositioner = options.tickPositioner,\n      minorTickIntervalOption = this.getMinorTickInterval(),\n      hasVerticalPanning = this.hasVerticalPanning(),\n      isColorAxis = this.coll === 'colorAxis',\n      startOnTick = (isColorAxis || !hasVerticalPanning) && options.startOnTick,\n      endOnTick = (isColorAxis || !hasVerticalPanning) && options.endOnTick;\n    let tickPositions = [],\n      tickPositionerResult;\n    // Set the tickmarkOffset\n    this.tickmarkOffset = this.categories && options.tickmarkPlacement === 'between' && this.tickInterval === 1 ? 0.5 : 0; // #3202\n    // get minorTickInterval\n    this.minorTickInterval = minorTickIntervalOption === 'auto' && this.tickInterval ? this.tickInterval / options.minorTicksPerMajor : minorTickIntervalOption;\n    // When there is only one point, or all points have the same value on\n    // this axis, then min and max are equal and tickPositions.length is 0\n    // or 1. In this case, add some padding in order to center the point,\n    // but leave it with one tick. #1337.\n    this.single = this.min === this.max && defined(this.min) && !this.tickAmount && (\n    // Data is on integer (#6563)\n    parseInt(this.min, 10) === this.min ||\n    // Between integers and decimals are not allowed (#6274)\n    options.allowDecimals !== false);\n    /**\n     * Contains the current positions that are laid out on the axis. The\n     * positions are numbers in terms of axis values. In a category axis\n     * they are integers, in a datetime axis they are also integers, but\n     * designating milliseconds.\n     *\n     * This property is read only - for modifying the tick positions, use\n     * the `tickPositioner` callback or [axis.tickPositions(\n     * https://api.highcharts.com/highcharts/xAxis.tickPositions) option\n     * instead.\n     *\n     * @name Highcharts.Axis#tickPositions\n     * @type {Highcharts.AxisTickPositionsArray|undefined}\n     */\n    if (tickPositionsOption) {\n      // Find the tick positions. Work on a copy (#1565)\n      tickPositions = tickPositionsOption.slice();\n    } else if (isNumber(this.min) && isNumber(this.max)) {\n      // Too many ticks (#6405). Create a friendly warning and provide two\n      // ticks so at least we can show the data series.\n      if ((!axis.ordinal || !axis.ordinal.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) {\n        tickPositions = [this.min, this.max];\n        error(19, false, this.chart);\n      } else if (axis.dateTime) {\n        tickPositions = axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, axis.ordinal && axis.ordinal.positions, this.closestPointRange, true);\n      } else if (axis.logarithmic) {\n        tickPositions = axis.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);\n      } else {\n        const startingTickInterval = this.tickInterval;\n        let adjustedTickInterval = startingTickInterval;\n        while (adjustedTickInterval <= startingTickInterval * 2) {\n          tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);\n          // If there are more tick positions than the set tickAmount,\n          // increase the tickInterval and continue until it fits.\n          // (#17100)\n          if (this.tickAmount && tickPositions.length > this.tickAmount) {\n            this.tickInterval = getNormalizedTickInterval(this, adjustedTickInterval *= 1.1);\n          } else {\n            break;\n          }\n        }\n      }\n      // Too dense ticks, keep only the first and last (#4477)\n      if (tickPositions.length > this.len) {\n        tickPositions = [tickPositions[0], tickPositions[tickPositions.length - 1]];\n        // Reduce doubled value (#7339)\n        if (tickPositions[0] === tickPositions[1]) {\n          tickPositions.length = 1;\n        }\n      }\n      // Run the tick positioner callback, that allows modifying auto tick\n      // positions.\n      if (tickPositioner) {\n        // Make it available to the positioner\n        this.tickPositions = tickPositions;\n        tickPositionerResult = tickPositioner.apply(axis, [this.min, this.max]);\n        if (tickPositionerResult) {\n          tickPositions = tickPositionerResult;\n        }\n      }\n    }\n    this.tickPositions = tickPositions;\n    // Reset min/max or remove extremes based on start/end on tick\n    this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor\n    this.trimTicks(tickPositions, startOnTick, endOnTick);\n    if (!this.isLinked && isNumber(this.min) && isNumber(this.max)) {\n      // Substract half a unit (#2619, #2846, #2515, #3390), but not in\n      // case of multiple ticks (#6897)\n      if (this.single && tickPositions.length < 2 && !this.categories && !this.series.some(s => s.is('heatmap') && s.options.pointPlacement === 'between')) {\n        this.min -= 0.5;\n        this.max += 0.5;\n      }\n      if (!tickPositionsOption && !tickPositionerResult) {\n        this.adjustTickAmount();\n      }\n    }\n    fireEvent(this, 'afterSetTickPositions');\n  }\n  /**\n   * Handle startOnTick and endOnTick by either adapting to padding min/max or\n   * rounded min/max. Also handle single data points.\n   *\n   * @private\n   * @function Highcharts.Axis#trimTicks\n   *\n   * @param {Array<number>} tickPositions\n   * TO-DO: parameter description\n   *\n   * @param {boolean} [startOnTick]\n   * TO-DO: parameter description\n   *\n   * @param {boolean} [endOnTick]\n   * TO-DO: parameter description\n   */\n  trimTicks(tickPositions, startOnTick, endOnTick) {\n    const roundedMin = tickPositions[0],\n      roundedMax = tickPositions[tickPositions.length - 1],\n      minPointOffset = !this.isOrdinal && this.minPointOffset || 0; // (#12716)\n    fireEvent(this, 'trimTicks');\n    if (!this.isLinked) {\n      if (startOnTick && roundedMin !== -Infinity) {\n        // #6502\n        this.min = roundedMin;\n      } else {\n        while (this.min - minPointOffset > tickPositions[0]) {\n          tickPositions.shift();\n        }\n      }\n      if (endOnTick) {\n        this.max = roundedMax;\n      } else {\n        while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {\n          tickPositions.pop();\n        }\n      }\n      // If no tick are left, set one tick in the middle (#3195)\n      if (tickPositions.length === 0 && defined(roundedMin) && !this.options.tickPositions) {\n        tickPositions.push((roundedMax + roundedMin) / 2);\n      }\n    }\n  }\n  /**\n   * Check if there are multiple axes in the same pane.\n   *\n   * @private\n   * @function Highcharts.Axis#alignToOthers\n   *\n   * @return {boolean|undefined}\n   * True if there are other axes.\n   */\n  alignToOthers() {\n    const axis = this,\n      alignedAxes = [this],\n      options = axis.options,\n      alignThresholds = this.coll === 'yAxis' && this.chart.options.chart.alignThresholds,\n      thresholdAlignments = [];\n    let hasOther;\n    axis.thresholdAlignment = void 0;\n    if ((\n    // Only if alignTicks or alignThresholds is true\n    this.chart.options.chart.alignTicks !== false && options.alignTicks || alignThresholds) &&\n    // Disabled when startOnTick or endOnTick are false (#7604)\n    options.startOnTick !== false && options.endOnTick !== false &&\n    // Don't try to align ticks on a log axis, they are not evenly\n    // spaced (#6021)\n    !axis.logarithmic) {\n      // Get a key identifying which pane the axis belongs to\n      const getKey = axis => {\n        const {\n          horiz,\n          options\n        } = axis;\n        return [horiz ? options.left : options.top, options.width, options.height, options.pane].join(',');\n      };\n      const thisKey = getKey(this);\n      this.chart[this.coll].forEach(function (otherAxis) {\n        const {\n          series\n        } = otherAxis;\n        if (\n        // #4442\n        series.length && series.some(s => s.visible) && otherAxis !== axis && getKey(otherAxis) === thisKey) {\n          hasOther = true; // #4201\n          alignedAxes.push(otherAxis);\n        }\n      });\n    }\n    if (hasOther && alignThresholds) {\n      // Handle alignThresholds. The `thresholdAlignments` array keeps\n      // records of where each axis in the group wants its threshold, from\n      // 0 which is on `axis.min`, to 1 which is on `axis.max`.\n      alignedAxes.forEach(otherAxis => {\n        const threshAlign = otherAxis.getThresholdAlignment(axis);\n        if (isNumber(threshAlign)) {\n          thresholdAlignments.push(threshAlign);\n        }\n      });\n      // For each of the axes in the group, record the average\n      // `thresholdAlignment`.\n      const thresholdAlignment = thresholdAlignments.length > 1 ? thresholdAlignments.reduce((sum, n) => sum += n, 0) / thresholdAlignments.length : void 0;\n      alignedAxes.forEach(axis => {\n        axis.thresholdAlignment = thresholdAlignment;\n      });\n    }\n    return hasOther;\n  }\n  /**\n   * Where the axis wants its threshold, from 0 which is on `axis.min`, to 1 which\n   * is on `axis.max`.\n   *\n   * @private\n   * @function Highcharts.Axis#getThresholdAlignment\n   */\n  getThresholdAlignment(callerAxis) {\n    if (!isNumber(this.dataMin) || this !== callerAxis && this.series.some(s => s.isDirty || s.isDirtyData)) {\n      this.getSeriesExtremes();\n    }\n    if (isNumber(this.threshold)) {\n      let thresholdAlignment = clamp((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);\n      if (this.options.reversed) {\n        thresholdAlignment = 1 - thresholdAlignment;\n      }\n      return thresholdAlignment;\n    }\n  }\n  /**\n   * Find the max ticks of either the x and y axis collection, and record it\n   * in `this.tickAmount`.\n   *\n   * @private\n   * @function Highcharts.Axis#getTickAmount\n   */\n  getTickAmount() {\n    const axis = this,\n      options = this.options,\n      tickPixelInterval = options.tickPixelInterval;\n    let tickAmount = options.tickAmount;\n    if (!defined(options.tickInterval) && !tickAmount && this.len < tickPixelInterval && !this.isRadial && !axis.logarithmic && options.startOnTick && options.endOnTick) {\n      tickAmount = 2;\n    }\n    if (!tickAmount && this.alignToOthers()) {\n      // Add 1 because 4 tick intervals require 5 ticks (including first\n      // and last)\n      tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;\n    }\n    // For tick amounts of 2 and 3, compute five ticks and remove the\n    // intermediate ones. This prevents the axis from adding ticks that are\n    // too far away from the data extremes.\n    if (tickAmount < 4) {\n      this.finalTickAmt = tickAmount;\n      tickAmount = 5;\n    }\n    this.tickAmount = tickAmount;\n  }\n  /**\n   * When using multiple axes, adjust the number of ticks to match the highest\n   * number of ticks in that group.\n   *\n   * @private\n   * @function Highcharts.Axis#adjustTickAmount\n   */\n  adjustTickAmount() {\n    const axis = this,\n      {\n        finalTickAmt,\n        max,\n        min,\n        options,\n        tickPositions,\n        tickAmount,\n        thresholdAlignment\n      } = axis,\n      currentTickAmount = tickPositions && tickPositions.length,\n      threshold = pick(axis.threshold, axis.softThreshold ? 0 : null);\n    let len,\n      i,\n      tickInterval = axis.tickInterval,\n      thresholdTickIndex;\n    const\n      // Extend the tickPositions by appending a position\n      append = () => tickPositions.push(correctFloat(tickPositions[tickPositions.length - 1] + tickInterval)),\n      // Extend the tickPositions by prepending a position\n      prepend = () => tickPositions.unshift(correctFloat(tickPositions[0] - tickInterval));\n    // If `thresholdAlignment` is a number, it means the `alignThresholds`\n    // option is true. The `thresholdAlignment` is a scalar value between 0\n    // and 1 for where the threshold should be relative to `axis.min` and\n    // `axis.max`. Now that we know the tick amount, convert this to the\n    // tick index. Unless `thresholdAlignment` is exactly 0 or 1, avoid the\n    // first or last tick because that would lead to series being clipped.\n    if (isNumber(thresholdAlignment)) {\n      thresholdTickIndex = thresholdAlignment < 0.5 ? Math.ceil(thresholdAlignment * (tickAmount - 1)) : Math.floor(thresholdAlignment * (tickAmount - 1));\n      if (options.reversed) {\n        thresholdTickIndex = tickAmount - 1 - thresholdTickIndex;\n      }\n    }\n    if (axis.hasData() && isNumber(min) && isNumber(max)) {\n      // #14769\n      // Adjust extremes and translation to the modified tick positions\n      const adjustExtremes = () => {\n        axis.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n        // Do not crop when ticks are not extremes (#9841)\n        axis.min = options.startOnTick ? tickPositions[0] : Math.min(min, tickPositions[0]);\n        axis.max = options.endOnTick ? tickPositions[tickPositions.length - 1] : Math.max(max, tickPositions[tickPositions.length - 1]);\n      };\n      // When the axis is subject to the alignThresholds option. Use\n      // axis.threshold because the local threshold includes the\n      // `softThreshold`.\n      if (isNumber(thresholdTickIndex) && isNumber(axis.threshold)) {\n        // Throw away the previously computed tickPositions and start\n        // from scratch with only the threshold itself, then add ticks\n        // below the threshold first, then fill up above the threshold.\n        // If we are not able to fill up to axis.max, double the\n        // tickInterval and run again.\n        while (tickPositions[thresholdTickIndex] !== threshold || tickPositions.length !== tickAmount || tickPositions[0] > min || tickPositions[tickPositions.length - 1] < max) {\n          tickPositions.length = 0;\n          tickPositions.push(axis.threshold);\n          while (tickPositions.length < tickAmount) {\n            if (\n            // Start by prepending positions until the threshold\n            // is at the required index...\n            tickPositions[thresholdTickIndex] === void 0 || tickPositions[thresholdTickIndex] > axis.threshold) {\n              prepend();\n            } else {\n              // ... then append positions until we have the\n              // required length\n              append();\n            }\n          }\n          // Safety vent\n          if (tickInterval > axis.tickInterval * 8) {\n            break;\n          }\n          tickInterval *= 2;\n        }\n        adjustExtremes();\n      } else if (currentTickAmount < tickAmount) {\n        while (tickPositions.length < tickAmount) {\n          // Extend evenly for both sides unless we're on the\n          // threshold (#3965)\n          if (tickPositions.length % 2 || min === threshold) {\n            append();\n          } else {\n            prepend();\n          }\n        }\n        adjustExtremes();\n      }\n      // The finalTickAmt property is set in getTickAmount\n      if (defined(finalTickAmt)) {\n        i = len = tickPositions.length;\n        while (i--) {\n          if (\n          // Remove every other tick\n          finalTickAmt === 3 && i % 2 === 1 ||\n          // Remove all but first and last\n          finalTickAmt <= 2 && i > 0 && i < len - 1) {\n            tickPositions.splice(i, 1);\n          }\n        }\n        axis.finalTickAmt = void 0;\n      }\n    }\n  }\n  /**\n   * Set the scale based on data min and max, user set min and max or options.\n   *\n   * @private\n   * @function Highcharts.Axis#setScale\n   *\n   * @emits Highcharts.Axis#event:afterSetScale\n   */\n  setScale() {\n    const axis = this,\n      {\n        coll,\n        stacking\n      } = axis;\n    let isDirtyData = false,\n      isXAxisDirty = false;\n    axis.series.forEach(series => {\n      isDirtyData = isDirtyData || series.isDirtyData || series.isDirty;\n      // When x axis is dirty, we need new data extremes for y as\n      // well:\n      isXAxisDirty = isXAxisDirty || series.xAxis && series.xAxis.isDirty || false;\n    });\n    // Set the new axisLength\n    axis.setAxisSize();\n    const isDirtyAxisLength = axis.len !== (axis.old && axis.old.len);\n    // Do we really need to go through all this?\n    if (isDirtyAxisLength || isDirtyData || isXAxisDirty || axis.isLinked || axis.forceRedraw || axis.userMin !== (axis.old && axis.old.userMin) || axis.userMax !== (axis.old && axis.old.userMax) || axis.alignToOthers()) {\n      if (stacking && coll === 'yAxis') {\n        stacking.buildStacks();\n      }\n      axis.forceRedraw = false;\n      // #18066 delete minRange property to ensure that it will be\n      // calculated again after dirty data in series\n      if (!axis.userMinRange) {\n        axis.minRange = void 0;\n      }\n      // Get data extremes if needed\n      axis.getSeriesExtremes();\n      // Get fixed positions based on tickInterval\n      axis.setTickInterval();\n      if (stacking && coll === 'xAxis') {\n        stacking.buildStacks();\n      }\n      // Mark as dirty if it is not already set to dirty and extremes have\n      // changed. #595.\n      if (!axis.isDirty) {\n        axis.isDirty = isDirtyAxisLength || axis.min !== (axis.old && axis.old.min) || axis.max !== (axis.old && axis.old.max);\n      }\n    } else if (stacking) {\n      stacking.cleanStacks();\n    }\n    // Recalculate panning state object, when the data\n    // has changed. It is required when vertical panning is enabled.\n    if (isDirtyData && axis.panningState) {\n      axis.panningState.isDirty = true;\n    }\n    fireEvent(this, 'afterSetScale');\n  }\n  /**\n   * Set the minimum and maximum of the axes after render time. If the\n   * `startOnTick` and `endOnTick` options are true, the minimum and maximum\n   * values are rounded off to the nearest tick. To prevent this, these\n   * options can be set to false before calling setExtremes. Also, setExtremes\n   * will not allow a range lower than the `minRange` option, which by default\n   * is the range of five points.\n   *\n   * @sample highcharts/members/axis-setextremes/\n   *         Set extremes from a button\n   * @sample highcharts/members/axis-setextremes-datetime/\n   *         Set extremes on a datetime axis\n   * @sample highcharts/members/axis-setextremes-off-ticks/\n   *         Set extremes off ticks\n   * @sample stock/members/axis-setextremes/\n   *         Set extremes in Highcharts Stock\n   *\n   * @function Highcharts.Axis#setExtremes\n   *\n   * @param {number} [newMin]\n   * The new minimum value.\n   *\n   * @param {number} [newMax]\n   * The new maximum value.\n   *\n   * @param {boolean} [redraw=true]\n   * Whether to redraw the chart or wait for an explicit call to\n   * {@link Highcharts.Chart#redraw}\n   *\n   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=true]\n   * Enable or modify animations.\n   *\n   * @param {*} [eventArguments]\n   * Arguments to be accessed in event handler.\n   *\n   * @emits Highcharts.Axis#event:setExtremes\n   */\n  setExtremes(newMin, newMax, redraw, animation, eventArguments) {\n    const axis = this,\n      chart = axis.chart;\n    redraw = pick(redraw, true); // defaults to true\n    axis.series.forEach(function (serie) {\n      delete serie.kdTree;\n    });\n    // Extend the arguments with min and max\n    eventArguments = extend(eventArguments, {\n      min: newMin,\n      max: newMax\n    });\n    // Fire the event\n    fireEvent(axis, 'setExtremes', eventArguments, function () {\n      axis.userMin = newMin;\n      axis.userMax = newMax;\n      axis.eventArgs = eventArguments;\n      if (redraw) {\n        chart.redraw(animation);\n      }\n    });\n  }\n  /**\n   * Overridable method for zooming chart. Pulled out in a separate method to\n   * allow overriding in stock charts.\n   *\n   * @private\n   * @function Highcharts.Axis#zoom\n   */\n  zoom(newMin, newMax) {\n    const axis = this,\n      dataMin = this.dataMin,\n      dataMax = this.dataMax,\n      options = this.options,\n      min = Math.min(dataMin, pick(options.min, dataMin)),\n      max = Math.max(dataMax, pick(options.max, dataMax)),\n      evt = {\n        newMin: newMin,\n        newMax: newMax\n      };\n    fireEvent(this, 'zoom', evt, function (e) {\n      // Use e.newMin and e.newMax - event handlers may have altered them\n      let newMin = e.newMin,\n        newMax = e.newMax;\n      if (newMin !== axis.min || newMax !== axis.max) {\n        // #5790\n        // Prevent pinch zooming out of range. Check for defined is for\n        // #1946. #1734.\n        if (!axis.allowZoomOutside) {\n          // #6014, sometimes newMax will be smaller than min (or\n          // newMin will be larger than max).\n          if (defined(dataMin)) {\n            if (newMin < min) {\n              newMin = min;\n            }\n            if (newMin > max) {\n              newMin = max;\n            }\n          }\n          if (defined(dataMax)) {\n            if (newMax < min) {\n              newMax = min;\n            }\n            if (newMax > max) {\n              newMax = max;\n            }\n          }\n        }\n        // In full view, displaying the reset zoom button is not\n        // required\n        axis.displayBtn = typeof newMin !== 'undefined' || typeof newMax !== 'undefined';\n        // Do it\n        axis.setExtremes(newMin, newMax, false, void 0, {\n          trigger: 'zoom'\n        });\n      }\n      e.zoomed = true;\n    });\n    return evt.zoomed;\n  }\n  /**\n   * Update the axis metrics.\n   *\n   * @private\n   * @function Highcharts.Axis#setAxisSize\n   */\n  setAxisSize() {\n    const chart = this.chart,\n      options = this.options,\n      // [top, right, bottom, left]\n      offsets = options.offsets || [0, 0, 0, 0],\n      horiz = this.horiz,\n      // Check for percentage based input values. Rounding fixes problems\n      // with column overflow and plot line filtering (#4898, #4899)\n      width = this.width = Math.round(relativeLength(pick(options.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth)),\n      height = this.height = Math.round(relativeLength(pick(options.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight)),\n      top = this.top = Math.round(relativeLength(pick(options.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop)),\n      left = this.left = Math.round(relativeLength(pick(options.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft));\n    // Expose basic values to use in Series object and navigator\n    this.bottom = chart.chartHeight - height - top;\n    this.right = chart.chartWidth - width - left;\n    // Direction agnostic properties\n    this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905\n    this.pos = horiz ? left : top; // distance from SVG origin\n  }\n  /**\n   * Get the current extremes for the axis.\n   *\n   * @sample highcharts/members/axis-getextremes/\n   *         Report extremes by click on a button\n   *\n   * @function Highcharts.Axis#getExtremes\n   *\n   * @return {Highcharts.ExtremesObject}\n   * An object containing extremes information.\n   */\n  getExtremes() {\n    const axis = this,\n      log = axis.logarithmic;\n    return {\n      min: log ? correctFloat(log.lin2log(axis.min)) : axis.min,\n      max: log ? correctFloat(log.lin2log(axis.max)) : axis.max,\n      dataMin: axis.dataMin,\n      dataMax: axis.dataMax,\n      userMin: axis.userMin,\n      userMax: axis.userMax\n    };\n  }\n  /**\n   * Get the zero plane either based on zero or on the min or max value.\n   * Used in bar and area plots.\n   *\n   * @function Highcharts.Axis#getThreshold\n   *\n   * @param {number} threshold\n   * The threshold in axis values.\n   *\n   * @return {number}\n   * The translated threshold position in terms of pixels, and corrected to\n   * stay within the axis bounds.\n   */\n  getThreshold(threshold) {\n    const axis = this,\n      log = axis.logarithmic,\n      realMin = log ? log.lin2log(axis.min) : axis.min,\n      realMax = log ? log.lin2log(axis.max) : axis.max;\n    if (threshold === null || threshold === -Infinity) {\n      threshold = realMin;\n    } else if (threshold === Infinity) {\n      threshold = realMax;\n    } else if (realMin > threshold) {\n      threshold = realMin;\n    } else if (realMax < threshold) {\n      threshold = realMax;\n    }\n    return axis.translate(threshold, 0, 1, 0, 1);\n  }\n  /**\n   * Compute auto alignment for the axis label based on which side the axis is\n   * on and the given rotation for the label.\n   *\n   * @private\n   * @function Highcharts.Axis#autoLabelAlign\n   *\n   * @param {number} rotation\n   * The rotation in degrees as set by either the `rotation` or `autoRotation`\n   * options.\n   *\n   * @return {Highcharts.AlignValue}\n   * Can be `\"center\"`, `\"left\"` or `\"right\"`.\n   */\n  autoLabelAlign(rotation) {\n    const angle = (pick(rotation, 0) - this.side * 90 + 720) % 360,\n      evt = {\n        align: 'center'\n      };\n    fireEvent(this, 'autoLabelAlign', evt, function (e) {\n      if (angle > 15 && angle < 165) {\n        e.align = 'right';\n      } else if (angle > 195 && angle < 345) {\n        e.align = 'left';\n      }\n    });\n    return evt.align;\n  }\n  /**\n   * Get the tick length and width for the axis based on axis options.\n   *\n   * @private\n   * @function Highcharts.Axis#tickSize\n   *\n   * @param {string} [prefix]\n   * 'tick' or 'minorTick'\n   *\n   * @return {Array<number,number>|undefined}\n   * An array of tickLength and tickWidth\n   */\n  tickSize(prefix) {\n    const options = this.options,\n      tickWidth = pick(options[prefix === 'tick' ? 'tickWidth' : 'minorTickWidth'],\n      // Default to 1 on linear and datetime X axes\n      prefix === 'tick' && this.isXAxis && !this.categories ? 1 : 0);\n    let tickLength = options[prefix === 'tick' ? 'tickLength' : 'minorTickLength'],\n      tickSize;\n    if (tickWidth && tickLength) {\n      // Negate the length\n      if (options[prefix + 'Position'] === 'inside') {\n        tickLength = -tickLength;\n      }\n      tickSize = [tickLength, tickWidth];\n    }\n    const e = {\n      tickSize\n    };\n    fireEvent(this, 'afterTickSize', e);\n    return e.tickSize;\n  }\n  /**\n   * Return the size of the labels.\n   *\n   * @private\n   * @function Highcharts.Axis#labelMetrics\n   */\n  labelMetrics() {\n    const renderer = this.chart.renderer,\n      ticks = this.ticks,\n      tick = ticks[Object.keys(ticks)[0]] || {};\n    return this.chart.renderer.fontMetrics(tick.label || tick.movedLabel || renderer.box);\n  }\n  /**\n   * Prevent the ticks from getting so close we can't draw the labels. On a\n   * horizontal axis, this is handled by rotating the labels, removing ticks\n   * and adding ellipsis. On a vertical axis remove ticks and add ellipsis.\n   *\n   * @private\n   * @function Highcharts.Axis#unsquish\n   */\n  unsquish() {\n    const labelOptions = this.options.labels,\n      horiz = this.horiz,\n      tickInterval = this.tickInterval,\n      slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),\n      rotationOption = labelOptions.rotation,\n      // We don't know the actual rendered line height at this point, but\n      // it defaults to 0.75em\n      lineHeight = this.labelMetrics().h * 0.75,\n      range = Math.max(this.max - this.min, 0),\n      // Return the multiple of tickInterval that is needed to avoid\n      // collision\n      getStep = function (spaceNeeded) {\n        let step = spaceNeeded / (slotSize || 1);\n        step = step > 1 ? Math.ceil(step) : 1;\n        // Guard for very small or negative angles (#9835)\n        if (step * tickInterval > range && spaceNeeded !== Infinity && slotSize !== Infinity && range) {\n          step = Math.ceil(range / tickInterval);\n        }\n        return correctFloat(step * tickInterval);\n      };\n    let newTickInterval = tickInterval,\n      rotation,\n      bestScore = Number.MAX_VALUE,\n      autoRotation;\n    if (horiz) {\n      if (!labelOptions.staggerLines) {\n        if (isNumber(rotationOption)) {\n          autoRotation = [rotationOption];\n        } else if (slotSize < labelOptions.autoRotationLimit) {\n          autoRotation = labelOptions.autoRotation;\n        }\n      }\n      if (autoRotation) {\n        let step, score;\n        // Loop over the given autoRotation options, and determine which\n        // gives the best score. The best score is that with the lowest\n        // number of steps and a rotation closest to horizontal.\n        for (const rot of autoRotation) {\n          if (rot === rotationOption || rot && rot >= -90 && rot <= 90) {\n            // #3891\n            step = getStep(Math.abs(lineHeight / Math.sin(deg2rad * rot)));\n            score = step + Math.abs(rot / 360);\n            if (score < bestScore) {\n              bestScore = score;\n              rotation = rot;\n              newTickInterval = step;\n            }\n          }\n        }\n      }\n    } else {\n      // #4411\n      newTickInterval = getStep(lineHeight);\n    }\n    this.autoRotation = autoRotation;\n    this.labelRotation = pick(rotation, isNumber(rotationOption) ? rotationOption : 0);\n    return labelOptions.step ? tickInterval : newTickInterval;\n  }\n  /**\n   * Get the general slot width for labels/categories on this axis. This may\n   * change between the pre-render (from Axis.getOffset) and the final tick\n   * rendering and placement.\n   *\n   * @private\n   * @function Highcharts.Axis#getSlotWidth\n   *\n   * @param {Highcharts.Tick} [tick] Optionally, calculate the slot width\n   * basing on tick label. It is used in highcharts-3d module, where the slots\n   * has different widths depending on perspective angles.\n   *\n   * @return {number}\n   * The pixel width allocated to each axis label.\n   */\n  getSlotWidth(tick) {\n    // #5086, #1580, #1931\n    const chart = this.chart,\n      horiz = this.horiz,\n      labelOptions = this.options.labels,\n      slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n      marginLeft = chart.margin[3];\n    // Used by grid axis\n    if (tick && isNumber(tick.slotWidth)) {\n      // #13221, can be 0\n      return tick.slotWidth;\n    }\n    if (horiz && labelOptions.step < 2) {\n      if (labelOptions.rotation) {\n        // #4415\n        return 0;\n      }\n      return (this.staggerLines || 1) * this.len / slotCount;\n    }\n    if (!horiz) {\n      // #7028\n      const cssWidth = labelOptions.style.width;\n      if (cssWidth !== void 0) {\n        return parseInt(String(cssWidth), 10);\n      }\n      if (marginLeft) {\n        return marginLeft - chart.spacing[3];\n      }\n    }\n    // Last resort, a fraction of the available size\n    return chart.chartWidth * 0.33;\n  }\n  /**\n   * Render the axis labels and determine whether ellipsis or rotation need to\n   * be applied.\n   *\n   * @private\n   * @function Highcharts.Axis#renderUnsquish\n   */\n  renderUnsquish() {\n    const chart = this.chart,\n      renderer = chart.renderer,\n      tickPositions = this.tickPositions,\n      ticks = this.ticks,\n      labelOptions = this.options.labels,\n      labelStyleOptions = labelOptions.style,\n      horiz = this.horiz,\n      slotWidth = this.getSlotWidth(),\n      innerWidth = Math.max(1, Math.round(slotWidth - 2 * labelOptions.padding)),\n      attr = {},\n      labelMetrics = this.labelMetrics(),\n      textOverflowOption = labelStyleOptions.textOverflow;\n    let commonWidth,\n      commonTextOverflow,\n      maxLabelLength = 0,\n      label,\n      i,\n      pos;\n    // Set rotation option unless it is \"auto\", like in gauges\n    if (!isString(labelOptions.rotation)) {\n      // #4443\n      attr.rotation = labelOptions.rotation || 0;\n    }\n    // Get the longest label length\n    tickPositions.forEach(function (tickPosition) {\n      const tick = ticks[tickPosition];\n      // Replace label - sorting animation\n      if (tick.movedLabel) {\n        tick.replaceMovedLabel();\n      }\n      if (tick && tick.label && tick.label.textPxLength > maxLabelLength) {\n        maxLabelLength = tick.label.textPxLength;\n      }\n    });\n    this.maxLabelLength = maxLabelLength;\n    // Handle auto rotation on horizontal axis\n    if (this.autoRotation) {\n      // Apply rotation only if the label is too wide for the slot, and\n      // the label is wider than its height.\n      if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {\n        attr.rotation = this.labelRotation;\n      } else {\n        this.labelRotation = 0;\n      }\n      // Handle word-wrap or ellipsis on vertical axis\n    } else if (slotWidth) {\n      // For word-wrap or ellipsis\n      commonWidth = innerWidth;\n      if (!textOverflowOption) {\n        commonTextOverflow = 'clip';\n        // On vertical axis, only allow word wrap if there is room\n        // for more lines.\n        i = tickPositions.length;\n        while (!horiz && i--) {\n          pos = tickPositions[i];\n          label = ticks[pos].label;\n          if (label) {\n            // Reset ellipsis in order to get the correct\n            // bounding box (#4070)\n            if (label.styles && label.styles.textOverflow === 'ellipsis') {\n              label.css({\n                textOverflow: 'clip'\n              });\n              // Set the correct width in order to read\n              // the bounding box height (#4678, #5034)\n            } else if (label.textPxLength > slotWidth) {\n              label.css({\n                width: slotWidth + 'px'\n              });\n            }\n            if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {\n              label.specificTextOverflow = 'ellipsis';\n            }\n          }\n        }\n      }\n    }\n    // Add ellipsis if the label length is significantly longer than ideal\n    if (attr.rotation) {\n      commonWidth = maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : maxLabelLength;\n      if (!textOverflowOption) {\n        commonTextOverflow = 'ellipsis';\n      }\n    }\n    // Set the explicit or automatic label alignment\n    this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);\n    if (this.labelAlign) {\n      attr.align = this.labelAlign;\n    }\n    // Apply general and specific CSS\n    tickPositions.forEach(function (pos) {\n      const tick = ticks[pos],\n        label = tick && tick.label,\n        widthOption = labelStyleOptions.width,\n        css = {};\n      if (label) {\n        // This needs to go before the CSS in old IE (#4502)\n        label.attr(attr);\n        if (tick.shortenLabel) {\n          tick.shortenLabel();\n        } else if (commonWidth && !widthOption &&\n        // Setting width in this case messes with the bounding box\n        // (#7975)\n        labelStyleOptions.whiteSpace !== 'nowrap' && (\n        // Speed optimizing, #7656\n        commonWidth < label.textPxLength ||\n        // Resetting CSS, #4928\n        label.element.tagName === 'SPAN')) {\n          css.width = commonWidth + 'px';\n          if (!textOverflowOption) {\n            css.textOverflow = label.specificTextOverflow || commonTextOverflow;\n          }\n          label.css(css);\n          // Reset previously shortened label (#8210)\n        } else if (label.styles && label.styles.width && !css.width && !widthOption) {\n          label.css({\n            width: null\n          });\n        }\n        delete label.specificTextOverflow;\n        tick.rotation = attr.rotation;\n      }\n    }, this);\n    // Note: Why is this not part of getLabelPosition?\n    this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);\n  }\n  /**\n   * Return true if the axis has associated data.\n   *\n   * @function Highcharts.Axis#hasData\n   *\n   * @return {boolean}\n   * True if the axis has associated visible series and those series have\n   * either valid data points or explicit `min` and `max` settings.\n   */\n  hasData() {\n    return this.series.some(function (s) {\n      return s.hasData();\n    }) || this.options.showEmpty && defined(this.min) && defined(this.max);\n  }\n  /**\n   * Adds the title defined in axis.options.title.\n   *\n   * @function Highcharts.Axis#addTitle\n   *\n   * @param {boolean} [display]\n   * Whether or not to display the title.\n   */\n  addTitle(display) {\n    const axis = this,\n      renderer = axis.chart.renderer,\n      horiz = axis.horiz,\n      opposite = axis.opposite,\n      options = axis.options,\n      axisTitleOptions = options.title,\n      styledMode = axis.chart.styledMode;\n    let textAlign;\n    if (!axis.axisTitle) {\n      textAlign = axisTitleOptions.textAlign;\n      if (!textAlign) {\n        textAlign = (horiz ? {\n          low: 'left',\n          middle: 'center',\n          high: 'right'\n        } : {\n          low: opposite ? 'right' : 'left',\n          middle: 'center',\n          high: opposite ? 'left' : 'right'\n        })[axisTitleOptions.align];\n      }\n      axis.axisTitle = renderer.text(axisTitleOptions.text || '', 0, 0, axisTitleOptions.useHTML).attr({\n        zIndex: 7,\n        rotation: axisTitleOptions.rotation,\n        align: textAlign\n      }).addClass('highcharts-axis-title');\n      // #7814, don't mutate style option\n      if (!styledMode) {\n        axis.axisTitle.css(merge(axisTitleOptions.style));\n      }\n      axis.axisTitle.add(axis.axisGroup);\n      axis.axisTitle.isNew = true;\n    }\n    // Max width defaults to the length of the axis\n    if (!styledMode && !axisTitleOptions.style.width && !axis.isRadial) {\n      axis.axisTitle.css({\n        width: axis.len + 'px'\n      });\n    }\n    // hide or show the title depending on whether showEmpty is set\n    axis.axisTitle[display ? 'show' : 'hide'](display);\n  }\n  /**\n   * Generates a tick for initial positioning.\n   *\n   * @private\n   * @function Highcharts.Axis#generateTick\n   *\n   * @param {number} pos\n   * The tick position in axis values.\n   *\n   * @param {number} [i]\n   * The index of the tick in {@link Axis.tickPositions}.\n   */\n  generateTick(pos) {\n    const axis = this,\n      ticks = axis.ticks;\n    if (!ticks[pos]) {\n      ticks[pos] = new Tick(axis, pos);\n    } else {\n      ticks[pos].addLabel(); // update labels depending on tick interval\n    }\n  }\n  /**\n   * Render the tick labels to a preliminary position to get their sizes\n   *\n   * @private\n   * @function Highcharts.Axis#getOffset\n   *\n   * @emits Highcharts.Axis#event:afterGetOffset\n   */\n  getOffset() {\n    const axis = this,\n      {\n        chart,\n        horiz,\n        options,\n        side,\n        ticks,\n        tickPositions,\n        coll,\n        axisParent // Used in color axis\n      } = axis,\n      renderer = chart.renderer,\n      invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side,\n      hasData = axis.hasData(),\n      axisTitleOptions = options.title,\n      labelOptions = options.labels,\n      hasCrossing = isNumber(options.crossing),\n      axisOffset = chart.axisOffset,\n      clipOffset = chart.clipOffset,\n      directionFactor = [-1, 1, 1, -1][side],\n      className = options.className;\n    let showAxis,\n      titleOffset = 0,\n      titleOffsetOption,\n      titleMargin = 0,\n      labelOffset = 0,\n      // reset\n      labelOffsetPadded,\n      lineHeightCorrection;\n    // For reuse in Axis.render\n    axis.showAxis = showAxis = hasData || options.showEmpty;\n    // Set/reset staggerLines\n    axis.staggerLines = axis.horiz && labelOptions.staggerLines || void 0;\n    // Create the axisGroup and gridGroup elements on first iteration\n    if (!axis.axisGroup) {\n      const createGroup = (name, suffix, zIndex) => renderer.g(name).attr({\n        zIndex\n      }).addClass(`highcharts-${coll.toLowerCase()}${suffix} ` + (this.isRadial ? `highcharts-radial-axis${suffix} ` : '') + (className || '')).add(axisParent);\n      axis.gridGroup = createGroup('grid', '-grid', options.gridZIndex);\n      axis.axisGroup = createGroup('axis', '', options.zIndex);\n      axis.labelGroup = createGroup('axis-labels', '-labels', labelOptions.zIndex);\n    }\n    if (hasData || axis.isLinked) {\n      // Generate ticks\n      tickPositions.forEach(function (pos) {\n        // i is not used here, but may be used in overrides\n        axis.generateTick(pos);\n      });\n      axis.renderUnsquish();\n      // Left side must be align: right and right side must\n      // have align: left for labels\n      axis.reserveSpaceDefault = side === 0 || side === 2 || {\n        1: 'left',\n        3: 'right'\n      }[side] === axis.labelAlign;\n      if (pick(labelOptions.reserveSpace, hasCrossing ? false : null, axis.labelAlign === 'center' ? true : null, axis.reserveSpaceDefault)) {\n        tickPositions.forEach(function (pos) {\n          // get the highest offset\n          labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset);\n        });\n      }\n      if (axis.staggerLines) {\n        labelOffset *= axis.staggerLines;\n      }\n      axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);\n    } else {\n      // doesn't have data\n      objectEach(ticks, function (tick, n) {\n        tick.destroy();\n        delete ticks[n];\n      });\n    }\n    if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {\n      axis.addTitle(showAxis);\n      if (showAxis && !hasCrossing && axisTitleOptions.reserveSpace !== false) {\n        axis.titleOffset = titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n        titleOffsetOption = axisTitleOptions.offset;\n        titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);\n      }\n    }\n    // Render the axis line\n    axis.renderLine();\n    // handle automatic or user set offset\n    axis.offset = directionFactor * pick(options.offset, axisOffset[side] ? axisOffset[side] + (options.margin || 0) : 0);\n    axis.tickRotCorr = axis.tickRotCorr || {\n      x: 0,\n      y: 0\n    }; // polar\n    if (side === 0) {\n      lineHeightCorrection = -axis.labelMetrics().h;\n    } else if (side === 2) {\n      lineHeightCorrection = axis.tickRotCorr.y;\n    } else {\n      lineHeightCorrection = 0;\n    }\n    // Find the padded label offset\n    labelOffsetPadded = Math.abs(labelOffset) + titleMargin;\n    if (labelOffset) {\n      labelOffsetPadded -= lineHeightCorrection;\n      labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * labelOptions.distance) : pick(labelOptions.x, directionFactor * labelOptions.distance));\n    }\n    axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n    if (axis.getMaxLabelDimensions) {\n      axis.maxLabelDimensions = axis.getMaxLabelDimensions(ticks, tickPositions);\n    }\n    // Due to GridAxis.tickSize, tickSize should be calculated after ticks\n    // has rendered.\n    if (coll !== 'colorAxis') {\n      const tickSize = this.tickSize('tick');\n      axisOffset[side] = Math.max(axisOffset[side], (axis.axisTitleMargin || 0) + titleOffset + directionFactor * axis.offset, labelOffsetPadded,\n      // #3027\n      tickPositions && tickPositions.length && tickSize ? tickSize[0] + directionFactor * axis.offset : 0 // #4866\n      );\n      // Decide the clipping needed to keep the graph inside\n      // the plot area and axis lines\n      const clip = !axis.axisLine || options.offset ? 0 :\n      // #4308, #4371:\n      Math.floor(axis.axisLine.strokeWidth() / 2) * 2;\n      clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);\n    }\n    fireEvent(this, 'afterGetOffset');\n  }\n  /**\n   * Internal function to get the path for the axis line. Extended for polar\n   * charts.\n   *\n   * @function Highcharts.Axis#getLinePath\n   *\n   * @param {number} lineWidth\n   * The line width in pixels.\n   *\n   * @return {Highcharts.SVGPathArray}\n   * The SVG path definition in array form.\n   */\n  getLinePath(lineWidth) {\n    const chart = this.chart,\n      opposite = this.opposite,\n      offset = this.offset,\n      horiz = this.horiz,\n      lineLeft = this.left + (opposite ? this.width : 0) + offset,\n      lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;\n    if (opposite) {\n      lineWidth *= -1; // crispify the other way - #1480, #1687\n    }\n\n    return chart.renderer.crispLine([['M', horiz ? this.left : lineLeft, horiz ? lineTop : this.top], ['L', horiz ? chart.chartWidth - this.right : lineLeft, horiz ? lineTop : chart.chartHeight - this.bottom]], lineWidth);\n  }\n  /**\n   * Render the axis line. Called internally when rendering and redrawing the\n   * axis.\n   *\n   * @function Highcharts.Axis#renderLine\n   */\n  renderLine() {\n    if (!this.axisLine) {\n      this.axisLine = this.chart.renderer.path().addClass('highcharts-axis-line').add(this.axisGroup);\n      if (!this.chart.styledMode) {\n        this.axisLine.attr({\n          stroke: this.options.lineColor,\n          'stroke-width': this.options.lineWidth,\n          zIndex: 7\n        });\n      }\n    }\n  }\n  /**\n   * Position the axis title.\n   *\n   * @private\n   * @function Highcharts.Axis#getTitlePosition\n   *\n   * @return {Highcharts.PositionObject}\n   * X and Y positions for the title.\n   */\n  getTitlePosition(axisTitle) {\n    // compute anchor points for each of the title align options\n    const horiz = this.horiz,\n      axisLeft = this.left,\n      axisTop = this.top,\n      axisLength = this.len,\n      axisTitleOptions = this.options.title,\n      margin = horiz ? axisLeft : axisTop,\n      opposite = this.opposite,\n      offset = this.offset,\n      xOption = axisTitleOptions.x,\n      yOption = axisTitleOptions.y,\n      fontMetrics = this.chart.renderer.fontMetrics(axisTitle),\n      // The part of a multiline text that is below the baseline of the\n      // first line. Subtract 1 to preserve pixel-perfectness from the\n      // old behaviour (v5.0.12), where only one line was allowed.\n      textHeightOvershoot = axisTitle ? Math.max(axisTitle.getBBox(false, 0).height - fontMetrics.h - 1, 0) : 0,\n      // the position in the length direction of the axis\n      alongAxis = {\n        low: margin + (horiz ? 0 : axisLength),\n        middle: margin + axisLength / 2,\n        high: margin + (horiz ? axisLength : 0)\n      }[axisTitleOptions.align],\n      // the position in the perpendicular direction of the axis\n      offAxis = (horiz ? axisTop + this.height : axisLeft) + (horiz ? 1 : -1) * (\n      // horizontal axis reverses the margin\n      opposite ? -1 : 1) * (\n      // so does opposite axes\n      this.axisTitleMargin || 0) + [-textHeightOvershoot, textHeightOvershoot, fontMetrics.f, -textHeightOvershoot // left\n      ][this.side],\n      titlePosition = {\n        x: horiz ? alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset + xOption,\n        y: horiz ? offAxis + yOption - (opposite ? this.height : 0) + offset : alongAxis + yOption\n      };\n    fireEvent(this, 'afterGetTitlePosition', {\n      titlePosition: titlePosition\n    });\n    return titlePosition;\n  }\n  /**\n   * Render a minor tick into the given position. If a minor tick already\n   * exists in this position, move it.\n   *\n   * @function Highcharts.Axis#renderMinorTick\n   *\n   * @param {number} pos\n   * The position in axis values.\n   *\n   * @param {boolean} slideIn\n   * Whether the tick should animate in from last computed position\n   */\n  renderMinorTick(pos, slideIn) {\n    const axis = this;\n    const minorTicks = axis.minorTicks;\n    if (!minorTicks[pos]) {\n      minorTicks[pos] = new Tick(axis, pos, 'minor');\n    }\n    // Render new ticks in old position\n    if (slideIn && minorTicks[pos].isNew) {\n      minorTicks[pos].render(null, true);\n    }\n    minorTicks[pos].render(null, false, 1);\n  }\n  /**\n   * Render a major tick into the given position. If a tick already exists\n   * in this position, move it.\n   *\n   * @function Highcharts.Axis#renderTick\n   *\n   * @param {number} pos\n   * The position in axis values.\n   *\n   * @param {number} i\n   * The tick index.\n   *\n   * @param {boolean} slideIn\n   * Whether the tick should animate in from last computed position\n   */\n  renderTick(pos, i, slideIn) {\n    const axis = this,\n      isLinked = axis.isLinked,\n      ticks = axis.ticks;\n    // Linked axes need an extra check to find out if\n    if (!isLinked || pos >= axis.min && pos <= axis.max || axis.grid && axis.grid.isColumn) {\n      if (!ticks[pos]) {\n        ticks[pos] = new Tick(axis, pos);\n      }\n      // NOTE this seems like overkill. Could be handled in tick.render by\n      // setting old position in attr, then set new position in animate.\n      // render new ticks in old position\n      if (slideIn && ticks[pos].isNew) {\n        // Start with negative opacity so that it is visible from\n        // halfway into the animation\n        ticks[pos].render(i, true, -1);\n      }\n      ticks[pos].render(i);\n    }\n  }\n  /**\n   * Render the axis.\n   *\n   * @private\n   * @function Highcharts.Axis#render\n   *\n   * @emits Highcharts.Axis#event:afterRender\n   */\n  render() {\n    const axis = this,\n      chart = axis.chart,\n      log = axis.logarithmic,\n      renderer = chart.renderer,\n      options = axis.options,\n      isLinked = axis.isLinked,\n      tickPositions = axis.tickPositions,\n      axisTitle = axis.axisTitle,\n      ticks = axis.ticks,\n      minorTicks = axis.minorTicks,\n      alternateBands = axis.alternateBands,\n      stackLabelOptions = options.stackLabels,\n      alternateGridColor = options.alternateGridColor,\n      crossing = options.crossing,\n      tickmarkOffset = axis.tickmarkOffset,\n      axisLine = axis.axisLine,\n      showAxis = axis.showAxis,\n      animation = animObject(renderer.globalAnimation);\n    let from, to;\n    // Reset\n    axis.labelEdge.length = 0;\n    axis.overlap = false;\n    // Mark all elements inActive before we go over and mark the active ones\n    [ticks, minorTicks, alternateBands].forEach(function (coll) {\n      objectEach(coll, function (tick) {\n        tick.isActive = false;\n      });\n    });\n    // Crossing\n    if (isNumber(crossing)) {\n      const otherAxis = this.isXAxis ? chart.yAxis[0] : chart.xAxis[0],\n        directionFactor = [1, -1, -1, 1][this.side];\n      if (otherAxis) {\n        let px = otherAxis.toPixels(crossing, true);\n        if (axis.horiz) {\n          px = otherAxis.len - px;\n        }\n        axis.offset = directionFactor * px;\n      }\n    }\n    // If the series has data draw the ticks. Else only the line and title\n    if (axis.hasData() || isLinked) {\n      const slideInTicks = axis.chart.hasRendered && axis.old && isNumber(axis.old.min);\n      // minor ticks\n      if (axis.minorTickInterval && !axis.categories) {\n        axis.getMinorTickPositions().forEach(function (pos) {\n          axis.renderMinorTick(pos, slideInTicks);\n        });\n      }\n      // Major ticks. Pull out the first item and render it last so that\n      // we can get the position of the neighbour label. #808.\n      if (tickPositions.length) {\n        // #1300\n        tickPositions.forEach(function (pos, i) {\n          axis.renderTick(pos, i, slideInTicks);\n        });\n        // In a categorized axis, the tick marks are displayed\n        // between labels. So we need to add a tick mark and\n        // grid line at the left edge of the X axis.\n        if (tickmarkOffset && (axis.min === 0 || axis.single)) {\n          if (!ticks[-1]) {\n            ticks[-1] = new Tick(axis, -1, null, true);\n          }\n          ticks[-1].render(-1);\n        }\n      }\n      // alternate grid color\n      if (alternateGridColor) {\n        tickPositions.forEach(function (pos, i) {\n          to = typeof tickPositions[i + 1] !== 'undefined' ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;\n          if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {\n            // #2248, #4660\n            if (!alternateBands[pos]) {\n              // Should be imported from PlotLineOrBand.js, but\n              // the dependency cycle with axis is a problem\n              alternateBands[pos] = new H.PlotLineOrBand(axis);\n            }\n            from = pos + tickmarkOffset; // #949\n            alternateBands[pos].options = {\n              from: log ? log.lin2log(from) : from,\n              to: log ? log.lin2log(to) : to,\n              color: alternateGridColor,\n              className: 'highcharts-alternate-grid'\n            };\n            alternateBands[pos].render();\n            alternateBands[pos].isActive = true;\n          }\n        });\n      }\n      // custom plot lines and bands\n      if (!axis._addedPlotLB) {\n        // only first time\n        axis._addedPlotLB = true;\n        (options.plotLines || []).concat(options.plotBands || []).forEach(function (plotLineOptions) {\n          axis.addPlotBandOrLine(plotLineOptions);\n        });\n      }\n    } // end if hasData\n    // Remove inactive ticks\n    [ticks, minorTicks, alternateBands].forEach(function (coll) {\n      const forDestruction = [],\n        delay = animation.duration,\n        destroyInactiveItems = function () {\n          let i = forDestruction.length;\n          while (i--) {\n            // When resizing rapidly, the same items\n            // may be destroyed in different timeouts,\n            // or the may be reactivated\n            if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {\n              coll[forDestruction[i]].destroy();\n              delete coll[forDestruction[i]];\n            }\n          }\n        };\n      objectEach(coll, function (tick, pos) {\n        if (!tick.isActive) {\n          // Render to zero opacity\n          tick.render(pos, false, 0);\n          tick.isActive = false;\n          forDestruction.push(pos);\n        }\n      });\n      // When the objects are finished fading out, destroy them\n      syncTimeout(destroyInactiveItems, coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay);\n    });\n    // Set the axis line path\n    if (axisLine) {\n      axisLine[axisLine.isPlaced ? 'animate' : 'attr']({\n        d: this.getLinePath(axisLine.strokeWidth())\n      });\n      axisLine.isPlaced = true;\n      // Show or hide the line depending on options.showEmpty\n      axisLine[showAxis ? 'show' : 'hide'](showAxis);\n    }\n    if (axisTitle && showAxis) {\n      axisTitle[axisTitle.isNew ? 'attr' : 'animate'](axis.getTitlePosition(axisTitle));\n      axisTitle.isNew = false;\n    }\n    // Stacked totals:\n    if (stackLabelOptions && stackLabelOptions.enabled && axis.stacking) {\n      axis.stacking.renderStackTotals();\n    }\n    // End stacked totals\n    // Record old scaling for updating/animation\n    axis.old = {\n      len: axis.len,\n      max: axis.max,\n      min: axis.min,\n      transA: axis.transA,\n      userMax: axis.userMax,\n      userMin: axis.userMin\n    };\n    axis.isDirty = false;\n    fireEvent(this, 'afterRender');\n  }\n  /**\n   * Redraw the axis to reflect changes in the data or axis extremes. Called\n   * internally from Highcharts.Chart#redraw.\n   *\n   * @private\n   * @function Highcharts.Axis#redraw\n   */\n  redraw() {\n    if (this.visible) {\n      // render the axis\n      this.render();\n      // move plot lines and bands\n      this.plotLinesAndBands.forEach(function (plotLine) {\n        plotLine.render();\n      });\n    }\n    // mark associated series as dirty and ready for redraw\n    this.series.forEach(function (series) {\n      series.isDirty = true;\n    });\n  }\n  /**\n   * Returns an array of axis properties, that should be untouched during\n   * reinitialization.\n   *\n   * @private\n   * @function Highcharts.Axis#getKeepProps\n   */\n  getKeepProps() {\n    return this.keepProps || Axis.keepProps;\n  }\n  /**\n   * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint\n   * to fully remove the axis.\n   *\n   * @private\n   * @function Highcharts.Axis#destroy\n   *\n   * @param {boolean} [keepEvents]\n   * Whether to preserve events, used internally in Axis.update.\n   */\n  destroy(keepEvents) {\n    const axis = this,\n      plotLinesAndBands = axis.plotLinesAndBands,\n      eventOptions = this.eventOptions;\n    fireEvent(this, 'destroy', {\n      keepEvents: keepEvents\n    });\n    // Remove the events\n    if (!keepEvents) {\n      removeEvent(axis);\n    }\n    // Destroy collections\n    [axis.ticks, axis.minorTicks, axis.alternateBands].forEach(function (coll) {\n      destroyObjectProperties(coll);\n    });\n    if (plotLinesAndBands) {\n      let i = plotLinesAndBands.length;\n      while (i--) {\n        // #1975\n        plotLinesAndBands[i].destroy();\n      }\n    }\n    // Destroy elements\n    ['axisLine', 'axisTitle', 'axisGroup', 'gridGroup', 'labelGroup', 'cross', 'scrollbar'].forEach(function (prop) {\n      if (axis[prop]) {\n        axis[prop] = axis[prop].destroy();\n      }\n    });\n    // Destroy each generated group for plotlines and plotbands\n    for (const plotGroup in axis.plotLinesAndBandsGroups) {\n      // eslint-disable-line guard-for-in\n      axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();\n    }\n    // Delete all properties and fall back to the prototype.\n    objectEach(axis, function (val, key) {\n      if (axis.getKeepProps().indexOf(key) === -1) {\n        delete axis[key];\n      }\n    });\n    this.eventOptions = eventOptions;\n  }\n  /**\n   * Internal function to draw a crosshair.\n   *\n   * @function Highcharts.Axis#drawCrosshair\n   *\n   * @param {Highcharts.PointerEventObject} [e]\n   * The event arguments from the modified pointer event, extended with\n   * `chartX` and `chartY`\n   *\n   * @param {Highcharts.Point} [point]\n   * The Point object if the crosshair snaps to points.\n   *\n   * @emits Highcharts.Axis#event:afterDrawCrosshair\n   * @emits Highcharts.Axis#event:drawCrosshair\n   */\n  drawCrosshair(e, point) {\n    const options = this.crosshair,\n      snap = pick(options && options.snap, true),\n      chart = this.chart;\n    let path,\n      pos,\n      categorized,\n      graphic = this.cross,\n      crossOptions;\n    fireEvent(this, 'drawCrosshair', {\n      e: e,\n      point: point\n    });\n    // Use last available event when updating non-snapped crosshairs without\n    // mouse interaction (#5287)\n    if (!e) {\n      e = this.cross && this.cross.e;\n    }\n    if (\n    // Disabled in options\n    !options ||\n    // Snap\n    (defined(point) || !snap) === false) {\n      this.hideCrosshair();\n    } else {\n      // Get the path\n      if (!snap) {\n        pos = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);\n      } else if (defined(point)) {\n        // #3834\n        pos = pick(this.coll !== 'colorAxis' ? point.crosshairPos :\n        // 3D axis extension\n        null, this.isXAxis ? point.plotX : this.len - point.plotY);\n      }\n      if (defined(pos)) {\n        crossOptions = {\n          // value, only used on radial\n          value: point && (this.isXAxis ? point.x : pick(point.stackY, point.y)),\n          translatedValue: pos\n        };\n        if (chart.polar) {\n          // Additional information required for crosshairs in\n          // polar chart\n          extend(crossOptions, {\n            isCrosshair: true,\n            chartX: e && e.chartX,\n            chartY: e && e.chartY,\n            point: point\n          });\n        }\n        path = this.getPlotLinePath(crossOptions) || null; // #3189\n      }\n\n      if (!defined(path)) {\n        this.hideCrosshair();\n        return;\n      }\n      categorized = this.categories && !this.isRadial;\n      // Draw the cross\n      if (!graphic) {\n        this.cross = graphic = chart.renderer.path().addClass('highcharts-crosshair highcharts-crosshair-' + (categorized ? 'category ' : 'thin ') + (options.className || '')).attr({\n          zIndex: pick(options.zIndex, 2)\n        }).add();\n        // Presentational attributes\n        if (!chart.styledMode) {\n          graphic.attr({\n            stroke: options.color || (categorized ? Color.parse(\"#ccd3ff\" /* Palette.highlightColor20 */).setOpacity(0.25).get() : \"#cccccc\" /* Palette.neutralColor20 */),\n            'stroke-width': pick(options.width, 1)\n          }).css({\n            'pointer-events': 'none'\n          });\n          if (options.dashStyle) {\n            graphic.attr({\n              dashstyle: options.dashStyle\n            });\n          }\n        }\n      }\n      graphic.show().attr({\n        d: path\n      });\n      if (categorized && !options.width) {\n        graphic.attr({\n          'stroke-width': this.transA\n        });\n      }\n      this.cross.e = e;\n    }\n    fireEvent(this, 'afterDrawCrosshair', {\n      e: e,\n      point: point\n    });\n  }\n  /**\n   * Hide the crosshair if visible.\n   *\n   * @function Highcharts.Axis#hideCrosshair\n   */\n  hideCrosshair() {\n    if (this.cross) {\n      this.cross.hide();\n    }\n    fireEvent(this, 'afterHideCrosshair');\n  }\n  /**\n   * Check whether the chart has vertical panning ('y' or 'xy' type).\n   *\n   * @private\n   * @function Highcharts.Axis#hasVerticalPanning\n   */\n  hasVerticalPanning() {\n    const panningOptions = this.chart.options.chart.panning;\n    return Boolean(panningOptions && panningOptions.enabled &&\n    // #14624\n    /y/.test(panningOptions.type));\n  }\n  /**\n   * Update an axis object with a new set of options. The options are merged\n   * with the existing options, so only new or altered options need to be\n   * specified.\n   *\n   * @sample highcharts/members/axis-update/\n   *         Axis update demo\n   *\n   * @function Highcharts.Axis#update\n   *\n   * @param {Highcharts.AxisOptions} options\n   * The new options that will be merged in with existing options on the axis.\n   *\n   * @param {boolean} [redraw=true]\n   * Whether to redraw the chart after the axis is altered. If doing more\n   * operations on the chart, it is a good idea to set redraw to false and\n   * call {@link Chart#redraw} after.\n   */\n  update(options, redraw) {\n    const chart = this.chart;\n    options = merge(this.userOptions, options);\n    this.destroy(true);\n    this.init(chart, options);\n    chart.isDirtyBox = true;\n    if (pick(redraw, true)) {\n      chart.redraw();\n    }\n  }\n  /**\n   * Remove the axis from the chart.\n   *\n   * @sample highcharts/members/chart-addaxis/\n   *         Add and remove axes\n   *\n   * @function Highcharts.Axis#remove\n   *\n   * @param {boolean} [redraw=true]\n   * Whether to redraw the chart following the remove.\n   */\n  remove(redraw) {\n    const chart = this.chart,\n      coll = this.coll,\n      axisSeries = this.series;\n    let i = axisSeries.length;\n    // Remove associated series (#2687)\n    while (i--) {\n      if (axisSeries[i]) {\n        axisSeries[i].remove(false);\n      }\n    }\n    // Remove the axis\n    erase(chart.axes, this);\n    erase(chart[coll] || [], this);\n    chart.orderItems(coll);\n    this.destroy();\n    chart.isDirtyBox = true;\n    if (pick(redraw, true)) {\n      chart.redraw();\n    }\n  }\n  /**\n   * Update the axis title by options after render time.\n   *\n   * @sample highcharts/members/axis-settitle/\n   *         Set a new Y axis title\n   *\n   * @function Highcharts.Axis#setTitle\n   *\n   * @param {Highcharts.AxisTitleOptions} titleOptions\n   * The additional title options.\n   *\n   * @param {boolean} [redraw=true]\n   * Whether to redraw the chart after setting the title.\n   */\n  setTitle(titleOptions, redraw) {\n    this.update({\n      title: titleOptions\n    }, redraw);\n  }\n  /**\n   * Set new axis categories and optionally redraw.\n   *\n   * @sample highcharts/members/axis-setcategories/\n   *         Set categories by click on a button\n   *\n   * @function Highcharts.Axis#setCategories\n   *\n   * @param {Array<string>} categories\n   * The new categories.\n   *\n   * @param {boolean} [redraw=true]\n   * Whether to redraw the chart.\n   */\n  setCategories(categories, redraw) {\n    this.update({\n      categories: categories\n    }, redraw);\n  }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nAxis.defaultOptions = AxisDefaults.defaultXAxisOptions;\n// Properties to survive after destroy, needed for Axis.update (#4317,\n// #5773, #5881).\nAxis.keepProps = ['coll', 'extKey', 'hcEvents', 'names', 'series', 'userMax', 'userMin'];\n/* *\n *\n *  Default Export\n *\n * */\nexport default Axis;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Options for the path on the Axis to be calculated.\n * @interface Highcharts.AxisPlotLinePathOptionsObject\n */ /**\n    * Axis value.\n    * @name Highcharts.AxisPlotLinePathOptionsObject#value\n    * @type {number|undefined}\n    */ /**\n       * Line width used for calculation crisp line coordinates. Defaults to 1.\n       * @name Highcharts.AxisPlotLinePathOptionsObject#lineWidth\n       * @type {number|undefined}\n       */ /**\n          * If `false`, the function will return null when it falls outside the axis\n          * bounds. If `true`, the function will return a path aligned to the plot area\n          * sides if it falls outside. If `pass`, it will return a path outside.\n          * @name Highcharts.AxisPlotLinePathOptionsObject#force\n          * @type {string|boolean|undefined}\n          */ /**\n             * Used in Highcharts Stock. When `true`, plot paths\n             * (crosshair, plotLines, gridLines)\n             * will be rendered on all axes when defined on the first axis.\n             * @name Highcharts.AxisPlotLinePathOptionsObject#acrossPanes\n             * @type {boolean|undefined}\n             */ /**\n                * Use old coordinates (for resizing and rescaling).\n                * If not set, defaults to `false`.\n                * @name Highcharts.AxisPlotLinePathOptionsObject#old\n                * @type {boolean|undefined}\n                */ /**\n                   * If given, return the plot line path of a pixel position on the axis.\n                   * @name Highcharts.AxisPlotLinePathOptionsObject#translatedValue\n                   * @type {number|undefined}\n                   */ /**\n                      * Used in Polar axes. Reverse the positions for concatenation of polygonal\n                      * plot bands\n                      * @name Highcharts.AxisPlotLinePathOptionsObject#reverse\n                      * @type {boolean|undefined}\n                      */\n/**\n * Options for crosshairs on axes.\n *\n * @product highstock\n *\n * @typedef {Highcharts.XAxisCrosshairOptions|Highcharts.YAxisCrosshairOptions} Highcharts.AxisCrosshairOptions\n */\n/**\n * @typedef {\"navigator\"|\"pan\"|\"rangeSelectorButton\"|\"rangeSelectorInput\"|\"scrollbar\"|\"traverseUpButton\"|\"zoom\"} Highcharts.AxisExtremesTriggerValue\n */\n/**\n * @callback Highcharts.AxisEventCallbackFunction\n *\n * @param {Highcharts.Axis} this\n */\n/**\n * @callback Highcharts.AxisLabelsFormatterCallbackFunction\n *\n * @param {Highcharts.AxisLabelsFormatterContextObject} this\n *\n * @param {Highcharts.AxisLabelsFormatterContextObject} ctx\n *\n * @return {string}\n */\n/**\n * @interface Highcharts.AxisLabelsFormatterContextObject\n */ /**\n    * The axis item of the label\n    * @name Highcharts.AxisLabelsFormatterContextObject#axis\n    * @type {Highcharts.Axis}\n    */ /**\n       * The chart instance.\n       * @name Highcharts.AxisLabelsFormatterContextObject#chart\n       * @type {Highcharts.Chart}\n       */ /**\n          * Default formatting of date/time labels.\n          * @name Highcharts.AxisLabelsFormatterContextObject#dateTimeLabelFormat\n          * @type {string|undefined}\n          */ /**\n             * Whether the label belongs to the first tick on the axis.\n             * @name Highcharts.AxisLabelsFormatterContextObject#isFirst\n             * @type {boolean}\n             */ /**\n                * Whether the label belongs to the last tick on the axis.\n                * @name Highcharts.AxisLabelsFormatterContextObject#isLast\n                * @type {boolean}\n                */ /**\n                   * The position on the axis in terms of axis values. For category axes, a\n                   * zero-based index. For datetime axes, the JavaScript time in milliseconds\n                   * since 1970.\n                   * @name Highcharts.AxisLabelsFormatterContextObject#pos\n                   * @type {number}\n                   */ /**\n                      * The preformatted text as the result of the default formatting. For example\n                      * dates will be formatted as strings, and numbers with language-specific comma\n                      * separators, thousands separators and numeric symbols like `k` or `M`.\n                      * @name Highcharts.AxisLabelsFormatterContextObject#text\n                      * @type {string|undefined}\n                      */ /**\n                         * The Tick instance.\n                         * @name Highcharts.AxisLabelsFormatterContextObject#tick\n                         * @type {Highcharts.Tick}\n                         */ /**\n                            * This can be either a numeric value or a category string.\n                            * @name Highcharts.AxisLabelsFormatterContextObject#value\n                            * @type {number|string}\n                            */\n/**\n * Options for axes.\n *\n * @typedef {Highcharts.XAxisOptions|Highcharts.YAxisOptions|Highcharts.ZAxisOptions} Highcharts.AxisOptions\n */\n/**\n * @callback Highcharts.AxisPointBreakEventCallbackFunction\n *\n * @param {Highcharts.Axis} this\n *\n * @param {Highcharts.AxisPointBreakEventObject} evt\n */\n/**\n * @interface Highcharts.AxisPointBreakEventObject\n */ /**\n    * @name Highcharts.AxisPointBreakEventObject#brk\n    * @type {Highcharts.Dictionary<number>}\n    */ /**\n       * @name Highcharts.AxisPointBreakEventObject#point\n       * @type {Highcharts.Point}\n       */ /**\n          * @name Highcharts.AxisPointBreakEventObject#preventDefault\n          * @type {Function}\n          */ /**\n             * @name Highcharts.AxisPointBreakEventObject#target\n             * @type {Highcharts.SVGElement}\n             */ /**\n                * @name Highcharts.AxisPointBreakEventObject#type\n                * @type {\"pointBreak\"|\"pointInBreak\"}\n                */\n/**\n * @callback Highcharts.AxisSetExtremesEventCallbackFunction\n *\n * @param {Highcharts.Axis} this\n *\n * @param {Highcharts.AxisSetExtremesEventObject} evt\n */\n/**\n * @interface Highcharts.AxisSetExtremesEventObject\n * @extends Highcharts.ExtremesObject\n */ /**\n    * @name Highcharts.AxisSetExtremesEventObject#preventDefault\n    * @type {Function}\n    */ /**\n       * @name Highcharts.AxisSetExtremesEventObject#target\n       * @type {Highcharts.SVGElement}\n       */ /**\n          * @name Highcharts.AxisSetExtremesEventObject#trigger\n          * @type {Highcharts.AxisExtremesTriggerValue|string}\n          */ /**\n             * @name Highcharts.AxisSetExtremesEventObject#type\n             * @type {\"setExtremes\"}\n             */\n/**\n * @callback Highcharts.AxisTickPositionerCallbackFunction\n *\n * @param {Highcharts.Axis} this\n *\n * @return {Highcharts.AxisTickPositionsArray}\n */\n/**\n * @interface Highcharts.AxisTickPositionsArray\n * @augments Array<number>\n */\n/**\n * @typedef {\"high\"|\"low\"|\"middle\"} Highcharts.AxisTitleAlignValue\n */\n/**\n * @typedef {Highcharts.XAxisTitleOptions|Highcharts.YAxisTitleOptions|Highcharts.ZAxisTitleOptions} Highcharts.AxisTitleOptions\n */\n/**\n * @typedef {\"linear\"|\"logarithmic\"|\"datetime\"|\"category\"|\"treegrid\"} Highcharts.AxisTypeValue\n */\n/**\n * The returned object literal from the {@link Highcharts.Axis#getExtremes}\n * function.\n *\n * @interface Highcharts.ExtremesObject\n */ /**\n    * The maximum value of the axis' associated series.\n    * @name Highcharts.ExtremesObject#dataMax\n    * @type {number}\n    */ /**\n       * The minimum value of the axis' associated series.\n       * @name Highcharts.ExtremesObject#dataMin\n       * @type {number}\n       */ /**\n          * The maximum axis value, either automatic or set manually. If the `max` option\n          * is not set, `maxPadding` is 0 and `endOnTick` is false, this value will be\n          * the same as `dataMax`.\n          * @name Highcharts.ExtremesObject#max\n          * @type {number}\n          */ /**\n             * The minimum axis value, either automatic or set manually. If the `min` option\n             * is not set, `minPadding` is 0 and `startOnTick` is false, this value will be\n             * the same as `dataMin`.\n             * @name Highcharts.ExtremesObject#min\n             * @type {number}\n             */ /**\n                * The user defined maximum, either from the `max` option or from a zoom or\n                * `setExtremes` action.\n                * @name Highcharts.ExtremesObject#userMax\n                * @type {number|undefined}\n                */ /**\n                   * The user defined minimum, either from the `min` option or from a zoom or\n                   * `setExtremes` action.\n                   * @name Highcharts.ExtremesObject#userMin\n                   * @type {number|undefined}\n                   */\n/**\n * Formatter function for the text of a crosshair label.\n *\n * @callback Highcharts.XAxisCrosshairLabelFormatterCallbackFunction\n *\n * @param {Highcharts.Axis} this\n * Axis context\n *\n * @param {number} value\n * Y value of the data point\n *\n * @return {string}\n */\n''; // keeps doclets above in JS file","map":{"version":3,"names":["A","animObject","AxisDefaults","Color","D","defaultOptions","F","registerEventOptions","H","deg2rad","Tick","U","arrayMax","arrayMin","clamp","correctFloat","defined","destroyObjectProperties","erase","error","extend","fireEvent","getClosestDistance","insertItem","isArray","isNumber","isString","merge","normalizeTickInterval","objectEach","pick","relativeLength","removeEvent","splat","syncTimeout","getNormalizedTickInterval","axis","tickInterval","options","allowDecimals","tickAmount","Axis","constructor","chart","userOptions","coll","alternateBands","bottom","closestPointRange","eventOptions","hasNames","hasVisibleSeries","height","index","isLinked","labelEdge","labelFormatter","left","len","max","maxLabelLength","min","minorTickInterval","minorTicks","minPixelPadding","names","offset","overlap","paddedTicks","plotLinesAndBands","plotLinesAndBandsGroups","pointRange","pointRangePadding","pos","positiveValuesOnly","right","series","side","tickmarkOffset","tickPositions","tickRotCorr","ticks","top","transA","transB","translationSlope","visible","width","zoomEnabled","init","isXAxis","horiz","isZAxis","inverted","opposite","setOptions","labelsOptions","labels","type","reversed","categories","keys","logarithmic","linkedTo","minRange","userMinRange","maxZoom","range","crosshair","tooltip","crosshairs","axes","indexOf","splice","xAxis","length","push","orderItems","labelRotation","rotation","defaultXAxisOptions","defaultYAxisOptions","defaultTopAxisOptions","defaultRightAxisOptions","defaultBottomAxisOptions","defaultLeftAxisOptions","defaultLabelFormatter","ctx","numberFormatter","value","NaN","time","dateTimeLabelFormat","lang","numericSymbols","numSymMagnitude","numericSymbolMagnitude","numericSymbolDetector","Math","abs","i","multi","ret","dateFormat","pow","getSeriesExtremes","xExtremes","dataMin","dataMax","threshold","softThreshold","forEach","reserveSpace","seriesOptions","xData","seriesDataMin","seriesDataMax","filter","x","getXExtremes","Date","dataExtremes","applyExtremes","translate","val","backwards","cvsCoord","old","handleLog","pointPlacement","linkedParent","localMin","doPostTranslate","isOrdinal","brokenAxis","hasBreaks","lin2val","sign","cvsOffset","localA","returnValue","sector","val2lin","isRadial","toPixels","paneCoordinates","toValue","pixel","getPlotLinePath","axisLeft","axisTop","lineWidth","cHeight","oldChartHeight","chartHeight","cWidth","oldChartWidth","chartWidth","translatedValue","force","x1","y1","x2","y2","skip","between","a","b","evt","acrossPanes","e","round","path","renderer","crispLine","getLinearTickPositions","roundedMin","floor","roundedMax","ceil","lastPos","precision","single","getMinorTickInterval","getMinorTickPositions","minorTickPositions","_pos","apply","getLogTickPositions","dateTime","concat","getTimeTicks","normalizeTimeTickInterval","startOfWeek","trimTicks","adjustForMinRange","zoomOffset","spaceAvailable","closestDataRange","minArgs","maxArgs","ceiling","map","s","xIncrement","slice","log2lin","getClosest","closestSingleDistance","closestDistance","singleXs","seriesClosest","noSharedTooltip","sort","nameToX","point","explicitCategories","nameX","requireSorting","uniqueNames","name","autoIncrement","updateNames","Object","key","points","isDirtyData","processData","generatePoints","data","setAxisTranslation","hasCategories","axisPointRange","minPointOffset","ordinalCorrection","seriesPointRange","isPointPlacementAxis","is","ordinal","slope","staticScale","minFromRange","setTickInterval","secondPass","log","tickPixelIntervalOption","tickPixelInterval","maxPadding","minPadding","linkedParentExtremes","tickIntervalOption","thresholdMin","thresholdMax","hardMin","hardMax","getTickAmount","userMin","userMax","getExtremes","beforePadding","softMin","softMax","stacking","usePercentage","polar","hasExtremesChanged","forceCrop","forceCropping","minTickInterval","some","unsquish","setTickPositions","tickPositionsOption","tickPositioner","minorTickIntervalOption","hasVerticalPanning","isColorAxis","startOnTick","endOnTick","tickPositionerResult","tickmarkPlacement","minorTicksPerMajor","parseInt","positions","units","startingTickInterval","adjustedTickInterval","adjustTickAmount","Infinity","shift","pop","alignToOthers","alignedAxes","alignThresholds","thresholdAlignments","hasOther","thresholdAlignment","alignTicks","getKey","pane","join","thisKey","otherAxis","threshAlign","getThresholdAlignment","reduce","sum","n","callerAxis","isDirty","finalTickAmt","currentTickAmount","thresholdTickIndex","append","prepend","unshift","hasData","adjustExtremes","setScale","isXAxisDirty","setAxisSize","isDirtyAxisLength","forceRedraw","buildStacks","cleanStacks","panningState","setExtremes","newMin","newMax","redraw","animation","eventArguments","serie","kdTree","eventArgs","zoom","allowZoomOutside","displayBtn","trigger","zoomed","offsets","plotWidth","plotHeight","plotTop","plotLeft","lin2log","getThreshold","realMin","realMax","autoLabelAlign","angle","align","tickSize","prefix","tickWidth","tickLength","labelMetrics","tick","fontMetrics","label","movedLabel","box","labelOptions","slotSize","rotationOption","lineHeight","h","getStep","spaceNeeded","step","newTickInterval","bestScore","Number","MAX_VALUE","autoRotation","staggerLines","autoRotationLimit","score","rot","sin","getSlotWidth","slotCount","marginLeft","margin","slotWidth","cssWidth","style","String","spacing","renderUnsquish","labelStyleOptions","innerWidth","padding","attr","textOverflowOption","textOverflow","commonWidth","commonTextOverflow","tickPosition","replaceMovedLabel","textPxLength","styles","css","getBBox","f","specificTextOverflow","labelAlign","widthOption","shortenLabel","whiteSpace","element","tagName","rotCorr","showEmpty","addTitle","display","axisTitleOptions","title","styledMode","textAlign","axisTitle","low","middle","high","text","useHTML","zIndex","addClass","add","axisGroup","isNew","generateTick","addLabel","getOffset","axisParent","invertedSide","hasCrossing","crossing","axisOffset","clipOffset","directionFactor","className","showAxis","titleOffset","titleOffsetOption","titleMargin","labelOffset","labelOffsetPadded","lineHeightCorrection","createGroup","suffix","g","toLowerCase","gridGroup","gridZIndex","labelGroup","reserveSpaceDefault","getLabelSize","destroy","enabled","renderLine","y","distance","axisTitleMargin","getMaxLabelDimensions","maxLabelDimensions","clip","axisLine","strokeWidth","getLinePath","lineLeft","lineTop","stroke","lineColor","getTitlePosition","axisLength","xOption","yOption","textHeightOvershoot","alongAxis","offAxis","titlePosition","renderMinorTick","slideIn","render","renderTick","grid","isColumn","stackLabelOptions","stackLabels","alternateGridColor","globalAnimation","from","to","isActive","yAxis","px","slideInTicks","hasRendered","PlotLineOrBand","color","_addedPlotLB","plotLines","plotBands","plotLineOptions","addPlotBandOrLine","forDestruction","delay","duration","destroyInactiveItems","isPlaced","d","renderStackTotals","plotLine","getKeepProps","keepProps","keepEvents","prop","plotGroup","drawCrosshair","snap","categorized","graphic","cross","crossOptions","hideCrosshair","chartX","chartY","crosshairPos","plotX","plotY","stackY","isCrosshair","parse","setOpacity","get","dashStyle","dashstyle","show","hide","panningOptions","panning","Boolean","test","update","isDirtyBox","remove","axisSeries","setTitle","titleOptions","setCategories"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Axis/Axis.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport A from '../Animation/AnimationUtilities.js';\nconst { animObject } = A;\nimport AxisDefaults from './AxisDefaults.js';\nimport Color from '../Color/Color.js';\nimport D from '../Defaults.js';\nconst { defaultOptions } = D;\nimport F from '../Foundation.js';\nconst { registerEventOptions } = F;\nimport H from '../Globals.js';\nconst { deg2rad } = H;\nimport Tick from './Tick.js';\nimport U from '../Utilities.js';\nconst { arrayMax, arrayMin, clamp, correctFloat, defined, destroyObjectProperties, erase, error, extend, fireEvent, getClosestDistance, insertItem, isArray, isNumber, isString, merge, normalizeTickInterval, objectEach, pick, relativeLength, removeEvent, splat, syncTimeout } = U;\nconst getNormalizedTickInterval = (axis, tickInterval) => normalizeTickInterval(tickInterval, void 0, void 0, pick(axis.options.allowDecimals, \n// If the tick interval is greather than 0.5, avoid decimals, as\n// linear axes are often used to render discrete values (#3363). If\n// a tick amount is set, allow decimals by default, as it increases\n// the chances for a good fit.\ntickInterval < 0.5 || axis.tickAmount !== void 0), !!axis.tickAmount);\n/* *\n *\n *  Class\n *\n * */\n/**\n * Create a new axis object. Called internally when instanciating a new chart or\n * adding axes by {@link Highcharts.Chart#addAxis}.\n *\n * A chart can have from 0 axes (pie chart) to multiples. In a normal, single\n * series cartesian chart, there is one X axis and one Y axis.\n *\n * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is\n * an array of Axis objects. If there is only one axis, it can be referenced\n * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same\n * pattern goes for Y axes.\n *\n * If you need to get the axes from a series object, use the `series.xAxis` and\n * `series.yAxis` properties. These are not arrays, as one series can only be\n * associated to one X and one Y axis.\n *\n * A third way to reference the axis programmatically is by `id`. Add an `id` in\n * the axis configuration options, and get the axis by\n * {@link Highcharts.Chart#get}.\n *\n * Configuration options for the axes are given in options.xAxis and\n * options.yAxis.\n *\n * @class\n * @name Highcharts.Axis\n *\n * @param {Highcharts.Chart} chart\n * The Chart instance to apply the axis on.\n *\n * @param {Highcharts.AxisOptions} userOptions\n * Axis options\n */\nclass Axis {\n    /* *\n     *\n     *  Constructors\n     *\n     * */\n    constructor(chart, userOptions, coll) {\n        this.alternateBands = void 0;\n        this.bottom = void 0;\n        this.chart = void 0;\n        this.closestPointRange = void 0;\n        this.coll = void 0;\n        this.eventOptions = void 0;\n        this.hasNames = void 0;\n        this.hasVisibleSeries = void 0;\n        this.height = void 0;\n        this.index = void 0;\n        this.isLinked = void 0;\n        this.labelEdge = void 0; // @todo\n        this.labelFormatter = void 0;\n        this.left = void 0;\n        this.len = void 0;\n        this.max = void 0;\n        this.maxLabelLength = void 0;\n        this.min = void 0;\n        this.minorTickInterval = void 0;\n        this.minorTicks = void 0;\n        this.minPixelPadding = void 0;\n        this.names = void 0;\n        this.offset = void 0;\n        this.options = void 0;\n        this.overlap = void 0;\n        this.paddedTicks = void 0;\n        this.plotLinesAndBands = void 0;\n        this.plotLinesAndBandsGroups = void 0;\n        this.pointRange = void 0;\n        this.pointRangePadding = void 0;\n        this.pos = void 0;\n        this.positiveValuesOnly = void 0;\n        this.right = void 0;\n        this.series = void 0;\n        this.side = void 0;\n        this.tickAmount = void 0;\n        this.tickInterval = void 0;\n        this.tickmarkOffset = void 0;\n        this.tickPositions = void 0;\n        this.tickRotCorr = void 0;\n        this.ticks = void 0;\n        this.top = void 0;\n        this.transA = void 0;\n        this.transB = void 0;\n        this.translationSlope = void 0;\n        this.userOptions = void 0;\n        this.visible = void 0;\n        this.width = void 0;\n        this.zoomEnabled = void 0;\n        this.init(chart, userOptions, coll);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Overrideable function to initialize the axis.\n     *\n     * @see {@link Axis}\n     *\n     * @function Highcharts.Axis#init\n     *\n     * @param {Highcharts.Chart} chart\n     * The Chart instance to apply the axis on.\n     *\n     * @param {AxisOptions} userOptions\n     * Axis options.\n     *\n     * @emits Highcharts.Axis#event:afterInit\n     * @emits Highcharts.Axis#event:init\n     */\n    init(chart, userOptions, coll = this.coll) {\n        const isXAxis = coll === 'xAxis', axis = this;\n        /**\n         * The Chart that the axis belongs to.\n         *\n         * @name Highcharts.Axis#chart\n         * @type {Highcharts.Chart}\n         */\n        axis.chart = chart;\n        /**\n         * Whether the axis is horizontal.\n         *\n         * @name Highcharts.Axis#horiz\n         * @type {boolean|undefined}\n         */\n        axis.horiz = axis.isZAxis || (chart.inverted ? !isXAxis : isXAxis);\n        /**\n         * Whether the axis is the x-axis.\n         *\n         * @name Highcharts.Axis#isXAxis\n         * @type {boolean|undefined}\n         */\n        axis.isXAxis = isXAxis;\n        /**\n         * The collection where the axis belongs, for example `xAxis`, `yAxis`\n         * or `colorAxis`. Corresponds to properties on Chart, for example\n         * {@link Chart.xAxis}.\n         *\n         * @name Highcharts.Axis#coll\n         * @type {string}\n         */\n        axis.coll = coll;\n        fireEvent(this, 'init', { userOptions: userOptions });\n        // Needed in setOptions\n        axis.opposite = pick(userOptions.opposite, axis.opposite);\n        /**\n         * The side on which the axis is rendered. 0 is top, 1 is right, 2\n         * is bottom and 3 is left.\n         *\n         * @name Highcharts.Axis#side\n         * @type {number}\n         */\n        axis.side = pick(userOptions.side, axis.side, (axis.horiz ?\n            (axis.opposite ? 0 : 2) : // top : bottom\n            (axis.opposite ? 1 : 3)) // right : left\n        );\n        /**\n         * Current options for the axis after merge of defaults and user's\n         * options.\n         *\n         * @name Highcharts.Axis#options\n         * @type {Highcharts.AxisOptions}\n         */\n        axis.setOptions(userOptions);\n        const options = this.options, labelsOptions = options.labels, type = options.type;\n        /**\n         * User's options for this axis without defaults.\n         *\n         * @name Highcharts.Axis#userOptions\n         * @type {Highcharts.AxisOptions}\n         */\n        axis.userOptions = userOptions;\n        axis.minPixelPadding = 0;\n        /**\n         * Whether the axis is reversed. Based on the `axis.reversed`,\n         * option, but inverted charts have reversed xAxis by default.\n         *\n         * @name Highcharts.Axis#reversed\n         * @type {boolean}\n         */\n        axis.reversed = pick(options.reversed, axis.reversed);\n        axis.visible = options.visible;\n        axis.zoomEnabled = options.zoomEnabled;\n        // Initial categories\n        axis.hasNames =\n            type === 'category' || options.categories === true;\n        /**\n         * If categories are present for the axis, names are used instead of\n         * numbers for that axis.\n         *\n         * Since Highcharts 3.0, categories can also be extracted by giving each\n         * point a name and setting axis type to `category`. However, if you\n         * have multiple series, best practice remains defining the `categories`\n         * array.\n         *\n         * @see [xAxis.categories](/highcharts/xAxis.categories)\n         *\n         * @name Highcharts.Axis#categories\n         * @type {Array<string>}\n         * @readonly\n         */\n        axis.categories = options.categories || (axis.hasNames ? [] : void 0);\n        if (!axis.names) { // Preserve on update (#3830)\n            axis.names = [];\n            axis.names.keys = {};\n        }\n        // Placeholder for plotlines and plotbands groups\n        axis.plotLinesAndBandsGroups = {};\n        // Shorthand types\n        axis.positiveValuesOnly = !!axis.logarithmic;\n        // Flag, if axis is linked to another axis\n        axis.isLinked = defined(options.linkedTo);\n        /**\n         * List of major ticks mapped by postition on axis.\n         *\n         * @see {@link Highcharts.Tick}\n         *\n         * @name Highcharts.Axis#ticks\n         * @type {Highcharts.Dictionary<Highcharts.Tick>}\n         */\n        axis.ticks = {};\n        axis.labelEdge = [];\n        /**\n         * List of minor ticks mapped by position on the axis.\n         *\n         * @see {@link Highcharts.Tick}\n         *\n         * @name Highcharts.Axis#minorTicks\n         * @type {Highcharts.Dictionary<Highcharts.Tick>}\n         */\n        axis.minorTicks = {};\n        // List of plotLines/Bands\n        axis.plotLinesAndBands = [];\n        // Alternate bands\n        axis.alternateBands = {};\n        // Axis metrics\n        axis.len = 0;\n        axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n        axis.range = options.range;\n        axis.offset = options.offset || 0;\n        /**\n         * The maximum value of the axis. In a logarithmic axis, this is the\n         * logarithm of the real value, and the real value can be obtained from\n         * {@link Axis#getExtremes}.\n         *\n         * @name Highcharts.Axis#max\n         * @type {number|null}\n         */\n        axis.max = null;\n        /**\n         * The minimum value of the axis. In a logarithmic axis, this is the\n         * logarithm of the real value, and the real value can be obtained from\n         * {@link Axis#getExtremes}.\n         *\n         * @name Highcharts.Axis#min\n         * @type {number|null}\n         */\n        axis.min = null;\n        /**\n         * The processed crosshair options.\n         *\n         * @name Highcharts.Axis#crosshair\n         * @type {boolean|Highcharts.AxisCrosshairOptions}\n         */\n        const crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1]);\n        axis.crosshair = crosshair === true ? {} : crosshair;\n        // Register. Don't add it again on Axis.update().\n        if (chart.axes.indexOf(axis) === -1) { //\n            if (isXAxis) { // #2713\n                chart.axes.splice(chart.xAxis.length, 0, axis);\n            }\n            else {\n                chart.axes.push(axis);\n            }\n            insertItem(this, chart[this.coll]);\n        }\n        chart.orderItems(axis.coll);\n        /**\n         * All series associated to the axis.\n         *\n         * @name Highcharts.Axis#series\n         * @type {Array<Highcharts.Series>}\n         */\n        axis.series = axis.series || []; // populated by Series\n        // Reversed axis\n        if (chart.inverted &&\n            !axis.isZAxis &&\n            isXAxis &&\n            typeof axis.reversed === 'undefined') {\n            axis.reversed = true;\n        }\n        axis.labelRotation = isNumber(labelsOptions.rotation) ?\n            labelsOptions.rotation :\n            void 0;\n        // Register event listeners\n        registerEventOptions(axis, options);\n        fireEvent(this, 'afterInit');\n    }\n    /**\n     * Merge and set options.\n     *\n     * @private\n     * @function Highcharts.Axis#setOptions\n     *\n     * @param {Highcharts.AxisOptions} userOptions\n     * Axis options.\n     *\n     * @emits Highcharts.Axis#event:afterSetOptions\n     */\n    setOptions(userOptions) {\n        this.options = merge(AxisDefaults.defaultXAxisOptions, (this.coll === 'yAxis') && AxisDefaults.defaultYAxisOptions, [\n            AxisDefaults.defaultTopAxisOptions,\n            AxisDefaults.defaultRightAxisOptions,\n            AxisDefaults.defaultBottomAxisOptions,\n            AxisDefaults.defaultLeftAxisOptions\n        ][this.side], merge(\n        // if set in setOptions (#1053):\n        defaultOptions[this.coll], userOptions));\n        fireEvent(this, 'afterSetOptions', { userOptions: userOptions });\n    }\n    /**\n     * The default label formatter. The context is a special config object for\n     * the label. In apps, use the\n     * [labels.formatter](https://api.highcharts.com/highcharts/xAxis.labels.formatter)\n     * instead, except when a modification is needed.\n     *\n     * @function Highcharts.Axis#defaultLabelFormatter\n     *\n     * @param {Highcharts.AxisLabelsFormatterContextObject} this\n     * Formatter context of axis label.\n     *\n     * @param {Highcharts.AxisLabelsFormatterContextObject} [ctx]\n     * Formatter context of axis label.\n     *\n     * @return {string}\n     * The formatted label content.\n     */\n    defaultLabelFormatter(ctx) {\n        const axis = this.axis, chart = this.chart, { numberFormatter } = chart, value = isNumber(this.value) ? this.value : NaN, time = axis.chart.time, categories = axis.categories, dateTimeLabelFormat = this.dateTimeLabelFormat, lang = defaultOptions.lang, numericSymbols = lang.numericSymbols, numSymMagnitude = lang.numericSymbolMagnitude || 1000, \n        // make sure the same symbol is added for all labels on a linear\n        // axis\n        numericSymbolDetector = axis.logarithmic ?\n            Math.abs(value) :\n            axis.tickInterval;\n        let i = numericSymbols && numericSymbols.length, multi, ret;\n        if (categories) {\n            ret = `${this.value}`;\n        }\n        else if (dateTimeLabelFormat) { // datetime axis\n            ret = time.dateFormat(dateTimeLabelFormat, value);\n        }\n        else if (i && numericSymbolDetector >= 1000) {\n            // Decide whether we should add a numeric symbol like k (thousands)\n            // or M (millions). If we are to enable this in tooltip or other\n            // places as well, we can move this logic to the numberFormatter and\n            // enable it by a parameter.\n            while (i-- && typeof ret === 'undefined') {\n                multi = Math.pow(numSymMagnitude, i + 1);\n                if (\n                // Only accept a numeric symbol when the distance is more\n                // than a full unit. So for example if the symbol is k, we\n                // don't accept numbers like 0.5k.\n                numericSymbolDetector >= multi &&\n                    // Accept one decimal before the symbol. Accepts 0.5k but\n                    // not 0.25k. How does this work with the previous?\n                    (value * 10) % multi === 0 &&\n                    numericSymbols[i] !== null &&\n                    value !== 0) { // #5480\n                    ret = numberFormatter(value / multi, -1) + numericSymbols[i];\n                }\n            }\n        }\n        if (typeof ret === 'undefined') {\n            if (Math.abs(value) >= 10000) { // add thousands separators\n                ret = numberFormatter(value, -1);\n            }\n            else { // small numbers\n                ret = numberFormatter(value, -1, void 0, ''); // #2466\n            }\n        }\n        return ret;\n    }\n    /**\n     * Get the minimum and maximum for the series of each axis. The function\n     * analyzes the axis series and updates `this.dataMin` and `this.dataMax`.\n     *\n     * @private\n     * @function Highcharts.Axis#getSeriesExtremes\n     *\n     * @emits Highcharts.Axis#event:afterGetSeriesExtremes\n     * @emits Highcharts.Axis#event:getSeriesExtremes\n     */\n    getSeriesExtremes() {\n        const axis = this, chart = axis.chart;\n        let xExtremes;\n        fireEvent(this, 'getSeriesExtremes', null, function () {\n            axis.hasVisibleSeries = false;\n            // Reset properties in case we're redrawing (#3353)\n            axis.dataMin = axis.dataMax = axis.threshold = null;\n            axis.softThreshold = !axis.isXAxis;\n            // Loop through this axis' series\n            axis.series.forEach(function (series) {\n                if (series.reserveSpace()) {\n                    const seriesOptions = series.options;\n                    let xData, threshold = seriesOptions.threshold, seriesDataMin, seriesDataMax;\n                    axis.hasVisibleSeries = true;\n                    // Validate threshold in logarithmic axes\n                    if (axis.positiveValuesOnly && threshold <= 0) {\n                        threshold = null;\n                    }\n                    // Get dataMin and dataMax for X axes\n                    if (axis.isXAxis) {\n                        xData = series.xData;\n                        if (xData && xData.length) {\n                            xData = axis.logarithmic ?\n                                xData.filter((x) => x > 0) :\n                                xData;\n                            xExtremes = series.getXExtremes(xData);\n                            // If xData contains values which is not numbers,\n                            // then filter them out. To prevent performance hit,\n                            // we only do this after we have already found\n                            // seriesDataMin because in most cases all data is\n                            // valid. #5234.\n                            seriesDataMin = xExtremes.min;\n                            seriesDataMax = xExtremes.max;\n                            if (!isNumber(seriesDataMin) &&\n                                // #5010:\n                                !(seriesDataMin instanceof Date)) {\n                                xData = xData.filter(isNumber);\n                                xExtremes = series.getXExtremes(xData);\n                                // Do it again with valid data\n                                seriesDataMin = xExtremes.min;\n                                seriesDataMax = xExtremes.max;\n                            }\n                            if (xData.length) {\n                                axis.dataMin = Math.min(pick(axis.dataMin, seriesDataMin), seriesDataMin);\n                                axis.dataMax = Math.max(pick(axis.dataMax, seriesDataMax), seriesDataMax);\n                            }\n                        }\n                        // Get dataMin and dataMax for Y axes, as well as handle\n                        // stacking and processed data\n                    }\n                    else {\n                        // Get this particular series extremes\n                        const dataExtremes = series.applyExtremes();\n                        // Get the dataMin and dataMax so far. If percentage is\n                        // used, the min and max are always 0 and 100. If\n                        // seriesDataMin and seriesDataMax is null, then series\n                        // doesn't have active y data, we continue with nulls\n                        if (isNumber(dataExtremes.dataMin)) {\n                            seriesDataMin = dataExtremes.dataMin;\n                            axis.dataMin = Math.min(pick(axis.dataMin, seriesDataMin), seriesDataMin);\n                        }\n                        if (isNumber(dataExtremes.dataMax)) {\n                            seriesDataMax = dataExtremes.dataMax;\n                            axis.dataMax = Math.max(pick(axis.dataMax, seriesDataMax), seriesDataMax);\n                        }\n                        // Adjust to threshold\n                        if (defined(threshold)) {\n                            axis.threshold = threshold;\n                        }\n                        // If any series has a hard threshold, it takes\n                        // precedence\n                        if (!seriesOptions.softThreshold ||\n                            axis.positiveValuesOnly) {\n                            axis.softThreshold = false;\n                        }\n                    }\n                }\n            });\n        });\n        fireEvent(this, 'afterGetSeriesExtremes');\n    }\n    /**\n     * Translate from axis value to pixel position on the chart, or back. Use\n     * the `toPixels` and `toValue` functions in applications.\n     *\n     * @private\n     * @function Highcharts.Axis#translate\n     */\n    translate(val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n        const axis = (this.linkedParent || this), // #1417\n        localMin = (old && axis.old ? axis.old.min : axis.min);\n        if (!isNumber(localMin)) {\n            return NaN;\n        }\n        const minPixelPadding = axis.minPixelPadding, doPostTranslate = (axis.isOrdinal ||\n            axis.brokenAxis && axis.brokenAxis.hasBreaks ||\n            (axis.logarithmic && handleLog)) && axis.lin2val;\n        let sign = 1, cvsOffset = 0, localA = old && axis.old ? axis.old.transA : axis.transA, returnValue = 0;\n        if (!localA) {\n            localA = axis.transA;\n        }\n        // In vertical axes, the canvas coordinates start from 0 at the top like\n        // in SVG.\n        if (cvsCoord) {\n            sign *= -1; // canvas coordinates inverts the value\n            cvsOffset = axis.len;\n        }\n        // Handle reversed axis\n        if (axis.reversed) {\n            sign *= -1;\n            cvsOffset -= sign * (axis.sector || axis.len);\n        }\n        // From pixels to value\n        if (backwards) { // reverse translation\n            val = val * sign + cvsOffset;\n            val -= minPixelPadding;\n            // from chart pixel to value:\n            returnValue = val / localA + localMin;\n            if (doPostTranslate) { // log, ordinal and broken axis\n                returnValue = axis.lin2val(returnValue);\n            }\n            // From value to pixels\n        }\n        else {\n            if (doPostTranslate) { // log, ordinal and broken axis\n                val = axis.val2lin(val);\n            }\n            const value = sign * (val - localMin) * localA;\n            returnValue = (!axis.isRadial ? correctFloat(value) : value) +\n                cvsOffset +\n                (sign * minPixelPadding) +\n                (isNumber(pointPlacement) ? localA * pointPlacement : 0);\n        }\n        return returnValue;\n    }\n    /**\n     * Translate a value in terms of axis units into pixels within the chart.\n     *\n     * @function Highcharts.Axis#toPixels\n     *\n     * @param {number} value\n     * A value in terms of axis units.\n     *\n     * @param {boolean} paneCoordinates\n     * Whether to return the pixel coordinate relative to the chart or just the\n     * axis/pane itself.\n     *\n     * @return {number}\n     * Pixel position of the value on the chart or axis.\n     */\n    toPixels(value, paneCoordinates) {\n        return this.translate(value, false, !this.horiz, void 0, true) +\n            (paneCoordinates ? 0 : this.pos);\n    }\n    /**\n     * Translate a pixel position along the axis to a value in terms of axis\n     * units.\n     *\n     * @function Highcharts.Axis#toValue\n     *\n     * @param {number} pixel\n     * The pixel value coordinate.\n     *\n     * @param {boolean} [paneCoordinates=false]\n     * Whether the input pixel is relative to the chart or just the axis/pane\n     * itself.\n     *\n     * @return {number}\n     * The axis value.\n     */\n    toValue(pixel, paneCoordinates) {\n        return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, void 0, true);\n    }\n    /**\n     * Create the path for a plot line that goes from the given value on\n     * this axis, across the plot to the opposite side. Also used internally for\n     * grid lines and crosshairs.\n     *\n     * @function Highcharts.Axis#getPlotLinePath\n     *\n     * @param {Highcharts.AxisPlotLinePathOptionsObject} options\n     * Options for the path.\n     *\n     * @return {Highcharts.SVGPathArray|null}\n     * The SVG path definition for the plot line.\n     */\n    getPlotLinePath(options) {\n        const axis = this, chart = axis.chart, axisLeft = axis.left, axisTop = axis.top, old = options.old, value = options.value, lineWidth = options.lineWidth, cHeight = (old && chart.oldChartHeight) || chart.chartHeight, cWidth = (old && chart.oldChartWidth) || chart.chartWidth, transB = axis.transB;\n        let translatedValue = options.translatedValue, force = options.force, x1, y1, x2, y2, skip;\n        // eslint-disable-next-line valid-jsdoc\n        /**\n         * Check if x is between a and b. If not, either move to a/b\n         * or skip, depending on the force parameter.\n         * @private\n         */\n        function between(x, a, b) {\n            if (force !== 'pass' && (x < a || x > b)) {\n                if (force) {\n                    x = clamp(x, a, b);\n                }\n                else {\n                    skip = true;\n                }\n            }\n            return x;\n        }\n        const evt = {\n            value: value,\n            lineWidth: lineWidth,\n            old: old,\n            force: force,\n            acrossPanes: options.acrossPanes,\n            translatedValue: translatedValue\n        };\n        fireEvent(this, 'getPlotLinePath', evt, function (e) {\n            translatedValue = pick(translatedValue, axis.translate(value, void 0, void 0, old));\n            // Keep the translated value within sane bounds, and avoid Infinity\n            // to fail the isNumber test (#7709).\n            translatedValue = clamp(translatedValue, -1e5, 1e5);\n            x1 = x2 = Math.round(translatedValue + transB);\n            y1 = y2 = Math.round(cHeight - translatedValue - transB);\n            if (!isNumber(translatedValue)) { // no min or max\n                skip = true;\n                force = false; // #7175, don't force it when path is invalid\n            }\n            else if (axis.horiz) {\n                y1 = axisTop;\n                y2 = cHeight - axis.bottom;\n                x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n            }\n            else {\n                x1 = axisLeft;\n                x2 = cWidth - axis.right;\n                y1 = y2 = between(y1, axisTop, axisTop + axis.height);\n            }\n            e.path = skip && !force ?\n                void 0 :\n                chart.renderer.crispLine([['M', x1, y1], ['L', x2, y2]], lineWidth || 1);\n        });\n        return (evt.path || null);\n    }\n    /**\n     * Internal function to get the tick positions of a linear axis to round\n     * values like whole tens or every five.\n     *\n     * @function Highcharts.Axis#getLinearTickPositions\n     *\n     * @param {number} tickInterval\n     * The normalized tick interval.\n     *\n     * @param {number} min\n     * Axis minimum.\n     *\n     * @param {number} max\n     * Axis maximum.\n     *\n     * @return {Array<number>}\n     * An array of axis values where ticks should be placed.\n     */\n    getLinearTickPositions(tickInterval, min, max) {\n        const roundedMin = correctFloat(Math.floor(min / tickInterval) * tickInterval), roundedMax = correctFloat(Math.ceil(max / tickInterval) * tickInterval), tickPositions = [];\n        let pos, lastPos, precision;\n        // When the precision is higher than what we filter out in\n        // correctFloat, skip it (#6183).\n        if (correctFloat(roundedMin + tickInterval) === roundedMin) {\n            precision = 20;\n        }\n        // For single points, add a tick regardless of the relative position\n        // (#2662, #6274)\n        if (this.single) {\n            return [min];\n        }\n        // Populate the intermediate values\n        pos = roundedMin;\n        while (pos <= roundedMax) {\n            // Place the tick on the rounded value\n            tickPositions.push(pos);\n            // Always add the raw tickInterval, not the corrected one.\n            pos = correctFloat(pos + tickInterval, precision);\n            // If the interval is not big enough in the current min - max range\n            // to actually increase the loop variable, we need to break out to\n            // prevent endless loop. Issue #619\n            if (pos === lastPos) {\n                break;\n            }\n            // Record the last value\n            lastPos = pos;\n        }\n        return tickPositions;\n    }\n    /**\n     * Resolve the new minorTicks/minorTickInterval options into the legacy\n     * loosely typed minorTickInterval option.\n     *\n     * @function Highcharts.Axis#getMinorTickInterval\n     *\n     * @return {number|\"auto\"|null}\n     * Legacy option\n     */\n    getMinorTickInterval() {\n        const options = this.options;\n        if (options.minorTicks === true) {\n            return pick(options.minorTickInterval, 'auto');\n        }\n        if (options.minorTicks === false) {\n            return null;\n        }\n        return options.minorTickInterval;\n    }\n    /**\n     * Internal function to return the minor tick positions. For logarithmic\n     * axes, the same logic as for major ticks is reused.\n     *\n     * @function Highcharts.Axis#getMinorTickPositions\n     *\n     * @return {Array<number>}\n     * An array of axis values where ticks should be placed.\n     */\n    getMinorTickPositions() {\n        const axis = this, options = axis.options, tickPositions = axis.tickPositions, minorTickInterval = axis.minorTickInterval, pointRangePadding = axis.pointRangePadding || 0, min = axis.min - pointRangePadding, // #1498\n        max = axis.max + pointRangePadding, // #1498\n        range = max - min;\n        let minorTickPositions = [], pos;\n        // If minor ticks get too dense, they are hard to read, and may cause\n        // long running script. So we don't draw them.\n        if (range && range / minorTickInterval < axis.len / 3) { // #3875\n            const logarithmic = axis.logarithmic;\n            if (logarithmic) {\n                // For each interval in the major ticks, compute the minor ticks\n                // separately.\n                this.paddedTicks.forEach(function (_pos, i, paddedTicks) {\n                    if (i) {\n                        minorTickPositions.push.apply(minorTickPositions, logarithmic.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));\n                    }\n                });\n            }\n            else if (axis.dateTime &&\n                this.getMinorTickInterval() === 'auto') { // #1314\n                minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(minorTickInterval), min, max, options.startOfWeek));\n            }\n            else {\n                for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {\n                    // Very, very, tight grid lines (#5771)\n                    if (pos === minorTickPositions[0]) {\n                        break;\n                    }\n                    minorTickPositions.push(pos);\n                }\n            }\n        }\n        if (minorTickPositions.length !== 0) {\n            axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330\n        }\n        return minorTickPositions;\n    }\n    /**\n     * Adjust the min and max for the minimum range. Keep in mind that the\n     * series data is not yet processed, so we don't have information on data\n     * cropping and grouping, or updated `axis.pointRange` or\n     * `series.pointRange`. The data can't be processed until we have finally\n     * established min and max.\n     *\n     * @private\n     * @function Highcharts.Axis#adjustForMinRange\n     */\n    adjustForMinRange() {\n        const axis = this, options = axis.options, logarithmic = axis.logarithmic;\n        let min = axis.min, max = axis.max, zoomOffset, spaceAvailable, closestDataRange, minArgs, maxArgs, minRange;\n        // Set the automatic minimum range based on the closest point distance\n        if (axis.isXAxis &&\n            typeof axis.minRange === 'undefined' &&\n            !logarithmic) {\n            if (defined(options.min) ||\n                defined(options.max) ||\n                defined(options.floor) ||\n                defined(options.ceiling)) {\n                axis.minRange = null; // don't do this again\n            }\n            else {\n                // Find the closest distance between raw data points, as opposed\n                // to closestPointRange that applies to processed points\n                // (cropped and grouped)\n                closestDataRange = getClosestDistance(axis.series.map((s) => \n                // If xIncrement, we only need to measure the two first\n                // points to get the distance. Saves processing time.\n                (s.xIncrement ? s.xData?.slice(0, 2) : s.xData) || [])) || 0;\n                axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);\n            }\n        }\n        // if minRange is exceeded, adjust\n        if (max - min < axis.minRange) {\n            spaceAvailable =\n                axis.dataMax - axis.dataMin >=\n                    axis.minRange;\n            minRange = axis.minRange;\n            zoomOffset = (minRange - max + min) / 2;\n            // if min and max options have been set, don't go beyond it\n            minArgs = [\n                min - zoomOffset,\n                pick(options.min, min - zoomOffset)\n            ];\n            // If space is available, stay within the data range\n            if (spaceAvailable) {\n                minArgs[2] = logarithmic ?\n                    logarithmic.log2lin(axis.dataMin) :\n                    axis.dataMin;\n            }\n            min = arrayMax(minArgs);\n            maxArgs = [\n                min + minRange,\n                pick(options.max, min + minRange)\n            ];\n            // If space is availabe, stay within the data range\n            if (spaceAvailable) {\n                maxArgs[2] = logarithmic ?\n                    logarithmic.log2lin(axis.dataMax) :\n                    axis.dataMax;\n            }\n            max = arrayMin(maxArgs);\n            // now if the max is adjusted, adjust the min back\n            if (max - min < minRange) {\n                minArgs[0] = max - minRange;\n                minArgs[1] = pick(options.min, max - minRange);\n                min = arrayMax(minArgs);\n            }\n        }\n        // Record modified extremes\n        axis.min = min;\n        axis.max = max;\n    }\n    /**\n     * Find the closestPointRange across all series, including the single data\n     * series.\n     *\n     * @private\n     * @function Highcharts.Axis#getClosest\n     */\n    getClosest() {\n        let closestSingleDistance, closestDistance;\n        if (this.categories) {\n            closestDistance = 1;\n        }\n        else {\n            const singleXs = [];\n            this.series.forEach(function (series) {\n                const seriesClosest = series.closestPointRange;\n                if (series.xData?.length === 1) {\n                    singleXs.push(series.xData[0]);\n                }\n                else if (!series.noSharedTooltip &&\n                    defined(seriesClosest) &&\n                    series.reserveSpace()) {\n                    closestDistance = defined(closestDistance) ?\n                        Math.min(closestDistance, seriesClosest) :\n                        seriesClosest;\n                }\n            });\n            if (singleXs.length) {\n                singleXs.sort((a, b) => a - b);\n                closestSingleDistance = getClosestDistance([singleXs]);\n            }\n        }\n        if (closestSingleDistance && closestDistance) {\n            return Math.min(closestSingleDistance, closestDistance);\n        }\n        return closestSingleDistance || closestDistance;\n    }\n    /**\n     * When a point name is given and no x, search for the name in the existing\n     * categories, or if categories aren't provided, search names or create a\n     * new category (#2522).\n     *\n     * @private\n     * @function Highcharts.Axis#nameToX\n     *\n     * @param {Highcharts.Point} point\n     * The point to inspect.\n     *\n     * @return {number}\n     * The X value that the point is given.\n     */\n    nameToX(point) {\n        const explicitCategories = isArray(this.options.categories), names = explicitCategories ? this.categories : this.names;\n        let nameX = point.options.x, x;\n        point.series.requireSorting = false;\n        if (!defined(nameX)) {\n            nameX = this.options.uniqueNames && names ?\n                (explicitCategories ?\n                    names.indexOf(point.name) :\n                    pick(names.keys[point.name], -1)) :\n                point.series.autoIncrement();\n        }\n        if (nameX === -1) { // Not found in currenct categories\n            if (!explicitCategories && names) {\n                x = names.length;\n            }\n        }\n        else {\n            x = nameX;\n        }\n        // Write the last point's name to the names array\n        if (typeof x !== 'undefined') {\n            this.names[x] = point.name;\n            // Backwards mapping is much faster than array searching (#7725)\n            this.names.keys[point.name] = x;\n        }\n        else if (point.x) {\n            x = point.x; // #17438\n        }\n        return x;\n    }\n    /**\n     * When changes have been done to series data, update the axis.names.\n     *\n     * @private\n     * @function Highcharts.Axis#updateNames\n     */\n    updateNames() {\n        const axis = this, names = this.names, i = names.length;\n        if (i > 0) {\n            Object.keys(names.keys).forEach(function (key) {\n                delete (names.keys)[key];\n            });\n            names.length = 0;\n            this.minRange = this.userMinRange; // Reset\n            (this.series || []).forEach(function (series) {\n                // Reset incrementer (#5928)\n                series.xIncrement = null;\n                // When adding a series, points are not yet generated\n                if (!series.points || series.isDirtyData) {\n                    // When we're updating the series with data that is longer\n                    // than it was, and cropThreshold is passed, we need to make\n                    // sure that the axis.max is increased _before_ running the\n                    // premature processData. Otherwise this early iteration of\n                    // processData will crop the points to axis.max, and the\n                    // names array will be too short (#5857).\n                    axis.max = Math.max(axis.max, series.xData.length - 1);\n                    series.processData();\n                    series.generatePoints();\n                }\n                series.data.forEach(function (point, i) {\n                    let x;\n                    if (point &&\n                        point.options &&\n                        typeof point.name !== 'undefined' // #9562\n                    ) {\n                        x = axis.nameToX(point);\n                        if (typeof x !== 'undefined' && x !== point.x) {\n                            point.x = x;\n                            series.xData[i] = x;\n                        }\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Update translation information.\n     *\n     * @private\n     * @function Highcharts.Axis#setAxisTranslation\n     *\n     * @emits Highcharts.Axis#event:afterSetAxisTranslation\n     */\n    setAxisTranslation() {\n        const axis = this, range = axis.max - axis.min, linkedParent = axis.linkedParent, hasCategories = !!axis.categories, isXAxis = axis.isXAxis;\n        let pointRange = axis.axisPointRange || 0, closestPointRange, minPointOffset = 0, pointRangePadding = 0, ordinalCorrection, transA = axis.transA;\n        // Adjust translation for padding. Y axis with categories need to go\n        // through the same (#1784).\n        if (isXAxis || hasCategories || pointRange) {\n            // Get the closest points\n            closestPointRange = axis.getClosest();\n            if (linkedParent) {\n                minPointOffset = linkedParent.minPointOffset;\n                pointRangePadding = linkedParent.pointRangePadding;\n            }\n            else {\n                axis.series.forEach(function (series) {\n                    const seriesPointRange = hasCategories ?\n                        1 :\n                        (isXAxis ?\n                            pick(series.options.pointRange, closestPointRange, 0) :\n                            (axis.axisPointRange || 0)), // #2806\n                    pointPlacement = series.options.pointPlacement;\n                    pointRange = Math.max(pointRange, seriesPointRange);\n                    if (!axis.single || hasCategories) {\n                        // TODO: series should internally set x- and y-\n                        // pointPlacement to simplify this logic.\n                        const isPointPlacementAxis = series.is('xrange') ?\n                            !isXAxis :\n                            isXAxis;\n                        // minPointOffset is the value padding to the left of\n                        // the axis in order to make room for points with a\n                        // pointRange, typically columns. When the\n                        // pointPlacement option is 'between' or 'on', this\n                        // padding does not apply.\n                        minPointOffset = Math.max(minPointOffset, isPointPlacementAxis && isString(pointPlacement) ?\n                            0 :\n                            seriesPointRange / 2);\n                        // Determine the total padding needed to the length of\n                        // the axis to make room for the pointRange. If the\n                        // series' pointPlacement is 'on', no padding is added.\n                        pointRangePadding = Math.max(pointRangePadding, isPointPlacementAxis && pointPlacement === 'on' ?\n                            0 :\n                            seriesPointRange);\n                    }\n                });\n            }\n            // Record minPointOffset and pointRangePadding\n            ordinalCorrection = (axis.ordinal && axis.ordinal.slope && closestPointRange) ?\n                axis.ordinal.slope / closestPointRange :\n                1; // #988, #1853\n            axis.minPointOffset = minPointOffset =\n                minPointOffset * ordinalCorrection;\n            axis.pointRangePadding =\n                pointRangePadding = pointRangePadding * ordinalCorrection;\n            // pointRange means the width reserved for each point, like in a\n            // column chart\n            axis.pointRange = Math.min(pointRange, axis.single && hasCategories ? 1 : range);\n            // closestPointRange means the closest distance between points. In\n            // columns it is mostly equal to pointRange, but in lines pointRange\n            // is 0 while closestPointRange is some other value\n            if (isXAxis && closestPointRange) {\n                axis.closestPointRange = closestPointRange;\n            }\n        }\n        // Secondary values\n        axis.translationSlope = axis.transA = transA =\n            axis.staticScale ||\n                axis.len / ((range + pointRangePadding) || 1);\n        // Translation addend\n        axis.transB = axis.horiz ? axis.left : axis.bottom;\n        axis.minPixelPadding = transA * minPointOffset;\n        fireEvent(this, 'afterSetAxisTranslation');\n    }\n    /**\n     * @private\n     * @function Highcharts.Axis#minFromRange\n     */\n    minFromRange() {\n        const axis = this;\n        return axis.max - axis.range;\n    }\n    /**\n     * Set the tick positions to round values and optionally extend the extremes\n     * to the nearest tick.\n     *\n     * @private\n     * @function Highcharts.Axis#setTickInterval\n     *\n     * @param {boolean} secondPass\n     * TO-DO: parameter description\n     *\n     * @emits Highcharts.Axis#event:foundExtremes\n     */\n    setTickInterval(secondPass) {\n        const axis = this, chart = axis.chart, log = axis.logarithmic, options = axis.options, isXAxis = axis.isXAxis, isLinked = axis.isLinked, tickPixelIntervalOption = options.tickPixelInterval, categories = axis.categories, softThreshold = axis.softThreshold;\n        let maxPadding = options.maxPadding, minPadding = options.minPadding, length, linkedParentExtremes, \n        // Only non-negative tickInterval is valid, #12961\n        tickIntervalOption = isNumber(options.tickInterval) && options.tickInterval >= 0 ?\n            options.tickInterval : void 0, threshold = isNumber(axis.threshold) ? axis.threshold : null, thresholdMin, thresholdMax, hardMin, hardMax;\n        if (!axis.dateTime && !categories && !isLinked) {\n            this.getTickAmount();\n        }\n        // Min or max set either by zooming/setExtremes or initial options\n        hardMin = pick(axis.userMin, options.min);\n        hardMax = pick(axis.userMax, options.max);\n        // Linked axis gets the extremes from the parent axis\n        if (isLinked) {\n            axis.linkedParent = chart[axis.coll][options.linkedTo];\n            linkedParentExtremes = axis.linkedParent.getExtremes();\n            axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n            axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n            if (options.type !== axis.linkedParent.options.type) {\n                // Can't link axes of different type\n                error(11, 1, chart);\n            }\n            // Initial min and max from the extreme data values\n        }\n        else {\n            // Adjust to hard threshold\n            if (softThreshold && defined(threshold)) {\n                if (axis.dataMin >= threshold) {\n                    thresholdMin = threshold;\n                    minPadding = 0;\n                }\n                else if (axis.dataMax <= threshold) {\n                    thresholdMax = threshold;\n                    maxPadding = 0;\n                }\n            }\n            axis.min = pick(hardMin, thresholdMin, axis.dataMin);\n            axis.max = pick(hardMax, thresholdMax, axis.dataMax);\n        }\n        if (log) {\n            if (axis.positiveValuesOnly &&\n                !secondPass &&\n                Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978\n                // Can't plot negative values on log axis\n                error(10, 1, chart);\n            }\n            // The correctFloat cures #934, float errors on full tens. But it\n            // was too aggressive for #4360 because of conversion back to lin,\n            // therefore use precision 15.\n            axis.min = correctFloat(log.log2lin(axis.min), 16);\n            axis.max = correctFloat(log.log2lin(axis.max), 16);\n        }\n        // handle zoomed range\n        if (axis.range && defined(axis.max)) {\n            // #618, #6773:\n            axis.userMin = axis.min = hardMin =\n                Math.max(axis.dataMin, axis.minFromRange());\n            axis.userMax = hardMax = axis.max;\n            axis.range = null; // don't use it when running setExtremes\n        }\n        // Hook for Highcharts Stock Scroller.\n        // Consider combining with beforePadding.\n        fireEvent(axis, 'foundExtremes');\n        // Hook for adjusting this.min and this.max. Used by bubble series.\n        if (axis.beforePadding) {\n            axis.beforePadding();\n        }\n        // Adjust min and max for the minimum range\n        axis.adjustForMinRange();\n        // Handle options for floor, ceiling, softMin and softMax (#6359)\n        if (!isNumber(axis.userMin)) {\n            if (isNumber(options.softMin) && options.softMin < axis.min) {\n                axis.min = hardMin = options.softMin; // #6894\n            }\n        }\n        if (!isNumber(axis.userMax)) {\n            if (isNumber(options.softMax) && options.softMax > axis.max) {\n                axis.max = hardMax = options.softMax; // #6894\n            }\n        }\n        // Pad the values to get clear of the chart's edges. To avoid\n        // tickInterval taking the padding into account, we do this after\n        // computing tick interval (#1337).\n        if (!categories &&\n            !axis.axisPointRange &&\n            !(axis.stacking && axis.stacking.usePercentage) &&\n            !isLinked &&\n            defined(axis.min) &&\n            defined(axis.max)) {\n            length = axis.max - axis.min;\n            if (length) {\n                if (!defined(hardMin) && minPadding) {\n                    axis.min -= length * minPadding;\n                }\n                if (!defined(hardMax) && maxPadding) {\n                    axis.max += length * maxPadding;\n                }\n            }\n        }\n        if (!isNumber(axis.userMin) && isNumber(options.floor)) {\n            axis.min = Math.max(axis.min, options.floor);\n        }\n        if (!isNumber(axis.userMax) && isNumber(options.ceiling)) {\n            axis.max = Math.min(axis.max, options.ceiling);\n        }\n        // When the threshold is soft, adjust the extreme value only if the data\n        // extreme and the padded extreme land on either side of the threshold.\n        // For example, a series of [0, 1, 2, 3] would make the yAxis add a tick\n        // for -1 because of the default minPadding and startOnTick options.\n        // This is prevented by the softThreshold option.\n        if (softThreshold && defined(axis.dataMin)) {\n            threshold = threshold || 0;\n            if (!defined(hardMin) &&\n                axis.min < threshold &&\n                axis.dataMin >= threshold) {\n                axis.min = axis.options.minRange ?\n                    Math.min(threshold, axis.max -\n                        axis.minRange) :\n                    threshold;\n            }\n            else if (!defined(hardMax) &&\n                axis.max > threshold &&\n                axis.dataMax <= threshold) {\n                axis.max = axis.options.minRange ?\n                    Math.max(threshold, axis.min +\n                        axis.minRange) :\n                    threshold;\n            }\n        }\n        // If min is bigger than highest, or if max less than lowest value, the\n        // chart should not render points. (#14417)\n        if (isNumber(axis.min) &&\n            isNumber(axis.max) &&\n            !this.chart.polar &&\n            (axis.min > axis.max)) {\n            if (defined(axis.options.min)) {\n                axis.max = axis.min;\n            }\n            else if (defined(axis.options.max)) {\n                axis.min = axis.max;\n            }\n        }\n        // get tickInterval\n        if (axis.min === axis.max ||\n            typeof axis.min === 'undefined' ||\n            typeof axis.max === 'undefined') {\n            axis.tickInterval = 1;\n        }\n        else if (isLinked &&\n            axis.linkedParent &&\n            !tickIntervalOption &&\n            tickPixelIntervalOption ===\n                axis.linkedParent.options.tickPixelInterval) {\n            axis.tickInterval = tickIntervalOption =\n                axis.linkedParent.tickInterval;\n        }\n        else {\n            axis.tickInterval = pick(tickIntervalOption, this.tickAmount ?\n                ((axis.max - axis.min) /\n                    Math.max(this.tickAmount - 1, 1)) :\n                void 0, \n            // For categoried axis, 1 is default, for linear axis use\n            // tickPix\n            categories ?\n                1 :\n                // don't let it be more than the data range\n                (axis.max - axis.min) *\n                    tickPixelIntervalOption /\n                    Math.max(axis.len, tickPixelIntervalOption));\n        }\n        // Now we're finished detecting min and max, crop and group series data.\n        // This is in turn needed in order to find tick positions in ordinal\n        // axes.\n        if (isXAxis && !secondPass) {\n            const hasExtremesChanged = axis.min !==\n                (axis.old && axis.old.min) ||\n                axis.max !== (axis.old && axis.old.max);\n            // First process all series assigned to that axis.\n            axis.series.forEach(function (series) {\n                // Allows filtering out points outside the plot area.\n                series.forceCrop = (series.forceCropping &&\n                    series.forceCropping());\n                series.processData(hasExtremesChanged);\n            });\n            // Then apply grouping if needed. The hasExtremesChanged helps to\n            // decide if the data grouping should be skipped in the further\n            // calculations #16319.\n            fireEvent(this, 'postProcessData', { hasExtremesChanged });\n        }\n        // set the translation factor used in translate function\n        axis.setAxisTranslation();\n        // hook for ordinal axes and radial axes\n        fireEvent(this, 'initialAxisTranslation');\n        // In column-like charts, don't cramp in more ticks than there are\n        // points (#1943, #4184)\n        if (axis.pointRange && !tickIntervalOption) {\n            axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);\n        }\n        // Before normalizing the tick interval, handle minimum tick interval.\n        // This applies only if tickInterval is not defined.\n        const minTickInterval = pick(options.minTickInterval, \n        // In datetime axes, don't go below the data interval, except when\n        // there are scatter-like series involved (#13369).\n        axis.dateTime &&\n            !axis.series.some((s) => s.noSharedTooltip) ?\n            axis.closestPointRange : 0);\n        if (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n            axis.tickInterval = minTickInterval;\n        }\n        // For linear axes, normalize the interval\n        if (!axis.dateTime && !axis.logarithmic && !tickIntervalOption) {\n            axis.tickInterval = getNormalizedTickInterval(axis, axis.tickInterval);\n        }\n        // Prevent ticks from getting so close that we can't draw the labels\n        if (!this.tickAmount) {\n            axis.tickInterval = axis.unsquish();\n        }\n        this.setTickPositions();\n    }\n    /**\n     * Now we have computed the normalized tickInterval, get the tick positions.\n     *\n     * @private\n     * @function Highcharts.Axis#setTickPositions\n     *\n     * @emits Highcharts.Axis#event:afterSetTickPositions\n     */\n    setTickPositions() {\n        const axis = this, options = this.options, tickPositionsOption = options.tickPositions, tickPositioner = options.tickPositioner, minorTickIntervalOption = this.getMinorTickInterval(), hasVerticalPanning = this.hasVerticalPanning(), isColorAxis = this.coll === 'colorAxis', startOnTick = ((isColorAxis || !hasVerticalPanning) && options.startOnTick), endOnTick = ((isColorAxis || !hasVerticalPanning) && options.endOnTick);\n        let tickPositions = [], tickPositionerResult;\n        // Set the tickmarkOffset\n        this.tickmarkOffset = (this.categories &&\n            options.tickmarkPlacement === 'between' &&\n            this.tickInterval === 1) ? 0.5 : 0; // #3202\n        // get minorTickInterval\n        this.minorTickInterval =\n            minorTickIntervalOption === 'auto' &&\n                this.tickInterval ?\n                this.tickInterval / options.minorTicksPerMajor :\n                minorTickIntervalOption;\n        // When there is only one point, or all points have the same value on\n        // this axis, then min and max are equal and tickPositions.length is 0\n        // or 1. In this case, add some padding in order to center the point,\n        // but leave it with one tick. #1337.\n        this.single =\n            this.min === this.max &&\n                defined(this.min) &&\n                !this.tickAmount &&\n                (\n                // Data is on integer (#6563)\n                parseInt(this.min, 10) === this.min ||\n                    // Between integers and decimals are not allowed (#6274)\n                    options.allowDecimals !== false);\n        /**\n         * Contains the current positions that are laid out on the axis. The\n         * positions are numbers in terms of axis values. In a category axis\n         * they are integers, in a datetime axis they are also integers, but\n         * designating milliseconds.\n         *\n         * This property is read only - for modifying the tick positions, use\n         * the `tickPositioner` callback or [axis.tickPositions(\n         * https://api.highcharts.com/highcharts/xAxis.tickPositions) option\n         * instead.\n         *\n         * @name Highcharts.Axis#tickPositions\n         * @type {Highcharts.AxisTickPositionsArray|undefined}\n         */\n        if (tickPositionsOption) {\n            // Find the tick positions. Work on a copy (#1565)\n            tickPositions = tickPositionsOption.slice();\n        }\n        else if (isNumber(this.min) && isNumber(this.max)) {\n            // Too many ticks (#6405). Create a friendly warning and provide two\n            // ticks so at least we can show the data series.\n            if ((!axis.ordinal || !axis.ordinal.positions) &&\n                ((this.max - this.min) /\n                    this.tickInterval >\n                    Math.max(2 * this.len, 200))) {\n                tickPositions = [this.min, this.max];\n                error(19, false, this.chart);\n            }\n            else if (axis.dateTime) {\n                tickPositions = axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, axis.ordinal && axis.ordinal.positions, this.closestPointRange, true);\n            }\n            else if (axis.logarithmic) {\n                tickPositions = axis.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);\n            }\n            else {\n                const startingTickInterval = this.tickInterval;\n                let adjustedTickInterval = startingTickInterval;\n                while (adjustedTickInterval <= startingTickInterval * 2) {\n                    tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);\n                    // If there are more tick positions than the set tickAmount,\n                    // increase the tickInterval and continue until it fits.\n                    // (#17100)\n                    if (this.tickAmount &&\n                        tickPositions.length > this.tickAmount) {\n                        this.tickInterval = getNormalizedTickInterval(this, adjustedTickInterval *= 1.1);\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            // Too dense ticks, keep only the first and last (#4477)\n            if (tickPositions.length > this.len) {\n                tickPositions = [\n                    tickPositions[0],\n                    tickPositions[tickPositions.length - 1]\n                ];\n                // Reduce doubled value (#7339)\n                if (tickPositions[0] === tickPositions[1]) {\n                    tickPositions.length = 1;\n                }\n            }\n            // Run the tick positioner callback, that allows modifying auto tick\n            // positions.\n            if (tickPositioner) {\n                // Make it available to the positioner\n                this.tickPositions = tickPositions;\n                tickPositionerResult = tickPositioner.apply(axis, [this.min, this.max]);\n                if (tickPositionerResult) {\n                    tickPositions = tickPositionerResult;\n                }\n            }\n        }\n        this.tickPositions = tickPositions;\n        // Reset min/max or remove extremes based on start/end on tick\n        this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor\n        this.trimTicks(tickPositions, startOnTick, endOnTick);\n        if (!this.isLinked && isNumber(this.min) && isNumber(this.max)) {\n            // Substract half a unit (#2619, #2846, #2515, #3390), but not in\n            // case of multiple ticks (#6897)\n            if (this.single &&\n                tickPositions.length < 2 &&\n                !this.categories &&\n                !this.series.some((s) => (s.is('heatmap') && s.options.pointPlacement === 'between'))) {\n                this.min -= 0.5;\n                this.max += 0.5;\n            }\n            if (!tickPositionsOption && !tickPositionerResult) {\n                this.adjustTickAmount();\n            }\n        }\n        fireEvent(this, 'afterSetTickPositions');\n    }\n    /**\n     * Handle startOnTick and endOnTick by either adapting to padding min/max or\n     * rounded min/max. Also handle single data points.\n     *\n     * @private\n     * @function Highcharts.Axis#trimTicks\n     *\n     * @param {Array<number>} tickPositions\n     * TO-DO: parameter description\n     *\n     * @param {boolean} [startOnTick]\n     * TO-DO: parameter description\n     *\n     * @param {boolean} [endOnTick]\n     * TO-DO: parameter description\n     */\n    trimTicks(tickPositions, startOnTick, endOnTick) {\n        const roundedMin = tickPositions[0], roundedMax = tickPositions[tickPositions.length - 1], minPointOffset = (!this.isOrdinal && this.minPointOffset) || 0; // (#12716)\n        fireEvent(this, 'trimTicks');\n        if (!this.isLinked) {\n            if (startOnTick && roundedMin !== -Infinity) { // #6502\n                this.min = roundedMin;\n            }\n            else {\n                while (this.min - minPointOffset > tickPositions[0]) {\n                    tickPositions.shift();\n                }\n            }\n            if (endOnTick) {\n                this.max = roundedMax;\n            }\n            else {\n                while (this.max + minPointOffset <\n                    tickPositions[tickPositions.length - 1]) {\n                    tickPositions.pop();\n                }\n            }\n            // If no tick are left, set one tick in the middle (#3195)\n            if (tickPositions.length === 0 &&\n                defined(roundedMin) &&\n                !this.options.tickPositions) {\n                tickPositions.push((roundedMax + roundedMin) / 2);\n            }\n        }\n    }\n    /**\n     * Check if there are multiple axes in the same pane.\n     *\n     * @private\n     * @function Highcharts.Axis#alignToOthers\n     *\n     * @return {boolean|undefined}\n     * True if there are other axes.\n     */\n    alignToOthers() {\n        const axis = this, alignedAxes = [this], options = axis.options, alignThresholds = (this.coll === 'yAxis' &&\n            this.chart.options.chart.alignThresholds), thresholdAlignments = [];\n        let hasOther;\n        axis.thresholdAlignment = void 0;\n        if ((\n        // Only if alignTicks or alignThresholds is true\n        (this.chart.options.chart.alignTicks !== false &&\n            options.alignTicks) || (alignThresholds)) &&\n            // Disabled when startOnTick or endOnTick are false (#7604)\n            options.startOnTick !== false &&\n            options.endOnTick !== false &&\n            // Don't try to align ticks on a log axis, they are not evenly\n            // spaced (#6021)\n            !axis.logarithmic) {\n            // Get a key identifying which pane the axis belongs to\n            const getKey = (axis) => {\n                const { horiz, options } = axis;\n                return [\n                    horiz ? options.left : options.top,\n                    options.width,\n                    options.height,\n                    options.pane\n                ].join(',');\n            };\n            const thisKey = getKey(this);\n            this.chart[this.coll].forEach(function (otherAxis) {\n                const { series } = otherAxis;\n                if (\n                // #4442\n                series.length &&\n                    series.some((s) => s.visible) &&\n                    otherAxis !== axis &&\n                    getKey(otherAxis) === thisKey) {\n                    hasOther = true; // #4201\n                    alignedAxes.push(otherAxis);\n                }\n            });\n        }\n        if (hasOther && alignThresholds) {\n            // Handle alignThresholds. The `thresholdAlignments` array keeps\n            // records of where each axis in the group wants its threshold, from\n            // 0 which is on `axis.min`, to 1 which is on `axis.max`.\n            alignedAxes.forEach((otherAxis) => {\n                const threshAlign = otherAxis.getThresholdAlignment(axis);\n                if (isNumber(threshAlign)) {\n                    thresholdAlignments.push(threshAlign);\n                }\n            });\n            // For each of the axes in the group, record the average\n            // `thresholdAlignment`.\n            const thresholdAlignment = thresholdAlignments.length > 1 ?\n                thresholdAlignments.reduce((sum, n) => (sum += n), 0) / thresholdAlignments.length :\n                void 0;\n            alignedAxes.forEach((axis) => {\n                axis.thresholdAlignment = thresholdAlignment;\n            });\n        }\n        return hasOther;\n    }\n    /**\n     * Where the axis wants its threshold, from 0 which is on `axis.min`, to 1 which\n     * is on `axis.max`.\n     *\n     * @private\n     * @function Highcharts.Axis#getThresholdAlignment\n     */\n    getThresholdAlignment(callerAxis) {\n        if (!isNumber(this.dataMin) ||\n            (this !== callerAxis &&\n                this.series.some((s) => (s.isDirty || s.isDirtyData)))) {\n            this.getSeriesExtremes();\n        }\n        if (isNumber(this.threshold)) {\n            let thresholdAlignment = clamp(((this.threshold - (this.dataMin || 0)) /\n                ((this.dataMax || 0) - (this.dataMin || 0))), 0, 1);\n            if (this.options.reversed) {\n                thresholdAlignment = 1 - thresholdAlignment;\n            }\n            return thresholdAlignment;\n        }\n    }\n    /**\n     * Find the max ticks of either the x and y axis collection, and record it\n     * in `this.tickAmount`.\n     *\n     * @private\n     * @function Highcharts.Axis#getTickAmount\n     */\n    getTickAmount() {\n        const axis = this, options = this.options, tickPixelInterval = options.tickPixelInterval;\n        let tickAmount = options.tickAmount;\n        if (!defined(options.tickInterval) &&\n            !tickAmount &&\n            this.len < tickPixelInterval &&\n            !this.isRadial &&\n            !axis.logarithmic &&\n            options.startOnTick &&\n            options.endOnTick) {\n            tickAmount = 2;\n        }\n        if (!tickAmount && this.alignToOthers()) {\n            // Add 1 because 4 tick intervals require 5 ticks (including first\n            // and last)\n            tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;\n        }\n        // For tick amounts of 2 and 3, compute five ticks and remove the\n        // intermediate ones. This prevents the axis from adding ticks that are\n        // too far away from the data extremes.\n        if (tickAmount < 4) {\n            this.finalTickAmt = tickAmount;\n            tickAmount = 5;\n        }\n        this.tickAmount = tickAmount;\n    }\n    /**\n     * When using multiple axes, adjust the number of ticks to match the highest\n     * number of ticks in that group.\n     *\n     * @private\n     * @function Highcharts.Axis#adjustTickAmount\n     */\n    adjustTickAmount() {\n        const axis = this, { finalTickAmt, max, min, options, tickPositions, tickAmount, thresholdAlignment } = axis, currentTickAmount = tickPositions && tickPositions.length, threshold = pick(axis.threshold, axis.softThreshold ? 0 : null);\n        let len, i, tickInterval = axis.tickInterval, thresholdTickIndex;\n        const \n        // Extend the tickPositions by appending a position\n        append = () => tickPositions.push(correctFloat(tickPositions[tickPositions.length - 1] +\n            tickInterval)), \n        // Extend the tickPositions by prepending a position\n        prepend = () => tickPositions.unshift(correctFloat(tickPositions[0] - tickInterval));\n        // If `thresholdAlignment` is a number, it means the `alignThresholds`\n        // option is true. The `thresholdAlignment` is a scalar value between 0\n        // and 1 for where the threshold should be relative to `axis.min` and\n        // `axis.max`. Now that we know the tick amount, convert this to the\n        // tick index. Unless `thresholdAlignment` is exactly 0 or 1, avoid the\n        // first or last tick because that would lead to series being clipped.\n        if (isNumber(thresholdAlignment)) {\n            thresholdTickIndex = thresholdAlignment < 0.5 ?\n                Math.ceil(thresholdAlignment * (tickAmount - 1)) :\n                Math.floor(thresholdAlignment * (tickAmount - 1));\n            if (options.reversed) {\n                thresholdTickIndex = tickAmount - 1 - thresholdTickIndex;\n            }\n        }\n        if (axis.hasData() && isNumber(min) && isNumber(max)) { // #14769\n            // Adjust extremes and translation to the modified tick positions\n            const adjustExtremes = () => {\n                axis.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n                // Do not crop when ticks are not extremes (#9841)\n                axis.min = options.startOnTick ?\n                    tickPositions[0] :\n                    Math.min(min, tickPositions[0]);\n                axis.max = options.endOnTick ?\n                    tickPositions[tickPositions.length - 1] :\n                    Math.max(max, tickPositions[tickPositions.length - 1]);\n            };\n            // When the axis is subject to the alignThresholds option. Use\n            // axis.threshold because the local threshold includes the\n            // `softThreshold`.\n            if (isNumber(thresholdTickIndex) && isNumber(axis.threshold)) {\n                // Throw away the previously computed tickPositions and start\n                // from scratch with only the threshold itself, then add ticks\n                // below the threshold first, then fill up above the threshold.\n                // If we are not able to fill up to axis.max, double the\n                // tickInterval and run again.\n                while (tickPositions[thresholdTickIndex] !== threshold ||\n                    tickPositions.length !== tickAmount ||\n                    tickPositions[0] > min ||\n                    tickPositions[tickPositions.length - 1] < max) {\n                    tickPositions.length = 0;\n                    tickPositions.push(axis.threshold);\n                    while (tickPositions.length < tickAmount) {\n                        if (\n                        // Start by prepending positions until the threshold\n                        // is at the required index...\n                        tickPositions[thresholdTickIndex] === void 0 ||\n                            tickPositions[thresholdTickIndex] > axis.threshold) {\n                            prepend();\n                        }\n                        else {\n                            // ... then append positions until we have the\n                            // required length\n                            append();\n                        }\n                    }\n                    // Safety vent\n                    if (tickInterval > axis.tickInterval * 8) {\n                        break;\n                    }\n                    tickInterval *= 2;\n                }\n                adjustExtremes();\n            }\n            else if (currentTickAmount < tickAmount) {\n                while (tickPositions.length < tickAmount) {\n                    // Extend evenly for both sides unless we're on the\n                    // threshold (#3965)\n                    if (tickPositions.length % 2 || min === threshold) {\n                        append();\n                    }\n                    else {\n                        prepend();\n                    }\n                }\n                adjustExtremes();\n            }\n            // The finalTickAmt property is set in getTickAmount\n            if (defined(finalTickAmt)) {\n                i = len = tickPositions.length;\n                while (i--) {\n                    if (\n                    // Remove every other tick\n                    (finalTickAmt === 3 && i % 2 === 1) ||\n                        // Remove all but first and last\n                        (finalTickAmt <= 2 && i > 0 && i < len - 1)) {\n                        tickPositions.splice(i, 1);\n                    }\n                }\n                axis.finalTickAmt = void 0;\n            }\n        }\n    }\n    /**\n     * Set the scale based on data min and max, user set min and max or options.\n     *\n     * @private\n     * @function Highcharts.Axis#setScale\n     *\n     * @emits Highcharts.Axis#event:afterSetScale\n     */\n    setScale() {\n        const axis = this, { coll, stacking } = axis;\n        let isDirtyData = false, isXAxisDirty = false;\n        axis.series.forEach((series) => {\n            isDirtyData = isDirtyData || series.isDirtyData || series.isDirty;\n            // When x axis is dirty, we need new data extremes for y as\n            // well:\n            isXAxisDirty = (isXAxisDirty ||\n                (series.xAxis && series.xAxis.isDirty) ||\n                false);\n        });\n        // Set the new axisLength\n        axis.setAxisSize();\n        const isDirtyAxisLength = axis.len !== (axis.old && axis.old.len);\n        // Do we really need to go through all this?\n        if (isDirtyAxisLength ||\n            isDirtyData ||\n            isXAxisDirty ||\n            axis.isLinked ||\n            axis.forceRedraw ||\n            axis.userMin !== (axis.old && axis.old.userMin) ||\n            axis.userMax !== (axis.old && axis.old.userMax) ||\n            axis.alignToOthers()) {\n            if (stacking && coll === 'yAxis') {\n                stacking.buildStacks();\n            }\n            axis.forceRedraw = false;\n            // #18066 delete minRange property to ensure that it will be\n            // calculated again after dirty data in series\n            if (!axis.userMinRange) {\n                axis.minRange = void 0;\n            }\n            // Get data extremes if needed\n            axis.getSeriesExtremes();\n            // Get fixed positions based on tickInterval\n            axis.setTickInterval();\n            if (stacking && coll === 'xAxis') {\n                stacking.buildStacks();\n            }\n            // Mark as dirty if it is not already set to dirty and extremes have\n            // changed. #595.\n            if (!axis.isDirty) {\n                axis.isDirty =\n                    isDirtyAxisLength ||\n                        axis.min !== (axis.old && axis.old.min) ||\n                        axis.max !== (axis.old && axis.old.max);\n            }\n        }\n        else if (stacking) {\n            stacking.cleanStacks();\n        }\n        // Recalculate panning state object, when the data\n        // has changed. It is required when vertical panning is enabled.\n        if (isDirtyData && axis.panningState) {\n            axis.panningState.isDirty = true;\n        }\n        fireEvent(this, 'afterSetScale');\n    }\n    /**\n     * Set the minimum and maximum of the axes after render time. If the\n     * `startOnTick` and `endOnTick` options are true, the minimum and maximum\n     * values are rounded off to the nearest tick. To prevent this, these\n     * options can be set to false before calling setExtremes. Also, setExtremes\n     * will not allow a range lower than the `minRange` option, which by default\n     * is the range of five points.\n     *\n     * @sample highcharts/members/axis-setextremes/\n     *         Set extremes from a button\n     * @sample highcharts/members/axis-setextremes-datetime/\n     *         Set extremes on a datetime axis\n     * @sample highcharts/members/axis-setextremes-off-ticks/\n     *         Set extremes off ticks\n     * @sample stock/members/axis-setextremes/\n     *         Set extremes in Highcharts Stock\n     *\n     * @function Highcharts.Axis#setExtremes\n     *\n     * @param {number} [newMin]\n     * The new minimum value.\n     *\n     * @param {number} [newMax]\n     * The new maximum value.\n     *\n     * @param {boolean} [redraw=true]\n     * Whether to redraw the chart or wait for an explicit call to\n     * {@link Highcharts.Chart#redraw}\n     *\n     * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=true]\n     * Enable or modify animations.\n     *\n     * @param {*} [eventArguments]\n     * Arguments to be accessed in event handler.\n     *\n     * @emits Highcharts.Axis#event:setExtremes\n     */\n    setExtremes(newMin, newMax, redraw, animation, eventArguments) {\n        const axis = this, chart = axis.chart;\n        redraw = pick(redraw, true); // defaults to true\n        axis.series.forEach(function (serie) {\n            delete serie.kdTree;\n        });\n        // Extend the arguments with min and max\n        eventArguments = extend(eventArguments, {\n            min: newMin,\n            max: newMax\n        });\n        // Fire the event\n        fireEvent(axis, 'setExtremes', eventArguments, function () {\n            axis.userMin = newMin;\n            axis.userMax = newMax;\n            axis.eventArgs = eventArguments;\n            if (redraw) {\n                chart.redraw(animation);\n            }\n        });\n    }\n    /**\n     * Overridable method for zooming chart. Pulled out in a separate method to\n     * allow overriding in stock charts.\n     *\n     * @private\n     * @function Highcharts.Axis#zoom\n     */\n    zoom(newMin, newMax) {\n        const axis = this, dataMin = this.dataMin, dataMax = this.dataMax, options = this.options, min = Math.min(dataMin, pick(options.min, dataMin)), max = Math.max(dataMax, pick(options.max, dataMax)), evt = {\n            newMin: newMin,\n            newMax: newMax\n        };\n        fireEvent(this, 'zoom', evt, function (e) {\n            // Use e.newMin and e.newMax - event handlers may have altered them\n            let newMin = e.newMin, newMax = e.newMax;\n            if (newMin !== axis.min || newMax !== axis.max) { // #5790\n                // Prevent pinch zooming out of range. Check for defined is for\n                // #1946. #1734.\n                if (!axis.allowZoomOutside) {\n                    // #6014, sometimes newMax will be smaller than min (or\n                    // newMin will be larger than max).\n                    if (defined(dataMin)) {\n                        if (newMin < min) {\n                            newMin = min;\n                        }\n                        if (newMin > max) {\n                            newMin = max;\n                        }\n                    }\n                    if (defined(dataMax)) {\n                        if (newMax < min) {\n                            newMax = min;\n                        }\n                        if (newMax > max) {\n                            newMax = max;\n                        }\n                    }\n                }\n                // In full view, displaying the reset zoom button is not\n                // required\n                axis.displayBtn = (typeof newMin !== 'undefined' ||\n                    typeof newMax !== 'undefined');\n                // Do it\n                axis.setExtremes(newMin, newMax, false, void 0, { trigger: 'zoom' });\n            }\n            e.zoomed = true;\n        });\n        return evt.zoomed;\n    }\n    /**\n     * Update the axis metrics.\n     *\n     * @private\n     * @function Highcharts.Axis#setAxisSize\n     */\n    setAxisSize() {\n        const chart = this.chart, options = this.options, \n        // [top, right, bottom, left]\n        offsets = options.offsets || [0, 0, 0, 0], horiz = this.horiz, \n        // Check for percentage based input values. Rounding fixes problems\n        // with column overflow and plot line filtering (#4898, #4899)\n        width = this.width = Math.round(relativeLength(pick(options.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth)), height = this.height = Math.round(relativeLength(pick(options.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight)), top = this.top = Math.round(relativeLength(pick(options.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop)), left = this.left = Math.round(relativeLength(pick(options.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft));\n        // Expose basic values to use in Series object and navigator\n        this.bottom = chart.chartHeight - height - top;\n        this.right = chart.chartWidth - width - left;\n        // Direction agnostic properties\n        this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905\n        this.pos = horiz ? left : top; // distance from SVG origin\n    }\n    /**\n     * Get the current extremes for the axis.\n     *\n     * @sample highcharts/members/axis-getextremes/\n     *         Report extremes by click on a button\n     *\n     * @function Highcharts.Axis#getExtremes\n     *\n     * @return {Highcharts.ExtremesObject}\n     * An object containing extremes information.\n     */\n    getExtremes() {\n        const axis = this, log = axis.logarithmic;\n        return {\n            min: log ?\n                correctFloat(log.lin2log(axis.min)) :\n                axis.min,\n            max: log ?\n                correctFloat(log.lin2log(axis.max)) :\n                axis.max,\n            dataMin: axis.dataMin,\n            dataMax: axis.dataMax,\n            userMin: axis.userMin,\n            userMax: axis.userMax\n        };\n    }\n    /**\n     * Get the zero plane either based on zero or on the min or max value.\n     * Used in bar and area plots.\n     *\n     * @function Highcharts.Axis#getThreshold\n     *\n     * @param {number} threshold\n     * The threshold in axis values.\n     *\n     * @return {number}\n     * The translated threshold position in terms of pixels, and corrected to\n     * stay within the axis bounds.\n     */\n    getThreshold(threshold) {\n        const axis = this, log = axis.logarithmic, realMin = log ? log.lin2log(axis.min) : axis.min, realMax = log ? log.lin2log(axis.max) : axis.max;\n        if (threshold === null || threshold === -Infinity) {\n            threshold = realMin;\n        }\n        else if (threshold === Infinity) {\n            threshold = realMax;\n        }\n        else if (realMin > threshold) {\n            threshold = realMin;\n        }\n        else if (realMax < threshold) {\n            threshold = realMax;\n        }\n        return axis.translate(threshold, 0, 1, 0, 1);\n    }\n    /**\n     * Compute auto alignment for the axis label based on which side the axis is\n     * on and the given rotation for the label.\n     *\n     * @private\n     * @function Highcharts.Axis#autoLabelAlign\n     *\n     * @param {number} rotation\n     * The rotation in degrees as set by either the `rotation` or `autoRotation`\n     * options.\n     *\n     * @return {Highcharts.AlignValue}\n     * Can be `\"center\"`, `\"left\"` or `\"right\"`.\n     */\n    autoLabelAlign(rotation) {\n        const angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360, evt = { align: 'center' };\n        fireEvent(this, 'autoLabelAlign', evt, function (e) {\n            if (angle > 15 && angle < 165) {\n                e.align = 'right';\n            }\n            else if (angle > 195 && angle < 345) {\n                e.align = 'left';\n            }\n        });\n        return evt.align;\n    }\n    /**\n     * Get the tick length and width for the axis based on axis options.\n     *\n     * @private\n     * @function Highcharts.Axis#tickSize\n     *\n     * @param {string} [prefix]\n     * 'tick' or 'minorTick'\n     *\n     * @return {Array<number,number>|undefined}\n     * An array of tickLength and tickWidth\n     */\n    tickSize(prefix) {\n        const options = this.options, tickWidth = pick(options[prefix === 'tick' ? 'tickWidth' : 'minorTickWidth'], \n        // Default to 1 on linear and datetime X axes\n        prefix === 'tick' && this.isXAxis && !this.categories ? 1 : 0);\n        let tickLength = options[prefix === 'tick' ? 'tickLength' : 'minorTickLength'], tickSize;\n        if (tickWidth && tickLength) {\n            // Negate the length\n            if (options[prefix + 'Position'] === 'inside') {\n                tickLength = -tickLength;\n            }\n            tickSize = [tickLength, tickWidth];\n        }\n        const e = { tickSize };\n        fireEvent(this, 'afterTickSize', e);\n        return e.tickSize;\n    }\n    /**\n     * Return the size of the labels.\n     *\n     * @private\n     * @function Highcharts.Axis#labelMetrics\n     */\n    labelMetrics() {\n        const renderer = this.chart.renderer, ticks = this.ticks, tick = ticks[Object.keys(ticks)[0]] || {};\n        return this.chart.renderer.fontMetrics(tick.label ||\n            tick.movedLabel ||\n            renderer.box);\n    }\n    /**\n     * Prevent the ticks from getting so close we can't draw the labels. On a\n     * horizontal axis, this is handled by rotating the labels, removing ticks\n     * and adding ellipsis. On a vertical axis remove ticks and add ellipsis.\n     *\n     * @private\n     * @function Highcharts.Axis#unsquish\n     */\n    unsquish() {\n        const labelOptions = this.options.labels, horiz = this.horiz, tickInterval = this.tickInterval, slotSize = this.len / (((this.categories ? 1 : 0) +\n            this.max -\n            this.min) /\n            tickInterval), rotationOption = labelOptions.rotation, \n        // We don't know the actual rendered line height at this point, but\n        // it defaults to 0.75em\n        lineHeight = this.labelMetrics().h * 0.75, range = Math.max(this.max - this.min, 0), \n        // Return the multiple of tickInterval that is needed to avoid\n        // collision\n        getStep = function (spaceNeeded) {\n            let step = spaceNeeded / (slotSize || 1);\n            step = step > 1 ? Math.ceil(step) : 1;\n            // Guard for very small or negative angles (#9835)\n            if (step * tickInterval > range &&\n                spaceNeeded !== Infinity &&\n                slotSize !== Infinity &&\n                range) {\n                step = Math.ceil(range / tickInterval);\n            }\n            return correctFloat(step * tickInterval);\n        };\n        let newTickInterval = tickInterval, rotation, bestScore = Number.MAX_VALUE, autoRotation;\n        if (horiz) {\n            if (!labelOptions.staggerLines) {\n                if (isNumber(rotationOption)) {\n                    autoRotation = [rotationOption];\n                }\n                else if (slotSize < labelOptions.autoRotationLimit) {\n                    autoRotation = labelOptions.autoRotation;\n                }\n            }\n            if (autoRotation) {\n                let step, score;\n                // Loop over the given autoRotation options, and determine which\n                // gives the best score. The best score is that with the lowest\n                // number of steps and a rotation closest to horizontal.\n                for (const rot of autoRotation) {\n                    if (rot === rotationOption ||\n                        (rot && rot >= -90 && rot <= 90)) { // #3891\n                        step = getStep(Math.abs(lineHeight / Math.sin(deg2rad * rot)));\n                        score = step + Math.abs(rot / 360);\n                        if (score < bestScore) {\n                            bestScore = score;\n                            rotation = rot;\n                            newTickInterval = step;\n                        }\n                    }\n                }\n            }\n        }\n        else { // #4411\n            newTickInterval = getStep(lineHeight);\n        }\n        this.autoRotation = autoRotation;\n        this.labelRotation = pick(rotation, isNumber(rotationOption) ? rotationOption : 0);\n        return labelOptions.step ? tickInterval : newTickInterval;\n    }\n    /**\n     * Get the general slot width for labels/categories on this axis. This may\n     * change between the pre-render (from Axis.getOffset) and the final tick\n     * rendering and placement.\n     *\n     * @private\n     * @function Highcharts.Axis#getSlotWidth\n     *\n     * @param {Highcharts.Tick} [tick] Optionally, calculate the slot width\n     * basing on tick label. It is used in highcharts-3d module, where the slots\n     * has different widths depending on perspective angles.\n     *\n     * @return {number}\n     * The pixel width allocated to each axis label.\n     */\n    getSlotWidth(tick) {\n        // #5086, #1580, #1931\n        const chart = this.chart, horiz = this.horiz, labelOptions = this.options.labels, slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), marginLeft = chart.margin[3];\n        // Used by grid axis\n        if (tick && isNumber(tick.slotWidth)) { // #13221, can be 0\n            return tick.slotWidth;\n        }\n        if (horiz && labelOptions.step < 2) {\n            if (labelOptions.rotation) { // #4415\n                return 0;\n            }\n            return ((this.staggerLines || 1) * this.len) / slotCount;\n        }\n        if (!horiz) {\n            // #7028\n            const cssWidth = labelOptions.style.width;\n            if (cssWidth !== void 0) {\n                return parseInt(String(cssWidth), 10);\n            }\n            if (marginLeft) {\n                return marginLeft - chart.spacing[3];\n            }\n        }\n        // Last resort, a fraction of the available size\n        return chart.chartWidth * 0.33;\n    }\n    /**\n     * Render the axis labels and determine whether ellipsis or rotation need to\n     * be applied.\n     *\n     * @private\n     * @function Highcharts.Axis#renderUnsquish\n     */\n    renderUnsquish() {\n        const chart = this.chart, renderer = chart.renderer, tickPositions = this.tickPositions, ticks = this.ticks, labelOptions = this.options.labels, labelStyleOptions = labelOptions.style, horiz = this.horiz, slotWidth = this.getSlotWidth(), innerWidth = Math.max(1, Math.round(slotWidth - 2 * labelOptions.padding)), attr = {}, labelMetrics = this.labelMetrics(), textOverflowOption = labelStyleOptions.textOverflow;\n        let commonWidth, commonTextOverflow, maxLabelLength = 0, label, i, pos;\n        // Set rotation option unless it is \"auto\", like in gauges\n        if (!isString(labelOptions.rotation)) {\n            // #4443\n            attr.rotation = labelOptions.rotation || 0;\n        }\n        // Get the longest label length\n        tickPositions.forEach(function (tickPosition) {\n            const tick = ticks[tickPosition];\n            // Replace label - sorting animation\n            if (tick.movedLabel) {\n                tick.replaceMovedLabel();\n            }\n            if (tick &&\n                tick.label &&\n                tick.label.textPxLength > maxLabelLength) {\n                maxLabelLength = tick.label.textPxLength;\n            }\n        });\n        this.maxLabelLength = maxLabelLength;\n        // Handle auto rotation on horizontal axis\n        if (this.autoRotation) {\n            // Apply rotation only if the label is too wide for the slot, and\n            // the label is wider than its height.\n            if (maxLabelLength > innerWidth &&\n                maxLabelLength > labelMetrics.h) {\n                attr.rotation = this.labelRotation;\n            }\n            else {\n                this.labelRotation = 0;\n            }\n            // Handle word-wrap or ellipsis on vertical axis\n        }\n        else if (slotWidth) {\n            // For word-wrap or ellipsis\n            commonWidth = innerWidth;\n            if (!textOverflowOption) {\n                commonTextOverflow = 'clip';\n                // On vertical axis, only allow word wrap if there is room\n                // for more lines.\n                i = tickPositions.length;\n                while (!horiz && i--) {\n                    pos = tickPositions[i];\n                    label = ticks[pos].label;\n                    if (label) {\n                        // Reset ellipsis in order to get the correct\n                        // bounding box (#4070)\n                        if (label.styles &&\n                            label.styles.textOverflow === 'ellipsis') {\n                            label.css({ textOverflow: 'clip' });\n                            // Set the correct width in order to read\n                            // the bounding box height (#4678, #5034)\n                        }\n                        else if (label.textPxLength > slotWidth) {\n                            label.css({ width: slotWidth + 'px' });\n                        }\n                        if (label.getBBox().height > (this.len / tickPositions.length -\n                            (labelMetrics.h - labelMetrics.f))) {\n                            label.specificTextOverflow = 'ellipsis';\n                        }\n                    }\n                }\n            }\n        }\n        // Add ellipsis if the label length is significantly longer than ideal\n        if (attr.rotation) {\n            commonWidth = (maxLabelLength > chart.chartHeight * 0.5 ?\n                chart.chartHeight * 0.33 :\n                maxLabelLength);\n            if (!textOverflowOption) {\n                commonTextOverflow = 'ellipsis';\n            }\n        }\n        // Set the explicit or automatic label alignment\n        this.labelAlign = labelOptions.align ||\n            this.autoLabelAlign(this.labelRotation);\n        if (this.labelAlign) {\n            attr.align = this.labelAlign;\n        }\n        // Apply general and specific CSS\n        tickPositions.forEach(function (pos) {\n            const tick = ticks[pos], label = tick && tick.label, widthOption = labelStyleOptions.width, css = {};\n            if (label) {\n                // This needs to go before the CSS in old IE (#4502)\n                label.attr(attr);\n                if (tick.shortenLabel) {\n                    tick.shortenLabel();\n                }\n                else if (commonWidth &&\n                    !widthOption &&\n                    // Setting width in this case messes with the bounding box\n                    // (#7975)\n                    labelStyleOptions.whiteSpace !== 'nowrap' &&\n                    (\n                    // Speed optimizing, #7656\n                    commonWidth < label.textPxLength ||\n                        // Resetting CSS, #4928\n                        label.element.tagName === 'SPAN')) {\n                    css.width = commonWidth + 'px';\n                    if (!textOverflowOption) {\n                        css.textOverflow = (label.specificTextOverflow ||\n                            commonTextOverflow);\n                    }\n                    label.css(css);\n                    // Reset previously shortened label (#8210)\n                }\n                else if (label.styles &&\n                    label.styles.width &&\n                    !css.width &&\n                    !widthOption) {\n                    label.css({ width: null });\n                }\n                delete label.specificTextOverflow;\n                tick.rotation = attr.rotation;\n            }\n        }, this);\n        // Note: Why is this not part of getLabelPosition?\n        this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);\n    }\n    /**\n     * Return true if the axis has associated data.\n     *\n     * @function Highcharts.Axis#hasData\n     *\n     * @return {boolean}\n     * True if the axis has associated visible series and those series have\n     * either valid data points or explicit `min` and `max` settings.\n     */\n    hasData() {\n        return this.series.some(function (s) {\n            return s.hasData();\n        }) ||\n            (this.options.showEmpty &&\n                defined(this.min) &&\n                defined(this.max));\n    }\n    /**\n     * Adds the title defined in axis.options.title.\n     *\n     * @function Highcharts.Axis#addTitle\n     *\n     * @param {boolean} [display]\n     * Whether or not to display the title.\n     */\n    addTitle(display) {\n        const axis = this, renderer = axis.chart.renderer, horiz = axis.horiz, opposite = axis.opposite, options = axis.options, axisTitleOptions = options.title, styledMode = axis.chart.styledMode;\n        let textAlign;\n        if (!axis.axisTitle) {\n            textAlign = axisTitleOptions.textAlign;\n            if (!textAlign) {\n                textAlign = (horiz ? {\n                    low: 'left',\n                    middle: 'center',\n                    high: 'right'\n                } : {\n                    low: opposite ? 'right' : 'left',\n                    middle: 'center',\n                    high: opposite ? 'left' : 'right'\n                })[axisTitleOptions.align];\n            }\n            axis.axisTitle = renderer\n                .text(axisTitleOptions.text || '', 0, 0, axisTitleOptions.useHTML)\n                .attr({\n                zIndex: 7,\n                rotation: axisTitleOptions.rotation,\n                align: textAlign\n            })\n                .addClass('highcharts-axis-title');\n            // #7814, don't mutate style option\n            if (!styledMode) {\n                axis.axisTitle.css(merge(axisTitleOptions.style));\n            }\n            axis.axisTitle.add(axis.axisGroup);\n            axis.axisTitle.isNew = true;\n        }\n        // Max width defaults to the length of the axis\n        if (!styledMode &&\n            !axisTitleOptions.style.width &&\n            !axis.isRadial) {\n            axis.axisTitle.css({\n                width: axis.len + 'px'\n            });\n        }\n        // hide or show the title depending on whether showEmpty is set\n        axis.axisTitle[display ? 'show' : 'hide'](display);\n    }\n    /**\n     * Generates a tick for initial positioning.\n     *\n     * @private\n     * @function Highcharts.Axis#generateTick\n     *\n     * @param {number} pos\n     * The tick position in axis values.\n     *\n     * @param {number} [i]\n     * The index of the tick in {@link Axis.tickPositions}.\n     */\n    generateTick(pos) {\n        const axis = this, ticks = axis.ticks;\n        if (!ticks[pos]) {\n            ticks[pos] = new Tick(axis, pos);\n        }\n        else {\n            ticks[pos].addLabel(); // update labels depending on tick interval\n        }\n    }\n    /**\n     * Render the tick labels to a preliminary position to get their sizes\n     *\n     * @private\n     * @function Highcharts.Axis#getOffset\n     *\n     * @emits Highcharts.Axis#event:afterGetOffset\n     */\n    getOffset() {\n        const axis = this, { chart, horiz, options, side, ticks, tickPositions, coll, axisParent // Used in color axis\n         } = axis, renderer = chart.renderer, invertedSide = (chart.inverted && !axis.isZAxis ?\n            [1, 0, 3, 2][side] :\n            side), hasData = axis.hasData(), axisTitleOptions = options.title, labelOptions = options.labels, hasCrossing = isNumber(options.crossing), axisOffset = chart.axisOffset, clipOffset = chart.clipOffset, directionFactor = [-1, 1, 1, -1][side], className = options.className;\n        let showAxis, titleOffset = 0, titleOffsetOption, titleMargin = 0, labelOffset = 0, // reset\n        labelOffsetPadded, lineHeightCorrection;\n        // For reuse in Axis.render\n        axis.showAxis = showAxis = hasData || options.showEmpty;\n        // Set/reset staggerLines\n        axis.staggerLines = (axis.horiz && labelOptions.staggerLines) || void 0;\n        // Create the axisGroup and gridGroup elements on first iteration\n        if (!axis.axisGroup) {\n            const createGroup = (name, suffix, zIndex) => renderer.g(name)\n                .attr({ zIndex })\n                .addClass(`highcharts-${coll.toLowerCase()}${suffix} ` +\n                (this.isRadial ? `highcharts-radial-axis${suffix} ` : '') +\n                (className || ''))\n                .add(axisParent);\n            axis.gridGroup = createGroup('grid', '-grid', options.gridZIndex);\n            axis.axisGroup = createGroup('axis', '', options.zIndex);\n            axis.labelGroup = createGroup('axis-labels', '-labels', labelOptions.zIndex);\n        }\n        if (hasData || axis.isLinked) {\n            // Generate ticks\n            tickPositions.forEach(function (pos) {\n                // i is not used here, but may be used in overrides\n                axis.generateTick(pos);\n            });\n            axis.renderUnsquish();\n            // Left side must be align: right and right side must\n            // have align: left for labels\n            axis.reserveSpaceDefault = (side === 0 ||\n                side === 2 ||\n                { 1: 'left', 3: 'right' }[side] === axis.labelAlign);\n            if (pick(labelOptions.reserveSpace, hasCrossing ? false : null, axis.labelAlign === 'center' ? true : null, axis.reserveSpaceDefault)) {\n                tickPositions.forEach(function (pos) {\n                    // get the highest offset\n                    labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset);\n                });\n            }\n            if (axis.staggerLines) {\n                labelOffset *= axis.staggerLines;\n            }\n            axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);\n        }\n        else { // doesn't have data\n            objectEach(ticks, function (tick, n) {\n                tick.destroy();\n                delete ticks[n];\n            });\n        }\n        if (axisTitleOptions &&\n            axisTitleOptions.text &&\n            axisTitleOptions.enabled !== false) {\n            axis.addTitle(showAxis);\n            if (showAxis &&\n                !hasCrossing &&\n                axisTitleOptions.reserveSpace !== false) {\n                axis.titleOffset = titleOffset =\n                    axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n                titleOffsetOption = axisTitleOptions.offset;\n                titleMargin = defined(titleOffsetOption) ?\n                    0 :\n                    pick(axisTitleOptions.margin, horiz ? 5 : 10);\n            }\n        }\n        // Render the axis line\n        axis.renderLine();\n        // handle automatic or user set offset\n        axis.offset = directionFactor * pick(options.offset, axisOffset[side] ? axisOffset[side] + (options.margin || 0) : 0);\n        axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar\n        if (side === 0) {\n            lineHeightCorrection = -axis.labelMetrics().h;\n        }\n        else if (side === 2) {\n            lineHeightCorrection = axis.tickRotCorr.y;\n        }\n        else {\n            lineHeightCorrection = 0;\n        }\n        // Find the padded label offset\n        labelOffsetPadded = Math.abs(labelOffset) + titleMargin;\n        if (labelOffset) {\n            labelOffsetPadded -= lineHeightCorrection;\n            labelOffsetPadded += directionFactor * (horiz ?\n                pick(labelOptions.y, axis.tickRotCorr.y +\n                    directionFactor * labelOptions.distance) :\n                pick(labelOptions.x, directionFactor * labelOptions.distance));\n        }\n        axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n        if (axis.getMaxLabelDimensions) {\n            axis.maxLabelDimensions = axis.getMaxLabelDimensions(ticks, tickPositions);\n        }\n        // Due to GridAxis.tickSize, tickSize should be calculated after ticks\n        // has rendered.\n        if (coll !== 'colorAxis') {\n            const tickSize = this.tickSize('tick');\n            axisOffset[side] = Math.max(axisOffset[side], (axis.axisTitleMargin || 0) + titleOffset +\n                directionFactor * axis.offset, labelOffsetPadded, // #3027\n            tickPositions && tickPositions.length && tickSize ?\n                tickSize[0] + directionFactor * axis.offset :\n                0 // #4866\n            );\n            // Decide the clipping needed to keep the graph inside\n            // the plot area and axis lines\n            const clip = !axis.axisLine || options.offset ?\n                0 :\n                // #4308, #4371:\n                Math.floor(axis.axisLine.strokeWidth() / 2) * 2;\n            clipOffset[invertedSide] =\n                Math.max(clipOffset[invertedSide], clip);\n        }\n        fireEvent(this, 'afterGetOffset');\n    }\n    /**\n     * Internal function to get the path for the axis line. Extended for polar\n     * charts.\n     *\n     * @function Highcharts.Axis#getLinePath\n     *\n     * @param {number} lineWidth\n     * The line width in pixels.\n     *\n     * @return {Highcharts.SVGPathArray}\n     * The SVG path definition in array form.\n     */\n    getLinePath(lineWidth) {\n        const chart = this.chart, opposite = this.opposite, offset = this.offset, horiz = this.horiz, lineLeft = this.left + (opposite ? this.width : 0) + offset, lineTop = chart.chartHeight - this.bottom -\n            (opposite ? this.height : 0) + offset;\n        if (opposite) {\n            lineWidth *= -1; // crispify the other way - #1480, #1687\n        }\n        return chart.renderer\n            .crispLine([\n            [\n                'M',\n                horiz ?\n                    this.left :\n                    lineLeft,\n                horiz ?\n                    lineTop :\n                    this.top\n            ],\n            [\n                'L',\n                horiz ?\n                    chart.chartWidth - this.right :\n                    lineLeft,\n                horiz ?\n                    lineTop :\n                    chart.chartHeight - this.bottom\n            ]\n        ], lineWidth);\n    }\n    /**\n     * Render the axis line. Called internally when rendering and redrawing the\n     * axis.\n     *\n     * @function Highcharts.Axis#renderLine\n     */\n    renderLine() {\n        if (!this.axisLine) {\n            this.axisLine = this.chart.renderer.path()\n                .addClass('highcharts-axis-line')\n                .add(this.axisGroup);\n            if (!this.chart.styledMode) {\n                this.axisLine.attr({\n                    stroke: this.options.lineColor,\n                    'stroke-width': this.options.lineWidth,\n                    zIndex: 7\n                });\n            }\n        }\n    }\n    /**\n     * Position the axis title.\n     *\n     * @private\n     * @function Highcharts.Axis#getTitlePosition\n     *\n     * @return {Highcharts.PositionObject}\n     * X and Y positions for the title.\n     */\n    getTitlePosition(axisTitle) {\n        // compute anchor points for each of the title align options\n        const horiz = this.horiz, axisLeft = this.left, axisTop = this.top, axisLength = this.len, axisTitleOptions = this.options.title, margin = horiz ? axisLeft : axisTop, opposite = this.opposite, offset = this.offset, xOption = axisTitleOptions.x, yOption = axisTitleOptions.y, fontMetrics = this.chart.renderer.fontMetrics(axisTitle), \n        // The part of a multiline text that is below the baseline of the\n        // first line. Subtract 1 to preserve pixel-perfectness from the\n        // old behaviour (v5.0.12), where only one line was allowed.\n        textHeightOvershoot = axisTitle ? Math.max(axisTitle.getBBox(false, 0).height - fontMetrics.h - 1, 0) : 0, \n        // the position in the length direction of the axis\n        alongAxis = ({\n            low: margin + (horiz ? 0 : axisLength),\n            middle: margin + axisLength / 2,\n            high: margin + (horiz ? axisLength : 0)\n        })[axisTitleOptions.align], \n        // the position in the perpendicular direction of the axis\n        offAxis = (horiz ? axisTop + this.height : axisLeft) +\n            (horiz ? 1 : -1) * // horizontal axis reverses the margin\n                (opposite ? -1 : 1) * // so does opposite axes\n                (this.axisTitleMargin || 0) +\n            [\n                -textHeightOvershoot,\n                textHeightOvershoot,\n                fontMetrics.f,\n                -textHeightOvershoot // left\n            ][this.side], titlePosition = {\n            x: horiz ?\n                alongAxis + xOption :\n                offAxis + (opposite ? this.width : 0) + offset + xOption,\n            y: horiz ?\n                offAxis + yOption - (opposite ? this.height : 0) + offset :\n                alongAxis + yOption\n        };\n        fireEvent(this, 'afterGetTitlePosition', { titlePosition: titlePosition });\n        return titlePosition;\n    }\n    /**\n     * Render a minor tick into the given position. If a minor tick already\n     * exists in this position, move it.\n     *\n     * @function Highcharts.Axis#renderMinorTick\n     *\n     * @param {number} pos\n     * The position in axis values.\n     *\n     * @param {boolean} slideIn\n     * Whether the tick should animate in from last computed position\n     */\n    renderMinorTick(pos, slideIn) {\n        const axis = this;\n        const minorTicks = axis.minorTicks;\n        if (!minorTicks[pos]) {\n            minorTicks[pos] = new Tick(axis, pos, 'minor');\n        }\n        // Render new ticks in old position\n        if (slideIn && minorTicks[pos].isNew) {\n            minorTicks[pos].render(null, true);\n        }\n        minorTicks[pos].render(null, false, 1);\n    }\n    /**\n     * Render a major tick into the given position. If a tick already exists\n     * in this position, move it.\n     *\n     * @function Highcharts.Axis#renderTick\n     *\n     * @param {number} pos\n     * The position in axis values.\n     *\n     * @param {number} i\n     * The tick index.\n     *\n     * @param {boolean} slideIn\n     * Whether the tick should animate in from last computed position\n     */\n    renderTick(pos, i, slideIn) {\n        const axis = this, isLinked = axis.isLinked, ticks = axis.ticks;\n        // Linked axes need an extra check to find out if\n        if (!isLinked ||\n            (pos >= axis.min && pos <= axis.max) ||\n            (axis.grid && axis.grid.isColumn)) {\n            if (!ticks[pos]) {\n                ticks[pos] = new Tick(axis, pos);\n            }\n            // NOTE this seems like overkill. Could be handled in tick.render by\n            // setting old position in attr, then set new position in animate.\n            // render new ticks in old position\n            if (slideIn && ticks[pos].isNew) {\n                // Start with negative opacity so that it is visible from\n                // halfway into the animation\n                ticks[pos].render(i, true, -1);\n            }\n            ticks[pos].render(i);\n        }\n    }\n    /**\n     * Render the axis.\n     *\n     * @private\n     * @function Highcharts.Axis#render\n     *\n     * @emits Highcharts.Axis#event:afterRender\n     */\n    render() {\n        const axis = this, chart = axis.chart, log = axis.logarithmic, renderer = chart.renderer, options = axis.options, isLinked = axis.isLinked, tickPositions = axis.tickPositions, axisTitle = axis.axisTitle, ticks = axis.ticks, minorTicks = axis.minorTicks, alternateBands = axis.alternateBands, stackLabelOptions = options.stackLabels, alternateGridColor = options.alternateGridColor, crossing = options.crossing, tickmarkOffset = axis.tickmarkOffset, axisLine = axis.axisLine, showAxis = axis.showAxis, animation = animObject(renderer.globalAnimation);\n        let from, to;\n        // Reset\n        axis.labelEdge.length = 0;\n        axis.overlap = false;\n        // Mark all elements inActive before we go over and mark the active ones\n        [ticks, minorTicks, alternateBands].forEach(function (coll) {\n            objectEach(coll, function (tick) {\n                tick.isActive = false;\n            });\n        });\n        // Crossing\n        if (isNumber(crossing)) {\n            const otherAxis = this.isXAxis ? chart.yAxis[0] : chart.xAxis[0], directionFactor = [1, -1, -1, 1][this.side];\n            if (otherAxis) {\n                let px = otherAxis.toPixels(crossing, true);\n                if (axis.horiz) {\n                    px = otherAxis.len - px;\n                }\n                axis.offset = directionFactor * px;\n            }\n        }\n        // If the series has data draw the ticks. Else only the line and title\n        if (axis.hasData() || isLinked) {\n            const slideInTicks = axis.chart.hasRendered &&\n                axis.old && isNumber(axis.old.min);\n            // minor ticks\n            if (axis.minorTickInterval && !axis.categories) {\n                axis.getMinorTickPositions().forEach(function (pos) {\n                    axis.renderMinorTick(pos, slideInTicks);\n                });\n            }\n            // Major ticks. Pull out the first item and render it last so that\n            // we can get the position of the neighbour label. #808.\n            if (tickPositions.length) { // #1300\n                tickPositions.forEach(function (pos, i) {\n                    axis.renderTick(pos, i, slideInTicks);\n                });\n                // In a categorized axis, the tick marks are displayed\n                // between labels. So we need to add a tick mark and\n                // grid line at the left edge of the X axis.\n                if (tickmarkOffset && (axis.min === 0 || axis.single)) {\n                    if (!ticks[-1]) {\n                        ticks[-1] = new Tick(axis, -1, null, true);\n                    }\n                    ticks[-1].render(-1);\n                }\n            }\n            // alternate grid color\n            if (alternateGridColor) {\n                tickPositions.forEach(function (pos, i) {\n                    to = typeof tickPositions[i + 1] !== 'undefined' ?\n                        tickPositions[i + 1] + tickmarkOffset :\n                        axis.max - tickmarkOffset;\n                    if (i % 2 === 0 &&\n                        pos < axis.max &&\n                        to <= axis.max + (chart.polar ?\n                            -tickmarkOffset :\n                            tickmarkOffset)) { // #2248, #4660\n                        if (!alternateBands[pos]) {\n                            // Should be imported from PlotLineOrBand.js, but\n                            // the dependency cycle with axis is a problem\n                            alternateBands[pos] = new H.PlotLineOrBand(axis);\n                        }\n                        from = pos + tickmarkOffset; // #949\n                        alternateBands[pos].options = {\n                            from: log ? log.lin2log(from) : from,\n                            to: log ? log.lin2log(to) : to,\n                            color: alternateGridColor,\n                            className: 'highcharts-alternate-grid'\n                        };\n                        alternateBands[pos].render();\n                        alternateBands[pos].isActive = true;\n                    }\n                });\n            }\n            // custom plot lines and bands\n            if (!axis._addedPlotLB) { // only first time\n                axis._addedPlotLB = true;\n                (options.plotLines || [])\n                    .concat(options.plotBands || [])\n                    .forEach(function (plotLineOptions) {\n                    axis\n                        .addPlotBandOrLine(plotLineOptions);\n                });\n            }\n        } // end if hasData\n        // Remove inactive ticks\n        [ticks, minorTicks, alternateBands].forEach(function (coll) {\n            const forDestruction = [], delay = animation.duration, destroyInactiveItems = function () {\n                let i = forDestruction.length;\n                while (i--) {\n                    // When resizing rapidly, the same items\n                    // may be destroyed in different timeouts,\n                    // or the may be reactivated\n                    if (coll[forDestruction[i]] &&\n                        !coll[forDestruction[i]].isActive) {\n                        coll[forDestruction[i]].destroy();\n                        delete coll[forDestruction[i]];\n                    }\n                }\n            };\n            objectEach(coll, function (tick, pos) {\n                if (!tick.isActive) {\n                    // Render to zero opacity\n                    tick.render(pos, false, 0);\n                    tick.isActive = false;\n                    forDestruction.push(pos);\n                }\n            });\n            // When the objects are finished fading out, destroy them\n            syncTimeout(destroyInactiveItems, coll === alternateBands ||\n                !chart.hasRendered ||\n                !delay ?\n                0 :\n                delay);\n        });\n        // Set the axis line path\n        if (axisLine) {\n            axisLine[axisLine.isPlaced ? 'animate' : 'attr']({\n                d: this.getLinePath(axisLine.strokeWidth())\n            });\n            axisLine.isPlaced = true;\n            // Show or hide the line depending on options.showEmpty\n            axisLine[showAxis ? 'show' : 'hide'](showAxis);\n        }\n        if (axisTitle && showAxis) {\n            axisTitle[axisTitle.isNew ? 'attr' : 'animate'](axis.getTitlePosition(axisTitle));\n            axisTitle.isNew = false;\n        }\n        // Stacked totals:\n        if (stackLabelOptions && stackLabelOptions.enabled && axis.stacking) {\n            axis.stacking.renderStackTotals();\n        }\n        // End stacked totals\n        // Record old scaling for updating/animation\n        axis.old = {\n            len: axis.len,\n            max: axis.max,\n            min: axis.min,\n            transA: axis.transA,\n            userMax: axis.userMax,\n            userMin: axis.userMin\n        };\n        axis.isDirty = false;\n        fireEvent(this, 'afterRender');\n    }\n    /**\n     * Redraw the axis to reflect changes in the data or axis extremes. Called\n     * internally from Highcharts.Chart#redraw.\n     *\n     * @private\n     * @function Highcharts.Axis#redraw\n     */\n    redraw() {\n        if (this.visible) {\n            // render the axis\n            this.render();\n            // move plot lines and bands\n            this.plotLinesAndBands.forEach(function (plotLine) {\n                plotLine.render();\n            });\n        }\n        // mark associated series as dirty and ready for redraw\n        this.series.forEach(function (series) {\n            series.isDirty = true;\n        });\n    }\n    /**\n     * Returns an array of axis properties, that should be untouched during\n     * reinitialization.\n     *\n     * @private\n     * @function Highcharts.Axis#getKeepProps\n     */\n    getKeepProps() {\n        return (this.keepProps || Axis.keepProps);\n    }\n    /**\n     * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint\n     * to fully remove the axis.\n     *\n     * @private\n     * @function Highcharts.Axis#destroy\n     *\n     * @param {boolean} [keepEvents]\n     * Whether to preserve events, used internally in Axis.update.\n     */\n    destroy(keepEvents) {\n        const axis = this, plotLinesAndBands = axis.plotLinesAndBands, eventOptions = this.eventOptions;\n        fireEvent(this, 'destroy', { keepEvents: keepEvents });\n        // Remove the events\n        if (!keepEvents) {\n            removeEvent(axis);\n        }\n        // Destroy collections\n        [axis.ticks, axis.minorTicks, axis.alternateBands].forEach(function (coll) {\n            destroyObjectProperties(coll);\n        });\n        if (plotLinesAndBands) {\n            let i = plotLinesAndBands.length;\n            while (i--) { // #1975\n                plotLinesAndBands[i].destroy();\n            }\n        }\n        // Destroy elements\n        ['axisLine', 'axisTitle', 'axisGroup',\n            'gridGroup', 'labelGroup', 'cross', 'scrollbar'].forEach(function (prop) {\n            if (axis[prop]) {\n                axis[prop] = axis[prop].destroy();\n            }\n        });\n        // Destroy each generated group for plotlines and plotbands\n        for (const plotGroup in axis.plotLinesAndBandsGroups) { // eslint-disable-line guard-for-in\n            axis.plotLinesAndBandsGroups[plotGroup] =\n                axis.plotLinesAndBandsGroups[plotGroup].destroy();\n        }\n        // Delete all properties and fall back to the prototype.\n        objectEach(axis, function (val, key) {\n            if (axis.getKeepProps().indexOf(key) === -1) {\n                delete axis[key];\n            }\n        });\n        this.eventOptions = eventOptions;\n    }\n    /**\n     * Internal function to draw a crosshair.\n     *\n     * @function Highcharts.Axis#drawCrosshair\n     *\n     * @param {Highcharts.PointerEventObject} [e]\n     * The event arguments from the modified pointer event, extended with\n     * `chartX` and `chartY`\n     *\n     * @param {Highcharts.Point} [point]\n     * The Point object if the crosshair snaps to points.\n     *\n     * @emits Highcharts.Axis#event:afterDrawCrosshair\n     * @emits Highcharts.Axis#event:drawCrosshair\n     */\n    drawCrosshair(e, point) {\n        const options = this.crosshair, snap = pick(options && options.snap, true), chart = this.chart;\n        let path, pos, categorized, graphic = this.cross, crossOptions;\n        fireEvent(this, 'drawCrosshair', { e: e, point: point });\n        // Use last available event when updating non-snapped crosshairs without\n        // mouse interaction (#5287)\n        if (!e) {\n            e = this.cross && this.cross.e;\n        }\n        if (\n        // Disabled in options\n        !options ||\n            // Snap\n            ((defined(point) || !snap) === false)) {\n            this.hideCrosshair();\n        }\n        else {\n            // Get the path\n            if (!snap) {\n                pos = e &&\n                    (this.horiz ?\n                        e.chartX - this.pos :\n                        this.len - e.chartY + this.pos);\n            }\n            else if (defined(point)) {\n                // #3834\n                pos = pick(this.coll !== 'colorAxis' ?\n                    point.crosshairPos : // 3D axis extension\n                    null, this.isXAxis ?\n                    point.plotX :\n                    this.len - point.plotY);\n            }\n            if (defined(pos)) {\n                crossOptions = {\n                    // value, only used on radial\n                    value: point && (this.isXAxis ?\n                        point.x :\n                        pick(point.stackY, point.y)),\n                    translatedValue: pos\n                };\n                if (chart.polar) {\n                    // Additional information required for crosshairs in\n                    // polar chart\n                    extend(crossOptions, {\n                        isCrosshair: true,\n                        chartX: e && e.chartX,\n                        chartY: e && e.chartY,\n                        point: point\n                    });\n                }\n                path = this.getPlotLinePath(crossOptions) ||\n                    null; // #3189\n            }\n            if (!defined(path)) {\n                this.hideCrosshair();\n                return;\n            }\n            categorized = this.categories && !this.isRadial;\n            // Draw the cross\n            if (!graphic) {\n                this.cross = graphic = chart.renderer\n                    .path()\n                    .addClass('highcharts-crosshair highcharts-crosshair-' +\n                    (categorized ? 'category ' : 'thin ') +\n                    (options.className || ''))\n                    .attr({\n                    zIndex: pick(options.zIndex, 2)\n                })\n                    .add();\n                // Presentational attributes\n                if (!chart.styledMode) {\n                    graphic.attr({\n                        stroke: options.color ||\n                            (categorized ?\n                                Color\n                                    .parse(\"#ccd3ff\" /* Palette.highlightColor20 */)\n                                    .setOpacity(0.25)\n                                    .get() :\n                                \"#cccccc\" /* Palette.neutralColor20 */),\n                        'stroke-width': pick(options.width, 1)\n                    }).css({\n                        'pointer-events': 'none'\n                    });\n                    if (options.dashStyle) {\n                        graphic.attr({\n                            dashstyle: options.dashStyle\n                        });\n                    }\n                }\n            }\n            graphic.show().attr({\n                d: path\n            });\n            if (categorized && !options.width) {\n                graphic.attr({\n                    'stroke-width': this.transA\n                });\n            }\n            this.cross.e = e;\n        }\n        fireEvent(this, 'afterDrawCrosshair', { e: e, point: point });\n    }\n    /**\n     * Hide the crosshair if visible.\n     *\n     * @function Highcharts.Axis#hideCrosshair\n     */\n    hideCrosshair() {\n        if (this.cross) {\n            this.cross.hide();\n        }\n        fireEvent(this, 'afterHideCrosshair');\n    }\n    /**\n     * Check whether the chart has vertical panning ('y' or 'xy' type).\n     *\n     * @private\n     * @function Highcharts.Axis#hasVerticalPanning\n     */\n    hasVerticalPanning() {\n        const panningOptions = this.chart.options.chart.panning;\n        return Boolean(panningOptions &&\n            panningOptions.enabled && // #14624\n            /y/.test(panningOptions.type));\n    }\n    /**\n     * Update an axis object with a new set of options. The options are merged\n     * with the existing options, so only new or altered options need to be\n     * specified.\n     *\n     * @sample highcharts/members/axis-update/\n     *         Axis update demo\n     *\n     * @function Highcharts.Axis#update\n     *\n     * @param {Highcharts.AxisOptions} options\n     * The new options that will be merged in with existing options on the axis.\n     *\n     * @param {boolean} [redraw=true]\n     * Whether to redraw the chart after the axis is altered. If doing more\n     * operations on the chart, it is a good idea to set redraw to false and\n     * call {@link Chart#redraw} after.\n     */\n    update(options, redraw) {\n        const chart = this.chart;\n        options = merge(this.userOptions, options);\n        this.destroy(true);\n        this.init(chart, options);\n        chart.isDirtyBox = true;\n        if (pick(redraw, true)) {\n            chart.redraw();\n        }\n    }\n    /**\n     * Remove the axis from the chart.\n     *\n     * @sample highcharts/members/chart-addaxis/\n     *         Add and remove axes\n     *\n     * @function Highcharts.Axis#remove\n     *\n     * @param {boolean} [redraw=true]\n     * Whether to redraw the chart following the remove.\n     */\n    remove(redraw) {\n        const chart = this.chart, coll = this.coll, axisSeries = this.series;\n        let i = axisSeries.length;\n        // Remove associated series (#2687)\n        while (i--) {\n            if (axisSeries[i]) {\n                axisSeries[i].remove(false);\n            }\n        }\n        // Remove the axis\n        erase(chart.axes, this);\n        erase(chart[coll] || [], this);\n        chart.orderItems(coll);\n        this.destroy();\n        chart.isDirtyBox = true;\n        if (pick(redraw, true)) {\n            chart.redraw();\n        }\n    }\n    /**\n     * Update the axis title by options after render time.\n     *\n     * @sample highcharts/members/axis-settitle/\n     *         Set a new Y axis title\n     *\n     * @function Highcharts.Axis#setTitle\n     *\n     * @param {Highcharts.AxisTitleOptions} titleOptions\n     * The additional title options.\n     *\n     * @param {boolean} [redraw=true]\n     * Whether to redraw the chart after setting the title.\n     */\n    setTitle(titleOptions, redraw) {\n        this.update({ title: titleOptions }, redraw);\n    }\n    /**\n     * Set new axis categories and optionally redraw.\n     *\n     * @sample highcharts/members/axis-setcategories/\n     *         Set categories by click on a button\n     *\n     * @function Highcharts.Axis#setCategories\n     *\n     * @param {Array<string>} categories\n     * The new categories.\n     *\n     * @param {boolean} [redraw=true]\n     * Whether to redraw the chart.\n     */\n    setCategories(categories, redraw) {\n        this.update({ categories: categories }, redraw);\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nAxis.defaultOptions = AxisDefaults.defaultXAxisOptions;\n// Properties to survive after destroy, needed for Axis.update (#4317,\n// #5773, #5881).\nAxis.keepProps = [\n    'coll',\n    'extKey',\n    'hcEvents',\n    'names',\n    'series',\n    'userMax',\n    'userMin'\n];\n/* *\n *\n *  Default Export\n *\n * */\nexport default Axis;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Options for the path on the Axis to be calculated.\n * @interface Highcharts.AxisPlotLinePathOptionsObject\n */ /**\n* Axis value.\n* @name Highcharts.AxisPlotLinePathOptionsObject#value\n* @type {number|undefined}\n*/ /**\n* Line width used for calculation crisp line coordinates. Defaults to 1.\n* @name Highcharts.AxisPlotLinePathOptionsObject#lineWidth\n* @type {number|undefined}\n*/ /**\n* If `false`, the function will return null when it falls outside the axis\n* bounds. If `true`, the function will return a path aligned to the plot area\n* sides if it falls outside. If `pass`, it will return a path outside.\n* @name Highcharts.AxisPlotLinePathOptionsObject#force\n* @type {string|boolean|undefined}\n*/ /**\n* Used in Highcharts Stock. When `true`, plot paths\n* (crosshair, plotLines, gridLines)\n* will be rendered on all axes when defined on the first axis.\n* @name Highcharts.AxisPlotLinePathOptionsObject#acrossPanes\n* @type {boolean|undefined}\n*/ /**\n* Use old coordinates (for resizing and rescaling).\n* If not set, defaults to `false`.\n* @name Highcharts.AxisPlotLinePathOptionsObject#old\n* @type {boolean|undefined}\n*/ /**\n* If given, return the plot line path of a pixel position on the axis.\n* @name Highcharts.AxisPlotLinePathOptionsObject#translatedValue\n* @type {number|undefined}\n*/ /**\n* Used in Polar axes. Reverse the positions for concatenation of polygonal\n* plot bands\n* @name Highcharts.AxisPlotLinePathOptionsObject#reverse\n* @type {boolean|undefined}\n*/\n/**\n * Options for crosshairs on axes.\n *\n * @product highstock\n *\n * @typedef {Highcharts.XAxisCrosshairOptions|Highcharts.YAxisCrosshairOptions} Highcharts.AxisCrosshairOptions\n */\n/**\n * @typedef {\"navigator\"|\"pan\"|\"rangeSelectorButton\"|\"rangeSelectorInput\"|\"scrollbar\"|\"traverseUpButton\"|\"zoom\"} Highcharts.AxisExtremesTriggerValue\n */\n/**\n * @callback Highcharts.AxisEventCallbackFunction\n *\n * @param {Highcharts.Axis} this\n */\n/**\n * @callback Highcharts.AxisLabelsFormatterCallbackFunction\n *\n * @param {Highcharts.AxisLabelsFormatterContextObject} this\n *\n * @param {Highcharts.AxisLabelsFormatterContextObject} ctx\n *\n * @return {string}\n */\n/**\n * @interface Highcharts.AxisLabelsFormatterContextObject\n */ /**\n* The axis item of the label\n* @name Highcharts.AxisLabelsFormatterContextObject#axis\n* @type {Highcharts.Axis}\n*/ /**\n* The chart instance.\n* @name Highcharts.AxisLabelsFormatterContextObject#chart\n* @type {Highcharts.Chart}\n*/ /**\n* Default formatting of date/time labels.\n* @name Highcharts.AxisLabelsFormatterContextObject#dateTimeLabelFormat\n* @type {string|undefined}\n*/ /**\n* Whether the label belongs to the first tick on the axis.\n* @name Highcharts.AxisLabelsFormatterContextObject#isFirst\n* @type {boolean}\n*/ /**\n* Whether the label belongs to the last tick on the axis.\n* @name Highcharts.AxisLabelsFormatterContextObject#isLast\n* @type {boolean}\n*/ /**\n* The position on the axis in terms of axis values. For category axes, a\n* zero-based index. For datetime axes, the JavaScript time in milliseconds\n* since 1970.\n* @name Highcharts.AxisLabelsFormatterContextObject#pos\n* @type {number}\n*/ /**\n* The preformatted text as the result of the default formatting. For example\n* dates will be formatted as strings, and numbers with language-specific comma\n* separators, thousands separators and numeric symbols like `k` or `M`.\n* @name Highcharts.AxisLabelsFormatterContextObject#text\n* @type {string|undefined}\n*/ /**\n* The Tick instance.\n* @name Highcharts.AxisLabelsFormatterContextObject#tick\n* @type {Highcharts.Tick}\n*/ /**\n* This can be either a numeric value or a category string.\n* @name Highcharts.AxisLabelsFormatterContextObject#value\n* @type {number|string}\n*/\n/**\n * Options for axes.\n *\n * @typedef {Highcharts.XAxisOptions|Highcharts.YAxisOptions|Highcharts.ZAxisOptions} Highcharts.AxisOptions\n */\n/**\n * @callback Highcharts.AxisPointBreakEventCallbackFunction\n *\n * @param {Highcharts.Axis} this\n *\n * @param {Highcharts.AxisPointBreakEventObject} evt\n */\n/**\n * @interface Highcharts.AxisPointBreakEventObject\n */ /**\n* @name Highcharts.AxisPointBreakEventObject#brk\n* @type {Highcharts.Dictionary<number>}\n*/ /**\n* @name Highcharts.AxisPointBreakEventObject#point\n* @type {Highcharts.Point}\n*/ /**\n* @name Highcharts.AxisPointBreakEventObject#preventDefault\n* @type {Function}\n*/ /**\n* @name Highcharts.AxisPointBreakEventObject#target\n* @type {Highcharts.SVGElement}\n*/ /**\n* @name Highcharts.AxisPointBreakEventObject#type\n* @type {\"pointBreak\"|\"pointInBreak\"}\n*/\n/**\n * @callback Highcharts.AxisSetExtremesEventCallbackFunction\n *\n * @param {Highcharts.Axis} this\n *\n * @param {Highcharts.AxisSetExtremesEventObject} evt\n */\n/**\n * @interface Highcharts.AxisSetExtremesEventObject\n * @extends Highcharts.ExtremesObject\n */ /**\n* @name Highcharts.AxisSetExtremesEventObject#preventDefault\n* @type {Function}\n*/ /**\n* @name Highcharts.AxisSetExtremesEventObject#target\n* @type {Highcharts.SVGElement}\n*/ /**\n* @name Highcharts.AxisSetExtremesEventObject#trigger\n* @type {Highcharts.AxisExtremesTriggerValue|string}\n*/ /**\n* @name Highcharts.AxisSetExtremesEventObject#type\n* @type {\"setExtremes\"}\n*/\n/**\n * @callback Highcharts.AxisTickPositionerCallbackFunction\n *\n * @param {Highcharts.Axis} this\n *\n * @return {Highcharts.AxisTickPositionsArray}\n */\n/**\n * @interface Highcharts.AxisTickPositionsArray\n * @augments Array<number>\n */\n/**\n * @typedef {\"high\"|\"low\"|\"middle\"} Highcharts.AxisTitleAlignValue\n */\n/**\n * @typedef {Highcharts.XAxisTitleOptions|Highcharts.YAxisTitleOptions|Highcharts.ZAxisTitleOptions} Highcharts.AxisTitleOptions\n */\n/**\n * @typedef {\"linear\"|\"logarithmic\"|\"datetime\"|\"category\"|\"treegrid\"} Highcharts.AxisTypeValue\n */\n/**\n * The returned object literal from the {@link Highcharts.Axis#getExtremes}\n * function.\n *\n * @interface Highcharts.ExtremesObject\n */ /**\n* The maximum value of the axis' associated series.\n* @name Highcharts.ExtremesObject#dataMax\n* @type {number}\n*/ /**\n* The minimum value of the axis' associated series.\n* @name Highcharts.ExtremesObject#dataMin\n* @type {number}\n*/ /**\n* The maximum axis value, either automatic or set manually. If the `max` option\n* is not set, `maxPadding` is 0 and `endOnTick` is false, this value will be\n* the same as `dataMax`.\n* @name Highcharts.ExtremesObject#max\n* @type {number}\n*/ /**\n* The minimum axis value, either automatic or set manually. If the `min` option\n* is not set, `minPadding` is 0 and `startOnTick` is false, this value will be\n* the same as `dataMin`.\n* @name Highcharts.ExtremesObject#min\n* @type {number}\n*/ /**\n* The user defined maximum, either from the `max` option or from a zoom or\n* `setExtremes` action.\n* @name Highcharts.ExtremesObject#userMax\n* @type {number|undefined}\n*/ /**\n* The user defined minimum, either from the `min` option or from a zoom or\n* `setExtremes` action.\n* @name Highcharts.ExtremesObject#userMin\n* @type {number|undefined}\n*/\n/**\n * Formatter function for the text of a crosshair label.\n *\n * @callback Highcharts.XAxisCrosshairLabelFormatterCallbackFunction\n *\n * @param {Highcharts.Axis} this\n * Axis context\n *\n * @param {number} value\n * Y value of the data point\n *\n * @return {string}\n */\n''; // keeps doclets above in JS file\n"],"mappings":"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EACI2N,QAAQA,CAACC,YAAY,EAAE5N,MAAM,EAAE;IAC3B,IAAI,CAACuN,MAAM,CAAC;MAAE/H,KAAK,EAAEoI;IAAa,CAAC,EAAE5N,MAAM,CAAC;EAChD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI6N,aAAaA,CAAC1e,UAAU,EAAE6Q,MAAM,EAAE;IAC9B,IAAI,CAACuN,MAAM,CAAC;MAAEpe,UAAU,EAAEA;IAAW,CAAC,EAAE6Q,MAAM,CAAC;EACnD;AACJ;AACA;AACA;AACA;AACA;AACA;AACAxU,IAAI,CAACpC,cAAc,GAAGH,YAAY,CAACsH,mBAAmB;AACtD;AACA;AACA/E,IAAI,CAACkgB,SAAS,GAAG,CACb,MAAM,EACN,QAAQ,EACR,UAAU,EACV,OAAO,EACP,QAAQ,EACR,SAAS,EACT,SAAS,CACZ;AACD;AACA;AACA;AACA;AACA;AACA,eAAelgB,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAHA,CAGI;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA,SAJG,CAIA;AACH;AACA;AACA;AACA;AACA;AACA,YANG,CAMA;AACH;AACA;AACA;AACA;AACA;AACA,eANG,CAMA;AACH;AACA;AACA;AACA;AACA,kBALG,CAKA;AACH;AACA;AACA;AACA,qBAJG,CAIA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAFA,CAEI;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA,SAJG,CAIA;AACH;AACA;AACA;AACA,YAJG,CAIA;AACH;AACA;AACA;AACA,eAJG,CAIA;AACH;AACA;AACA;AACA,kBAJG,CAIA;AACH;AACA;AACA;AACA;AACA;AACA,qBANG,CAMA;AACH;AACA;AACA;AACA;AACA;AACA,wBANG,CAMA;AACH;AACA;AACA;AACA,2BAJG,CAIA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAFA,CAEI;AACJ;AACA;AACA,MAHI,CAGD;AACH;AACA;AACA,SAHG,CAGA;AACH;AACA;AACA,YAHG,CAGA;AACH;AACA;AACA,eAHG,CAGA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAHA,CAGI;AACJ;AACA;AACA,MAHI,CAGD;AACH;AACA;AACA,SAHG,CAGA;AACH;AACA;AACA,YAHG,CAGA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GALA,CAKI;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA,SAJG,CAIA;AACH;AACA;AACA;AACA;AACA;AACA,YANG,CAMA;AACH;AACA;AACA;AACA;AACA;AACA,eANG,CAMA;AACH;AACA;AACA;AACA;AACA,kBALG,CAKA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}