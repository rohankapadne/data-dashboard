{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport A from '../../Core/Animation/AnimationUtilities.js';\nconst {\n  animObject\n} = A;\nimport Color from '../../Core/Color/Color.js';\nconst {\n  parse: color\n} = Color;\nimport ColumnSeriesDefaults from './ColumnSeriesDefaults.js';\nimport H from '../../Core/Globals.js';\nconst {\n  hasTouch,\n  noop\n} = H;\nimport Series from '../../Core/Series/Series.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nimport U from '../../Core/Utilities.js';\nconst {\n  clamp,\n  defined,\n  extend,\n  fireEvent,\n  isArray,\n  isNumber,\n  merge,\n  pick,\n  objectEach,\n  relativeLength\n} = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * The column series type.\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes.column\n *\n * @augments Highcharts.Series\n */\nclass ColumnSeries extends Series {\n  constructor() {\n    /* *\n     *\n     *  Static Properties\n     *\n     * */\n    super(...arguments);\n    /* *\n     *\n     *  Properties\n     *\n     * */\n    this.borderWidth = void 0;\n    this.data = void 0;\n    this.group = void 0;\n    this.options = void 0;\n    this.points = void 0;\n    /* eslint-enable valid-jsdoc */\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Animate the column heights one by one from zero.\n   *\n   * @private\n   * @function Highcharts.seriesTypes.column#animate\n   *\n   * @param {boolean} init\n   *        Whether to initialize the animation or run it\n   */\n  animate(init) {\n    const series = this,\n      yAxis = this.yAxis,\n      yAxisPos = yAxis.pos,\n      options = series.options,\n      inverted = this.chart.inverted,\n      attr = {},\n      translateProp = inverted ? 'translateX' : 'translateY';\n    let translateStart, translatedThreshold;\n    if (init) {\n      attr.scaleY = 0.001;\n      translatedThreshold = clamp(yAxis.toPixels(options.threshold), yAxisPos, yAxisPos + yAxis.len);\n      if (inverted) {\n        attr.translateX = translatedThreshold - yAxis.len;\n      } else {\n        attr.translateY = translatedThreshold;\n      }\n      // apply finnal clipping (used in Highcharts Stock) (#7083)\n      // animation is done by scaleY, so cliping is for panes\n      if (series.clipBox) {\n        series.setClip();\n      }\n      series.group.attr(attr);\n    } else {\n      // run the animation\n      translateStart = Number(series.group.attr(translateProp));\n      series.group.animate({\n        scaleY: 1\n      }, extend(animObject(series.options.animation), {\n        // Do the scale synchronously to ensure smooth\n        // updating (#5030, #7228)\n        step: function (val, fx) {\n          if (series.group) {\n            attr[translateProp] = translateStart + fx.pos * (yAxisPos - translateStart);\n            series.group.attr(attr);\n          }\n        }\n      }));\n    }\n  }\n  /**\n   * Initialize the series. Extends the basic Series.init method by\n   * marking other series of the same type as dirty.\n   *\n   * @private\n   * @function Highcharts.seriesTypes.column#init\n   */\n  init(chart, options) {\n    super.init.apply(this, arguments);\n    const series = this;\n    chart = series.chart;\n    // if the series is added dynamically, force redraw of other\n    // series affected by a new column\n    if (chart.hasRendered) {\n      chart.series.forEach(function (otherSeries) {\n        if (otherSeries.type === series.type) {\n          otherSeries.isDirty = true;\n        }\n      });\n    }\n  }\n  /**\n   * Return the width and x offset of the columns adjusted for grouping,\n   * groupPadding, pointPadding, pointWidth etc.\n   *\n   * @private\n   * @function Highcharts.seriesTypes.column#getColumnMetrics\n   */\n  getColumnMetrics() {\n    const series = this,\n      options = series.options,\n      xAxis = series.xAxis,\n      yAxis = series.yAxis,\n      reversedStacks = xAxis.options.reversedStacks,\n      // Keep backward compatibility: reversed xAxis had reversed\n      // stacks\n      reverseStacks = xAxis.reversed && !reversedStacks || !xAxis.reversed && reversedStacks,\n      stackGroups = {};\n    let stackKey,\n      columnCount = 0;\n    // Get the total number of column type series. This is called on\n    // every series. Consider moving this logic to a chart.orderStacks()\n    // function and call it on init, addSeries and removeSeries\n    if (options.grouping === false) {\n      columnCount = 1;\n    } else {\n      series.chart.series.forEach(function (otherSeries) {\n        const otherYAxis = otherSeries.yAxis,\n          otherOptions = otherSeries.options;\n        let columnIndex;\n        if (otherSeries.type === series.type && otherSeries.reserveSpace() && yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {\n          // #642, #2086\n          if (otherOptions.stacking && otherOptions.stacking !== 'group') {\n            stackKey = otherSeries.stackKey;\n            if (typeof stackGroups[stackKey] === 'undefined') {\n              stackGroups[stackKey] = columnCount++;\n            }\n            columnIndex = stackGroups[stackKey];\n          } else if (otherOptions.grouping !== false) {\n            // #1162\n            columnIndex = columnCount++;\n          }\n          otherSeries.columnIndex = columnIndex;\n        }\n      });\n    }\n    const categoryWidth = Math.min(Math.abs(xAxis.transA) * (!xAxis.brokenAxis?.hasBreaks && xAxis.ordinal?.slope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1),\n      // #2610\n      xAxis.len // #1535\n      ),\n      groupPadding = categoryWidth * options.groupPadding,\n      groupWidth = categoryWidth - 2 * groupPadding,\n      pointOffsetWidth = groupWidth / (columnCount || 1),\n      pointWidth = Math.min(options.maxPointWidth || xAxis.len, pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))),\n      pointPadding = (pointOffsetWidth - pointWidth) / 2,\n      // #1251, #3737\n      colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0),\n      pointXOffset = pointPadding + (groupPadding + colIndex * pointOffsetWidth - categoryWidth / 2) * (reverseStacks ? -1 : 1);\n    // Save it for reading in linked series (Error bars particularly)\n    series.columnMetrics = {\n      width: pointWidth,\n      offset: pointXOffset,\n      paddedWidth: pointOffsetWidth,\n      columnCount\n    };\n    return series.columnMetrics;\n  }\n  /**\n   * Make the columns crisp. The edges are rounded to the nearest full\n   * pixel.\n   *\n   * @private\n   * @function Highcharts.seriesTypes.column#crispCol\n   */\n  crispCol(x, y, w, h) {\n    const chart = this.chart,\n      borderWidth = this.borderWidth,\n      xCrisp = -(borderWidth % 2 ? 0.5 : 0);\n    let right,\n      yCrisp = borderWidth % 2 ? 0.5 : 1;\n    // Horizontal. We need to first compute the exact right edge, then\n    // round it and compute the width from there.\n    if (this.options.crisp) {\n      right = Math.round(x + w) + xCrisp;\n      x = Math.round(x) + xCrisp;\n      w = right - x;\n    }\n    // Vertical\n    const bottom = Math.round(y + h) + yCrisp,\n      fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656\n    y = Math.round(y) + yCrisp;\n    h = bottom - y;\n    // Top edges are exceptions\n    if (fromTop && h) {\n      // #5146\n      y -= 1;\n      h += 1;\n    }\n    return {\n      x: x,\n      y: y,\n      width: w,\n      height: h\n    };\n  }\n  /**\n   * Adjust for missing columns, according to the `centerInCategory`\n   * option. Missing columns are either single points or stacks where the\n   * point or points are either missing or null.\n   *\n   * @private\n   * @function Highcharts.seriesTypes.column#adjustForMissingColumns\n   * @param {number} x\n   * The x coordinate of the column, left side\n   *\n   * @param {number} pointWidth\n   * The pointWidth, already computed upstream\n   *\n   * @param {Highcharts.ColumnPoint} point\n   * The point instance\n   *\n   * @param {Highcharts.ColumnMetricsObject} metrics\n   * The series-wide column metrics\n   *\n   * @return {number}\n   * The adjusted x position, or the original if not adjusted\n   */\n  adjustForMissingColumns(x, pointWidth, point, metrics) {\n    if (!point.isNull && metrics.columnCount > 1) {\n      const visibleSeries = this.xAxis.series.filter(s => s.visible).map(s => s.index);\n      let indexInCategory = 0,\n        totalInCategory = 0;\n      // Loop over all the stacks on the Y axis. When stacking is enabled,\n      // these are real point stacks. When stacking is not enabled, but\n      // `centerInCategory` is true, there is one stack handling the\n      // grouping of points in each category. This is done in the\n      // `setGroupedPoints` function.\n      objectEach(this.xAxis.stacking?.stacks, stack => {\n        if (typeof point.x === 'number') {\n          const stackItem = stack[point.x.toString()];\n          if (stackItem) {\n            const pointValues = stackItem.points[this.index];\n            // Look for the index\n            if (isArray(pointValues)) {\n              // If there are multiple points with the same X\n              // then gather all series in category, and\n              // assign index\n              const seriesIndexes = Object.keys(stackItem.points).filter(pointKey =>\n              // Filter out duplicate X's\n              !pointKey.match(',') &&\n              // Filter out null points\n              stackItem.points[pointKey] && stackItem.points[pointKey].length > 1).map(parseFloat).filter(index => visibleSeries.indexOf(index) !== -1).sort((a, b) => b - a);\n              indexInCategory = seriesIndexes.indexOf(this.index);\n              totalInCategory = seriesIndexes.length;\n            }\n          }\n        }\n      });\n      // Compute the adjusted x position\n      const boxWidth = (totalInCategory - 1) * metrics.paddedWidth + pointWidth;\n      x = (point.plotX || 0) + boxWidth / 2 - pointWidth - indexInCategory * metrics.paddedWidth;\n    }\n    return x;\n  }\n  /**\n   * Translate each point to the plot area coordinate system and find\n   * shape positions\n   *\n   * @private\n   * @function Highcharts.seriesTypes.column#translate\n   */\n  translate() {\n    const series = this,\n      chart = series.chart,\n      options = series.options,\n      dense = series.dense = series.closestPointRange * series.xAxis.transA < 2,\n      borderWidth = series.borderWidth = pick(options.borderWidth, dense ? 0 : 1 // #3635\n      ),\n      xAxis = series.xAxis,\n      yAxis = series.yAxis,\n      threshold = options.threshold,\n      minPointLength = pick(options.minPointLength, 5),\n      metrics = series.getColumnMetrics(),\n      seriesPointWidth = metrics.width,\n      seriesXOffset = series.pointXOffset = metrics.offset,\n      dataMin = series.dataMin,\n      dataMax = series.dataMax;\n    // postprocessed for border width\n    let seriesBarW = series.barW = Math.max(seriesPointWidth, 1 + 2 * borderWidth),\n      translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold);\n    if (chart.inverted) {\n      translatedThreshold -= 0.5; // #3355\n    }\n    // When the pointPadding is 0, we want the columns to be packed\n    // tightly, so we allow individual columns to have individual sizes.\n    // When pointPadding is greater, we strive for equal-width columns\n    // (#2694).\n    if (options.pointPadding) {\n      seriesBarW = Math.ceil(seriesBarW);\n    }\n    Series.prototype.translate.apply(series);\n    // Record the new values\n    series.points.forEach(function (point) {\n      const yBottom = pick(point.yBottom, translatedThreshold),\n        safeDistance = 999 + Math.abs(yBottom),\n        plotX = point.plotX || 0,\n        // Don't draw too far outside plot area (#1303, #2241,\n        // #4264)\n        plotY = clamp(point.plotY, -safeDistance, yAxis.len + safeDistance),\n        stackBox = point.stackBox;\n      let up,\n        barY = Math.min(plotY, yBottom),\n        barH = Math.max(plotY, yBottom) - barY,\n        pointWidth = seriesPointWidth,\n        barX = plotX + seriesXOffset,\n        barW = seriesBarW;\n      // Handle options.minPointLength\n      if (minPointLength && Math.abs(barH) < minPointLength) {\n        barH = minPointLength;\n        up = !yAxis.reversed && !point.negative || yAxis.reversed && point.negative;\n        // Reverse zeros if there's no positive value in the series\n        // in visible range (#7046)\n        if (isNumber(threshold) && isNumber(dataMax) && point.y === threshold && dataMax <= threshold &&\n        // and if there's room for it (#7311)\n        (yAxis.min || 0) < threshold && (\n        // if all points are the same value (i.e zero) not draw\n        // as negative points (#10646), but only if there's room\n        // for it (#14876)\n        dataMin !== dataMax || (yAxis.max || 0) <= threshold)) {\n          up = !up;\n          point.negative = !point.negative;\n        }\n        // If stacked...\n        barY = Math.abs(barY - translatedThreshold) > minPointLength ?\n        // ...keep position\n        yBottom - minPointLength :\n        // #1485, #4051\n        translatedThreshold - (up ? minPointLength : 0);\n      }\n      // Handle point.options.pointWidth\n      // @todo Handle grouping/stacking too. Calculate offset properly\n      if (defined(point.options.pointWidth)) {\n        pointWidth = barW = Math.ceil(point.options.pointWidth);\n        barX -= Math.round((pointWidth - seriesPointWidth) / 2);\n      }\n      // Adjust for null or missing points\n      if (options.centerInCategory && !options.stacking) {\n        barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);\n      }\n      // Cache for access in polar\n      point.barX = barX;\n      point.pointWidth = pointWidth;\n      // Fix the tooltip on center of grouped columns (#1216, #424,\n      // #3648)\n      point.tooltipPos = chart.inverted ? [clamp(yAxis.len + yAxis.pos - chart.plotLeft - plotY, yAxis.pos - chart.plotLeft, yAxis.len + yAxis.pos - chart.plotLeft), xAxis.len + xAxis.pos - chart.plotTop - barX - barW / 2, barH] : [xAxis.left - chart.plotLeft + barX + barW / 2, clamp(plotY + yAxis.pos - chart.plotTop, yAxis.pos - chart.plotTop, yAxis.len + yAxis.pos - chart.plotTop), barH];\n      // Register shape type and arguments to be used in drawPoints. Allow\n      // `shapeType` defined on `pointClass` level.\n      point.shapeType = series.pointClass.prototype.shapeType || 'roundedRect';\n      point.shapeArgs = series.crispCol(barX,\n      // #3169, drilldown from null must have a position to work from.\n      // #6585, dataLabel should be placed on xAxis, not floating in\n      // the middle of the chart.\n      point.isNull ? translatedThreshold : barY, barW, point.isNull ? 0 : barH);\n    });\n    // Fire a specific event after column translate. We could instead apply\n    // all the column logic in an `afterTranslate` event handler, but there\n    // are so many other series types that use the column translation, that\n    // it is more convenient to have a specific event for it.\n    fireEvent(this, 'afterColumnTranslate');\n  }\n  /**\n   * Columns have no graph\n   *\n   * @private\n   * @function Highcharts.seriesTypes.column#drawGraph\n   */\n  drawGraph() {\n    this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');\n  }\n  /**\n   * Get presentational attributes\n   *\n   * @private\n   * @function Highcharts.seriesTypes.column#pointAttribs\n   */\n  pointAttribs(point, state) {\n    const options = this.options,\n      p2o = this.pointAttrToOptions || {},\n      strokeOption = p2o.stroke || 'borderColor',\n      strokeWidthOption = p2o['stroke-width'] || 'borderWidth';\n    let stateOptions,\n      zone,\n      brightness,\n      fill = point && point.color || this.color,\n      // set to fill when borderColor null:\n      stroke = point && point[strokeOption] || options[strokeOption] || fill,\n      dashstyle = point && point.options.dashStyle || options.dashStyle,\n      strokeWidth = point && point[strokeWidthOption] || options[strokeWidthOption] || this[strokeWidthOption] || 0,\n      opacity = pick(point && point.opacity, options.opacity, 1);\n    // Handle zone colors\n    if (point && this.zones.length) {\n      zone = point.getZone();\n      // When zones are present, don't use point.color (#4267).\n      // Changed order (#6527), added support for colorAxis (#10670)\n      fill = point.options.color || zone && (zone.color || point.nonZonedColor) || this.color;\n      if (zone) {\n        stroke = zone.borderColor || stroke;\n        dashstyle = zone.dashStyle || dashstyle;\n        strokeWidth = zone.borderWidth || strokeWidth;\n      }\n    }\n    // Select or hover states\n    if (state && point) {\n      stateOptions = merge(options.states[state],\n      // #6401\n      point.options.states && point.options.states[state] || {});\n      brightness = stateOptions.brightness;\n      fill = stateOptions.color || typeof brightness !== 'undefined' && color(fill).brighten(stateOptions.brightness).get() || fill;\n      stroke = stateOptions[strokeOption] || stroke;\n      strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;\n      dashstyle = stateOptions.dashStyle || dashstyle;\n      opacity = pick(stateOptions.opacity, opacity);\n    }\n    const ret = {\n      fill: fill,\n      stroke: stroke,\n      'stroke-width': strokeWidth,\n      opacity: opacity\n    };\n    if (dashstyle) {\n      ret.dashstyle = dashstyle;\n    }\n    return ret;\n  }\n  /**\n   * Draw the columns. For bars, the series.group is rotated, so the same\n   * coordinates apply for columns and bars. This method is inherited by\n   * scatter series.\n   *\n   * @private\n   * @function Highcharts.seriesTypes.column#drawPoints\n   */\n  drawPoints(points = this.points) {\n    const series = this,\n      chart = this.chart,\n      options = series.options,\n      renderer = chart.renderer,\n      animationLimit = options.animationLimit || 250;\n    let shapeArgs;\n    // draw the columns\n    points.forEach(function (point) {\n      const plotY = point.plotY;\n      let graphic = point.graphic,\n        hasGraphic = !!graphic,\n        verb = graphic && chart.pointCount < animationLimit ? 'animate' : 'attr';\n      if (isNumber(plotY) && point.y !== null) {\n        shapeArgs = point.shapeArgs;\n        // When updating a series between 2d and 3d or cartesian and\n        // polar, the shape type changes.\n        if (graphic && point.hasNewShapeType()) {\n          graphic = graphic.destroy();\n        }\n        // Set starting position for point sliding animation.\n        if (series.enabledDataSorting) {\n          point.startXPos = series.xAxis.reversed ? -(shapeArgs ? shapeArgs.width || 0 : 0) : series.xAxis.width;\n        }\n        if (!graphic) {\n          point.graphic = graphic = renderer[point.shapeType](shapeArgs).add(point.group || series.group);\n          if (graphic && series.enabledDataSorting && chart.hasRendered && chart.pointCount < animationLimit) {\n            graphic.attr({\n              x: point.startXPos\n            });\n            hasGraphic = true;\n            verb = 'animate';\n          }\n        }\n        if (graphic && hasGraphic) {\n          // update\n          graphic[verb](merge(shapeArgs));\n        }\n        // Presentational\n        if (!chart.styledMode) {\n          graphic[verb](series.pointAttribs(point, point.selected && 'select')).shadow(point.allowShadow !== false && options.shadow);\n        }\n        if (graphic) {\n          graphic.addClass(point.getClassName(), true);\n          graphic.attr({\n            visibility: point.visible ? 'inherit' : 'hidden'\n          });\n        }\n      } else if (graphic) {\n        point.graphic = graphic.destroy(); // #1269\n      }\n    });\n  }\n  /**\n   * Draw the tracker for a point.\n   * @private\n   */\n  drawTracker(points = this.points) {\n    const series = this,\n      chart = series.chart,\n      pointer = chart.pointer,\n      onMouseOver = function (e) {\n        const point = pointer.getPointFromEvent(e);\n        // undefined on graph in scatterchart\n        if (typeof point !== 'undefined' && series.options.enableMouseTracking) {\n          pointer.isDirectTouch = true;\n          point.onMouseOver(e);\n        }\n      };\n    let dataLabels;\n    // Add reference to the point\n    points.forEach(function (point) {\n      dataLabels = isArray(point.dataLabels) ? point.dataLabels : point.dataLabel ? [point.dataLabel] : [];\n      if (point.graphic) {\n        point.graphic.element.point = point;\n      }\n      dataLabels.forEach(function (dataLabel) {\n        if (dataLabel.div) {\n          dataLabel.div.point = point;\n        } else {\n          dataLabel.element.point = point;\n        }\n      });\n    });\n    // Add the event listeners, we need to do this only once\n    if (!series._hasTracking) {\n      series.trackerGroups.forEach(function (key) {\n        if (series[key]) {\n          // we don't always have dataLabelsGroup\n          series[key].addClass('highcharts-tracker').on('mouseover', onMouseOver).on('mouseout', function (e) {\n            pointer.onTrackerMouseOut(e);\n          });\n          if (hasTouch) {\n            series[key].on('touchstart', onMouseOver);\n          }\n          if (!chart.styledMode && series.options.cursor) {\n            series[key].css({\n              cursor: series.options.cursor\n            });\n          }\n        }\n      });\n      series._hasTracking = true;\n    }\n    fireEvent(this, 'afterDrawTracker');\n  }\n  /**\n   * Remove this series from the chart\n   *\n   * @private\n   * @function Highcharts.seriesTypes.column#remove\n   */\n  remove() {\n    const series = this,\n      chart = series.chart;\n    // column and bar series affects other series of the same type\n    // as they are either stacked or grouped\n    if (chart.hasRendered) {\n      chart.series.forEach(function (otherSeries) {\n        if (otherSeries.type === series.type) {\n          otherSeries.isDirty = true;\n        }\n      });\n    }\n    Series.prototype.remove.apply(series, arguments);\n  }\n}\nColumnSeries.defaultOptions = merge(Series.defaultOptions, ColumnSeriesDefaults);\nextend(ColumnSeries.prototype, {\n  // When tooltip is not shared, this series (and derivatives) requires\n  // direct touch/hover. KD-tree does not apply.\n  directTouch: true,\n  getSymbol: noop,\n  // Use separate negative stacks, unlike area stacks where a negative\n  // point is substracted from previous (#1910)\n  negStacks: true,\n  trackerGroups: ['group', 'dataLabelsGroup']\n});\nSeriesRegistry.registerSeriesType('column', ColumnSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default ColumnSeries;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Adjusted width and x offset of the columns for grouping.\n *\n * @private\n * @interface Highcharts.ColumnMetricsObject\n */ /**\n    * Width of the columns.\n    * @name Highcharts.ColumnMetricsObject#width\n    * @type {number}\n    */ /**\n       * Offset of the columns.\n       * @name Highcharts.ColumnMetricsObject#offset\n       * @type {number}\n       */\n''; // detach doclets above","map":{"version":3,"names":["A","animObject","Color","parse","color","ColumnSeriesDefaults","H","hasTouch","noop","Series","SeriesRegistry","U","clamp","defined","extend","fireEvent","isArray","isNumber","merge","pick","objectEach","relativeLength","ColumnSeries","constructor","arguments","borderWidth","data","group","options","points","animate","init","series","yAxis","yAxisPos","pos","inverted","chart","attr","translateProp","translateStart","translatedThreshold","scaleY","toPixels","threshold","len","translateX","translateY","clipBox","setClip","Number","animation","step","val","fx","apply","hasRendered","forEach","otherSeries","type","isDirty","getColumnMetrics","xAxis","reversedStacks","reverseStacks","reversed","stackGroups","stackKey","columnCount","grouping","otherYAxis","otherOptions","columnIndex","reserveSpace","stacking","categoryWidth","Math","min","abs","transA","brokenAxis","hasBreaks","ordinal","slope","pointRange","closestPointRange","tickInterval","groupPadding","groupWidth","pointOffsetWidth","pointWidth","maxPointWidth","pointPadding","colIndex","pointXOffset","columnMetrics","width","offset","paddedWidth","crispCol","x","y","w","h","xCrisp","right","yCrisp","crisp","round","bottom","fromTop","height","adjustForMissingColumns","point","metrics","isNull","visibleSeries","filter","s","visible","map","index","indexInCategory","totalInCategory","stacks","stack","stackItem","toString","pointValues","seriesIndexes","Object","keys","pointKey","match","length","parseFloat","indexOf","sort","a","b","boxWidth","plotX","translate","dense","minPointLength","seriesPointWidth","seriesXOffset","dataMin","dataMax","seriesBarW","barW","max","getThreshold","ceil","prototype","yBottom","safeDistance","plotY","stackBox","up","barY","barH","barX","negative","centerInCategory","tooltipPos","plotLeft","plotTop","left","shapeType","pointClass","shapeArgs","drawGraph","pointAttribs","state","p2o","pointAttrToOptions","strokeOption","stroke","strokeWidthOption","stateOptions","zone","brightness","fill","dashstyle","dashStyle","strokeWidth","opacity","zones","getZone","nonZonedColor","borderColor","states","brighten","get","ret","drawPoints","renderer","animationLimit","graphic","hasGraphic","verb","pointCount","hasNewShapeType","destroy","enabledDataSorting","startXPos","add","styledMode","selected","shadow","allowShadow","addClass","getClassName","visibility","drawTracker","pointer","onMouseOver","e","getPointFromEvent","enableMouseTracking","isDirectTouch","dataLabels","dataLabel","element","div","_hasTracking","trackerGroups","key","on","onTrackerMouseOut","cursor","css","remove","defaultOptions","directTouch","getSymbol","negStacks","registerSeriesType"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Series/Column/ColumnSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport A from '../../Core/Animation/AnimationUtilities.js';\nconst { animObject } = A;\nimport Color from '../../Core/Color/Color.js';\nconst { parse: color } = Color;\nimport ColumnSeriesDefaults from './ColumnSeriesDefaults.js';\nimport H from '../../Core/Globals.js';\nconst { hasTouch, noop } = H;\nimport Series from '../../Core/Series/Series.js';\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nimport U from '../../Core/Utilities.js';\nconst { clamp, defined, extend, fireEvent, isArray, isNumber, merge, pick, objectEach, relativeLength } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * The column series type.\n *\n * @private\n * @class\n * @name Highcharts.seriesTypes.column\n *\n * @augments Highcharts.Series\n */\nclass ColumnSeries extends Series {\n    constructor() {\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        super(...arguments);\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        this.borderWidth = void 0;\n        this.data = void 0;\n        this.group = void 0;\n        this.options = void 0;\n        this.points = void 0;\n        /* eslint-enable valid-jsdoc */\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Animate the column heights one by one from zero.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#animate\n     *\n     * @param {boolean} init\n     *        Whether to initialize the animation or run it\n     */\n    animate(init) {\n        const series = this, yAxis = this.yAxis, yAxisPos = yAxis.pos, options = series.options, inverted = this.chart.inverted, attr = {}, translateProp = inverted ?\n            'translateX' :\n            'translateY';\n        let translateStart, translatedThreshold;\n        if (init) {\n            attr.scaleY = 0.001;\n            translatedThreshold = clamp(yAxis.toPixels(options.threshold), yAxisPos, yAxisPos + yAxis.len);\n            if (inverted) {\n                attr.translateX = translatedThreshold - yAxis.len;\n            }\n            else {\n                attr.translateY = translatedThreshold;\n            }\n            // apply finnal clipping (used in Highcharts Stock) (#7083)\n            // animation is done by scaleY, so cliping is for panes\n            if (series.clipBox) {\n                series.setClip();\n            }\n            series.group.attr(attr);\n        }\n        else { // run the animation\n            translateStart = Number(series.group.attr(translateProp));\n            series.group.animate({ scaleY: 1 }, extend(animObject(series.options.animation), {\n                // Do the scale synchronously to ensure smooth\n                // updating (#5030, #7228)\n                step: function (val, fx) {\n                    if (series.group) {\n                        attr[translateProp] = translateStart +\n                            fx.pos * (yAxisPos - translateStart);\n                        series.group.attr(attr);\n                    }\n                }\n            }));\n        }\n    }\n    /**\n     * Initialize the series. Extends the basic Series.init method by\n     * marking other series of the same type as dirty.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#init\n     */\n    init(chart, options) {\n        super.init.apply(this, arguments);\n        const series = this;\n        chart = series.chart;\n        // if the series is added dynamically, force redraw of other\n        // series affected by a new column\n        if (chart.hasRendered) {\n            chart.series.forEach(function (otherSeries) {\n                if (otherSeries.type === series.type) {\n                    otherSeries.isDirty = true;\n                }\n            });\n        }\n    }\n    /**\n     * Return the width and x offset of the columns adjusted for grouping,\n     * groupPadding, pointPadding, pointWidth etc.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#getColumnMetrics\n     */\n    getColumnMetrics() {\n        const series = this, options = series.options, xAxis = series.xAxis, yAxis = series.yAxis, reversedStacks = xAxis.options.reversedStacks, \n        // Keep backward compatibility: reversed xAxis had reversed\n        // stacks\n        reverseStacks = (xAxis.reversed && !reversedStacks) ||\n            (!xAxis.reversed && reversedStacks), stackGroups = {};\n        let stackKey, columnCount = 0;\n        // Get the total number of column type series. This is called on\n        // every series. Consider moving this logic to a chart.orderStacks()\n        // function and call it on init, addSeries and removeSeries\n        if (options.grouping === false) {\n            columnCount = 1;\n        }\n        else {\n            series.chart.series.forEach(function (otherSeries) {\n                const otherYAxis = otherSeries.yAxis, otherOptions = otherSeries.options;\n                let columnIndex;\n                if (otherSeries.type === series.type &&\n                    otherSeries.reserveSpace() &&\n                    yAxis.len === otherYAxis.len &&\n                    yAxis.pos === otherYAxis.pos) { // #642, #2086\n                    if (otherOptions.stacking &&\n                        otherOptions.stacking !== 'group') {\n                        stackKey = otherSeries.stackKey;\n                        if (typeof stackGroups[stackKey] ===\n                            'undefined') {\n                            stackGroups[stackKey] = columnCount++;\n                        }\n                        columnIndex = stackGroups[stackKey];\n                    }\n                    else if (otherOptions.grouping !== false) { // #1162\n                        columnIndex = columnCount++;\n                    }\n                    otherSeries.columnIndex = columnIndex;\n                }\n            });\n        }\n        const categoryWidth = Math.min(Math.abs(xAxis.transA) * ((!xAxis.brokenAxis?.hasBreaks && xAxis.ordinal?.slope) ||\n            options.pointRange ||\n            xAxis.closestPointRange ||\n            xAxis.tickInterval ||\n            1), // #2610\n        xAxis.len // #1535\n        ), groupPadding = categoryWidth * options.groupPadding, groupWidth = categoryWidth - 2 * groupPadding, pointOffsetWidth = groupWidth / (columnCount || 1), pointWidth = Math.min(options.maxPointWidth || xAxis.len, pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))), pointPadding = (pointOffsetWidth - pointWidth) / 2, \n        // #1251, #3737\n        colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0), pointXOffset = pointPadding +\n            (groupPadding +\n                colIndex * pointOffsetWidth -\n                (categoryWidth / 2)) * (reverseStacks ? -1 : 1);\n        // Save it for reading in linked series (Error bars particularly)\n        series.columnMetrics = {\n            width: pointWidth,\n            offset: pointXOffset,\n            paddedWidth: pointOffsetWidth,\n            columnCount\n        };\n        return series.columnMetrics;\n    }\n    /**\n     * Make the columns crisp. The edges are rounded to the nearest full\n     * pixel.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#crispCol\n     */\n    crispCol(x, y, w, h) {\n        const chart = this.chart, borderWidth = this.borderWidth, xCrisp = -(borderWidth % 2 ? 0.5 : 0);\n        let right, yCrisp = borderWidth % 2 ? 0.5 : 1;\n        // Horizontal. We need to first compute the exact right edge, then\n        // round it and compute the width from there.\n        if (this.options.crisp) {\n            right = Math.round(x + w) + xCrisp;\n            x = Math.round(x) + xCrisp;\n            w = right - x;\n        }\n        // Vertical\n        const bottom = Math.round(y + h) + yCrisp, fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656\n        y = Math.round(y) + yCrisp;\n        h = bottom - y;\n        // Top edges are exceptions\n        if (fromTop && h) { // #5146\n            y -= 1;\n            h += 1;\n        }\n        return {\n            x: x,\n            y: y,\n            width: w,\n            height: h\n        };\n    }\n    /**\n     * Adjust for missing columns, according to the `centerInCategory`\n     * option. Missing columns are either single points or stacks where the\n     * point or points are either missing or null.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#adjustForMissingColumns\n     * @param {number} x\n     * The x coordinate of the column, left side\n     *\n     * @param {number} pointWidth\n     * The pointWidth, already computed upstream\n     *\n     * @param {Highcharts.ColumnPoint} point\n     * The point instance\n     *\n     * @param {Highcharts.ColumnMetricsObject} metrics\n     * The series-wide column metrics\n     *\n     * @return {number}\n     * The adjusted x position, or the original if not adjusted\n     */\n    adjustForMissingColumns(x, pointWidth, point, metrics) {\n        if (!point.isNull && metrics.columnCount > 1) {\n            const visibleSeries = this.xAxis.series\n                .filter((s) => s.visible)\n                .map((s) => s.index);\n            let indexInCategory = 0, totalInCategory = 0;\n            // Loop over all the stacks on the Y axis. When stacking is enabled,\n            // these are real point stacks. When stacking is not enabled, but\n            // `centerInCategory` is true, there is one stack handling the\n            // grouping of points in each category. This is done in the\n            // `setGroupedPoints` function.\n            objectEach(this.xAxis.stacking?.stacks, (stack) => {\n                if (typeof point.x === 'number') {\n                    const stackItem = stack[point.x.toString()];\n                    if (stackItem) {\n                        const pointValues = stackItem.points[this.index];\n                        // Look for the index\n                        if (isArray(pointValues)) {\n                            // If there are multiple points with the same X\n                            // then gather all series in category, and\n                            // assign index\n                            const seriesIndexes = Object\n                                .keys(stackItem.points)\n                                .filter((pointKey) => \n                            // Filter out duplicate X's\n                            !pointKey.match(',') &&\n                                // Filter out null points\n                                stackItem.points[pointKey] &&\n                                stackItem.points[pointKey].length > 1)\n                                .map(parseFloat)\n                                .filter((index) => visibleSeries.indexOf(index) !== -1)\n                                .sort((a, b) => b - a);\n                            indexInCategory = seriesIndexes.indexOf(this.index);\n                            totalInCategory = seriesIndexes.length;\n                        }\n                    }\n                }\n            });\n            // Compute the adjusted x position\n            const boxWidth = (totalInCategory - 1) * metrics.paddedWidth +\n                pointWidth;\n            x = (point.plotX || 0) + boxWidth / 2 - pointWidth -\n                indexInCategory * metrics.paddedWidth;\n        }\n        return x;\n    }\n    /**\n     * Translate each point to the plot area coordinate system and find\n     * shape positions\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#translate\n     */\n    translate() {\n        const series = this, chart = series.chart, options = series.options, dense = series.dense =\n            series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick(options.borderWidth, dense ? 0 : 1 // #3635\n        ), xAxis = series.xAxis, yAxis = series.yAxis, threshold = options.threshold, minPointLength = pick(options.minPointLength, 5), metrics = series.getColumnMetrics(), seriesPointWidth = metrics.width, seriesXOffset = series.pointXOffset = metrics.offset, dataMin = series.dataMin, dataMax = series.dataMax;\n        // postprocessed for border width\n        let seriesBarW = series.barW =\n            Math.max(seriesPointWidth, 1 + 2 * borderWidth), translatedThreshold = series.translatedThreshold =\n            yAxis.getThreshold(threshold);\n        if (chart.inverted) {\n            translatedThreshold -= 0.5; // #3355\n        }\n        // When the pointPadding is 0, we want the columns to be packed\n        // tightly, so we allow individual columns to have individual sizes.\n        // When pointPadding is greater, we strive for equal-width columns\n        // (#2694).\n        if (options.pointPadding) {\n            seriesBarW = Math.ceil(seriesBarW);\n        }\n        Series.prototype.translate.apply(series);\n        // Record the new values\n        series.points.forEach(function (point) {\n            const yBottom = pick(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotX = point.plotX || 0, \n            // Don't draw too far outside plot area (#1303, #2241,\n            // #4264)\n            plotY = clamp(point.plotY, -safeDistance, yAxis.len + safeDistance), stackBox = point.stackBox;\n            let up, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, pointWidth = seriesPointWidth, barX = plotX + seriesXOffset, barW = seriesBarW;\n            // Handle options.minPointLength\n            if (minPointLength && Math.abs(barH) < minPointLength) {\n                barH = minPointLength;\n                up = (!yAxis.reversed && !point.negative) ||\n                    (yAxis.reversed && point.negative);\n                // Reverse zeros if there's no positive value in the series\n                // in visible range (#7046)\n                if (isNumber(threshold) &&\n                    isNumber(dataMax) &&\n                    point.y === threshold &&\n                    dataMax <= threshold &&\n                    // and if there's room for it (#7311)\n                    (yAxis.min || 0) < threshold &&\n                    // if all points are the same value (i.e zero) not draw\n                    // as negative points (#10646), but only if there's room\n                    // for it (#14876)\n                    (dataMin !== dataMax || (yAxis.max || 0) <= threshold)) {\n                    up = !up;\n                    point.negative = !point.negative;\n                }\n                // If stacked...\n                barY = (Math.abs(barY - translatedThreshold) > minPointLength ?\n                    // ...keep position\n                    yBottom - minPointLength :\n                    // #1485, #4051\n                    translatedThreshold -\n                        (up ? minPointLength : 0));\n            }\n            // Handle point.options.pointWidth\n            // @todo Handle grouping/stacking too. Calculate offset properly\n            if (defined(point.options.pointWidth)) {\n                pointWidth = barW =\n                    Math.ceil(point.options.pointWidth);\n                barX -= Math.round((pointWidth - seriesPointWidth) / 2);\n            }\n            // Adjust for null or missing points\n            if (options.centerInCategory && !options.stacking) {\n                barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);\n            }\n            // Cache for access in polar\n            point.barX = barX;\n            point.pointWidth = pointWidth;\n            // Fix the tooltip on center of grouped columns (#1216, #424,\n            // #3648)\n            point.tooltipPos = chart.inverted ?\n                [\n                    clamp(yAxis.len + yAxis.pos - chart.plotLeft - plotY, yAxis.pos - chart.plotLeft, yAxis.len + yAxis.pos - chart.plotLeft),\n                    xAxis.len + xAxis.pos - chart.plotTop - barX - barW / 2,\n                    barH\n                ] :\n                [\n                    xAxis.left - chart.plotLeft + barX + barW / 2,\n                    clamp(plotY + yAxis.pos -\n                        chart.plotTop, yAxis.pos - chart.plotTop, yAxis.len + yAxis.pos - chart.plotTop),\n                    barH\n                ];\n            // Register shape type and arguments to be used in drawPoints. Allow\n            // `shapeType` defined on `pointClass` level.\n            point.shapeType = series.pointClass.prototype.shapeType ||\n                'roundedRect';\n            point.shapeArgs = series.crispCol(barX, \n            // #3169, drilldown from null must have a position to work from.\n            // #6585, dataLabel should be placed on xAxis, not floating in\n            // the middle of the chart.\n            point.isNull ? translatedThreshold : barY, barW, point.isNull ? 0 : barH);\n        });\n        // Fire a specific event after column translate. We could instead apply\n        // all the column logic in an `afterTranslate` event handler, but there\n        // are so many other series types that use the column translation, that\n        // it is more convenient to have a specific event for it.\n        fireEvent(this, 'afterColumnTranslate');\n    }\n    /**\n     * Columns have no graph\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#drawGraph\n     */\n    drawGraph() {\n        this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');\n    }\n    /**\n     * Get presentational attributes\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#pointAttribs\n     */\n    pointAttribs(point, state) {\n        const options = this.options, p2o = this.pointAttrToOptions || {}, strokeOption = p2o.stroke || 'borderColor', strokeWidthOption = p2o['stroke-width'] || 'borderWidth';\n        let stateOptions, zone, brightness, fill = (point && point.color) || this.color, \n        // set to fill when borderColor null:\n        stroke = ((point && point[strokeOption]) ||\n            options[strokeOption] ||\n            fill), dashstyle = (point && point.options.dashStyle) || options.dashStyle, strokeWidth = (point && point[strokeWidthOption]) ||\n            options[strokeWidthOption] ||\n            this[strokeWidthOption] || 0, opacity = pick(point && point.opacity, options.opacity, 1);\n        // Handle zone colors\n        if (point && this.zones.length) {\n            zone = point.getZone();\n            // When zones are present, don't use point.color (#4267).\n            // Changed order (#6527), added support for colorAxis (#10670)\n            fill = (point.options.color ||\n                (zone && (zone.color || point.nonZonedColor)) ||\n                this.color);\n            if (zone) {\n                stroke = zone.borderColor || stroke;\n                dashstyle = zone.dashStyle || dashstyle;\n                strokeWidth = zone.borderWidth || strokeWidth;\n            }\n        }\n        // Select or hover states\n        if (state && point) {\n            stateOptions = merge(options.states[state], \n            // #6401\n            point.options.states &&\n                point.options.states[state] ||\n                {});\n            brightness = stateOptions.brightness;\n            fill =\n                stateOptions.color || (typeof brightness !== 'undefined' &&\n                    color(fill)\n                        .brighten(stateOptions.brightness)\n                        .get()) || fill;\n            stroke = stateOptions[strokeOption] || stroke;\n            strokeWidth =\n                stateOptions[strokeWidthOption] || strokeWidth;\n            dashstyle = stateOptions.dashStyle || dashstyle;\n            opacity = pick(stateOptions.opacity, opacity);\n        }\n        const ret = {\n            fill: fill,\n            stroke: stroke,\n            'stroke-width': strokeWidth,\n            opacity: opacity\n        };\n        if (dashstyle) {\n            ret.dashstyle = dashstyle;\n        }\n        return ret;\n    }\n    /**\n     * Draw the columns. For bars, the series.group is rotated, so the same\n     * coordinates apply for columns and bars. This method is inherited by\n     * scatter series.\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#drawPoints\n     */\n    drawPoints(points = this.points) {\n        const series = this, chart = this.chart, options = series.options, renderer = chart.renderer, animationLimit = options.animationLimit || 250;\n        let shapeArgs;\n        // draw the columns\n        points.forEach(function (point) {\n            const plotY = point.plotY;\n            let graphic = point.graphic, hasGraphic = !!graphic, verb = graphic && chart.pointCount < animationLimit ?\n                'animate' : 'attr';\n            if (isNumber(plotY) && point.y !== null) {\n                shapeArgs = point.shapeArgs;\n                // When updating a series between 2d and 3d or cartesian and\n                // polar, the shape type changes.\n                if (graphic && point.hasNewShapeType()) {\n                    graphic = graphic.destroy();\n                }\n                // Set starting position for point sliding animation.\n                if (series.enabledDataSorting) {\n                    point.startXPos = series.xAxis.reversed ?\n                        -(shapeArgs ? (shapeArgs.width || 0) : 0) :\n                        series.xAxis.width;\n                }\n                if (!graphic) {\n                    point.graphic = graphic =\n                        renderer[point.shapeType](shapeArgs)\n                            .add(point.group || series.group);\n                    if (graphic &&\n                        series.enabledDataSorting &&\n                        chart.hasRendered &&\n                        chart.pointCount < animationLimit) {\n                        graphic.attr({\n                            x: point.startXPos\n                        });\n                        hasGraphic = true;\n                        verb = 'animate';\n                    }\n                }\n                if (graphic && hasGraphic) { // update\n                    graphic[verb](merge(shapeArgs));\n                }\n                // Presentational\n                if (!chart.styledMode) {\n                    graphic[verb](series.pointAttribs(point, (point.selected && 'select')))\n                        .shadow(point.allowShadow !== false && options.shadow);\n                }\n                if (graphic) {\n                    graphic.addClass(point.getClassName(), true);\n                    graphic.attr({\n                        visibility: point.visible ? 'inherit' : 'hidden'\n                    });\n                }\n            }\n            else if (graphic) {\n                point.graphic = graphic.destroy(); // #1269\n            }\n        });\n    }\n    /**\n     * Draw the tracker for a point.\n     * @private\n     */\n    drawTracker(points = this.points) {\n        const series = this, chart = series.chart, pointer = chart.pointer, onMouseOver = function (e) {\n            const point = pointer.getPointFromEvent(e);\n            // undefined on graph in scatterchart\n            if (typeof point !== 'undefined' &&\n                series.options.enableMouseTracking) {\n                pointer.isDirectTouch = true;\n                point.onMouseOver(e);\n            }\n        };\n        let dataLabels;\n        // Add reference to the point\n        points.forEach(function (point) {\n            dataLabels = (isArray(point.dataLabels) ?\n                point.dataLabels :\n                (point.dataLabel ? [point.dataLabel] : []));\n            if (point.graphic) {\n                point.graphic.element.point = point;\n            }\n            dataLabels.forEach(function (dataLabel) {\n                if (dataLabel.div) {\n                    dataLabel.div.point = point;\n                }\n                else {\n                    dataLabel.element.point = point;\n                }\n            });\n        });\n        // Add the event listeners, we need to do this only once\n        if (!series._hasTracking) {\n            series.trackerGroups.forEach(function (key) {\n                if (series[key]) {\n                    // we don't always have dataLabelsGroup\n                    series[key]\n                        .addClass('highcharts-tracker')\n                        .on('mouseover', onMouseOver)\n                        .on('mouseout', function (e) {\n                        pointer.onTrackerMouseOut(e);\n                    });\n                    if (hasTouch) {\n                        series[key].on('touchstart', onMouseOver);\n                    }\n                    if (!chart.styledMode && series.options.cursor) {\n                        series[key]\n                            .css({ cursor: series.options.cursor });\n                    }\n                }\n            });\n            series._hasTracking = true;\n        }\n        fireEvent(this, 'afterDrawTracker');\n    }\n    /**\n     * Remove this series from the chart\n     *\n     * @private\n     * @function Highcharts.seriesTypes.column#remove\n     */\n    remove() {\n        const series = this, chart = series.chart;\n        // column and bar series affects other series of the same type\n        // as they are either stacked or grouped\n        if (chart.hasRendered) {\n            chart.series.forEach(function (otherSeries) {\n                if (otherSeries.type === series.type) {\n                    otherSeries.isDirty = true;\n                }\n            });\n        }\n        Series.prototype.remove.apply(series, arguments);\n    }\n}\nColumnSeries.defaultOptions = merge(Series.defaultOptions, ColumnSeriesDefaults);\nextend(ColumnSeries.prototype, {\n    // When tooltip is not shared, this series (and derivatives) requires\n    // direct touch/hover. KD-tree does not apply.\n    directTouch: true,\n    getSymbol: noop,\n    // Use separate negative stacks, unlike area stacks where a negative\n    // point is substracted from previous (#1910)\n    negStacks: true,\n    trackerGroups: ['group', 'dataLabelsGroup']\n});\nSeriesRegistry.registerSeriesType('column', ColumnSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default ColumnSeries;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Adjusted width and x offset of the columns for grouping.\n *\n * @private\n * @interface Highcharts.ColumnMetricsObject\n */ /**\n* Width of the columns.\n* @name Highcharts.ColumnMetricsObject#width\n* @type {number}\n*/ /**\n* Offset of the columns.\n* @name Highcharts.ColumnMetricsObject#offset\n* @type {number}\n*/\n''; // detach doclets above\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AACZ,OAAOA,CAAC,MAAM,4CAA4C;AAC1D,MAAM;EAAEC;AAAW,CAAC,GAAGD,CAAC;AACxB,OAAOE,KAAK,MAAM,2BAA2B;AAC7C,MAAM;EAAEC,KAAK,EAAEC;AAAM,CAAC,GAAGF,KAAK;AAC9B,OAAOG,oBAAoB,MAAM,2BAA2B;AAC5D,OAAOC,CAAC,MAAM,uBAAuB;AACrC,MAAM;EAAEC,QAAQ;EAAEC;AAAK,CAAC,GAAGF,CAAC;AAC5B,OAAOG,MAAM,MAAM,6BAA6B;AAChD,OAAOC,cAAc,MAAM,qCAAqC;AAChE,OAAOC,CAAC,MAAM,yBAAyB;AACvC,MAAM;EAAEC,KAAK;EAAEC,OAAO;EAAEC,MAAM;EAAEC,SAAS;EAAEC,OAAO;EAAEC,QAAQ;EAAEC,KAAK;EAAEC,IAAI;EAAEC,UAAU;EAAEC;AAAe,CAAC,GAAGV,CAAC;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMW,YAAY,SAASb,MAAM,CAAC;EAC9Bc,WAAWA,CAAA,EAAG;IACV;AACR;AACA;AACA;AACA;IACQ,KAAK,CAAC,GAAGC,SAAS,CAAC;IACnB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,KAAK,CAAC;IACzB,IAAI,CAACC,IAAI,GAAG,KAAK,CAAC;IAClB,IAAI,CAACC,KAAK,GAAG,KAAK,CAAC;IACnB,IAAI,CAACC,OAAO,GAAG,KAAK,CAAC;IACrB,IAAI,CAACC,MAAM,GAAG,KAAK,CAAC;IACpB;EACJ;EACA;AACJ;AACA;AACA;AACA;EACI;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,OAAOA,CAACC,IAAI,EAAE;IACV,MAAMC,MAAM,GAAG,IAAI;MAAEC,KAAK,GAAG,IAAI,CAACA,KAAK;MAAEC,QAAQ,GAAGD,KAAK,CAACE,GAAG;MAAEP,OAAO,GAAGI,MAAM,CAACJ,OAAO;MAAEQ,QAAQ,GAAG,IAAI,CAACC,KAAK,CAACD,QAAQ;MAAEE,IAAI,GAAG,CAAC,CAAC;MAAEC,aAAa,GAAGH,QAAQ,GACxJ,YAAY,GACZ,YAAY;IAChB,IAAII,cAAc,EAAEC,mBAAmB;IACvC,IAAIV,IAAI,EAAE;MACNO,IAAI,CAACI,MAAM,GAAG,KAAK;MACnBD,mBAAmB,GAAG7B,KAAK,CAACqB,KAAK,CAACU,QAAQ,CAACf,OAAO,CAACgB,SAAS,CAAC,EAAEV,QAAQ,EAAEA,QAAQ,GAAGD,KAAK,CAACY,GAAG,CAAC;MAC9F,IAAIT,QAAQ,EAAE;QACVE,IAAI,CAACQ,UAAU,GAAGL,mBAAmB,GAAGR,KAAK,CAACY,GAAG;MACrD,CAAC,MACI;QACDP,IAAI,CAACS,UAAU,GAAGN,mBAAmB;MACzC;MACA;MACA;MACA,IAAIT,MAAM,CAACgB,OAAO,EAAE;QAChBhB,MAAM,CAACiB,OAAO,CAAC,CAAC;MACpB;MACAjB,MAAM,CAACL,KAAK,CAACW,IAAI,CAACA,IAAI,CAAC;IAC3B,CAAC,MACI;MAAE;MACHE,cAAc,GAAGU,MAAM,CAAClB,MAAM,CAACL,KAAK,CAACW,IAAI,CAACC,aAAa,CAAC,CAAC;MACzDP,MAAM,CAACL,KAAK,CAACG,OAAO,CAAC;QAAEY,MAAM,EAAE;MAAE,CAAC,EAAE5B,MAAM,CAACb,UAAU,CAAC+B,MAAM,CAACJ,OAAO,CAACuB,SAAS,CAAC,EAAE;QAC7E;QACA;QACAC,IAAI,EAAE,SAAAA,CAAUC,GAAG,EAAEC,EAAE,EAAE;UACrB,IAAItB,MAAM,CAACL,KAAK,EAAE;YACdW,IAAI,CAACC,aAAa,CAAC,GAAGC,cAAc,GAChCc,EAAE,CAACnB,GAAG,IAAID,QAAQ,GAAGM,cAAc,CAAC;YACxCR,MAAM,CAACL,KAAK,CAACW,IAAI,CAACA,IAAI,CAAC;UAC3B;QACJ;MACJ,CAAC,CAAC,CAAC;IACP;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIP,IAAIA,CAACM,KAAK,EAAET,OAAO,EAAE;IACjB,KAAK,CAACG,IAAI,CAACwB,KAAK,CAAC,IAAI,EAAE/B,SAAS,CAAC;IACjC,MAAMQ,MAAM,GAAG,IAAI;IACnBK,KAAK,GAAGL,MAAM,CAACK,KAAK;IACpB;IACA;IACA,IAAIA,KAAK,CAACmB,WAAW,EAAE;MACnBnB,KAAK,CAACL,MAAM,CAACyB,OAAO,CAAC,UAAUC,WAAW,EAAE;QACxC,IAAIA,WAAW,CAACC,IAAI,KAAK3B,MAAM,CAAC2B,IAAI,EAAE;UAClCD,WAAW,CAACE,OAAO,GAAG,IAAI;QAC9B;MACJ,CAAC,CAAC;IACN;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,gBAAgBA,CAAA,EAAG;IACf,MAAM7B,MAAM,GAAG,IAAI;MAAEJ,OAAO,GAAGI,MAAM,CAACJ,OAAO;MAAEkC,KAAK,GAAG9B,MAAM,CAAC8B,KAAK;MAAE7B,KAAK,GAAGD,MAAM,CAACC,KAAK;MAAE8B,cAAc,GAAGD,KAAK,CAAClC,OAAO,CAACmC,cAAc;MACxI;MACA;MACAC,aAAa,GAAIF,KAAK,CAACG,QAAQ,IAAI,CAACF,cAAc,IAC7C,CAACD,KAAK,CAACG,QAAQ,IAAIF,cAAe;MAAEG,WAAW,GAAG,CAAC,CAAC;IACzD,IAAIC,QAAQ;MAAEC,WAAW,GAAG,CAAC;IAC7B;IACA;IACA;IACA,IAAIxC,OAAO,CAACyC,QAAQ,KAAK,KAAK,EAAE;MAC5BD,WAAW,GAAG,CAAC;IACnB,CAAC,MACI;MACDpC,MAAM,CAACK,KAAK,CAACL,MAAM,CAACyB,OAAO,CAAC,UAAUC,WAAW,EAAE;QAC/C,MAAMY,UAAU,GAAGZ,WAAW,CAACzB,KAAK;UAAEsC,YAAY,GAAGb,WAAW,CAAC9B,OAAO;QACxE,IAAI4C,WAAW;QACf,IAAId,WAAW,CAACC,IAAI,KAAK3B,MAAM,CAAC2B,IAAI,IAChCD,WAAW,CAACe,YAAY,CAAC,CAAC,IAC1BxC,KAAK,CAACY,GAAG,KAAKyB,UAAU,CAACzB,GAAG,IAC5BZ,KAAK,CAACE,GAAG,KAAKmC,UAAU,CAACnC,GAAG,EAAE;UAAE;UAChC,IAAIoC,YAAY,CAACG,QAAQ,IACrBH,YAAY,CAACG,QAAQ,KAAK,OAAO,EAAE;YACnCP,QAAQ,GAAGT,WAAW,CAACS,QAAQ;YAC/B,IAAI,OAAOD,WAAW,CAACC,QAAQ,CAAC,KAC5B,WAAW,EAAE;cACbD,WAAW,CAACC,QAAQ,CAAC,GAAGC,WAAW,EAAE;YACzC;YACAI,WAAW,GAAGN,WAAW,CAACC,QAAQ,CAAC;UACvC,CAAC,MACI,IAAII,YAAY,CAACF,QAAQ,KAAK,KAAK,EAAE;YAAE;YACxCG,WAAW,GAAGJ,WAAW,EAAE;UAC/B;UACAV,WAAW,CAACc,WAAW,GAAGA,WAAW;QACzC;MACJ,CAAC,CAAC;IACN;IACA,MAAMG,aAAa,GAAGC,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAAChB,KAAK,CAACiB,MAAM,CAAC,IAAK,CAACjB,KAAK,CAACkB,UAAU,EAAEC,SAAS,IAAInB,KAAK,CAACoB,OAAO,EAAEC,KAAK,IAC1GvD,OAAO,CAACwD,UAAU,IAClBtB,KAAK,CAACuB,iBAAiB,IACvBvB,KAAK,CAACwB,YAAY,IAClB,CAAC,CAAC;MAAE;MACRxB,KAAK,CAACjB,GAAG,CAAC;MACV,CAAC;MAAE0C,YAAY,GAAGZ,aAAa,GAAG/C,OAAO,CAAC2D,YAAY;MAAEC,UAAU,GAAGb,aAAa,GAAG,CAAC,GAAGY,YAAY;MAAEE,gBAAgB,GAAGD,UAAU,IAAIpB,WAAW,IAAI,CAAC,CAAC;MAAEsB,UAAU,GAAGd,IAAI,CAACC,GAAG,CAACjD,OAAO,CAAC+D,aAAa,IAAI7B,KAAK,CAACjB,GAAG,EAAE1B,IAAI,CAACS,OAAO,CAAC8D,UAAU,EAAED,gBAAgB,IAAI,CAAC,GAAG,CAAC,GAAG7D,OAAO,CAACgE,YAAY,CAAC,CAAC,CAAC;MAAEA,YAAY,GAAG,CAACH,gBAAgB,GAAGC,UAAU,IAAI,CAAC;MACrV;MACAG,QAAQ,GAAG,CAAC7D,MAAM,CAACwC,WAAW,IAAI,CAAC,KAAKR,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC;MAAE8B,YAAY,GAAGF,YAAY,GACvF,CAACL,YAAY,GACTM,QAAQ,GAAGJ,gBAAgB,GAC1Bd,aAAa,GAAG,CAAE,KAAKX,aAAa,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IACvD;IACAhC,MAAM,CAAC+D,aAAa,GAAG;MACnBC,KAAK,EAAEN,UAAU;MACjBO,MAAM,EAAEH,YAAY;MACpBI,WAAW,EAAET,gBAAgB;MAC7BrB;IACJ,CAAC;IACD,OAAOpC,MAAM,CAAC+D,aAAa;EAC/B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACII,QAAQA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;IACjB,MAAMlE,KAAK,GAAG,IAAI,CAACA,KAAK;MAAEZ,WAAW,GAAG,IAAI,CAACA,WAAW;MAAE+E,MAAM,GAAG,EAAE/E,WAAW,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;IAC/F,IAAIgF,KAAK;MAAEC,MAAM,GAAGjF,WAAW,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC;IAC7C;IACA;IACA,IAAI,IAAI,CAACG,OAAO,CAAC+E,KAAK,EAAE;MACpBF,KAAK,GAAG7B,IAAI,CAACgC,KAAK,CAACR,CAAC,GAAGE,CAAC,CAAC,GAAGE,MAAM;MAClCJ,CAAC,GAAGxB,IAAI,CAACgC,KAAK,CAACR,CAAC,CAAC,GAAGI,MAAM;MAC1BF,CAAC,GAAGG,KAAK,GAAGL,CAAC;IACjB;IACA;IACA,MAAMS,MAAM,GAAGjC,IAAI,CAACgC,KAAK,CAACP,CAAC,GAAGE,CAAC,CAAC,GAAGG,MAAM;MAAEI,OAAO,GAAGlC,IAAI,CAACE,GAAG,CAACuB,CAAC,CAAC,IAAI,GAAG,IAAIQ,MAAM,GAAG,GAAG,CAAC,CAAC;IACzFR,CAAC,GAAGzB,IAAI,CAACgC,KAAK,CAACP,CAAC,CAAC,GAAGK,MAAM;IAC1BH,CAAC,GAAGM,MAAM,GAAGR,CAAC;IACd;IACA,IAAIS,OAAO,IAAIP,CAAC,EAAE;MAAE;MAChBF,CAAC,IAAI,CAAC;MACNE,CAAC,IAAI,CAAC;IACV;IACA,OAAO;MACHH,CAAC,EAAEA,CAAC;MACJC,CAAC,EAAEA,CAAC;MACJL,KAAK,EAAEM,CAAC;MACRS,MAAM,EAAER;IACZ,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIS,uBAAuBA,CAACZ,CAAC,EAAEV,UAAU,EAAEuB,KAAK,EAAEC,OAAO,EAAE;IACnD,IAAI,CAACD,KAAK,CAACE,MAAM,IAAID,OAAO,CAAC9C,WAAW,GAAG,CAAC,EAAE;MAC1C,MAAMgD,aAAa,GAAG,IAAI,CAACtD,KAAK,CAAC9B,MAAM,CAClCqF,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAACC,OAAO,CAAC,CACxBC,GAAG,CAAEF,CAAC,IAAKA,CAAC,CAACG,KAAK,CAAC;MACxB,IAAIC,eAAe,GAAG,CAAC;QAAEC,eAAe,GAAG,CAAC;MAC5C;MACA;MACA;MACA;MACA;MACAvG,UAAU,CAAC,IAAI,CAAC0C,KAAK,CAACY,QAAQ,EAAEkD,MAAM,EAAGC,KAAK,IAAK;QAC/C,IAAI,OAAOZ,KAAK,CAACb,CAAC,KAAK,QAAQ,EAAE;UAC7B,MAAM0B,SAAS,GAAGD,KAAK,CAACZ,KAAK,CAACb,CAAC,CAAC2B,QAAQ,CAAC,CAAC,CAAC;UAC3C,IAAID,SAAS,EAAE;YACX,MAAME,WAAW,GAAGF,SAAS,CAACjG,MAAM,CAAC,IAAI,CAAC4F,KAAK,CAAC;YAChD;YACA,IAAIzG,OAAO,CAACgH,WAAW,CAAC,EAAE;cACtB;cACA;cACA;cACA,MAAMC,aAAa,GAAGC,MAAM,CACvBC,IAAI,CAACL,SAAS,CAACjG,MAAM,CAAC,CACtBwF,MAAM,CAAEe,QAAQ;cACrB;cACA,CAACA,QAAQ,CAACC,KAAK,CAAC,GAAG,CAAC;cAChB;cACAP,SAAS,CAACjG,MAAM,CAACuG,QAAQ,CAAC,IAC1BN,SAAS,CAACjG,MAAM,CAACuG,QAAQ,CAAC,CAACE,MAAM,GAAG,CAAC,CAAC,CACrCd,GAAG,CAACe,UAAU,CAAC,CACflB,MAAM,CAAEI,KAAK,IAAKL,aAAa,CAACoB,OAAO,CAACf,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CACtDgB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,GAAGD,CAAC,CAAC;cAC1BhB,eAAe,GAAGO,aAAa,CAACO,OAAO,CAAC,IAAI,CAACf,KAAK,CAAC;cACnDE,eAAe,GAAGM,aAAa,CAACK,MAAM;YAC1C;UACJ;QACJ;MACJ,CAAC,CAAC;MACF;MACA,MAAMM,QAAQ,GAAG,CAACjB,eAAe,GAAG,CAAC,IAAIT,OAAO,CAAChB,WAAW,GACxDR,UAAU;MACdU,CAAC,GAAG,CAACa,KAAK,CAAC4B,KAAK,IAAI,CAAC,IAAID,QAAQ,GAAG,CAAC,GAAGlD,UAAU,GAC9CgC,eAAe,GAAGR,OAAO,CAAChB,WAAW;IAC7C;IACA,OAAOE,CAAC;EACZ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI0C,SAASA,CAAA,EAAG;IACR,MAAM9G,MAAM,GAAG,IAAI;MAAEK,KAAK,GAAGL,MAAM,CAACK,KAAK;MAAET,OAAO,GAAGI,MAAM,CAACJ,OAAO;MAAEmH,KAAK,GAAG/G,MAAM,CAAC+G,KAAK,GACrF/G,MAAM,CAACqD,iBAAiB,GAAGrD,MAAM,CAAC8B,KAAK,CAACiB,MAAM,GAAG,CAAC;MAAEtD,WAAW,GAAGO,MAAM,CAACP,WAAW,GAAGN,IAAI,CAACS,OAAO,CAACH,WAAW,EAAEsH,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;MACnI,CAAC;MAAEjF,KAAK,GAAG9B,MAAM,CAAC8B,KAAK;MAAE7B,KAAK,GAAGD,MAAM,CAACC,KAAK;MAAEW,SAAS,GAAGhB,OAAO,CAACgB,SAAS;MAAEoG,cAAc,GAAG7H,IAAI,CAACS,OAAO,CAACoH,cAAc,EAAE,CAAC,CAAC;MAAE9B,OAAO,GAAGlF,MAAM,CAAC6B,gBAAgB,CAAC,CAAC;MAAEoF,gBAAgB,GAAG/B,OAAO,CAAClB,KAAK;MAAEkD,aAAa,GAAGlH,MAAM,CAAC8D,YAAY,GAAGoB,OAAO,CAACjB,MAAM;MAAEkD,OAAO,GAAGnH,MAAM,CAACmH,OAAO;MAAEC,OAAO,GAAGpH,MAAM,CAACoH,OAAO;IAC/S;IACA,IAAIC,UAAU,GAAGrH,MAAM,CAACsH,IAAI,GACxB1E,IAAI,CAAC2E,GAAG,CAACN,gBAAgB,EAAE,CAAC,GAAG,CAAC,GAAGxH,WAAW,CAAC;MAAEgB,mBAAmB,GAAGT,MAAM,CAACS,mBAAmB,GACjGR,KAAK,CAACuH,YAAY,CAAC5G,SAAS,CAAC;IACjC,IAAIP,KAAK,CAACD,QAAQ,EAAE;MAChBK,mBAAmB,IAAI,GAAG,CAAC,CAAC;IAChC;IACA;IACA;IACA;IACA;IACA,IAAIb,OAAO,CAACgE,YAAY,EAAE;MACtByD,UAAU,GAAGzE,IAAI,CAAC6E,IAAI,CAACJ,UAAU,CAAC;IACtC;IACA5I,MAAM,CAACiJ,SAAS,CAACZ,SAAS,CAACvF,KAAK,CAACvB,MAAM,CAAC;IACxC;IACAA,MAAM,CAACH,MAAM,CAAC4B,OAAO,CAAC,UAAUwD,KAAK,EAAE;MACnC,MAAM0C,OAAO,GAAGxI,IAAI,CAAC8F,KAAK,CAAC0C,OAAO,EAAElH,mBAAmB,CAAC;QAAEmH,YAAY,GAAG,GAAG,GAAGhF,IAAI,CAACE,GAAG,CAAC6E,OAAO,CAAC;QAAEd,KAAK,GAAG5B,KAAK,CAAC4B,KAAK,IAAI,CAAC;QAC1H;QACA;QACAgB,KAAK,GAAGjJ,KAAK,CAACqG,KAAK,CAAC4C,KAAK,EAAE,CAACD,YAAY,EAAE3H,KAAK,CAACY,GAAG,GAAG+G,YAAY,CAAC;QAAEE,QAAQ,GAAG7C,KAAK,CAAC6C,QAAQ;MAC9F,IAAIC,EAAE;QAAEC,IAAI,GAAGpF,IAAI,CAACC,GAAG,CAACgF,KAAK,EAAEF,OAAO,CAAC;QAAEM,IAAI,GAAGrF,IAAI,CAAC2E,GAAG,CAACM,KAAK,EAAEF,OAAO,CAAC,GAAGK,IAAI;QAAEtE,UAAU,GAAGuD,gBAAgB;QAAEiB,IAAI,GAAGrB,KAAK,GAAGK,aAAa;QAAEI,IAAI,GAAGD,UAAU;MAC/J;MACA,IAAIL,cAAc,IAAIpE,IAAI,CAACE,GAAG,CAACmF,IAAI,CAAC,GAAGjB,cAAc,EAAE;QACnDiB,IAAI,GAAGjB,cAAc;QACrBe,EAAE,GAAI,CAAC9H,KAAK,CAACgC,QAAQ,IAAI,CAACgD,KAAK,CAACkD,QAAQ,IACnClI,KAAK,CAACgC,QAAQ,IAAIgD,KAAK,CAACkD,QAAS;QACtC;QACA;QACA,IAAIlJ,QAAQ,CAAC2B,SAAS,CAAC,IACnB3B,QAAQ,CAACmI,OAAO,CAAC,IACjBnC,KAAK,CAACZ,CAAC,KAAKzD,SAAS,IACrBwG,OAAO,IAAIxG,SAAS;QACpB;QACA,CAACX,KAAK,CAAC4C,GAAG,IAAI,CAAC,IAAIjC,SAAS;QAC5B;QACA;QACA;QACCuG,OAAO,KAAKC,OAAO,IAAI,CAACnH,KAAK,CAACsH,GAAG,IAAI,CAAC,KAAK3G,SAAS,CAAC,EAAE;UACxDmH,EAAE,GAAG,CAACA,EAAE;UACR9C,KAAK,CAACkD,QAAQ,GAAG,CAAClD,KAAK,CAACkD,QAAQ;QACpC;QACA;QACAH,IAAI,GAAIpF,IAAI,CAACE,GAAG,CAACkF,IAAI,GAAGvH,mBAAmB,CAAC,GAAGuG,cAAc;QACzD;QACAW,OAAO,GAAGX,cAAc;QACxB;QACAvG,mBAAmB,IACdsH,EAAE,GAAGf,cAAc,GAAG,CAAC,CAAE;MACtC;MACA;MACA;MACA,IAAInI,OAAO,CAACoG,KAAK,CAACrF,OAAO,CAAC8D,UAAU,CAAC,EAAE;QACnCA,UAAU,GAAG4D,IAAI,GACb1E,IAAI,CAAC6E,IAAI,CAACxC,KAAK,CAACrF,OAAO,CAAC8D,UAAU,CAAC;QACvCwE,IAAI,IAAItF,IAAI,CAACgC,KAAK,CAAC,CAAClB,UAAU,GAAGuD,gBAAgB,IAAI,CAAC,CAAC;MAC3D;MACA;MACA,IAAIrH,OAAO,CAACwI,gBAAgB,IAAI,CAACxI,OAAO,CAAC8C,QAAQ,EAAE;QAC/CwF,IAAI,GAAGlI,MAAM,CAACgF,uBAAuB,CAACkD,IAAI,EAAExE,UAAU,EAAEuB,KAAK,EAAEC,OAAO,CAAC;MAC3E;MACA;MACAD,KAAK,CAACiD,IAAI,GAAGA,IAAI;MACjBjD,KAAK,CAACvB,UAAU,GAAGA,UAAU;MAC7B;MACA;MACAuB,KAAK,CAACoD,UAAU,GAAGhI,KAAK,CAACD,QAAQ,GAC7B,CACIxB,KAAK,CAACqB,KAAK,CAACY,GAAG,GAAGZ,KAAK,CAACE,GAAG,GAAGE,KAAK,CAACiI,QAAQ,GAAGT,KAAK,EAAE5H,KAAK,CAACE,GAAG,GAAGE,KAAK,CAACiI,QAAQ,EAAErI,KAAK,CAACY,GAAG,GAAGZ,KAAK,CAACE,GAAG,GAAGE,KAAK,CAACiI,QAAQ,CAAC,EACzHxG,KAAK,CAACjB,GAAG,GAAGiB,KAAK,CAAC3B,GAAG,GAAGE,KAAK,CAACkI,OAAO,GAAGL,IAAI,GAAGZ,IAAI,GAAG,CAAC,EACvDW,IAAI,CACP,GACD,CACInG,KAAK,CAAC0G,IAAI,GAAGnI,KAAK,CAACiI,QAAQ,GAAGJ,IAAI,GAAGZ,IAAI,GAAG,CAAC,EAC7C1I,KAAK,CAACiJ,KAAK,GAAG5H,KAAK,CAACE,GAAG,GACnBE,KAAK,CAACkI,OAAO,EAAEtI,KAAK,CAACE,GAAG,GAAGE,KAAK,CAACkI,OAAO,EAAEtI,KAAK,CAACY,GAAG,GAAGZ,KAAK,CAACE,GAAG,GAAGE,KAAK,CAACkI,OAAO,CAAC,EACpFN,IAAI,CACP;MACL;MACA;MACAhD,KAAK,CAACwD,SAAS,GAAGzI,MAAM,CAAC0I,UAAU,CAAChB,SAAS,CAACe,SAAS,IACnD,aAAa;MACjBxD,KAAK,CAAC0D,SAAS,GAAG3I,MAAM,CAACmE,QAAQ,CAAC+D,IAAI;MACtC;MACA;MACA;MACAjD,KAAK,CAACE,MAAM,GAAG1E,mBAAmB,GAAGuH,IAAI,EAAEV,IAAI,EAAErC,KAAK,CAACE,MAAM,GAAG,CAAC,GAAG8C,IAAI,CAAC;IAC7E,CAAC,CAAC;IACF;IACA;IACA;IACA;IACAlJ,SAAS,CAAC,IAAI,EAAE,sBAAsB,CAAC;EAC3C;EACA;AACJ;AACA;AACA;AACA;AACA;EACI6J,SAASA,CAAA,EAAG;IACR,IAAI,CAACjJ,KAAK,CAAC,IAAI,CAACoH,KAAK,GAAG,UAAU,GAAG,aAAa,CAAC,CAAC,uBAAuB,CAAC;EAChF;EACA;AACJ;AACA;AACA;AACA;AACA;EACI8B,YAAYA,CAAC5D,KAAK,EAAE6D,KAAK,EAAE;IACvB,MAAMlJ,OAAO,GAAG,IAAI,CAACA,OAAO;MAAEmJ,GAAG,GAAG,IAAI,CAACC,kBAAkB,IAAI,CAAC,CAAC;MAAEC,YAAY,GAAGF,GAAG,CAACG,MAAM,IAAI,aAAa;MAAEC,iBAAiB,GAAGJ,GAAG,CAAC,cAAc,CAAC,IAAI,aAAa;IACvK,IAAIK,YAAY;MAAEC,IAAI;MAAEC,UAAU;MAAEC,IAAI,GAAItE,KAAK,IAAIA,KAAK,CAAC7G,KAAK,IAAK,IAAI,CAACA,KAAK;MAC/E;MACA8K,MAAM,GAAKjE,KAAK,IAAIA,KAAK,CAACgE,YAAY,CAAC,IACnCrJ,OAAO,CAACqJ,YAAY,CAAC,IACrBM,IAAK;MAAEC,SAAS,GAAIvE,KAAK,IAAIA,KAAK,CAACrF,OAAO,CAAC6J,SAAS,IAAK7J,OAAO,CAAC6J,SAAS;MAAEC,WAAW,GAAIzE,KAAK,IAAIA,KAAK,CAACkE,iBAAiB,CAAC,IAC5HvJ,OAAO,CAACuJ,iBAAiB,CAAC,IAC1B,IAAI,CAACA,iBAAiB,CAAC,IAAI,CAAC;MAAEQ,OAAO,GAAGxK,IAAI,CAAC8F,KAAK,IAAIA,KAAK,CAAC0E,OAAO,EAAE/J,OAAO,CAAC+J,OAAO,EAAE,CAAC,CAAC;IAC5F;IACA,IAAI1E,KAAK,IAAI,IAAI,CAAC2E,KAAK,CAACtD,MAAM,EAAE;MAC5B+C,IAAI,GAAGpE,KAAK,CAAC4E,OAAO,CAAC,CAAC;MACtB;MACA;MACAN,IAAI,GAAItE,KAAK,CAACrF,OAAO,CAACxB,KAAK,IACtBiL,IAAI,KAAKA,IAAI,CAACjL,KAAK,IAAI6G,KAAK,CAAC6E,aAAa,CAAE,IAC7C,IAAI,CAAC1L,KAAM;MACf,IAAIiL,IAAI,EAAE;QACNH,MAAM,GAAGG,IAAI,CAACU,WAAW,IAAIb,MAAM;QACnCM,SAAS,GAAGH,IAAI,CAACI,SAAS,IAAID,SAAS;QACvCE,WAAW,GAAGL,IAAI,CAAC5J,WAAW,IAAIiK,WAAW;MACjD;IACJ;IACA;IACA,IAAIZ,KAAK,IAAI7D,KAAK,EAAE;MAChBmE,YAAY,GAAGlK,KAAK,CAACU,OAAO,CAACoK,MAAM,CAAClB,KAAK,CAAC;MAC1C;MACA7D,KAAK,CAACrF,OAAO,CAACoK,MAAM,IAChB/E,KAAK,CAACrF,OAAO,CAACoK,MAAM,CAAClB,KAAK,CAAC,IAC3B,CAAC,CAAC,CAAC;MACPQ,UAAU,GAAGF,YAAY,CAACE,UAAU;MACpCC,IAAI,GACAH,YAAY,CAAChL,KAAK,IAAK,OAAOkL,UAAU,KAAK,WAAW,IACpDlL,KAAK,CAACmL,IAAI,CAAC,CACNU,QAAQ,CAACb,YAAY,CAACE,UAAU,CAAC,CACjCY,GAAG,CAAC,CAAE,IAAIX,IAAI;MAC3BL,MAAM,GAAGE,YAAY,CAACH,YAAY,CAAC,IAAIC,MAAM;MAC7CQ,WAAW,GACPN,YAAY,CAACD,iBAAiB,CAAC,IAAIO,WAAW;MAClDF,SAAS,GAAGJ,YAAY,CAACK,SAAS,IAAID,SAAS;MAC/CG,OAAO,GAAGxK,IAAI,CAACiK,YAAY,CAACO,OAAO,EAAEA,OAAO,CAAC;IACjD;IACA,MAAMQ,GAAG,GAAG;MACRZ,IAAI,EAAEA,IAAI;MACVL,MAAM,EAAEA,MAAM;MACd,cAAc,EAAEQ,WAAW;MAC3BC,OAAO,EAAEA;IACb,CAAC;IACD,IAAIH,SAAS,EAAE;MACXW,GAAG,CAACX,SAAS,GAAGA,SAAS;IAC7B;IACA,OAAOW,GAAG;EACd;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,UAAUA,CAACvK,MAAM,GAAG,IAAI,CAACA,MAAM,EAAE;IAC7B,MAAMG,MAAM,GAAG,IAAI;MAAEK,KAAK,GAAG,IAAI,CAACA,KAAK;MAAET,OAAO,GAAGI,MAAM,CAACJ,OAAO;MAAEyK,QAAQ,GAAGhK,KAAK,CAACgK,QAAQ;MAAEC,cAAc,GAAG1K,OAAO,CAAC0K,cAAc,IAAI,GAAG;IAC5I,IAAI3B,SAAS;IACb;IACA9I,MAAM,CAAC4B,OAAO,CAAC,UAAUwD,KAAK,EAAE;MAC5B,MAAM4C,KAAK,GAAG5C,KAAK,CAAC4C,KAAK;MACzB,IAAI0C,OAAO,GAAGtF,KAAK,CAACsF,OAAO;QAAEC,UAAU,GAAG,CAAC,CAACD,OAAO;QAAEE,IAAI,GAAGF,OAAO,IAAIlK,KAAK,CAACqK,UAAU,GAAGJ,cAAc,GACpG,SAAS,GAAG,MAAM;MACtB,IAAIrL,QAAQ,CAAC4I,KAAK,CAAC,IAAI5C,KAAK,CAACZ,CAAC,KAAK,IAAI,EAAE;QACrCsE,SAAS,GAAG1D,KAAK,CAAC0D,SAAS;QAC3B;QACA;QACA,IAAI4B,OAAO,IAAItF,KAAK,CAAC0F,eAAe,CAAC,CAAC,EAAE;UACpCJ,OAAO,GAAGA,OAAO,CAACK,OAAO,CAAC,CAAC;QAC/B;QACA;QACA,IAAI5K,MAAM,CAAC6K,kBAAkB,EAAE;UAC3B5F,KAAK,CAAC6F,SAAS,GAAG9K,MAAM,CAAC8B,KAAK,CAACG,QAAQ,GACnC,EAAE0G,SAAS,GAAIA,SAAS,CAAC3E,KAAK,IAAI,CAAC,GAAI,CAAC,CAAC,GACzChE,MAAM,CAAC8B,KAAK,CAACkC,KAAK;QAC1B;QACA,IAAI,CAACuG,OAAO,EAAE;UACVtF,KAAK,CAACsF,OAAO,GAAGA,OAAO,GACnBF,QAAQ,CAACpF,KAAK,CAACwD,SAAS,CAAC,CAACE,SAAS,CAAC,CAC/BoC,GAAG,CAAC9F,KAAK,CAACtF,KAAK,IAAIK,MAAM,CAACL,KAAK,CAAC;UACzC,IAAI4K,OAAO,IACPvK,MAAM,CAAC6K,kBAAkB,IACzBxK,KAAK,CAACmB,WAAW,IACjBnB,KAAK,CAACqK,UAAU,GAAGJ,cAAc,EAAE;YACnCC,OAAO,CAACjK,IAAI,CAAC;cACT8D,CAAC,EAAEa,KAAK,CAAC6F;YACb,CAAC,CAAC;YACFN,UAAU,GAAG,IAAI;YACjBC,IAAI,GAAG,SAAS;UACpB;QACJ;QACA,IAAIF,OAAO,IAAIC,UAAU,EAAE;UAAE;UACzBD,OAAO,CAACE,IAAI,CAAC,CAACvL,KAAK,CAACyJ,SAAS,CAAC,CAAC;QACnC;QACA;QACA,IAAI,CAACtI,KAAK,CAAC2K,UAAU,EAAE;UACnBT,OAAO,CAACE,IAAI,CAAC,CAACzK,MAAM,CAAC6I,YAAY,CAAC5D,KAAK,EAAGA,KAAK,CAACgG,QAAQ,IAAI,QAAS,CAAC,CAAC,CAClEC,MAAM,CAACjG,KAAK,CAACkG,WAAW,KAAK,KAAK,IAAIvL,OAAO,CAACsL,MAAM,CAAC;QAC9D;QACA,IAAIX,OAAO,EAAE;UACTA,OAAO,CAACa,QAAQ,CAACnG,KAAK,CAACoG,YAAY,CAAC,CAAC,EAAE,IAAI,CAAC;UAC5Cd,OAAO,CAACjK,IAAI,CAAC;YACTgL,UAAU,EAAErG,KAAK,CAACM,OAAO,GAAG,SAAS,GAAG;UAC5C,CAAC,CAAC;QACN;MACJ,CAAC,MACI,IAAIgF,OAAO,EAAE;QACdtF,KAAK,CAACsF,OAAO,GAAGA,OAAO,CAACK,OAAO,CAAC,CAAC,CAAC,CAAC;MACvC;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;EACIW,WAAWA,CAAC1L,MAAM,GAAG,IAAI,CAACA,MAAM,EAAE;IAC9B,MAAMG,MAAM,GAAG,IAAI;MAAEK,KAAK,GAAGL,MAAM,CAACK,KAAK;MAAEmL,OAAO,GAAGnL,KAAK,CAACmL,OAAO;MAAEC,WAAW,GAAG,SAAAA,CAAUC,CAAC,EAAE;QAC3F,MAAMzG,KAAK,GAAGuG,OAAO,CAACG,iBAAiB,CAACD,CAAC,CAAC;QAC1C;QACA,IAAI,OAAOzG,KAAK,KAAK,WAAW,IAC5BjF,MAAM,CAACJ,OAAO,CAACgM,mBAAmB,EAAE;UACpCJ,OAAO,CAACK,aAAa,GAAG,IAAI;UAC5B5G,KAAK,CAACwG,WAAW,CAACC,CAAC,CAAC;QACxB;MACJ,CAAC;IACD,IAAII,UAAU;IACd;IACAjM,MAAM,CAAC4B,OAAO,CAAC,UAAUwD,KAAK,EAAE;MAC5B6G,UAAU,GAAI9M,OAAO,CAACiG,KAAK,CAAC6G,UAAU,CAAC,GACnC7G,KAAK,CAAC6G,UAAU,GACf7G,KAAK,CAAC8G,SAAS,GAAG,CAAC9G,KAAK,CAAC8G,SAAS,CAAC,GAAG,EAAI;MAC/C,IAAI9G,KAAK,CAACsF,OAAO,EAAE;QACftF,KAAK,CAACsF,OAAO,CAACyB,OAAO,CAAC/G,KAAK,GAAGA,KAAK;MACvC;MACA6G,UAAU,CAACrK,OAAO,CAAC,UAAUsK,SAAS,EAAE;QACpC,IAAIA,SAAS,CAACE,GAAG,EAAE;UACfF,SAAS,CAACE,GAAG,CAAChH,KAAK,GAAGA,KAAK;QAC/B,CAAC,MACI;UACD8G,SAAS,CAACC,OAAO,CAAC/G,KAAK,GAAGA,KAAK;QACnC;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;IACF;IACA,IAAI,CAACjF,MAAM,CAACkM,YAAY,EAAE;MACtBlM,MAAM,CAACmM,aAAa,CAAC1K,OAAO,CAAC,UAAU2K,GAAG,EAAE;QACxC,IAAIpM,MAAM,CAACoM,GAAG,CAAC,EAAE;UACb;UACApM,MAAM,CAACoM,GAAG,CAAC,CACNhB,QAAQ,CAAC,oBAAoB,CAAC,CAC9BiB,EAAE,CAAC,WAAW,EAAEZ,WAAW,CAAC,CAC5BY,EAAE,CAAC,UAAU,EAAE,UAAUX,CAAC,EAAE;YAC7BF,OAAO,CAACc,iBAAiB,CAACZ,CAAC,CAAC;UAChC,CAAC,CAAC;UACF,IAAInN,QAAQ,EAAE;YACVyB,MAAM,CAACoM,GAAG,CAAC,CAACC,EAAE,CAAC,YAAY,EAAEZ,WAAW,CAAC;UAC7C;UACA,IAAI,CAACpL,KAAK,CAAC2K,UAAU,IAAIhL,MAAM,CAACJ,OAAO,CAAC2M,MAAM,EAAE;YAC5CvM,MAAM,CAACoM,GAAG,CAAC,CACNI,GAAG,CAAC;cAAED,MAAM,EAAEvM,MAAM,CAACJ,OAAO,CAAC2M;YAAO,CAAC,CAAC;UAC/C;QACJ;MACJ,CAAC,CAAC;MACFvM,MAAM,CAACkM,YAAY,GAAG,IAAI;IAC9B;IACAnN,SAAS,CAAC,IAAI,EAAE,kBAAkB,CAAC;EACvC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI0N,MAAMA,CAAA,EAAG;IACL,MAAMzM,MAAM,GAAG,IAAI;MAAEK,KAAK,GAAGL,MAAM,CAACK,KAAK;IACzC;IACA;IACA,IAAIA,KAAK,CAACmB,WAAW,EAAE;MACnBnB,KAAK,CAACL,MAAM,CAACyB,OAAO,CAAC,UAAUC,WAAW,EAAE;QACxC,IAAIA,WAAW,CAACC,IAAI,KAAK3B,MAAM,CAAC2B,IAAI,EAAE;UAClCD,WAAW,CAACE,OAAO,GAAG,IAAI;QAC9B;MACJ,CAAC,CAAC;IACN;IACAnD,MAAM,CAACiJ,SAAS,CAAC+E,MAAM,CAAClL,KAAK,CAACvB,MAAM,EAAER,SAAS,CAAC;EACpD;AACJ;AACAF,YAAY,CAACoN,cAAc,GAAGxN,KAAK,CAACT,MAAM,CAACiO,cAAc,EAAErO,oBAAoB,CAAC;AAChFS,MAAM,CAACQ,YAAY,CAACoI,SAAS,EAAE;EAC3B;EACA;EACAiF,WAAW,EAAE,IAAI;EACjBC,SAAS,EAAEpO,IAAI;EACf;EACA;EACAqO,SAAS,EAAE,IAAI;EACfV,aAAa,EAAE,CAAC,OAAO,EAAE,iBAAiB;AAC9C,CAAC,CAAC;AACFzN,cAAc,CAACoO,kBAAkB,CAAC,QAAQ,EAAExN,YAAY,CAAC;AACzD;AACA;AACA;AACA;AACA;AACA,eAAeA,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GALA,CAKI;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA;AACA,EAAE,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}