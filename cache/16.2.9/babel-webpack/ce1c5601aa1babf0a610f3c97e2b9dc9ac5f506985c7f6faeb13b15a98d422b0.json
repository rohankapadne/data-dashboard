{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport Color from '../../Core/Color/Color.js';\nconst {\n  parse: color\n} = Color;\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst {\n  seriesTypes: {\n    line: LineSeries\n  }\n} = SeriesRegistry;\nimport U from '../../Core/Utilities.js';\nconst {\n  extend,\n  merge,\n  objectEach,\n  pick\n} = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * Area series type.\n *\n * @private\n * @class\n * @name AreaSeries\n *\n * @augments LineSeries\n */\nclass AreaSeries extends LineSeries {\n  constructor() {\n    /* *\n     *\n     *  Static Properties\n     *\n     * */\n    super(...arguments);\n    this.data = void 0;\n    this.options = void 0;\n    this.points = void 0;\n    /* eslint-enable valid-jsdoc */\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Draw the graph and the underlying area. This method calls the Series\n   * base function and adds the area. The areaPath is calculated in the\n   * getSegmentPath method called from Series.prototype.drawGraph.\n   * @private\n   */\n  drawGraph() {\n    // Define or reset areaPath\n    this.areaPath = [];\n    // Call the base method\n    super.drawGraph.apply(this);\n    // Define local variables\n    const series = this,\n      areaPath = this.areaPath,\n      options = this.options,\n      zones = this.zones,\n      props = [['area', 'highcharts-area', this.color, options.fillColor]]; // area name, main color, fill color\n    zones.forEach(function (zone, i) {\n      props.push(['zone-area-' + i, 'highcharts-area highcharts-zone-area-' + i + ' ' + zone.className, zone.color || series.color, zone.fillColor || options.fillColor]);\n    });\n    props.forEach(function (prop) {\n      const areaKey = prop[0],\n        attribs = {};\n      let area = series[areaKey];\n      const verb = area ? 'animate' : 'attr';\n      // Create or update the area\n      if (area) {\n        // update\n        area.endX = series.preventGraphAnimation ? null : areaPath.xMap;\n        area.animate({\n          d: areaPath\n        });\n      } else {\n        // create\n        attribs.zIndex = 0; // #1069\n        area = series[areaKey] = series.chart.renderer.path(areaPath).addClass(prop[1]).add(series.group);\n        area.isArea = true;\n      }\n      if (!series.chart.styledMode) {\n        // If there is fillColor defined for the area, set it\n        if (prop[3]) {\n          attribs.fill = prop[3];\n        } else {\n          // Otherwise, we set it to the series color and add\n          // fill-opacity (#18939)\n          attribs.fill = prop[2];\n          attribs['fill-opacity'] = pick(options.fillOpacity, 0.75);\n        }\n      }\n      area[verb](attribs);\n      area.startX = areaPath.xMap;\n      area.shiftUnit = options.step ? 2 : 1;\n    });\n  }\n  /**\n   * @private\n   */\n  getGraphPath(points) {\n    const getGraphPath = LineSeries.prototype.getGraphPath,\n      options = this.options,\n      stacking = options.stacking,\n      yAxis = this.yAxis,\n      bottomPoints = [],\n      graphPoints = [],\n      seriesIndex = this.index,\n      stacks = yAxis.stacking.stacks[this.stackKey],\n      threshold = options.threshold,\n      translatedThreshold = Math.round(\n      // #10909\n      yAxis.getThreshold(options.threshold)),\n      connectNulls = pick(\n      // #10574\n      options.connectNulls, stacking === 'percent'),\n      // To display null points in underlying stacked series, this\n      // series graph must be broken, and the area also fall down to\n      // fill the gap left by the null point. #2069\n      addDummyPoints = function (i, otherI, side) {\n        const point = points[i],\n          stackedValues = stacking && stacks[point.x].points[seriesIndex],\n          nullVal = point[side + 'Null'] || 0,\n          cliffVal = point[side + 'Cliff'] || 0;\n        let top,\n          bottom,\n          isNull = true;\n        if (cliffVal || nullVal) {\n          top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;\n          bottom = stackedValues[0] + cliffVal;\n          isNull = !!nullVal;\n        } else if (!stacking && points[otherI] && points[otherI].isNull) {\n          top = bottom = threshold;\n        }\n        // Add to the top and bottom line of the area\n        if (typeof top !== 'undefined') {\n          graphPoints.push({\n            plotX: plotX,\n            plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),\n            isNull: isNull,\n            isCliff: true\n          });\n          bottomPoints.push({\n            plotX: plotX,\n            plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom),\n            doCurve: false // #1041, gaps in areaspline areas\n          });\n        }\n      };\n\n    let plotX, isNull, yBottom;\n    // Find what points to use\n    points = points || this.points;\n    // Fill in missing points\n    if (stacking) {\n      points = this.getStackPoints(points);\n    }\n    for (let i = 0, iEnd = points.length; i < iEnd; ++i) {\n      // Reset after series.update of stacking property (#12033)\n      if (!stacking) {\n        points[i].leftCliff = points[i].rightCliff = points[i].leftNull = points[i].rightNull = void 0;\n      }\n      isNull = points[i].isNull;\n      plotX = pick(points[i].rectPlotX, points[i].plotX);\n      yBottom = stacking ? pick(points[i].yBottom, translatedThreshold) : translatedThreshold;\n      if (!isNull || connectNulls) {\n        if (!connectNulls) {\n          addDummyPoints(i, i - 1, 'left');\n        }\n        // Skip null point when stacking is false and connectNulls\n        // true\n        if (!(isNull && !stacking && connectNulls)) {\n          graphPoints.push(points[i]);\n          bottomPoints.push({\n            x: i,\n            plotX: plotX,\n            plotY: yBottom\n          });\n        }\n        if (!connectNulls) {\n          addDummyPoints(i, i + 1, 'right');\n        }\n      }\n    }\n    const topPath = getGraphPath.call(this, graphPoints, true, true);\n    bottomPoints.reversed = true;\n    const bottomPath = getGraphPath.call(this, bottomPoints, true, true);\n    const firstBottomPoint = bottomPath[0];\n    if (firstBottomPoint && firstBottomPoint[0] === 'M') {\n      bottomPath[0] = ['L', firstBottomPoint[1], firstBottomPoint[2]];\n    }\n    const areaPath = topPath.concat(bottomPath);\n    if (areaPath.length) {\n      areaPath.push(['Z']);\n    }\n    // TODO: don't set leftCliff and rightCliff when connectNulls?\n    const graphPath = getGraphPath.call(this, graphPoints, false, connectNulls);\n    areaPath.xMap = topPath.xMap;\n    this.areaPath = areaPath;\n    return graphPath;\n  }\n  /**\n   * Return an array of stacked points, where null and missing points are\n   * replaced by dummy points in order for gaps to be drawn correctly in\n   * stacks.\n   * @private\n   */\n  getStackPoints(points) {\n    const series = this,\n      segment = [],\n      keys = [],\n      xAxis = this.xAxis,\n      yAxis = this.yAxis,\n      stack = yAxis.stacking.stacks[this.stackKey],\n      pointMap = {},\n      yAxisSeries = yAxis.series,\n      seriesLength = yAxisSeries.length,\n      upOrDown = yAxis.options.reversedStacks ? 1 : -1,\n      seriesIndex = yAxisSeries.indexOf(series);\n    points = points || this.points;\n    if (this.options.stacking) {\n      for (let i = 0; i < points.length; i++) {\n        // Reset after point update (#7326)\n        points[i].leftNull = points[i].rightNull = void 0;\n        // Create a map where we can quickly look up the points by\n        // their X values.\n        pointMap[points[i].x] = points[i];\n      }\n      // Sort the keys (#1651)\n      objectEach(stack, function (stackX, x) {\n        // nulled after switching between\n        // grouping and not (#1651, #2336)\n        if (stackX.total !== null) {\n          keys.push(x);\n        }\n      });\n      keys.sort(function (a, b) {\n        return a - b;\n      });\n      const visibleSeries = yAxisSeries.map(s => s.visible);\n      keys.forEach(function (x, idx) {\n        let y = 0,\n          stackPoint,\n          stackedValues;\n        if (pointMap[x] && !pointMap[x].isNull) {\n          segment.push(pointMap[x]);\n          // Find left and right cliff. -1 goes left, 1 goes\n          // right.\n          [-1, 1].forEach(function (direction) {\n            const nullName = direction === 1 ? 'rightNull' : 'leftNull',\n              cliffName = direction === 1 ? 'rightCliff' : 'leftCliff',\n              otherStack = stack[keys[idx + direction]];\n            let cliff = 0;\n            // If there is a stack next to this one,\n            // to the left or to the right...\n            if (otherStack) {\n              let i = seriesIndex;\n              // Can go either up or down,\n              // depending on reversedStacks\n              while (i >= 0 && i < seriesLength) {\n                const si = yAxisSeries[i].index;\n                stackPoint = otherStack.points[si];\n                if (!stackPoint) {\n                  // If the next point in this series is\n                  // missing, mark the point with\n                  // point.leftNull or point.rightNull = true.\n                  if (si === series.index) {\n                    pointMap[x][nullName] = true;\n                    // If there are missing points in the next\n                    // stack in any of the series below this\n                    // one, we need to substract the missing\n                    // values and add a hiatus to the left or\n                    // right.\n                  } else if (visibleSeries[i]) {\n                    stackedValues = stack[x].points[si];\n                    if (stackedValues) {\n                      cliff -= stackedValues[1] - stackedValues[0];\n                    }\n                  }\n                }\n                // When reversedStacks is true, loop up,\n                // else loop down\n                i += upOrDown;\n              }\n            }\n            pointMap[x][cliffName] = cliff;\n          });\n          // There is no point for this X value in this series, so we\n          // insert a dummy point in order for the areas to be drawn\n          // correctly.\n        } else {\n          // Loop down the stack to find the series below this\n          // one that has a value (#1991)\n          let i = seriesIndex;\n          while (i >= 0 && i < seriesLength) {\n            const si = yAxisSeries[i].index;\n            stackPoint = stack[x].points[si];\n            if (stackPoint) {\n              y = stackPoint[1];\n              break;\n            }\n            // When reversedStacks is true, loop up, else loop\n            // down\n            i += upOrDown;\n          }\n          y = pick(y, 0);\n          y = yAxis.translate(\n          // #6272\n          y, 0, 1, 0, 1);\n          segment.push({\n            isNull: true,\n            plotX: xAxis.translate(\n            // #6272\n            x, 0, 0, 0, 1),\n            x: x,\n            plotY: y,\n            yBottom: y\n          });\n        }\n      });\n    }\n    return segment;\n  }\n}\n/**\n * The area series type.\n *\n * @sample {highcharts} highcharts/demo/area-basic/\n *         Area chart\n * @sample {highstock} stock/demo/area/\n *         Area chart\n *\n * @extends      plotOptions.line\n * @excluding    useOhlcData\n * @product      highcharts highstock\n * @optionparent plotOptions.area\n */\nAreaSeries.defaultOptions = merge(LineSeries.defaultOptions, {\n  /**\n   * @see [fillColor](#plotOptions.area.fillColor)\n   * @see [fillOpacity](#plotOptions.area.fillOpacity)\n   *\n   * @apioption plotOptions.area.color\n   */\n  /**\n   * Fill color or gradient for the area. When `null`, the series' `color`\n   * is used with the series' `fillOpacity`.\n   *\n   * In styled mode, the fill color can be set with the `.highcharts-area`\n   * class name.\n   *\n   * @see [color](#plotOptions.area.color)\n   * @see [fillOpacity](#plotOptions.area.fillOpacity)\n   *\n   * @sample {highcharts} highcharts/plotoptions/area-fillcolor-default/\n   *         Null by default\n   * @sample {highcharts} highcharts/plotoptions/area-fillcolor-gradient/\n   *         Gradient\n   *\n   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n   * @product   highcharts highstock\n   * @apioption plotOptions.area.fillColor\n   */\n  /**\n   * Fill opacity for the area. When you set an explicit `fillColor`,\n   * the `fillOpacity` is not applied. Instead, you should define the\n   * opacity in the `fillColor` with an rgba color definition. The\n   * `fillOpacity` setting, also the default setting, overrides the alpha\n   * component of the `color` setting.\n   *\n   * In styled mode, the fill opacity can be set with the\n   * `.highcharts-area` class name.\n   *\n   * @see [color](#plotOptions.area.color)\n   * @see [fillColor](#plotOptions.area.fillColor)\n   *\n   * @sample {highcharts} highcharts/plotoptions/area-fillopacity/\n   *         Automatic fill color and fill opacity of 0.1\n   *\n   * @type      {number}\n   * @default   {highcharts} 0.75\n   * @default   {highstock} 0.75\n   * @product   highcharts highstock\n   * @apioption plotOptions.area.fillOpacity\n   */\n  /**\n   * A separate color for the graph line. By default the line takes the\n   * `color` of the series, but the lineColor setting allows setting a\n   * separate color for the line without altering the `fillColor`.\n   *\n   * In styled mode, the line stroke can be set with the\n   * `.highcharts-graph` class name.\n   *\n   * @sample {highcharts} highcharts/plotoptions/area-linecolor/\n   *         Dark gray line\n   *\n   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n   * @product   highcharts highstock\n   * @apioption plotOptions.area.lineColor\n   */\n  /**\n   * A separate color for the negative part of the area.\n   *\n   * In styled mode, a negative color is set with the\n   * `.highcharts-negative` class name.\n   *\n   * @see [negativeColor](#plotOptions.area.negativeColor)\n   *\n   * @sample {highcharts} highcharts/css/series-negative-color/\n   *         Negative color in styled mode\n   *\n   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n   * @since     3.0\n   * @product   highcharts\n   * @apioption plotOptions.area.negativeFillColor\n   */\n  /**\n   * Whether the whole area or just the line should respond to mouseover\n   * tooltips and other mouse or touch events.\n   *\n   * @sample {highcharts|highstock} highcharts/plotoptions/area-trackbyarea/\n   *         Display the tooltip when the area is hovered\n   *\n   * @type      {boolean}\n   * @default   false\n   * @since     1.1.6\n   * @product   highcharts highstock\n   * @apioption plotOptions.area.trackByArea\n   */\n  /**\n   * The Y axis value to serve as the base for the area, for\n   * distinguishing between values above and below a threshold. The area\n   * between the graph and the threshold is filled.\n   *\n   * * If a number is given, the Y axis will scale to the threshold.\n   * * If `null`, the scaling behaves like a line series with fill between\n   *   the graph and the Y axis minimum.\n   * * If `Infinity` or `-Infinity`, the area between the graph and the\n   *   corresponding Y axis extreme is filled (since v6.1.0).\n   *\n   * @sample {highcharts} highcharts/plotoptions/area-threshold/\n   *         A threshold of 100\n   * @sample {highcharts} highcharts/plotoptions/area-threshold-infinity/\n   *         A threshold of Infinity\n   *\n   * @type    {number|null}\n   * @since   2.0\n   * @product highcharts highstock\n   */\n  threshold: 0,\n  legendSymbol: 'rectangle'\n});\nextend(AreaSeries.prototype, {\n  singleStacks: false\n});\nSeriesRegistry.registerSeriesType('area', AreaSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default AreaSeries;\n/* *\n *\n *  API Options\n *\n * */\n/**\n * A `area` series. If the [type](#series.area.type) option is not\n * specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.area\n * @excluding dataParser, dataURL, useOhlcData\n * @product   highcharts highstock\n * @apioption series.area\n */\n/**\n * @see [fillColor](#series.area.fillColor)\n * @see [fillOpacity](#series.area.fillOpacity)\n *\n * @apioption series.area.color\n */\n/**\n * An array of data points for the series. For the `area` series type,\n * points can be given in the following ways:\n *\n * 1. An array of numerical values. In this case, the numerical values will be\n *    interpreted as `y` options. The `x` values will be automatically\n *    calculated, either starting at 0 and incremented by 1, or from\n *    `pointStart` * and `pointInterval` given in the series options. If the\n *    axis has categories, these will be used. Example:\n *    ```js\n *    data: [0, 5, 3, 5]\n *    ```\n *\n * 2. An array of arrays with 2 values. In this case, the values correspond to\n *    `x,y`. If the first value is a string, it is applied as the name of the\n *    point, and the `x` value is inferred.\n *    ```js\n *    data: [\n *        [0, 9],\n *        [1, 7],\n *        [2, 6]\n *    ]\n *    ```\n *\n * 3. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.area.turboThreshold), this option is not\n *    available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        y: 9,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        y: 6,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n * @extends   series.line.data\n * @product   highcharts highstock\n * @apioption series.area.data\n */\n/**\n * @see [color](#series.area.color)\n * @see [fillOpacity](#series.area.fillOpacity)\n *\n * @apioption series.area.fillColor\n */\n/**\n * @see [color](#series.area.color)\n * @see [fillColor](#series.area.fillColor)\n *\n * @default   {highcharts} 0.75\n * @default   {highstock} 0.75\n * @apioption series.area.fillOpacity\n */\n''; // adds doclets above to transpilat","map":{"version":3,"names":["Color","parse","color","SeriesRegistry","seriesTypes","line","LineSeries","U","extend","merge","objectEach","pick","AreaSeries","constructor","arguments","data","options","points","drawGraph","areaPath","apply","series","zones","props","fillColor","forEach","zone","i","push","className","prop","areaKey","attribs","area","verb","endX","preventGraphAnimation","xMap","animate","d","zIndex","chart","renderer","path","addClass","add","group","isArea","styledMode","fill","fillOpacity","startX","shiftUnit","step","getGraphPath","prototype","stacking","yAxis","bottomPoints","graphPoints","seriesIndex","index","stacks","stackKey","threshold","translatedThreshold","Math","round","getThreshold","connectNulls","addDummyPoints","otherI","side","point","stackedValues","x","nullVal","cliffVal","top","bottom","isNull","plotX","plotY","isCliff","doCurve","yBottom","getStackPoints","iEnd","length","leftCliff","rightCliff","leftNull","rightNull","rectPlotX","topPath","call","reversed","bottomPath","firstBottomPoint","concat","graphPath","segment","keys","xAxis","stack","pointMap","yAxisSeries","seriesLength","upOrDown","reversedStacks","indexOf","stackX","total","sort","a","b","visibleSeries","map","s","visible","idx","y","stackPoint","direction","nullName","cliffName","otherStack","cliff","si","translate","defaultOptions","legendSymbol","singleStacks","registerSeriesType"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Series/Area/AreaSeries.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport Color from '../../Core/Color/Color.js';\nconst { parse: color } = Color;\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { seriesTypes: { line: LineSeries } } = SeriesRegistry;\nimport U from '../../Core/Utilities.js';\nconst { extend, merge, objectEach, pick } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * Area series type.\n *\n * @private\n * @class\n * @name AreaSeries\n *\n * @augments LineSeries\n */\nclass AreaSeries extends LineSeries {\n    constructor() {\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        super(...arguments);\n        this.data = void 0;\n        this.options = void 0;\n        this.points = void 0;\n        /* eslint-enable valid-jsdoc */\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Draw the graph and the underlying area. This method calls the Series\n     * base function and adds the area. The areaPath is calculated in the\n     * getSegmentPath method called from Series.prototype.drawGraph.\n     * @private\n     */\n    drawGraph() {\n        // Define or reset areaPath\n        this.areaPath = [];\n        // Call the base method\n        super.drawGraph.apply(this);\n        // Define local variables\n        const series = this, areaPath = this.areaPath, options = this.options, zones = this.zones, props = [[\n                'area',\n                'highcharts-area',\n                this.color,\n                options.fillColor\n            ]]; // area name, main color, fill color\n        zones.forEach(function (zone, i) {\n            props.push([\n                'zone-area-' + i,\n                'highcharts-area highcharts-zone-area-' + i + ' ' +\n                    zone.className,\n                zone.color || series.color,\n                zone.fillColor || options.fillColor\n            ]);\n        });\n        props.forEach(function (prop) {\n            const areaKey = prop[0], attribs = {};\n            let area = series[areaKey];\n            const verb = area ? 'animate' : 'attr';\n            // Create or update the area\n            if (area) { // update\n                area.endX = series.preventGraphAnimation ?\n                    null :\n                    areaPath.xMap;\n                area.animate({ d: areaPath });\n            }\n            else { // create\n                attribs.zIndex = 0; // #1069\n                area = series[areaKey] = series.chart.renderer\n                    .path(areaPath)\n                    .addClass(prop[1])\n                    .add(series.group);\n                area.isArea = true;\n            }\n            if (!series.chart.styledMode) {\n                // If there is fillColor defined for the area, set it\n                if (prop[3]) {\n                    attribs.fill = prop[3];\n                }\n                else {\n                    // Otherwise, we set it to the series color and add\n                    // fill-opacity (#18939)\n                    attribs.fill = prop[2];\n                    attribs['fill-opacity'] = pick(options.fillOpacity, 0.75);\n                }\n            }\n            area[verb](attribs);\n            area.startX = areaPath.xMap;\n            area.shiftUnit = options.step ? 2 : 1;\n        });\n    }\n    /**\n     * @private\n     */\n    getGraphPath(points) {\n        const getGraphPath = LineSeries.prototype.getGraphPath, options = this.options, stacking = options.stacking, yAxis = this.yAxis, bottomPoints = [], graphPoints = [], seriesIndex = this.index, stacks = yAxis.stacking.stacks[this.stackKey], threshold = options.threshold, translatedThreshold = Math.round(// #10909\n        yAxis.getThreshold(options.threshold)), connectNulls = pick(// #10574\n        options.connectNulls, stacking === 'percent'), \n        // To display null points in underlying stacked series, this\n        // series graph must be broken, and the area also fall down to\n        // fill the gap left by the null point. #2069\n        addDummyPoints = function (i, otherI, side) {\n            const point = points[i], stackedValues = stacking &&\n                stacks[point.x].points[seriesIndex], nullVal = point[side + 'Null'] || 0, cliffVal = point[side + 'Cliff'] || 0;\n            let top, bottom, isNull = true;\n            if (cliffVal || nullVal) {\n                top = (nullVal ?\n                    stackedValues[0] :\n                    stackedValues[1]) + cliffVal;\n                bottom = stackedValues[0] + cliffVal;\n                isNull = !!nullVal;\n            }\n            else if (!stacking &&\n                points[otherI] &&\n                points[otherI].isNull) {\n                top = bottom = threshold;\n            }\n            // Add to the top and bottom line of the area\n            if (typeof top !== 'undefined') {\n                graphPoints.push({\n                    plotX: plotX,\n                    plotY: top === null ?\n                        translatedThreshold :\n                        yAxis.getThreshold(top),\n                    isNull: isNull,\n                    isCliff: true\n                });\n                bottomPoints.push({\n                    plotX: plotX,\n                    plotY: bottom === null ?\n                        translatedThreshold :\n                        yAxis.getThreshold(bottom),\n                    doCurve: false // #1041, gaps in areaspline areas\n                });\n            }\n        };\n        let plotX, isNull, yBottom;\n        // Find what points to use\n        points = points || this.points;\n        // Fill in missing points\n        if (stacking) {\n            points = this.getStackPoints(points);\n        }\n        for (let i = 0, iEnd = points.length; i < iEnd; ++i) {\n            // Reset after series.update of stacking property (#12033)\n            if (!stacking) {\n                points[i].leftCliff = points[i].rightCliff =\n                    points[i].leftNull = points[i].rightNull = void 0;\n            }\n            isNull = points[i].isNull;\n            plotX = pick(points[i].rectPlotX, points[i].plotX);\n            yBottom = stacking ?\n                pick(points[i].yBottom, translatedThreshold) :\n                translatedThreshold;\n            if (!isNull || connectNulls) {\n                if (!connectNulls) {\n                    addDummyPoints(i, i - 1, 'left');\n                }\n                // Skip null point when stacking is false and connectNulls\n                // true\n                if (!(isNull && !stacking && connectNulls)) {\n                    graphPoints.push(points[i]);\n                    bottomPoints.push({\n                        x: i,\n                        plotX: plotX,\n                        plotY: yBottom\n                    });\n                }\n                if (!connectNulls) {\n                    addDummyPoints(i, i + 1, 'right');\n                }\n            }\n        }\n        const topPath = getGraphPath.call(this, graphPoints, true, true);\n        bottomPoints.reversed = true;\n        const bottomPath = getGraphPath.call(this, bottomPoints, true, true);\n        const firstBottomPoint = bottomPath[0];\n        if (firstBottomPoint && firstBottomPoint[0] === 'M') {\n            bottomPath[0] = ['L', firstBottomPoint[1], firstBottomPoint[2]];\n        }\n        const areaPath = topPath.concat(bottomPath);\n        if (areaPath.length) {\n            areaPath.push(['Z']);\n        }\n        // TODO: don't set leftCliff and rightCliff when connectNulls?\n        const graphPath = getGraphPath\n            .call(this, graphPoints, false, connectNulls);\n        areaPath.xMap = topPath.xMap;\n        this.areaPath = areaPath;\n        return graphPath;\n    }\n    /**\n     * Return an array of stacked points, where null and missing points are\n     * replaced by dummy points in order for gaps to be drawn correctly in\n     * stacks.\n     * @private\n     */\n    getStackPoints(points) {\n        const series = this, segment = [], keys = [], xAxis = this.xAxis, yAxis = this.yAxis, stack = yAxis.stacking.stacks[this.stackKey], pointMap = {}, yAxisSeries = yAxis.series, seriesLength = yAxisSeries.length, upOrDown = yAxis.options.reversedStacks ? 1 : -1, seriesIndex = yAxisSeries.indexOf(series);\n        points = points || this.points;\n        if (this.options.stacking) {\n            for (let i = 0; i < points.length; i++) {\n                // Reset after point update (#7326)\n                points[i].leftNull = points[i].rightNull = void 0;\n                // Create a map where we can quickly look up the points by\n                // their X values.\n                pointMap[points[i].x] = points[i];\n            }\n            // Sort the keys (#1651)\n            objectEach(stack, function (stackX, x) {\n                // nulled after switching between\n                // grouping and not (#1651, #2336)\n                if (stackX.total !== null) {\n                    keys.push(x);\n                }\n            });\n            keys.sort(function (a, b) {\n                return a - b;\n            });\n            const visibleSeries = yAxisSeries.map((s) => s.visible);\n            keys.forEach(function (x, idx) {\n                let y = 0, stackPoint, stackedValues;\n                if (pointMap[x] && !pointMap[x].isNull) {\n                    segment.push(pointMap[x]);\n                    // Find left and right cliff. -1 goes left, 1 goes\n                    // right.\n                    [-1, 1].forEach(function (direction) {\n                        const nullName = direction === 1 ?\n                            'rightNull' :\n                            'leftNull', cliffName = direction === 1 ?\n                            'rightCliff' :\n                            'leftCliff', otherStack = stack[keys[idx + direction]];\n                        let cliff = 0;\n                        // If there is a stack next to this one,\n                        // to the left or to the right...\n                        if (otherStack) {\n                            let i = seriesIndex;\n                            // Can go either up or down,\n                            // depending on reversedStacks\n                            while (i >= 0 && i < seriesLength) {\n                                const si = yAxisSeries[i].index;\n                                stackPoint = otherStack.points[si];\n                                if (!stackPoint) {\n                                    // If the next point in this series is\n                                    // missing, mark the point with\n                                    // point.leftNull or point.rightNull = true.\n                                    if (si === series.index) {\n                                        pointMap[x][nullName] = true;\n                                        // If there are missing points in the next\n                                        // stack in any of the series below this\n                                        // one, we need to substract the missing\n                                        // values and add a hiatus to the left or\n                                        // right.\n                                    }\n                                    else if (visibleSeries[i]) {\n                                        stackedValues = stack[x].points[si];\n                                        if (stackedValues) {\n                                            cliff -= (stackedValues[1] -\n                                                stackedValues[0]);\n                                        }\n                                    }\n                                }\n                                // When reversedStacks is true, loop up,\n                                // else loop down\n                                i += upOrDown;\n                            }\n                        }\n                        pointMap[x][cliffName] = cliff;\n                    });\n                    // There is no point for this X value in this series, so we\n                    // insert a dummy point in order for the areas to be drawn\n                    // correctly.\n                }\n                else {\n                    // Loop down the stack to find the series below this\n                    // one that has a value (#1991)\n                    let i = seriesIndex;\n                    while (i >= 0 && i < seriesLength) {\n                        const si = yAxisSeries[i].index;\n                        stackPoint = stack[x].points[si];\n                        if (stackPoint) {\n                            y = stackPoint[1];\n                            break;\n                        }\n                        // When reversedStacks is true, loop up, else loop\n                        // down\n                        i += upOrDown;\n                    }\n                    y = pick(y, 0);\n                    y = yAxis.translate(// #6272\n                    y, 0, 1, 0, 1);\n                    segment.push({\n                        isNull: true,\n                        plotX: xAxis.translate(// #6272\n                        x, 0, 0, 0, 1),\n                        x: x,\n                        plotY: y,\n                        yBottom: y\n                    });\n                }\n            });\n        }\n        return segment;\n    }\n}\n/**\n * The area series type.\n *\n * @sample {highcharts} highcharts/demo/area-basic/\n *         Area chart\n * @sample {highstock} stock/demo/area/\n *         Area chart\n *\n * @extends      plotOptions.line\n * @excluding    useOhlcData\n * @product      highcharts highstock\n * @optionparent plotOptions.area\n */\nAreaSeries.defaultOptions = merge(LineSeries.defaultOptions, {\n    /**\n     * @see [fillColor](#plotOptions.area.fillColor)\n     * @see [fillOpacity](#plotOptions.area.fillOpacity)\n     *\n     * @apioption plotOptions.area.color\n     */\n    /**\n     * Fill color or gradient for the area. When `null`, the series' `color`\n     * is used with the series' `fillOpacity`.\n     *\n     * In styled mode, the fill color can be set with the `.highcharts-area`\n     * class name.\n     *\n     * @see [color](#plotOptions.area.color)\n     * @see [fillOpacity](#plotOptions.area.fillOpacity)\n     *\n     * @sample {highcharts} highcharts/plotoptions/area-fillcolor-default/\n     *         Null by default\n     * @sample {highcharts} highcharts/plotoptions/area-fillcolor-gradient/\n     *         Gradient\n     *\n     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @product   highcharts highstock\n     * @apioption plotOptions.area.fillColor\n     */\n    /**\n     * Fill opacity for the area. When you set an explicit `fillColor`,\n     * the `fillOpacity` is not applied. Instead, you should define the\n     * opacity in the `fillColor` with an rgba color definition. The\n     * `fillOpacity` setting, also the default setting, overrides the alpha\n     * component of the `color` setting.\n     *\n     * In styled mode, the fill opacity can be set with the\n     * `.highcharts-area` class name.\n     *\n     * @see [color](#plotOptions.area.color)\n     * @see [fillColor](#plotOptions.area.fillColor)\n     *\n     * @sample {highcharts} highcharts/plotoptions/area-fillopacity/\n     *         Automatic fill color and fill opacity of 0.1\n     *\n     * @type      {number}\n     * @default   {highcharts} 0.75\n     * @default   {highstock} 0.75\n     * @product   highcharts highstock\n     * @apioption plotOptions.area.fillOpacity\n     */\n    /**\n     * A separate color for the graph line. By default the line takes the\n     * `color` of the series, but the lineColor setting allows setting a\n     * separate color for the line without altering the `fillColor`.\n     *\n     * In styled mode, the line stroke can be set with the\n     * `.highcharts-graph` class name.\n     *\n     * @sample {highcharts} highcharts/plotoptions/area-linecolor/\n     *         Dark gray line\n     *\n     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @product   highcharts highstock\n     * @apioption plotOptions.area.lineColor\n     */\n    /**\n     * A separate color for the negative part of the area.\n     *\n     * In styled mode, a negative color is set with the\n     * `.highcharts-negative` class name.\n     *\n     * @see [negativeColor](#plotOptions.area.negativeColor)\n     *\n     * @sample {highcharts} highcharts/css/series-negative-color/\n     *         Negative color in styled mode\n     *\n     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @since     3.0\n     * @product   highcharts\n     * @apioption plotOptions.area.negativeFillColor\n     */\n    /**\n     * Whether the whole area or just the line should respond to mouseover\n     * tooltips and other mouse or touch events.\n     *\n     * @sample {highcharts|highstock} highcharts/plotoptions/area-trackbyarea/\n     *         Display the tooltip when the area is hovered\n     *\n     * @type      {boolean}\n     * @default   false\n     * @since     1.1.6\n     * @product   highcharts highstock\n     * @apioption plotOptions.area.trackByArea\n     */\n    /**\n     * The Y axis value to serve as the base for the area, for\n     * distinguishing between values above and below a threshold. The area\n     * between the graph and the threshold is filled.\n     *\n     * * If a number is given, the Y axis will scale to the threshold.\n     * * If `null`, the scaling behaves like a line series with fill between\n     *   the graph and the Y axis minimum.\n     * * If `Infinity` or `-Infinity`, the area between the graph and the\n     *   corresponding Y axis extreme is filled (since v6.1.0).\n     *\n     * @sample {highcharts} highcharts/plotoptions/area-threshold/\n     *         A threshold of 100\n     * @sample {highcharts} highcharts/plotoptions/area-threshold-infinity/\n     *         A threshold of Infinity\n     *\n     * @type    {number|null}\n     * @since   2.0\n     * @product highcharts highstock\n     */\n    threshold: 0,\n    legendSymbol: 'rectangle'\n});\nextend(AreaSeries.prototype, {\n    singleStacks: false\n});\nSeriesRegistry.registerSeriesType('area', AreaSeries);\n/* *\n *\n *  Default Export\n *\n * */\nexport default AreaSeries;\n/* *\n *\n *  API Options\n *\n * */\n/**\n * A `area` series. If the [type](#series.area.type) option is not\n * specified, it is inherited from [chart.type](#chart.type).\n *\n * @extends   series,plotOptions.area\n * @excluding dataParser, dataURL, useOhlcData\n * @product   highcharts highstock\n * @apioption series.area\n */\n/**\n * @see [fillColor](#series.area.fillColor)\n * @see [fillOpacity](#series.area.fillOpacity)\n *\n * @apioption series.area.color\n */\n/**\n * An array of data points for the series. For the `area` series type,\n * points can be given in the following ways:\n *\n * 1. An array of numerical values. In this case, the numerical values will be\n *    interpreted as `y` options. The `x` values will be automatically\n *    calculated, either starting at 0 and incremented by 1, or from\n *    `pointStart` * and `pointInterval` given in the series options. If the\n *    axis has categories, these will be used. Example:\n *    ```js\n *    data: [0, 5, 3, 5]\n *    ```\n *\n * 2. An array of arrays with 2 values. In this case, the values correspond to\n *    `x,y`. If the first value is a string, it is applied as the name of the\n *    point, and the `x` value is inferred.\n *    ```js\n *    data: [\n *        [0, 9],\n *        [1, 7],\n *        [2, 6]\n *    ]\n *    ```\n *\n * 3. An array of objects with named values. The following snippet shows only a\n *    few settings, see the complete options set below. If the total number of\n *    data points exceeds the series'\n *    [turboThreshold](#series.area.turboThreshold), this option is not\n *    available.\n *    ```js\n *    data: [{\n *        x: 1,\n *        y: 9,\n *        name: \"Point2\",\n *        color: \"#00FF00\"\n *    }, {\n *        x: 1,\n *        y: 6,\n *        name: \"Point1\",\n *        color: \"#FF00FF\"\n *    }]\n *    ```\n *\n * @sample {highcharts} highcharts/chart/reflow-true/\n *         Numerical values\n * @sample {highcharts} highcharts/series/data-array-of-arrays/\n *         Arrays of numeric x and y\n * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n *         Arrays of datetime x and y\n * @sample {highcharts} highcharts/series/data-array-of-name-value/\n *         Arrays of point.name and y\n * @sample {highcharts} highcharts/series/data-array-of-objects/\n *         Config objects\n *\n * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n * @extends   series.line.data\n * @product   highcharts highstock\n * @apioption series.area.data\n */\n/**\n * @see [color](#series.area.color)\n * @see [fillOpacity](#series.area.fillOpacity)\n *\n * @apioption series.area.fillColor\n */\n/**\n * @see [color](#series.area.color)\n * @see [fillColor](#series.area.fillColor)\n *\n * @default   {highcharts} 0.75\n * @default   {highstock} 0.75\n * @apioption series.area.fillOpacity\n */\n''; // adds doclets above to transpilat\n"],"mappings":"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AzF,UAAU,CAACsH,cAAc,GAAGzH,KAAK,CAACH,UAAU,CAAC4H,cAAc,EAAE;EACzD;AACJ;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIlE,SAAS,EAAE,CAAC;EACZmE,YAAY,EAAE;AAClB,CAAC,CAAC;AACF3H,MAAM,CAACI,UAAU,CAAC2C,SAAS,EAAE;EACzB6E,YAAY,EAAE;AAClB,CAAC,CAAC;AACFjI,cAAc,CAACkI,kBAAkB,CAAC,MAAM,EAAEzH,UAAU,CAAC;AACrD;AACA;AACA;AACA;AACA;AACA,eAAeA,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}