{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport A from '../Animation/AnimationUtilities.js';\nconst {\n  animObject,\n  setAnimation\n} = A;\nimport F from '../Templating.js';\nconst {\n  format\n} = F;\nimport H from '../Globals.js';\nconst {\n  marginNames\n} = H;\nimport Point from '../Series/Point.js';\nimport R from '../Renderer/RendererUtilities.js';\nconst {\n  distribute\n} = R;\nimport U from '../Utilities.js';\nconst {\n  addEvent,\n  createElement,\n  css,\n  defined,\n  discardElement,\n  find,\n  fireEvent,\n  isNumber,\n  merge,\n  pick,\n  relativeLength,\n  stableSort,\n  syncTimeout\n} = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * The overview of the chart's series. The legend object is instanciated\n * internally in the chart constructor, and is available from the `chart.legend`\n * property. Each chart has only one legend.\n *\n * @class\n * @name Highcharts.Legend\n *\n * @param {Highcharts.Chart} chart\n * The chart instance.\n *\n * @param {Highcharts.LegendOptions} options\n * Legend options.\n */\nclass Legend {\n  /* *\n   *\n   *  Constructors\n   *\n   * */\n  constructor(chart, options) {\n    /* *\n     *\n     *  Properties\n     *\n     * */\n    this.allItems = [];\n    this.box = void 0;\n    this.contentGroup = void 0;\n    this.display = false;\n    this.group = void 0;\n    this.initialItemY = 0;\n    this.itemHeight = 0;\n    this.itemMarginBottom = 0;\n    this.itemMarginTop = 0;\n    this.itemX = 0;\n    this.itemY = 0;\n    this.lastItemY = 0;\n    this.lastLineHeight = 0;\n    this.legendHeight = 0;\n    this.legendWidth = 0;\n    this.maxItemWidth = 0;\n    this.maxLegendWidth = 0;\n    this.offsetWidth = 0;\n    this.options = void 0;\n    this.padding = 0;\n    this.pages = [];\n    this.proximate = false;\n    this.scrollGroup = void 0;\n    this.symbolHeight = 0;\n    this.symbolWidth = 0;\n    this.titleHeight = 0;\n    this.totalItemWidth = 0;\n    this.widthOption = 0;\n    this.chart = chart;\n    this.init(chart, options);\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * Initialize the legend.\n   *\n   * @private\n   * @function Highcharts.Legend#init\n   *\n   * @param {Highcharts.Chart} chart\n   * The chart instance.\n   *\n   * @param {Highcharts.LegendOptions} options\n   * Legend options.\n   */\n  init(chart, options) {\n    /**\n     * Chart of this legend.\n     *\n     * @readonly\n     * @name Highcharts.Legend#chart\n     * @type {Highcharts.Chart}\n     */\n    this.chart = chart;\n    this.setOptions(options);\n    if (options.enabled) {\n      // Render it\n      this.render();\n      // Move checkboxes\n      addEvent(this.chart, 'endResize', function () {\n        this.legend.positionCheckboxes();\n      });\n    }\n    // On Legend.init and Legend.update, make sure that proximate layout\n    // events are either added or removed (#18362).\n    addEvent(this.chart, 'render', () => {\n      if (this.options.enabled && this.proximate) {\n        this.proximatePositions();\n        this.positionItems();\n      }\n    });\n  }\n  /**\n   * @private\n   * @function Highcharts.Legend#setOptions\n   * @param {Highcharts.LegendOptions} options\n   */\n  setOptions(options) {\n    const padding = pick(options.padding, 8);\n    /**\n     * Legend options.\n     *\n     * @readonly\n     * @name Highcharts.Legend#options\n     * @type {Highcharts.LegendOptions}\n     */\n    this.options = options;\n    if (!this.chart.styledMode) {\n      this.itemStyle = options.itemStyle;\n      this.itemHiddenStyle = merge(this.itemStyle, options.itemHiddenStyle);\n    }\n    this.itemMarginTop = options.itemMarginTop;\n    this.itemMarginBottom = options.itemMarginBottom;\n    this.padding = padding;\n    this.initialItemY = padding - 5; // 5 is pixels above the text\n    this.symbolWidth = pick(options.symbolWidth, 16);\n    this.pages = [];\n    this.proximate = options.layout === 'proximate' && !this.chart.inverted;\n    // #12705: baseline has to be reset on every update\n    this.baseline = void 0;\n  }\n  /**\n   * Update the legend with new options. Equivalent to running `chart.update`\n   * with a legend configuration option.\n   *\n   * @sample highcharts/legend/legend-update/\n   *         Legend update\n   *\n   * @function Highcharts.Legend#update\n   *\n   * @param {Highcharts.LegendOptions} options\n   * Legend options.\n   *\n   * @param {boolean} [redraw=true]\n   * Whether to redraw the chart after the axis is altered. If doing more\n   * operations on the chart, it is a good idea to set redraw to false and\n   * call {@link Chart#redraw} after. Whether to redraw the chart.\n   *\n   * @emits Highcharts.Legends#event:afterUpdate\n   */\n  update(options, redraw) {\n    const chart = this.chart;\n    this.setOptions(merge(true, this.options, options));\n    this.destroy();\n    chart.isDirtyLegend = chart.isDirtyBox = true;\n    if (pick(redraw, true)) {\n      chart.redraw();\n    }\n    fireEvent(this, 'afterUpdate', {\n      redraw\n    });\n  }\n  /**\n   * Set the colors for the legend item.\n   *\n   * @private\n   * @function Highcharts.Legend#colorizeItem\n   * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item\n   *        A Series or Point instance\n   * @param {boolean} [visible=false]\n   *        Dimmed or colored\n   *\n   * @todo\n   * Make events official: Fires the event `afterColorizeItem`.\n   */\n  colorizeItem(item, visible) {\n    const {\n      group,\n      label,\n      line,\n      symbol\n    } = item.legendItem || {};\n    if (group) {\n      group[visible ? 'removeClass' : 'addClass']('highcharts-legend-item-hidden');\n    }\n    if (!this.chart.styledMode) {\n      const {\n          itemHiddenStyle\n        } = this,\n        hiddenColor = itemHiddenStyle.color,\n        symbolColor = visible ? item.color || hiddenColor : hiddenColor,\n        markerOptions = item.options && item.options.marker;\n      let symbolAttr = {\n        fill: symbolColor\n      };\n      label?.css(merge(visible ? this.itemStyle : itemHiddenStyle));\n      line?.attr({\n        stroke: symbolColor\n      });\n      if (symbol) {\n        // Apply marker options\n        if (markerOptions && symbol.isMarker) {\n          // #585\n          symbolAttr = item.pointAttribs();\n          if (!visible) {\n            // #6769\n            symbolAttr.stroke = symbolAttr.fill = hiddenColor;\n          }\n        }\n        symbol.attr(symbolAttr);\n      }\n    }\n    fireEvent(this, 'afterColorizeItem', {\n      item,\n      visible\n    });\n  }\n  /**\n   * @private\n   * @function Highcharts.Legend#positionItems\n   */\n  positionItems() {\n    // Now that the legend width and height are established, put the items\n    // in the final position\n    this.allItems.forEach(this.positionItem, this);\n    if (!this.chart.isResizing) {\n      this.positionCheckboxes();\n    }\n  }\n  /**\n   * Position the legend item.\n   *\n   * @private\n   * @function Highcharts.Legend#positionItem\n   * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item\n   * The item to position\n   */\n  positionItem(item) {\n    const legend = this,\n      {\n        group,\n        x = 0,\n        y = 0\n      } = item.legendItem || {},\n      options = legend.options,\n      symbolPadding = options.symbolPadding,\n      ltr = !options.rtl,\n      checkbox = item.checkbox;\n    if (group && group.element) {\n      const attribs = {\n        translateX: ltr ? x : legend.legendWidth - x - 2 * symbolPadding - 4,\n        translateY: y\n      };\n      const complete = () => {\n        fireEvent(this, 'afterPositionItem', {\n          item\n        });\n      };\n      group[defined(group.translateY) ? 'animate' : 'attr'](attribs, void 0, complete);\n    }\n    if (checkbox) {\n      checkbox.x = x;\n      checkbox.y = y;\n    }\n  }\n  /**\n   * Destroy a single legend item, used internally on removing series items.\n   *\n   * @private\n   * @function Highcharts.Legend#destroyItem\n   * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item\n   * The item to remove\n   */\n  destroyItem(item) {\n    const checkbox = item.checkbox,\n      legendItem = item.legendItem || {};\n    // destroy SVG elements\n    for (const key of ['group', 'label', 'line', 'symbol']) {\n      if (legendItem[key]) {\n        legendItem[key] = legendItem[key].destroy();\n      }\n    }\n    if (checkbox) {\n      discardElement(checkbox);\n    }\n    item.legendItem = void 0;\n  }\n  /**\n   * Destroy the legend. Used internally. To reflow objects, `chart.redraw`\n   * must be called after destruction.\n   *\n   * @private\n   * @function Highcharts.Legend#destroy\n   */\n  destroy() {\n    const legend = this;\n    // Destroy items\n    for (const item of this.getAllItems()) {\n      this.destroyItem(item);\n    }\n    // Destroy legend elements\n    for (const key of ['clipRect', 'up', 'down', 'pager', 'nav', 'box', 'title', 'group']) {\n      if (legend[key]) {\n        legend[key] = legend[key].destroy();\n      }\n    }\n    this.display = null; // Reset in .render on update.\n  }\n  /**\n   * Position the checkboxes after the width is determined.\n   *\n   * @private\n   * @function Highcharts.Legend#positionCheckboxes\n   */\n  positionCheckboxes() {\n    const alignAttr = this.group && this.group.alignAttr,\n      clipHeight = this.clipHeight || this.legendHeight,\n      titleHeight = this.titleHeight;\n    let translateY;\n    if (alignAttr) {\n      translateY = alignAttr.translateY;\n      this.allItems.forEach(function (item) {\n        const checkbox = item.checkbox;\n        let top;\n        if (checkbox) {\n          top = translateY + titleHeight + checkbox.y + (this.scrollOffset || 0) + 3;\n          css(checkbox, {\n            left: alignAttr.translateX + item.checkboxOffset + checkbox.x - 20 + 'px',\n            top: top + 'px',\n            display: this.proximate || top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : 'none'\n          });\n        }\n      }, this);\n    }\n  }\n  /**\n   * Render the legend title on top of the legend.\n   *\n   * @private\n   * @function Highcharts.Legend#renderTitle\n   */\n  renderTitle() {\n    const options = this.options,\n      padding = this.padding,\n      titleOptions = options.title;\n    let bBox,\n      titleHeight = 0;\n    if (titleOptions.text) {\n      if (!this.title) {\n        /**\n         * SVG element of the legend title.\n         *\n         * @readonly\n         * @name Highcharts.Legend#title\n         * @type {Highcharts.SVGElement}\n         */\n        this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, void 0, void 0, void 0, options.useHTML, void 0, 'legend-title').attr({\n          zIndex: 1\n        });\n        if (!this.chart.styledMode) {\n          this.title.css(titleOptions.style);\n        }\n        this.title.add(this.group);\n      }\n      // Set the max title width (#7253)\n      if (!titleOptions.width) {\n        this.title.css({\n          width: this.maxLegendWidth + 'px'\n        });\n      }\n      bBox = this.title.getBBox();\n      titleHeight = bBox.height;\n      this.offsetWidth = bBox.width; // #1717\n      this.contentGroup.attr({\n        translateY: titleHeight\n      });\n    }\n    this.titleHeight = titleHeight;\n  }\n  /**\n   * Set the legend item text.\n   *\n   * @function Highcharts.Legend#setText\n   * @param {Highcharts.Point|Highcharts.Series} item\n   *        The item for which to update the text in the legend.\n   */\n  setText(item) {\n    const options = this.options;\n    item.legendItem.label.attr({\n      text: options.labelFormat ? format(options.labelFormat, item, this.chart) : options.labelFormatter.call(item)\n    });\n  }\n  /**\n   * Render a single specific legend item. Called internally from the `render`\n   * function.\n   *\n   * @private\n   * @function Highcharts.Legend#renderItem\n   * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item\n   * The item to render.\n   */\n  renderItem(item) {\n    const legend = this,\n      legendItem = item.legendItem = item.legendItem || {},\n      chart = legend.chart,\n      renderer = chart.renderer,\n      options = legend.options,\n      horizontal = options.layout === 'horizontal',\n      symbolWidth = legend.symbolWidth,\n      symbolPadding = options.symbolPadding || 0,\n      itemStyle = legend.itemStyle,\n      itemHiddenStyle = legend.itemHiddenStyle,\n      itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n      ltr = !options.rtl,\n      isSeries = !item.series,\n      series = !isSeries && item.series.drawLegendSymbol ? item.series : item,\n      seriesOptions = series.options,\n      showCheckbox = !!legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,\n      useHTML = options.useHTML,\n      itemClassName = item.options.className;\n    let label = legendItem.label,\n      // full width minus text width\n      itemExtraWidth = symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);\n    if (!label) {\n      // generate it once, later move it\n      // Generate the group box, a group to hold the symbol and text. Text\n      // is to be appended in Legend class.\n      legendItem.group = renderer.g('legend-item').addClass('highcharts-' + series.type + '-series ' + 'highcharts-color-' + item.colorIndex + (itemClassName ? ' ' + itemClassName : '') + (isSeries ? ' highcharts-series-' + item.index : '')).attr({\n        zIndex: 1\n      }).add(legend.scrollGroup);\n      // Generate the list item text and add it to the group\n      legendItem.label = label = renderer.text('', ltr ? symbolWidth + symbolPadding : -symbolPadding, legend.baseline || 0, useHTML);\n      if (!chart.styledMode) {\n        // merge to prevent modifying original (#1021)\n        label.css(merge(item.visible ? itemStyle : itemHiddenStyle));\n      }\n      label.attr({\n        align: ltr ? 'left' : 'right',\n        zIndex: 2\n      }).add(legendItem.group);\n      // Get the baseline for the first item - the font size is equal for\n      // all\n      if (!legend.baseline) {\n        legend.fontMetrics = renderer.fontMetrics(label);\n        legend.baseline = legend.fontMetrics.f + 3 + legend.itemMarginTop;\n        label.attr('y', legend.baseline);\n        legend.symbolHeight = pick(options.symbolHeight, legend.fontMetrics.f);\n        if (options.squareSymbol) {\n          legend.symbolWidth = pick(options.symbolWidth, Math.max(legend.symbolHeight, 16));\n          itemExtraWidth = legend.symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);\n          if (ltr) {\n            label.attr('x', legend.symbolWidth + symbolPadding);\n          }\n        }\n      }\n      // Draw the legend symbol inside the group box\n      series.drawLegendSymbol(legend, item);\n      if (legend.setItemEvents) {\n        legend.setItemEvents(item, label, useHTML);\n      }\n    }\n    // Add the HTML checkbox on top\n    if (showCheckbox && !item.checkbox && legend.createCheckboxForItem) {\n      legend.createCheckboxForItem(item);\n    }\n    // Colorize the items\n    legend.colorizeItem(item, item.visible);\n    // Take care of max width and text overflow (#6659)\n    if (chart.styledMode || !itemStyle.width) {\n      label.css({\n        width: (options.itemWidth || legend.widthOption || chart.spacingBox.width) - itemExtraWidth + 'px'\n      });\n    }\n    // Always update the text\n    legend.setText(item);\n    // calculate the positions for the next line\n    const bBox = label.getBBox();\n    const fontMetricsH = legend.fontMetrics && legend.fontMetrics.h || 0;\n    item.itemWidth = item.checkboxOffset = options.itemWidth || legendItem.labelWidth || bBox.width + itemExtraWidth;\n    legend.maxItemWidth = Math.max(legend.maxItemWidth, item.itemWidth);\n    legend.totalItemWidth += item.itemWidth;\n    legend.itemHeight = item.itemHeight = Math.round(legendItem.labelHeight || (\n    // use bBox for multiline (#16398)\n    bBox.height > fontMetricsH * 1.5 ? bBox.height : fontMetricsH));\n  }\n  /**\n   * Get the position of the item in the layout. We now know the\n   * maxItemWidth from the previous loop.\n   *\n   * @private\n   * @function Highcharts.Legend#layoutItem\n   * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item\n   */\n  layoutItem(item) {\n    const options = this.options,\n      padding = this.padding,\n      horizontal = options.layout === 'horizontal',\n      itemHeight = item.itemHeight,\n      itemMarginBottom = this.itemMarginBottom,\n      itemMarginTop = this.itemMarginTop,\n      itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n      maxLegendWidth = this.maxLegendWidth,\n      itemWidth = options.alignColumns && this.totalItemWidth > maxLegendWidth ? this.maxItemWidth : item.itemWidth,\n      legendItem = item.legendItem || {};\n    // If the item exceeds the width, start a new line\n    if (horizontal && this.itemX - padding + itemWidth > maxLegendWidth) {\n      this.itemX = padding;\n      if (this.lastLineHeight) {\n        // Not for the first line (#10167)\n        this.itemY += itemMarginTop + this.lastLineHeight + itemMarginBottom;\n      }\n      this.lastLineHeight = 0; // reset for next line (#915, #3976)\n    }\n    // Set the edge positions\n    this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;\n    this.lastLineHeight = Math.max(\n    // #915\n    itemHeight, this.lastLineHeight);\n    // cache the position of the newly generated or reordered items\n    legendItem.x = this.itemX;\n    legendItem.y = this.itemY;\n    // advance\n    if (horizontal) {\n      this.itemX += itemWidth;\n    } else {\n      this.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n      this.lastLineHeight = itemHeight;\n    }\n    // the width of the widest item\n    this.offsetWidth = this.widthOption || Math.max((horizontal ? this.itemX - padding - (item.checkbox ?\n    // decrease by itemDistance only when no checkbox #4853\n    0 : itemDistance) : itemWidth) + padding, this.offsetWidth);\n  }\n  /**\n   * Get all items, which is one item per series for most series and one\n   * item per point for pie series and its derivatives. Fires the event\n   * `afterGetAllItems`.\n   *\n   * @private\n   * @function Highcharts.Legend#getAllItems\n   * @return {Array<(Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series)>}\n   * The current items in the legend.\n   * @emits Highcharts.Legend#event:afterGetAllItems\n   */\n  getAllItems() {\n    let allItems = [];\n    this.chart.series.forEach(function (series) {\n      const seriesOptions = series && series.options;\n      // Handle showInLegend. If the series is linked to another series,\n      // defaults to false.\n      if (series && pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? void 0 : false, true)) {\n        // Use points or series for the legend item depending on\n        // legendType\n        allItems = allItems.concat((series.legendItem || {}).labels || (seriesOptions.legendType === 'point' ? series.data : series));\n      }\n    });\n    fireEvent(this, 'afterGetAllItems', {\n      allItems\n    });\n    return allItems;\n  }\n  /**\n   * Get a short, three letter string reflecting the alignment and layout.\n   *\n   * @private\n   * @function Highcharts.Legend#getAlignment\n   * @return {string}\n   * The alignment, empty string if floating\n   */\n  getAlignment() {\n    const options = this.options;\n    // Use the first letter of each alignment option in order to detect\n    // the side. (#4189 - use charAt(x) notation instead of [x] for IE7)\n    if (this.proximate) {\n      return options.align.charAt(0) + 'tv';\n    }\n    return options.floating ? '' : options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0);\n  }\n  /**\n   * Adjust the chart margins by reserving space for the legend on only one\n   * side of the chart. If the position is set to a corner, top or bottom is\n   * reserved for horizontal legends and left or right for vertical ones.\n   *\n   * @private\n   * @function Highcharts.Legend#adjustMargins\n   * @param {Array<number>} margin\n   * @param {Array<number>} spacing\n   */\n  adjustMargins(margin, spacing) {\n    const chart = this.chart,\n      options = this.options,\n      alignment = this.getAlignment();\n    if (alignment) {\n      [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (alignments, side) {\n        if (alignments.test(alignment) && !defined(margin[side])) {\n          // Now we have detected on which side of the chart we should\n          // reserve space for the legend\n          chart[marginNames[side]] = Math.max(chart[marginNames[side]], chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + [1, -1, -1, 1][side] * options[side % 2 ? 'x' : 'y'] + pick(options.margin, 12) + spacing[side] + (chart.titleOffset[side] || 0));\n        }\n      });\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.Legend#proximatePositions\n   */\n  proximatePositions() {\n    const chart = this.chart,\n      boxes = [],\n      alignLeft = this.options.align === 'left';\n    this.allItems.forEach(function (item) {\n      let lastPoint,\n        height,\n        useFirstPoint = alignLeft,\n        target,\n        top;\n      if (item.yAxis) {\n        if (item.xAxis.options.reversed) {\n          useFirstPoint = !useFirstPoint;\n        }\n        if (item.points) {\n          lastPoint = find(useFirstPoint ? item.points : item.points.slice(0).reverse(), function (item) {\n            return isNumber(item.plotY);\n          });\n        }\n        height = this.itemMarginTop + item.legendItem.label.getBBox().height + this.itemMarginBottom;\n        top = item.yAxis.top - chart.plotTop;\n        if (item.visible) {\n          target = lastPoint ? lastPoint.plotY : item.yAxis.height;\n          target += top - 0.3 * height;\n        } else {\n          target = top + item.yAxis.height;\n        }\n        boxes.push({\n          target: target,\n          size: height,\n          item\n        });\n      }\n    }, this);\n    let legendItem;\n    for (const box of distribute(boxes, chart.plotHeight)) {\n      legendItem = box.item.legendItem || {};\n      if (isNumber(box.pos)) {\n        legendItem.y = chart.plotTop - chart.spacing[0] + box.pos;\n      }\n    }\n  }\n  /**\n   * Render the legend. This method can be called both before and after\n   * `chart.render`. If called after, it will only rearrange items instead\n   * of creating new ones. Called internally on initial render and after\n   * redraws.\n   *\n   * @private\n   * @function Highcharts.Legend#render\n   */\n  render() {\n    const legend = this,\n      chart = legend.chart,\n      renderer = chart.renderer,\n      options = legend.options,\n      padding = legend.padding,\n      // add each series or point\n      allItems = legend.getAllItems();\n    let display,\n      legendWidth,\n      legendHeight,\n      legendGroup = legend.group,\n      allowedWidth,\n      box = legend.box;\n    legend.itemX = padding;\n    legend.itemY = legend.initialItemY;\n    legend.offsetWidth = 0;\n    legend.lastItemY = 0;\n    legend.widthOption = relativeLength(options.width, chart.spacingBox.width - padding);\n    // Compute how wide the legend is allowed to be\n    allowedWidth = chart.spacingBox.width - 2 * padding - options.x;\n    if (['rm', 'lm'].indexOf(legend.getAlignment().substring(0, 2)) > -1) {\n      allowedWidth /= 2;\n    }\n    legend.maxLegendWidth = legend.widthOption || allowedWidth;\n    if (!legendGroup) {\n      /**\n       * SVG group of the legend.\n       *\n       * @readonly\n       * @name Highcharts.Legend#group\n       * @type {Highcharts.SVGElement}\n       */\n      legend.group = legendGroup = renderer.g('legend').addClass(options.className || '').attr({\n        zIndex: 7\n      }).add();\n      legend.contentGroup = renderer.g().attr({\n        zIndex: 1\n      }) // above background\n      .add(legendGroup);\n      legend.scrollGroup = renderer.g().add(legend.contentGroup);\n    }\n    legend.renderTitle();\n    // sort by legendIndex\n    stableSort(allItems, (a, b) => (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0));\n    // reversed legend\n    if (options.reversed) {\n      allItems.reverse();\n    }\n    /**\n     * All items for the legend, which is an array of series for most series\n     * and an array of points for pie series and its derivatives.\n     *\n     * @readonly\n     * @name Highcharts.Legend#allItems\n     * @type {Array<(Highcharts.Point|Highcharts.Series)>}\n     */\n    legend.allItems = allItems;\n    legend.display = display = !!allItems.length;\n    // Render the items. First we run a loop to set the text and properties\n    // and read all the bounding boxes. The next loop computes the item\n    // positions based on the bounding boxes.\n    legend.lastLineHeight = 0;\n    legend.maxItemWidth = 0;\n    legend.totalItemWidth = 0;\n    legend.itemHeight = 0;\n    allItems.forEach(legend.renderItem, legend);\n    allItems.forEach(legend.layoutItem, legend);\n    // Get the box\n    legendWidth = (legend.widthOption || legend.offsetWidth) + padding;\n    legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;\n    legendHeight = legend.handleOverflow(legendHeight);\n    legendHeight += padding;\n    // Draw the border and/or background\n    if (!box) {\n      /**\n       * SVG element of the legend box.\n       *\n       * @readonly\n       * @name Highcharts.Legend#box\n       * @type {Highcharts.SVGElement}\n       */\n      legend.box = box = renderer.rect().addClass('highcharts-legend-box').attr({\n        r: options.borderRadius\n      }).add(legendGroup);\n    }\n    // Presentational\n    if (!chart.styledMode) {\n      box.attr({\n        stroke: options.borderColor,\n        'stroke-width': options.borderWidth || 0,\n        fill: options.backgroundColor || 'none'\n      }).shadow(options.shadow);\n    }\n    if (legendWidth > 0 && legendHeight > 0) {\n      box[box.placed ? 'animate' : 'attr'](box.crisp.call({}, {\n        x: 0,\n        y: 0,\n        width: legendWidth,\n        height: legendHeight\n      }, box.strokeWidth()));\n    }\n    // hide the border if no items\n    legendGroup[display ? 'show' : 'hide']();\n    // Open for responsiveness\n    if (chart.styledMode && legendGroup.getStyle('display') === 'none') {\n      legendWidth = legendHeight = 0;\n    }\n    legend.legendWidth = legendWidth;\n    legend.legendHeight = legendHeight;\n    if (display) {\n      legend.align();\n    }\n    if (!this.proximate) {\n      this.positionItems();\n    }\n    fireEvent(this, 'afterRender');\n  }\n  /**\n   * Align the legend to chart's box.\n   *\n   * @private\n   * @function Highcharts.align\n   * @param {Highcharts.BBoxObject} alignTo\n   */\n  align(alignTo = this.chart.spacingBox) {\n    const chart = this.chart,\n      options = this.options;\n    // If aligning to the top and the layout is horizontal, adjust for\n    // the title (#7428)\n    let y = alignTo.y;\n    if (/(lth|ct|rth)/.test(this.getAlignment()) && chart.titleOffset[0] > 0) {\n      y += chart.titleOffset[0];\n    } else if (/(lbh|cb|rbh)/.test(this.getAlignment()) && chart.titleOffset[2] > 0) {\n      y -= chart.titleOffset[2];\n    }\n    if (y !== alignTo.y) {\n      alignTo = merge(alignTo, {\n        y\n      });\n    }\n    if (!chart.hasRendered) {\n      // Avoid animation when adjusting alignment for responsiveness and\n      // colorAxis label layout\n      this.group.placed = false;\n    }\n    this.group.align(merge(options, {\n      width: this.legendWidth,\n      height: this.legendHeight,\n      verticalAlign: this.proximate ? 'top' : options.verticalAlign\n    }), true, alignTo);\n  }\n  /**\n   * Set up the overflow handling by adding navigation with up and down arrows\n   * below the legend.\n   *\n   * @private\n   * @function Highcharts.Legend#handleOverflow\n   */\n  handleOverflow(legendHeight) {\n    const legend = this,\n      chart = this.chart,\n      renderer = chart.renderer,\n      options = this.options,\n      optionsY = options.y,\n      alignTop = options.verticalAlign === 'top',\n      padding = this.padding,\n      maxHeight = options.maxHeight,\n      navOptions = options.navigation,\n      animation = pick(navOptions.animation, true),\n      arrowSize = navOptions.arrowSize || 12,\n      pages = this.pages,\n      allItems = this.allItems,\n      clipToHeight = function (height) {\n        if (typeof height === 'number') {\n          clipRect.attr({\n            height: height\n          });\n        } else if (clipRect) {\n          // Reset (#5912)\n          legend.clipRect = clipRect.destroy();\n          legend.contentGroup.clip();\n        }\n        // useHTML\n        if (legend.contentGroup.div) {\n          legend.contentGroup.div.style.clip = height ? 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)' : 'auto';\n        }\n      },\n      addTracker = function (key) {\n        legend[key] = renderer.circle(0, 0, arrowSize * 1.3).translate(arrowSize / 2, arrowSize / 2).add(nav);\n        if (!chart.styledMode) {\n          legend[key].attr('fill', 'rgba(0,0,0,0.0001)');\n        }\n        return legend[key];\n      };\n    let clipHeight,\n      lastY,\n      legendItem,\n      spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - padding,\n      nav = this.nav,\n      clipRect = this.clipRect;\n    // Adjust the height\n    if (options.layout === 'horizontal' && options.verticalAlign !== 'middle' && !options.floating) {\n      spaceHeight /= 2;\n    }\n    if (maxHeight) {\n      spaceHeight = Math.min(spaceHeight, maxHeight);\n    }\n    // Reset the legend height and adjust the clipping rectangle\n    pages.length = 0;\n    if (legendHeight && spaceHeight > 0 && legendHeight > spaceHeight && navOptions.enabled !== false) {\n      this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);\n      this.currentPage = pick(this.currentPage, 1);\n      this.fullHeight = legendHeight;\n      // Fill pages with Y positions so that the top of each a legend item\n      // defines the scroll top for each page (#2098)\n      allItems.forEach((item, i) => {\n        legendItem = item.legendItem || {};\n        const y = legendItem.y || 0,\n          h = Math.round(legendItem.label.getBBox().height);\n        let len = pages.length;\n        if (!len || y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1]) {\n          pages.push(lastY || y);\n          len++;\n        }\n        // Keep track of which page each item is on\n        legendItem.pageIx = len - 1;\n        if (lastY) {\n          (allItems[i - 1].legendItem || {}).pageIx = len - 1;\n        }\n        // add the last page if needed (#2617, #13683)\n        if (\n        // check the last item\n        i === allItems.length - 1 &&\n        // if adding next page is needed (#18768)\n        y + h - pages[len - 1] > clipHeight && y > pages[len - 1]) {\n          pages.push(y);\n          legendItem.pageIx = len;\n        }\n        if (y !== lastY) {\n          lastY = y;\n        }\n      });\n      // Only apply clipping if needed. Clipping causes blurred legend in\n      // PDF export (#1787)\n      if (!clipRect) {\n        clipRect = legend.clipRect = renderer.clipRect(0, padding - 2, 9999, 0);\n        legend.contentGroup.clip(clipRect);\n      }\n      clipToHeight(clipHeight);\n      // Add navigation elements\n      if (!nav) {\n        this.nav = nav = renderer.g().attr({\n          zIndex: 1\n        }).add(this.group);\n        this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize).add(nav);\n        addTracker('upTracker').on('click', function () {\n          legend.scroll(-1, animation);\n        });\n        this.pager = renderer.text('', 15, 10).addClass('highcharts-legend-navigation');\n        if (!chart.styledMode && navOptions.style) {\n          this.pager.css(navOptions.style);\n        }\n        this.pager.add(nav);\n        this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize).add(nav);\n        addTracker('downTracker').on('click', function () {\n          legend.scroll(1, animation);\n        });\n      }\n      // Set initial position\n      legend.scroll(0);\n      legendHeight = spaceHeight;\n      // Reset\n    } else if (nav) {\n      clipToHeight();\n      this.nav = nav.destroy(); // #6322\n      this.scrollGroup.attr({\n        translateY: 1\n      });\n      this.clipHeight = 0; // #1379\n    }\n\n    return legendHeight;\n  }\n  /**\n   * Scroll the legend by a number of pages.\n   *\n   * @private\n   * @function Highcharts.Legend#scroll\n   *\n   * @param {number} scrollBy\n   *        The number of pages to scroll.\n   *\n   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]\n   *        Whether and how to apply animation.\n   *\n   */\n  scroll(scrollBy, animation) {\n    const chart = this.chart,\n      pages = this.pages,\n      pageCount = pages.length,\n      clipHeight = this.clipHeight,\n      navOptions = this.options.navigation,\n      pager = this.pager,\n      padding = this.padding;\n    let currentPage = this.currentPage + scrollBy;\n    // When resizing while looking at the last page\n    if (currentPage > pageCount) {\n      currentPage = pageCount;\n    }\n    if (currentPage > 0) {\n      if (typeof animation !== 'undefined') {\n        setAnimation(animation, chart);\n      }\n      this.nav.attr({\n        translateX: padding,\n        translateY: clipHeight + this.padding + 7 + this.titleHeight,\n        visibility: 'inherit'\n      });\n      [this.up, this.upTracker].forEach(function (elem) {\n        elem.attr({\n          'class': currentPage === 1 ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n        });\n      });\n      pager.attr({\n        text: currentPage + '/' + pageCount\n      });\n      [this.down, this.downTracker].forEach(function (elem) {\n        elem.attr({\n          // adjust to text width\n          x: 18 + this.pager.getBBox().width,\n          'class': currentPage === pageCount ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n        });\n      }, this);\n      if (!chart.styledMode) {\n        this.up.attr({\n          fill: currentPage === 1 ? navOptions.inactiveColor : navOptions.activeColor\n        });\n        this.upTracker.css({\n          cursor: currentPage === 1 ? 'default' : 'pointer'\n        });\n        this.down.attr({\n          fill: currentPage === pageCount ? navOptions.inactiveColor : navOptions.activeColor\n        });\n        this.downTracker.css({\n          cursor: currentPage === pageCount ? 'default' : 'pointer'\n        });\n      }\n      this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;\n      this.scrollGroup.animate({\n        translateY: this.scrollOffset\n      });\n      this.currentPage = currentPage;\n      this.positionCheckboxes();\n      // Fire event after scroll animation is complete\n      const animOptions = animObject(pick(animation, chart.renderer.globalAnimation, true));\n      syncTimeout(() => {\n        fireEvent(this, 'afterScroll', {\n          currentPage\n        });\n      }, animOptions.duration);\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.Legend#setItemEvents\n   * @param {Highcharts.BubbleLegendItem|Point|Highcharts.Series} item\n   * @param {Highcharts.SVGElement} legendLabel\n   * @param {boolean} [useHTML=false]\n   * @emits Highcharts.Point#event:legendItemClick\n   * @emits Highcharts.Series#event:legendItemClick\n   */\n  setItemEvents(item, legendLabel, useHTML) {\n    const legend = this,\n      legendItem = item.legendItem || {},\n      boxWrapper = legend.chart.renderer.boxWrapper,\n      isPoint = item instanceof Point,\n      activeClass = 'highcharts-legend-' + (isPoint ? 'point' : 'series') + '-active',\n      styledMode = legend.chart.styledMode,\n      // When `useHTML`, the symbol is rendered in other group, so\n      // we need to apply events listeners to both places\n      legendElements = useHTML ? [legendLabel, legendItem.symbol] : [legendItem.group];\n    const setOtherItemsState = state => {\n      legend.allItems.forEach(otherItem => {\n        if (item !== otherItem) {\n          [otherItem].concat(otherItem.linkedSeries || []).forEach(otherItem => {\n            otherItem.setState(state, !isPoint);\n          });\n        }\n      });\n    };\n    // Set the events on the item group, or in case of useHTML, the item\n    // itself (#1249)\n    for (const element of legendElements) {\n      if (element) {\n        element.on('mouseover', function () {\n          if (item.visible) {\n            setOtherItemsState('inactive');\n          }\n          item.setState('hover');\n          // A CSS class to dim or hide other than the hovered\n          // series.\n          // Works only if hovered series is visible (#10071).\n          if (item.visible) {\n            boxWrapper.addClass(activeClass);\n          }\n          if (!styledMode) {\n            legendLabel.css(legend.options.itemHoverStyle);\n          }\n        }).on('mouseout', function () {\n          if (!legend.chart.styledMode) {\n            legendLabel.css(merge(item.visible ? legend.itemStyle : legend.itemHiddenStyle));\n          }\n          setOtherItemsState('');\n          // A CSS class to dim or hide other than the hovered\n          // series.\n          boxWrapper.removeClass(activeClass);\n          item.setState();\n        }).on('click', function (event) {\n          const strLegendItemClick = 'legendItemClick',\n            fnLegendItemClick = function () {\n              if (item.setVisible) {\n                item.setVisible();\n              }\n              // Reset inactive state\n              setOtherItemsState(item.visible ? 'inactive' : '');\n            };\n          // A CSS class to dim or hide other than the hovered\n          // series. Event handling in iOS causes the activeClass\n          // to be added prior to click in some cases (#7418).\n          boxWrapper.removeClass(activeClass);\n          // Pass over the click/touch event. #4.\n          event = {\n            browserEvent: event\n          };\n          // click the name or symbol\n          if (item.firePointEvent) {\n            // point\n            item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n          } else {\n            fireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n          }\n        });\n      }\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.Legend#createCheckboxForItem\n   * @param {Highcharts.BubbleLegendItem|Point|Highcharts.Series} item\n   * @emits Highcharts.Series#event:checkboxClick\n   */\n  createCheckboxForItem(item) {\n    const legend = this;\n    item.checkbox = createElement('input', {\n      type: 'checkbox',\n      className: 'highcharts-legend-checkbox',\n      checked: item.selected,\n      defaultChecked: item.selected // required by IE7\n    }, legend.options.itemCheckboxStyle, legend.chart.container);\n    addEvent(item.checkbox, 'click', function (event) {\n      const target = event.target;\n      fireEvent(item.series || item, 'checkboxClick', {\n        checked: target.checked,\n        item: item\n      }, function () {\n        item.select();\n      });\n    });\n  }\n}\n/* *\n *\n *  Class Namespace\n *\n * */\n(function (Legend) {\n  /* *\n   *\n   *  Declarations\n   *\n   * */\n  /* *\n   *\n   *  Constants\n   *\n   * */\n  const composedMembers = [];\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * @private\n   */\n  function compose(ChartClass) {\n    if (U.pushUnique(composedMembers, ChartClass)) {\n      addEvent(ChartClass, 'beforeMargins', function () {\n        /**\n         * The legend contains an interactive overview over chart items,\n         * usually individual series or points depending on the series\n         * type. The color axis and bubble legend are also rendered in\n         * the chart legend.\n         *\n         * @name Highcharts.Chart#legend\n         * @type {Highcharts.Legend}\n         */\n        this.legend = new Legend(this, this.options.legend);\n      });\n    }\n  }\n  Legend.compose = compose;\n})(Legend || (Legend = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default Legend;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * @interface Highcharts.LegendItemObject\n */ /**\n    * @name Highcharts.LegendItemObject#item\n    * @type {Highcharts.SVGElement|undefined}\n    */ /**\n       * @name Highcharts.LegendItemObject#line\n       * @type {Highcharts.SVGElement|undefined}\n       */ /**\n          * @name Highcharts.LegendItemObject#symbol\n          * @type {Highcharts.SVGElement|undefined}\n          */\n/**\n * Gets fired when the legend item belonging to a point is clicked. The default\n * action is to toggle the visibility of the point. This can be prevented by\n * returning `false` or calling `event.preventDefault()`.\n *\n * @callback Highcharts.PointLegendItemClickCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        The point on which the event occured.\n *\n * @param {Highcharts.PointLegendItemClickEventObject} event\n *        The event that occured.\n */\n/**\n * Information about the legend click event.\n *\n * @interface Highcharts.PointLegendItemClickEventObject\n */ /**\n    * Related browser event.\n    * @name Highcharts.PointLegendItemClickEventObject#browserEvent\n    * @type {Highcharts.PointerEvent}\n    */ /**\n       * Prevent the default action of toggle the visibility of the point.\n       * @name Highcharts.PointLegendItemClickEventObject#preventDefault\n       * @type {Function}\n       */ /**\n          * Related point.\n          * @name Highcharts.PointLegendItemClickEventObject#target\n          * @type {Highcharts.Point}\n          */ /**\n             * Event type.\n             * @name Highcharts.PointLegendItemClickEventObject#type\n             * @type {\"legendItemClick\"}\n             */\n/**\n * Series color as used by the legend and some series types.\n * @name Highcharts.Series#color\n * @type {Highcharts.ColorType|undefined}\n */ /**\n    * Legend data for the series.\n    * @name Highcharts.Series#legendItem\n    * @type {Highcharts.LegendItemObject|undefined}\n    * @since 10.3.0\n    */\n/**\n * Gets fired when the legend item belonging to a series is clicked. The default\n * action is to toggle the visibility of the series. This can be prevented by\n * returning `false` or calling `event.preventDefault()`.\n *\n * @callback Highcharts.SeriesLegendItemClickCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        The series where the event occured.\n *\n * @param {Highcharts.SeriesLegendItemClickEventObject} event\n *        The event that occured.\n */\n/**\n * Information about the legend click event.\n *\n * @interface Highcharts.SeriesLegendItemClickEventObject\n */ /**\n    * Related browser event.\n    * @name Highcharts.SeriesLegendItemClickEventObject#browserEvent\n    * @type {Highcharts.PointerEvent}\n    */ /**\n       * Prevent the default action of toggle the visibility of the series.\n       * @name Highcharts.SeriesLegendItemClickEventObject#preventDefault\n       * @type {Function}\n       */ /**\n          * Related series.\n          * @name Highcharts.SeriesLegendItemClickEventObject#target\n          * @type {Highcharts.Series}\n          */ /**\n             * Event type.\n             * @name Highcharts.SeriesLegendItemClickEventObject#type\n             * @type {\"legendItemClick\"}\n             */\n''; // keeps doclets above in JS file","map":{"version":3,"names":["A","animObject","setAnimation","F","format","H","marginNames","Point","R","distribute","U","addEvent","createElement","css","defined","discardElement","find","fireEvent","isNumber","merge","pick","relativeLength","stableSort","syncTimeout","Legend","constructor","chart","options","allItems","box","contentGroup","display","group","initialItemY","itemHeight","itemMarginBottom","itemMarginTop","itemX","itemY","lastItemY","lastLineHeight","legendHeight","legendWidth","maxItemWidth","maxLegendWidth","offsetWidth","padding","pages","proximate","scrollGroup","symbolHeight","symbolWidth","titleHeight","totalItemWidth","widthOption","init","setOptions","enabled","render","legend","positionCheckboxes","proximatePositions","positionItems","styledMode","itemStyle","itemHiddenStyle","layout","inverted","baseline","update","redraw","destroy","isDirtyLegend","isDirtyBox","colorizeItem","item","visible","label","line","symbol","legendItem","hiddenColor","color","symbolColor","markerOptions","marker","symbolAttr","fill","attr","stroke","isMarker","pointAttribs","forEach","positionItem","isResizing","x","y","symbolPadding","ltr","rtl","checkbox","element","attribs","translateX","translateY","complete","destroyItem","key","getAllItems","alignAttr","clipHeight","top","scrollOffset","left","checkboxOffset","renderTitle","titleOptions","title","bBox","text","renderer","useHTML","zIndex","style","add","width","getBBox","height","setText","labelFormat","labelFormatter","call","renderItem","horizontal","itemDistance","isSeries","series","drawLegendSymbol","seriesOptions","showCheckbox","createCheckboxForItem","itemClassName","className","itemExtraWidth","g","addClass","type","colorIndex","index","align","fontMetrics","f","squareSymbol","Math","max","setItemEvents","itemWidth","spacingBox","fontMetricsH","h","labelWidth","round","labelHeight","layoutItem","alignColumns","showInLegend","linkedTo","concat","labels","legendType","data","getAlignment","charAt","floating","verticalAlign","adjustMargins","margin","spacing","alignment","alignments","side","test","titleOffset","boxes","alignLeft","lastPoint","useFirstPoint","target","yAxis","xAxis","reversed","points","slice","reverse","plotY","plotTop","push","size","plotHeight","pos","legendGroup","allowedWidth","indexOf","substring","a","b","legendIndex","length","handleOverflow","rect","r","borderRadius","borderColor","borderWidth","backgroundColor","shadow","placed","crisp","strokeWidth","getStyle","alignTo","hasRendered","optionsY","alignTop","maxHeight","navOptions","navigation","animation","arrowSize","clipToHeight","clipRect","clip","div","addTracker","circle","translate","nav","lastY","spaceHeight","min","currentPage","fullHeight","i","len","pageIx","up","on","scroll","pager","down","scrollBy","pageCount","visibility","upTracker","elem","downTracker","inactiveColor","activeColor","cursor","animate","animOptions","globalAnimation","duration","legendLabel","boxWrapper","isPoint","activeClass","legendElements","setOtherItemsState","state","otherItem","linkedSeries","setState","itemHoverStyle","removeClass","event","strLegendItemClick","fnLegendItemClick","setVisible","browserEvent","firePointEvent","checked","selected","defaultChecked","itemCheckboxStyle","container","select","composedMembers","compose","ChartClass","pushUnique"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Legend/Legend.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport A from '../Animation/AnimationUtilities.js';\nconst { animObject, setAnimation } = A;\nimport F from '../Templating.js';\nconst { format } = F;\nimport H from '../Globals.js';\nconst { marginNames } = H;\nimport Point from '../Series/Point.js';\nimport R from '../Renderer/RendererUtilities.js';\nconst { distribute } = R;\nimport U from '../Utilities.js';\nconst { addEvent, createElement, css, defined, discardElement, find, fireEvent, isNumber, merge, pick, relativeLength, stableSort, syncTimeout } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * The overview of the chart's series. The legend object is instanciated\n * internally in the chart constructor, and is available from the `chart.legend`\n * property. Each chart has only one legend.\n *\n * @class\n * @name Highcharts.Legend\n *\n * @param {Highcharts.Chart} chart\n * The chart instance.\n *\n * @param {Highcharts.LegendOptions} options\n * Legend options.\n */\nclass Legend {\n    /* *\n     *\n     *  Constructors\n     *\n     * */\n    constructor(chart, options) {\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        this.allItems = [];\n        this.box = void 0;\n        this.contentGroup = void 0;\n        this.display = false;\n        this.group = void 0;\n        this.initialItemY = 0;\n        this.itemHeight = 0;\n        this.itemMarginBottom = 0;\n        this.itemMarginTop = 0;\n        this.itemX = 0;\n        this.itemY = 0;\n        this.lastItemY = 0;\n        this.lastLineHeight = 0;\n        this.legendHeight = 0;\n        this.legendWidth = 0;\n        this.maxItemWidth = 0;\n        this.maxLegendWidth = 0;\n        this.offsetWidth = 0;\n        this.options = void 0;\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = false;\n        this.scrollGroup = void 0;\n        this.symbolHeight = 0;\n        this.symbolWidth = 0;\n        this.titleHeight = 0;\n        this.totalItemWidth = 0;\n        this.widthOption = 0;\n        this.chart = chart;\n        this.init(chart, options);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Initialize the legend.\n     *\n     * @private\n     * @function Highcharts.Legend#init\n     *\n     * @param {Highcharts.Chart} chart\n     * The chart instance.\n     *\n     * @param {Highcharts.LegendOptions} options\n     * Legend options.\n     */\n    init(chart, options) {\n        /**\n         * Chart of this legend.\n         *\n         * @readonly\n         * @name Highcharts.Legend#chart\n         * @type {Highcharts.Chart}\n         */\n        this.chart = chart;\n        this.setOptions(options);\n        if (options.enabled) {\n            // Render it\n            this.render();\n            // Move checkboxes\n            addEvent(this.chart, 'endResize', function () {\n                this.legend.positionCheckboxes();\n            });\n        }\n        // On Legend.init and Legend.update, make sure that proximate layout\n        // events are either added or removed (#18362).\n        addEvent(this.chart, 'render', () => {\n            if (this.options.enabled && this.proximate) {\n                this.proximatePositions();\n                this.positionItems();\n            }\n        });\n    }\n    /**\n     * @private\n     * @function Highcharts.Legend#setOptions\n     * @param {Highcharts.LegendOptions} options\n     */\n    setOptions(options) {\n        const padding = pick(options.padding, 8);\n        /**\n         * Legend options.\n         *\n         * @readonly\n         * @name Highcharts.Legend#options\n         * @type {Highcharts.LegendOptions}\n         */\n        this.options = options;\n        if (!this.chart.styledMode) {\n            this.itemStyle = options.itemStyle;\n            this.itemHiddenStyle = merge(this.itemStyle, options.itemHiddenStyle);\n        }\n        this.itemMarginTop = options.itemMarginTop;\n        this.itemMarginBottom = options.itemMarginBottom;\n        this.padding = padding;\n        this.initialItemY = padding - 5; // 5 is pixels above the text\n        this.symbolWidth = pick(options.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = options.layout === 'proximate' && !this.chart.inverted;\n        // #12705: baseline has to be reset on every update\n        this.baseline = void 0;\n    }\n    /**\n     * Update the legend with new options. Equivalent to running `chart.update`\n     * with a legend configuration option.\n     *\n     * @sample highcharts/legend/legend-update/\n     *         Legend update\n     *\n     * @function Highcharts.Legend#update\n     *\n     * @param {Highcharts.LegendOptions} options\n     * Legend options.\n     *\n     * @param {boolean} [redraw=true]\n     * Whether to redraw the chart after the axis is altered. If doing more\n     * operations on the chart, it is a good idea to set redraw to false and\n     * call {@link Chart#redraw} after. Whether to redraw the chart.\n     *\n     * @emits Highcharts.Legends#event:afterUpdate\n     */\n    update(options, redraw) {\n        const chart = this.chart;\n        this.setOptions(merge(true, this.options, options));\n        this.destroy();\n        chart.isDirtyLegend = chart.isDirtyBox = true;\n        if (pick(redraw, true)) {\n            chart.redraw();\n        }\n        fireEvent(this, 'afterUpdate', { redraw });\n    }\n    /**\n     * Set the colors for the legend item.\n     *\n     * @private\n     * @function Highcharts.Legend#colorizeItem\n     * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item\n     *        A Series or Point instance\n     * @param {boolean} [visible=false]\n     *        Dimmed or colored\n     *\n     * @todo\n     * Make events official: Fires the event `afterColorizeItem`.\n     */\n    colorizeItem(item, visible) {\n        const { group, label, line, symbol } = item.legendItem || {};\n        if (group) {\n            group[visible ? 'removeClass' : 'addClass']('highcharts-legend-item-hidden');\n        }\n        if (!this.chart.styledMode) {\n            const { itemHiddenStyle } = this, hiddenColor = itemHiddenStyle.color, symbolColor = visible ?\n                (item.color || hiddenColor) :\n                hiddenColor, markerOptions = item.options && item.options.marker;\n            let symbolAttr = { fill: symbolColor };\n            label?.css(merge(visible ? this.itemStyle : itemHiddenStyle));\n            line?.attr({ stroke: symbolColor });\n            if (symbol) {\n                // Apply marker options\n                if (markerOptions && symbol.isMarker) { // #585\n                    symbolAttr = item.pointAttribs();\n                    if (!visible) {\n                        // #6769\n                        symbolAttr.stroke = symbolAttr.fill = hiddenColor;\n                    }\n                }\n                symbol.attr(symbolAttr);\n            }\n        }\n        fireEvent(this, 'afterColorizeItem', { item, visible });\n    }\n    /**\n     * @private\n     * @function Highcharts.Legend#positionItems\n     */\n    positionItems() {\n        // Now that the legend width and height are established, put the items\n        // in the final position\n        this.allItems.forEach(this.positionItem, this);\n        if (!this.chart.isResizing) {\n            this.positionCheckboxes();\n        }\n    }\n    /**\n     * Position the legend item.\n     *\n     * @private\n     * @function Highcharts.Legend#positionItem\n     * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item\n     * The item to position\n     */\n    positionItem(item) {\n        const legend = this, { group, x = 0, y = 0 } = item.legendItem || {}, options = legend.options, symbolPadding = options.symbolPadding, ltr = !options.rtl, checkbox = item.checkbox;\n        if (group && group.element) {\n            const attribs = {\n                translateX: ltr ?\n                    x :\n                    legend.legendWidth - x - 2 * symbolPadding - 4,\n                translateY: y\n            };\n            const complete = () => {\n                fireEvent(this, 'afterPositionItem', { item });\n            };\n            group[defined(group.translateY) ? 'animate' : 'attr'](attribs, void 0, complete);\n        }\n        if (checkbox) {\n            checkbox.x = x;\n            checkbox.y = y;\n        }\n    }\n    /**\n     * Destroy a single legend item, used internally on removing series items.\n     *\n     * @private\n     * @function Highcharts.Legend#destroyItem\n     * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item\n     * The item to remove\n     */\n    destroyItem(item) {\n        const checkbox = item.checkbox, legendItem = item.legendItem || {};\n        // destroy SVG elements\n        for (const key of ['group', 'label', 'line', 'symbol']) {\n            if (legendItem[key]) {\n                legendItem[key] = legendItem[key].destroy();\n            }\n        }\n        if (checkbox) {\n            discardElement(checkbox);\n        }\n        item.legendItem = void 0;\n    }\n    /**\n     * Destroy the legend. Used internally. To reflow objects, `chart.redraw`\n     * must be called after destruction.\n     *\n     * @private\n     * @function Highcharts.Legend#destroy\n     */\n    destroy() {\n        const legend = this;\n        // Destroy items\n        for (const item of this.getAllItems()) {\n            this.destroyItem(item);\n        }\n        // Destroy legend elements\n        for (const key of [\n            'clipRect',\n            'up',\n            'down',\n            'pager',\n            'nav',\n            'box',\n            'title',\n            'group'\n        ]) {\n            if (legend[key]) {\n                legend[key] = legend[key].destroy();\n            }\n        }\n        this.display = null; // Reset in .render on update.\n    }\n    /**\n     * Position the checkboxes after the width is determined.\n     *\n     * @private\n     * @function Highcharts.Legend#positionCheckboxes\n     */\n    positionCheckboxes() {\n        const alignAttr = this.group && this.group.alignAttr, clipHeight = this.clipHeight || this.legendHeight, titleHeight = this.titleHeight;\n        let translateY;\n        if (alignAttr) {\n            translateY = alignAttr.translateY;\n            this.allItems.forEach(function (item) {\n                const checkbox = item.checkbox;\n                let top;\n                if (checkbox) {\n                    top = translateY + titleHeight + checkbox.y +\n                        (this.scrollOffset || 0) + 3;\n                    css(checkbox, {\n                        left: (alignAttr.translateX + item.checkboxOffset +\n                            checkbox.x - 20) + 'px',\n                        top: top + 'px',\n                        display: this.proximate || (top > translateY - 6 &&\n                            top < translateY + clipHeight - 6) ?\n                            '' :\n                            'none'\n                    });\n                }\n            }, this);\n        }\n    }\n    /**\n     * Render the legend title on top of the legend.\n     *\n     * @private\n     * @function Highcharts.Legend#renderTitle\n     */\n    renderTitle() {\n        const options = this.options, padding = this.padding, titleOptions = options.title;\n        let bBox, titleHeight = 0;\n        if (titleOptions.text) {\n            if (!this.title) {\n                /**\n                 * SVG element of the legend title.\n                 *\n                 * @readonly\n                 * @name Highcharts.Legend#title\n                 * @type {Highcharts.SVGElement}\n                 */\n                this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, void 0, void 0, void 0, options.useHTML, void 0, 'legend-title')\n                    .attr({ zIndex: 1 });\n                if (!this.chart.styledMode) {\n                    this.title.css(titleOptions.style);\n                }\n                this.title.add(this.group);\n            }\n            // Set the max title width (#7253)\n            if (!titleOptions.width) {\n                this.title.css({\n                    width: this.maxLegendWidth + 'px'\n                });\n            }\n            bBox = this.title.getBBox();\n            titleHeight = bBox.height;\n            this.offsetWidth = bBox.width; // #1717\n            this.contentGroup.attr({ translateY: titleHeight });\n        }\n        this.titleHeight = titleHeight;\n    }\n    /**\n     * Set the legend item text.\n     *\n     * @function Highcharts.Legend#setText\n     * @param {Highcharts.Point|Highcharts.Series} item\n     *        The item for which to update the text in the legend.\n     */\n    setText(item) {\n        const options = this.options;\n        item.legendItem.label.attr({\n            text: options.labelFormat ?\n                format(options.labelFormat, item, this.chart) :\n                options.labelFormatter.call(item)\n        });\n    }\n    /**\n     * Render a single specific legend item. Called internally from the `render`\n     * function.\n     *\n     * @private\n     * @function Highcharts.Legend#renderItem\n     * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item\n     * The item to render.\n     */\n    renderItem(item) {\n        const legend = this, legendItem = item.legendItem = item.legendItem || {}, chart = legend.chart, renderer = chart.renderer, options = legend.options, horizontal = options.layout === 'horizontal', symbolWidth = legend.symbolWidth, symbolPadding = options.symbolPadding || 0, itemStyle = legend.itemStyle, itemHiddenStyle = legend.itemHiddenStyle, itemDistance = horizontal ? pick(options.itemDistance, 20) : 0, ltr = !options.rtl, isSeries = !item.series, series = !isSeries && item.series.drawLegendSymbol ?\n            item.series :\n            item, seriesOptions = series.options, showCheckbox = (!!legend.createCheckboxForItem &&\n            seriesOptions &&\n            seriesOptions.showCheckbox), useHTML = options.useHTML, itemClassName = item.options.className;\n        let label = legendItem.label, \n        // full width minus text width\n        itemExtraWidth = symbolWidth + symbolPadding +\n            itemDistance + (showCheckbox ? 20 : 0);\n        if (!label) { // generate it once, later move it\n            // Generate the group box, a group to hold the symbol and text. Text\n            // is to be appended in Legend class.\n            legendItem.group = renderer\n                .g('legend-item')\n                .addClass('highcharts-' + series.type + '-series ' +\n                'highcharts-color-' + item.colorIndex +\n                (itemClassName ? ' ' + itemClassName : '') +\n                (isSeries ?\n                    ' highcharts-series-' + item.index :\n                    ''))\n                .attr({ zIndex: 1 })\n                .add(legend.scrollGroup);\n            // Generate the list item text and add it to the group\n            legendItem.label = label = renderer.text('', ltr ?\n                symbolWidth + symbolPadding :\n                -symbolPadding, legend.baseline || 0, useHTML);\n            if (!chart.styledMode) {\n                // merge to prevent modifying original (#1021)\n                label.css(merge(item.visible ?\n                    itemStyle :\n                    itemHiddenStyle));\n            }\n            label\n                .attr({\n                align: ltr ? 'left' : 'right',\n                zIndex: 2\n            })\n                .add(legendItem.group);\n            // Get the baseline for the first item - the font size is equal for\n            // all\n            if (!legend.baseline) {\n                legend.fontMetrics = renderer.fontMetrics(label);\n                legend.baseline =\n                    legend.fontMetrics.f + 3 + legend.itemMarginTop;\n                label.attr('y', legend.baseline);\n                legend.symbolHeight =\n                    pick(options.symbolHeight, legend.fontMetrics.f);\n                if (options.squareSymbol) {\n                    legend.symbolWidth = pick(options.symbolWidth, Math.max(legend.symbolHeight, 16));\n                    itemExtraWidth = legend.symbolWidth + symbolPadding +\n                        itemDistance + (showCheckbox ? 20 : 0);\n                    if (ltr) {\n                        label.attr('x', legend.symbolWidth + symbolPadding);\n                    }\n                }\n            }\n            // Draw the legend symbol inside the group box\n            series.drawLegendSymbol(legend, item);\n            if (legend.setItemEvents) {\n                legend.setItemEvents(item, label, useHTML);\n            }\n        }\n        // Add the HTML checkbox on top\n        if (showCheckbox && !item.checkbox && legend.createCheckboxForItem) {\n            legend.createCheckboxForItem(item);\n        }\n        // Colorize the items\n        legend.colorizeItem(item, item.visible);\n        // Take care of max width and text overflow (#6659)\n        if (chart.styledMode || !itemStyle.width) {\n            label.css({\n                width: ((options.itemWidth ||\n                    legend.widthOption ||\n                    chart.spacingBox.width) - itemExtraWidth) + 'px'\n            });\n        }\n        // Always update the text\n        legend.setText(item);\n        // calculate the positions for the next line\n        const bBox = label.getBBox();\n        const fontMetricsH = (legend.fontMetrics && legend.fontMetrics.h) || 0;\n        item.itemWidth = item.checkboxOffset =\n            options.itemWidth ||\n                legendItem.labelWidth ||\n                bBox.width + itemExtraWidth;\n        legend.maxItemWidth = Math.max(legend.maxItemWidth, item.itemWidth);\n        legend.totalItemWidth += item.itemWidth;\n        legend.itemHeight = item.itemHeight = Math.round(legendItem.labelHeight ||\n            // use bBox for multiline (#16398)\n            (bBox.height > fontMetricsH * 1.5 ? bBox.height : fontMetricsH));\n    }\n    /**\n     * Get the position of the item in the layout. We now know the\n     * maxItemWidth from the previous loop.\n     *\n     * @private\n     * @function Highcharts.Legend#layoutItem\n     * @param {Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series} item\n     */\n    layoutItem(item) {\n        const options = this.options, padding = this.padding, horizontal = options.layout === 'horizontal', itemHeight = item.itemHeight, itemMarginBottom = this.itemMarginBottom, itemMarginTop = this.itemMarginTop, itemDistance = horizontal ? pick(options.itemDistance, 20) : 0, maxLegendWidth = this.maxLegendWidth, itemWidth = (options.alignColumns &&\n            this.totalItemWidth > maxLegendWidth) ?\n            this.maxItemWidth :\n            item.itemWidth, legendItem = item.legendItem || {};\n        // If the item exceeds the width, start a new line\n        if (horizontal &&\n            this.itemX - padding + itemWidth > maxLegendWidth) {\n            this.itemX = padding;\n            if (this.lastLineHeight) { // Not for the first line (#10167)\n                this.itemY += (itemMarginTop +\n                    this.lastLineHeight +\n                    itemMarginBottom);\n            }\n            this.lastLineHeight = 0; // reset for next line (#915, #3976)\n        }\n        // Set the edge positions\n        this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;\n        this.lastLineHeight = Math.max(// #915\n        itemHeight, this.lastLineHeight);\n        // cache the position of the newly generated or reordered items\n        legendItem.x = this.itemX;\n        legendItem.y = this.itemY;\n        // advance\n        if (horizontal) {\n            this.itemX += itemWidth;\n        }\n        else {\n            this.itemY +=\n                itemMarginTop + itemHeight + itemMarginBottom;\n            this.lastLineHeight = itemHeight;\n        }\n        // the width of the widest item\n        this.offsetWidth = this.widthOption || Math.max((horizontal ? this.itemX - padding - (item.checkbox ?\n            // decrease by itemDistance only when no checkbox #4853\n            0 :\n            itemDistance) : itemWidth) + padding, this.offsetWidth);\n    }\n    /**\n     * Get all items, which is one item per series for most series and one\n     * item per point for pie series and its derivatives. Fires the event\n     * `afterGetAllItems`.\n     *\n     * @private\n     * @function Highcharts.Legend#getAllItems\n     * @return {Array<(Highcharts.BubbleLegendItem|Highcharts.Point|Highcharts.Series)>}\n     * The current items in the legend.\n     * @emits Highcharts.Legend#event:afterGetAllItems\n     */\n    getAllItems() {\n        let allItems = [];\n        this.chart.series.forEach(function (series) {\n            const seriesOptions = series && series.options;\n            // Handle showInLegend. If the series is linked to another series,\n            // defaults to false.\n            if (series && pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? void 0 : false, true)) {\n                // Use points or series for the legend item depending on\n                // legendType\n                allItems = allItems.concat((series.legendItem || {}).labels ||\n                    (seriesOptions.legendType === 'point' ?\n                        series.data :\n                        series));\n            }\n        });\n        fireEvent(this, 'afterGetAllItems', { allItems });\n        return allItems;\n    }\n    /**\n     * Get a short, three letter string reflecting the alignment and layout.\n     *\n     * @private\n     * @function Highcharts.Legend#getAlignment\n     * @return {string}\n     * The alignment, empty string if floating\n     */\n    getAlignment() {\n        const options = this.options;\n        // Use the first letter of each alignment option in order to detect\n        // the side. (#4189 - use charAt(x) notation instead of [x] for IE7)\n        if (this.proximate) {\n            return options.align.charAt(0) + 'tv';\n        }\n        return options.floating ? '' : (options.align.charAt(0) +\n            options.verticalAlign.charAt(0) +\n            options.layout.charAt(0));\n    }\n    /**\n     * Adjust the chart margins by reserving space for the legend on only one\n     * side of the chart. If the position is set to a corner, top or bottom is\n     * reserved for horizontal legends and left or right for vertical ones.\n     *\n     * @private\n     * @function Highcharts.Legend#adjustMargins\n     * @param {Array<number>} margin\n     * @param {Array<number>} spacing\n     */\n    adjustMargins(margin, spacing) {\n        const chart = this.chart, options = this.options, alignment = this.getAlignment();\n        if (alignment) {\n            ([\n                /(lth|ct|rth)/,\n                /(rtv|rm|rbv)/,\n                /(rbh|cb|lbh)/,\n                /(lbv|lm|ltv)/\n            ]).forEach(function (alignments, side) {\n                if (alignments.test(alignment) && !defined(margin[side])) {\n                    // Now we have detected on which side of the chart we should\n                    // reserve space for the legend\n                    chart[marginNames[side]] = Math.max(chart[marginNames[side]], (chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] +\n                        [1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] +\n                        pick(options.margin, 12) +\n                        spacing[side] +\n                        (chart.titleOffset[side] || 0)));\n                }\n            });\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.Legend#proximatePositions\n     */\n    proximatePositions() {\n        const chart = this.chart, boxes = [], alignLeft = this.options.align === 'left';\n        this.allItems.forEach(function (item) {\n            let lastPoint, height, useFirstPoint = alignLeft, target, top;\n            if (item.yAxis) {\n                if (item.xAxis.options.reversed) {\n                    useFirstPoint = !useFirstPoint;\n                }\n                if (item.points) {\n                    lastPoint = find(useFirstPoint ?\n                        item.points :\n                        item.points.slice(0).reverse(), function (item) {\n                        return isNumber(item.plotY);\n                    });\n                }\n                height = this.itemMarginTop +\n                    item.legendItem.label.getBBox().height +\n                    this.itemMarginBottom;\n                top = item.yAxis.top - chart.plotTop;\n                if (item.visible) {\n                    target = lastPoint ?\n                        lastPoint.plotY :\n                        item.yAxis.height;\n                    target += top - 0.3 * height;\n                }\n                else {\n                    target = top + item.yAxis.height;\n                }\n                boxes.push({\n                    target: target,\n                    size: height,\n                    item\n                });\n            }\n        }, this);\n        let legendItem;\n        for (const box of distribute(boxes, chart.plotHeight)) {\n            legendItem = box.item.legendItem || {};\n            if (isNumber(box.pos)) {\n                legendItem.y = chart.plotTop - chart.spacing[0] + box.pos;\n            }\n        }\n    }\n    /**\n     * Render the legend. This method can be called both before and after\n     * `chart.render`. If called after, it will only rearrange items instead\n     * of creating new ones. Called internally on initial render and after\n     * redraws.\n     *\n     * @private\n     * @function Highcharts.Legend#render\n     */\n    render() {\n        const legend = this, chart = legend.chart, renderer = chart.renderer, options = legend.options, padding = legend.padding, \n        // add each series or point\n        allItems = legend.getAllItems();\n        let display, legendWidth, legendHeight, legendGroup = legend.group, allowedWidth, box = legend.box;\n        legend.itemX = padding;\n        legend.itemY = legend.initialItemY;\n        legend.offsetWidth = 0;\n        legend.lastItemY = 0;\n        legend.widthOption = relativeLength(options.width, chart.spacingBox.width - padding);\n        // Compute how wide the legend is allowed to be\n        allowedWidth = chart.spacingBox.width - 2 * padding - options.x;\n        if (['rm', 'lm'].indexOf(legend.getAlignment().substring(0, 2)) > -1) {\n            allowedWidth /= 2;\n        }\n        legend.maxLegendWidth = legend.widthOption || allowedWidth;\n        if (!legendGroup) {\n            /**\n             * SVG group of the legend.\n             *\n             * @readonly\n             * @name Highcharts.Legend#group\n             * @type {Highcharts.SVGElement}\n             */\n            legend.group = legendGroup = renderer\n                .g('legend')\n                .addClass(options.className || '')\n                .attr({ zIndex: 7 })\n                .add();\n            legend.contentGroup = renderer\n                .g()\n                .attr({ zIndex: 1 }) // above background\n                .add(legendGroup);\n            legend.scrollGroup = renderer\n                .g()\n                .add(legend.contentGroup);\n        }\n        legend.renderTitle();\n        // sort by legendIndex\n        stableSort(allItems, (a, b) => ((a.options && a.options.legendIndex) || 0) -\n            ((b.options && b.options.legendIndex) || 0));\n        // reversed legend\n        if (options.reversed) {\n            allItems.reverse();\n        }\n        /**\n         * All items for the legend, which is an array of series for most series\n         * and an array of points for pie series and its derivatives.\n         *\n         * @readonly\n         * @name Highcharts.Legend#allItems\n         * @type {Array<(Highcharts.Point|Highcharts.Series)>}\n         */\n        legend.allItems = allItems;\n        legend.display = display = !!allItems.length;\n        // Render the items. First we run a loop to set the text and properties\n        // and read all the bounding boxes. The next loop computes the item\n        // positions based on the bounding boxes.\n        legend.lastLineHeight = 0;\n        legend.maxItemWidth = 0;\n        legend.totalItemWidth = 0;\n        legend.itemHeight = 0;\n        allItems.forEach(legend.renderItem, legend);\n        allItems.forEach(legend.layoutItem, legend);\n        // Get the box\n        legendWidth = (legend.widthOption || legend.offsetWidth) + padding;\n        legendHeight = legend.lastItemY + legend.lastLineHeight +\n            legend.titleHeight;\n        legendHeight = legend.handleOverflow(legendHeight);\n        legendHeight += padding;\n        // Draw the border and/or background\n        if (!box) {\n            /**\n             * SVG element of the legend box.\n             *\n             * @readonly\n             * @name Highcharts.Legend#box\n             * @type {Highcharts.SVGElement}\n             */\n            legend.box = box = renderer.rect()\n                .addClass('highcharts-legend-box')\n                .attr({\n                r: options.borderRadius\n            })\n                .add(legendGroup);\n        }\n        // Presentational\n        if (!chart.styledMode) {\n            box\n                .attr({\n                stroke: options.borderColor,\n                'stroke-width': options.borderWidth || 0,\n                fill: options.backgroundColor || 'none'\n            })\n                .shadow(options.shadow);\n        }\n        if (legendWidth > 0 && legendHeight > 0) {\n            box[box.placed ? 'animate' : 'attr'](box.crisp.call({}, {\n                x: 0,\n                y: 0,\n                width: legendWidth,\n                height: legendHeight\n            }, box.strokeWidth()));\n        }\n        // hide the border if no items\n        legendGroup[display ? 'show' : 'hide']();\n        // Open for responsiveness\n        if (chart.styledMode && legendGroup.getStyle('display') === 'none') {\n            legendWidth = legendHeight = 0;\n        }\n        legend.legendWidth = legendWidth;\n        legend.legendHeight = legendHeight;\n        if (display) {\n            legend.align();\n        }\n        if (!this.proximate) {\n            this.positionItems();\n        }\n        fireEvent(this, 'afterRender');\n    }\n    /**\n     * Align the legend to chart's box.\n     *\n     * @private\n     * @function Highcharts.align\n     * @param {Highcharts.BBoxObject} alignTo\n     */\n    align(alignTo = this.chart.spacingBox) {\n        const chart = this.chart, options = this.options;\n        // If aligning to the top and the layout is horizontal, adjust for\n        // the title (#7428)\n        let y = alignTo.y;\n        if (/(lth|ct|rth)/.test(this.getAlignment()) &&\n            chart.titleOffset[0] > 0) {\n            y += chart.titleOffset[0];\n        }\n        else if (/(lbh|cb|rbh)/.test(this.getAlignment()) &&\n            chart.titleOffset[2] > 0) {\n            y -= chart.titleOffset[2];\n        }\n        if (y !== alignTo.y) {\n            alignTo = merge(alignTo, { y });\n        }\n        if (!chart.hasRendered) {\n            // Avoid animation when adjusting alignment for responsiveness and\n            // colorAxis label layout\n            this.group.placed = false;\n        }\n        this.group.align(merge(options, {\n            width: this.legendWidth,\n            height: this.legendHeight,\n            verticalAlign: this.proximate ? 'top' : options.verticalAlign\n        }), true, alignTo);\n    }\n    /**\n     * Set up the overflow handling by adding navigation with up and down arrows\n     * below the legend.\n     *\n     * @private\n     * @function Highcharts.Legend#handleOverflow\n     */\n    handleOverflow(legendHeight) {\n        const legend = this, chart = this.chart, renderer = chart.renderer, options = this.options, optionsY = options.y, alignTop = options.verticalAlign === 'top', padding = this.padding, maxHeight = options.maxHeight, navOptions = options.navigation, animation = pick(navOptions.animation, true), arrowSize = navOptions.arrowSize || 12, pages = this.pages, allItems = this.allItems, clipToHeight = function (height) {\n            if (typeof height === 'number') {\n                clipRect.attr({\n                    height: height\n                });\n            }\n            else if (clipRect) { // Reset (#5912)\n                legend.clipRect = clipRect.destroy();\n                legend.contentGroup.clip();\n            }\n            // useHTML\n            if (legend.contentGroup.div) {\n                legend.contentGroup.div.style.clip = height ?\n                    'rect(' + padding + 'px,9999px,' +\n                        (padding + height) + 'px,0)' :\n                    'auto';\n            }\n        }, addTracker = function (key) {\n            legend[key] = renderer\n                .circle(0, 0, arrowSize * 1.3)\n                .translate(arrowSize / 2, arrowSize / 2)\n                .add(nav);\n            if (!chart.styledMode) {\n                legend[key].attr('fill', 'rgba(0,0,0,0.0001)');\n            }\n            return legend[key];\n        };\n        let clipHeight, lastY, legendItem, spaceHeight = (chart.spacingBox.height +\n            (alignTop ? -optionsY : optionsY) - padding), nav = this.nav, clipRect = this.clipRect;\n        // Adjust the height\n        if (options.layout === 'horizontal' &&\n            options.verticalAlign !== 'middle' &&\n            !options.floating) {\n            spaceHeight /= 2;\n        }\n        if (maxHeight) {\n            spaceHeight = Math.min(spaceHeight, maxHeight);\n        }\n        // Reset the legend height and adjust the clipping rectangle\n        pages.length = 0;\n        if (legendHeight &&\n            spaceHeight > 0 &&\n            legendHeight > spaceHeight &&\n            navOptions.enabled !== false) {\n            this.clipHeight = clipHeight =\n                Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);\n            this.currentPage = pick(this.currentPage, 1);\n            this.fullHeight = legendHeight;\n            // Fill pages with Y positions so that the top of each a legend item\n            // defines the scroll top for each page (#2098)\n            allItems.forEach((item, i) => {\n                legendItem = item.legendItem || {};\n                const y = legendItem.y || 0, h = Math.round(legendItem.label.getBBox().height);\n                let len = pages.length;\n                if (!len || (y - pages[len - 1] > clipHeight &&\n                    (lastY || y) !== pages[len - 1])) {\n                    pages.push(lastY || y);\n                    len++;\n                }\n                // Keep track of which page each item is on\n                legendItem.pageIx = len - 1;\n                if (lastY) {\n                    (allItems[i - 1].legendItem || {}).pageIx = len - 1;\n                }\n                // add the last page if needed (#2617, #13683)\n                if (\n                // check the last item\n                i === allItems.length - 1 &&\n                    // if adding next page is needed (#18768)\n                    y + h - pages[len - 1] > clipHeight &&\n                    y > pages[len - 1]) {\n                    pages.push(y);\n                    legendItem.pageIx = len;\n                }\n                if (y !== lastY) {\n                    lastY = y;\n                }\n            });\n            // Only apply clipping if needed. Clipping causes blurred legend in\n            // PDF export (#1787)\n            if (!clipRect) {\n                clipRect = legend.clipRect =\n                    renderer.clipRect(0, padding - 2, 9999, 0);\n                legend.contentGroup.clip(clipRect);\n            }\n            clipToHeight(clipHeight);\n            // Add navigation elements\n            if (!nav) {\n                this.nav = nav = renderer.g()\n                    .attr({ zIndex: 1 })\n                    .add(this.group);\n                this.up = renderer\n                    .symbol('triangle', 0, 0, arrowSize, arrowSize)\n                    .add(nav);\n                addTracker('upTracker')\n                    .on('click', function () {\n                    legend.scroll(-1, animation);\n                });\n                this.pager = renderer.text('', 15, 10)\n                    .addClass('highcharts-legend-navigation');\n                if (!chart.styledMode && navOptions.style) {\n                    this.pager.css(navOptions.style);\n                }\n                this.pager.add(nav);\n                this.down = renderer\n                    .symbol('triangle-down', 0, 0, arrowSize, arrowSize)\n                    .add(nav);\n                addTracker('downTracker')\n                    .on('click', function () {\n                    legend.scroll(1, animation);\n                });\n            }\n            // Set initial position\n            legend.scroll(0);\n            legendHeight = spaceHeight;\n            // Reset\n        }\n        else if (nav) {\n            clipToHeight();\n            this.nav = nav.destroy(); // #6322\n            this.scrollGroup.attr({\n                translateY: 1\n            });\n            this.clipHeight = 0; // #1379\n        }\n        return legendHeight;\n    }\n    /**\n     * Scroll the legend by a number of pages.\n     *\n     * @private\n     * @function Highcharts.Legend#scroll\n     *\n     * @param {number} scrollBy\n     *        The number of pages to scroll.\n     *\n     * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]\n     *        Whether and how to apply animation.\n     *\n     */\n    scroll(scrollBy, animation) {\n        const chart = this.chart, pages = this.pages, pageCount = pages.length, clipHeight = this.clipHeight, navOptions = this.options.navigation, pager = this.pager, padding = this.padding;\n        let currentPage = this.currentPage + scrollBy;\n        // When resizing while looking at the last page\n        if (currentPage > pageCount) {\n            currentPage = pageCount;\n        }\n        if (currentPage > 0) {\n            if (typeof animation !== 'undefined') {\n                setAnimation(animation, chart);\n            }\n            this.nav.attr({\n                translateX: padding,\n                translateY: clipHeight + this.padding + 7 + this.titleHeight,\n                visibility: 'inherit'\n            });\n            [this.up, this.upTracker].forEach(function (elem) {\n                elem.attr({\n                    'class': currentPage === 1 ?\n                        'highcharts-legend-nav-inactive' :\n                        'highcharts-legend-nav-active'\n                });\n            });\n            pager.attr({\n                text: currentPage + '/' + pageCount\n            });\n            [this.down, this.downTracker].forEach(function (elem) {\n                elem.attr({\n                    // adjust to text width\n                    x: 18 + this.pager.getBBox().width,\n                    'class': currentPage === pageCount ?\n                        'highcharts-legend-nav-inactive' :\n                        'highcharts-legend-nav-active'\n                });\n            }, this);\n            if (!chart.styledMode) {\n                this.up\n                    .attr({\n                    fill: currentPage === 1 ?\n                        navOptions.inactiveColor :\n                        navOptions.activeColor\n                });\n                this.upTracker\n                    .css({\n                    cursor: currentPage === 1 ? 'default' : 'pointer'\n                });\n                this.down\n                    .attr({\n                    fill: currentPage === pageCount ?\n                        navOptions.inactiveColor :\n                        navOptions.activeColor\n                });\n                this.downTracker\n                    .css({\n                    cursor: currentPage === pageCount ?\n                        'default' :\n                        'pointer'\n                });\n            }\n            this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;\n            this.scrollGroup.animate({\n                translateY: this.scrollOffset\n            });\n            this.currentPage = currentPage;\n            this.positionCheckboxes();\n            // Fire event after scroll animation is complete\n            const animOptions = animObject(pick(animation, chart.renderer.globalAnimation, true));\n            syncTimeout(() => {\n                fireEvent(this, 'afterScroll', { currentPage });\n            }, animOptions.duration);\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.Legend#setItemEvents\n     * @param {Highcharts.BubbleLegendItem|Point|Highcharts.Series} item\n     * @param {Highcharts.SVGElement} legendLabel\n     * @param {boolean} [useHTML=false]\n     * @emits Highcharts.Point#event:legendItemClick\n     * @emits Highcharts.Series#event:legendItemClick\n     */\n    setItemEvents(item, legendLabel, useHTML) {\n        const legend = this, legendItem = item.legendItem || {}, boxWrapper = legend.chart.renderer.boxWrapper, isPoint = item instanceof Point, activeClass = 'highcharts-legend-' +\n            (isPoint ? 'point' : 'series') + '-active', styledMode = legend.chart.styledMode, \n        // When `useHTML`, the symbol is rendered in other group, so\n        // we need to apply events listeners to both places\n        legendElements = useHTML ?\n            [legendLabel, legendItem.symbol] :\n            [legendItem.group];\n        const setOtherItemsState = (state) => {\n            legend.allItems.forEach((otherItem) => {\n                if (item !== otherItem) {\n                    [otherItem]\n                        .concat(otherItem.linkedSeries || [])\n                        .forEach((otherItem) => {\n                        otherItem.setState(state, !isPoint);\n                    });\n                }\n            });\n        };\n        // Set the events on the item group, or in case of useHTML, the item\n        // itself (#1249)\n        for (const element of legendElements) {\n            if (element) {\n                element\n                    .on('mouseover', function () {\n                    if (item.visible) {\n                        setOtherItemsState('inactive');\n                    }\n                    item.setState('hover');\n                    // A CSS class to dim or hide other than the hovered\n                    // series.\n                    // Works only if hovered series is visible (#10071).\n                    if (item.visible) {\n                        boxWrapper.addClass(activeClass);\n                    }\n                    if (!styledMode) {\n                        legendLabel.css(legend.options.itemHoverStyle);\n                    }\n                })\n                    .on('mouseout', function () {\n                    if (!legend.chart.styledMode) {\n                        legendLabel.css(merge(item.visible ?\n                            legend.itemStyle :\n                            legend.itemHiddenStyle));\n                    }\n                    setOtherItemsState('');\n                    // A CSS class to dim or hide other than the hovered\n                    // series.\n                    boxWrapper.removeClass(activeClass);\n                    item.setState();\n                })\n                    .on('click', function (event) {\n                    const strLegendItemClick = 'legendItemClick', fnLegendItemClick = function () {\n                        if (item.setVisible) {\n                            item.setVisible();\n                        }\n                        // Reset inactive state\n                        setOtherItemsState(item.visible ? 'inactive' : '');\n                    };\n                    // A CSS class to dim or hide other than the hovered\n                    // series. Event handling in iOS causes the activeClass\n                    // to be added prior to click in some cases (#7418).\n                    boxWrapper.removeClass(activeClass);\n                    // Pass over the click/touch event. #4.\n                    event = {\n                        browserEvent: event\n                    };\n                    // click the name or symbol\n                    if (item.firePointEvent) { // point\n                        item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n                    }\n                    else {\n                        fireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n                    }\n                });\n            }\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.Legend#createCheckboxForItem\n     * @param {Highcharts.BubbleLegendItem|Point|Highcharts.Series} item\n     * @emits Highcharts.Series#event:checkboxClick\n     */\n    createCheckboxForItem(item) {\n        const legend = this;\n        item.checkbox = createElement('input', {\n            type: 'checkbox',\n            className: 'highcharts-legend-checkbox',\n            checked: item.selected,\n            defaultChecked: item.selected // required by IE7\n        }, legend.options.itemCheckboxStyle, legend.chart.container);\n        addEvent(item.checkbox, 'click', function (event) {\n            const target = event.target;\n            fireEvent(item.series || item, 'checkboxClick', {\n                checked: target.checked,\n                item: item\n            }, function () {\n                item.select();\n            });\n        });\n    }\n}\n/* *\n *\n *  Class Namespace\n *\n * */\n(function (Legend) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Constants\n     *\n     * */\n    const composedMembers = [];\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * @private\n     */\n    function compose(ChartClass) {\n        if (U.pushUnique(composedMembers, ChartClass)) {\n            addEvent(ChartClass, 'beforeMargins', function () {\n                /**\n                 * The legend contains an interactive overview over chart items,\n                 * usually individual series or points depending on the series\n                 * type. The color axis and bubble legend are also rendered in\n                 * the chart legend.\n                 *\n                 * @name Highcharts.Chart#legend\n                 * @type {Highcharts.Legend}\n                 */\n                this.legend = new Legend(this, this.options.legend);\n            });\n        }\n    }\n    Legend.compose = compose;\n})(Legend || (Legend = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default Legend;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * @interface Highcharts.LegendItemObject\n */ /**\n* @name Highcharts.LegendItemObject#item\n* @type {Highcharts.SVGElement|undefined}\n*/ /**\n* @name Highcharts.LegendItemObject#line\n* @type {Highcharts.SVGElement|undefined}\n*/ /**\n* @name Highcharts.LegendItemObject#symbol\n* @type {Highcharts.SVGElement|undefined}\n*/\n/**\n * Gets fired when the legend item belonging to a point is clicked. The default\n * action is to toggle the visibility of the point. This can be prevented by\n * returning `false` or calling `event.preventDefault()`.\n *\n * @callback Highcharts.PointLegendItemClickCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        The point on which the event occured.\n *\n * @param {Highcharts.PointLegendItemClickEventObject} event\n *        The event that occured.\n */\n/**\n * Information about the legend click event.\n *\n * @interface Highcharts.PointLegendItemClickEventObject\n */ /**\n* Related browser event.\n* @name Highcharts.PointLegendItemClickEventObject#browserEvent\n* @type {Highcharts.PointerEvent}\n*/ /**\n* Prevent the default action of toggle the visibility of the point.\n* @name Highcharts.PointLegendItemClickEventObject#preventDefault\n* @type {Function}\n*/ /**\n* Related point.\n* @name Highcharts.PointLegendItemClickEventObject#target\n* @type {Highcharts.Point}\n*/ /**\n* Event type.\n* @name Highcharts.PointLegendItemClickEventObject#type\n* @type {\"legendItemClick\"}\n*/\n/**\n * Series color as used by the legend and some series types.\n * @name Highcharts.Series#color\n * @type {Highcharts.ColorType|undefined}\n */ /**\n* Legend data for the series.\n* @name Highcharts.Series#legendItem\n* @type {Highcharts.LegendItemObject|undefined}\n* @since 10.3.0\n*/\n/**\n * Gets fired when the legend item belonging to a series is clicked. The default\n * action is to toggle the visibility of the series. This can be prevented by\n * returning `false` or calling `event.preventDefault()`.\n *\n * @callback Highcharts.SeriesLegendItemClickCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        The series where the event occured.\n *\n * @param {Highcharts.SeriesLegendItemClickEventObject} event\n *        The event that occured.\n */\n/**\n * Information about the legend click event.\n *\n * @interface Highcharts.SeriesLegendItemClickEventObject\n */ /**\n* Related browser event.\n* @name Highcharts.SeriesLegendItemClickEventObject#browserEvent\n* @type {Highcharts.PointerEvent}\n*/ /**\n* Prevent the default action of toggle the visibility of the series.\n* @name Highcharts.SeriesLegendItemClickEventObject#preventDefault\n* @type {Function}\n*/ /**\n* Related series.\n* @name Highcharts.SeriesLegendItemClickEventObject#target\n* @type {Highcharts.Series}\n*/ /**\n* Event type.\n* @name Highcharts.SeriesLegendItemClickEventObject#type\n* @type {\"legendItemClick\"}\n*/\n(''); // keeps doclets above in JS file\n"],"mappings":"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EAAE;MAC3CtR,QAAQ,CAACsR,UAAU,EAAE,eAAe,EAAE,YAAY;QAC9C;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;QACgB,IAAI,CAACtO,MAAM,GAAG,IAAInC,MAAM,CAAC,IAAI,EAAE,IAAI,CAACG,OAAO,CAACgC,MAAM,CAAC;MACvD,CAAC,CAAC;IACN;EACJ;EACAnC,MAAM,CAACwQ,OAAO,GAAGA,OAAO;AAC5B,CAAC,EAAExQ,MAAM,KAAKA,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3B;AACA;AACA;AACA;AACA;AACA,eAAeA,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAFA,CAEI;AACJ;AACA;AACA,MAHI,CAGD;AACH;AACA;AACA,SAHG,CAGA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA,SAJG,CAIA;AACH;AACA;AACA;AACA,YAJG,CAIA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA,SAJG,CAIA;AACH;AACA;AACA;AACA,YAJG,CAIA;AACH;AACA;AACA;AACA;AACC,EAAE,CAAE,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}