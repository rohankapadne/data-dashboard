{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Highcharts feature to make the Y axis stay fixed when scrolling the chart\n *  horizontally on mobile devices. Supports left and right side axes.\n */\n/*\nWIP on vertical scrollable plot area (#9378). To do:\n- Bottom axis positioning\n- Test with Gantt\n- Look for size optimizing the code\n- API and demos\n */\n'use strict';\n\nimport A from '../Core/Animation/AnimationUtilities.js';\nconst {\n  stop\n} = A;\nimport Axis from '../Core/Axis/Axis.js';\nimport Chart from '../Core/Chart/Chart.js';\nimport Series from '../Core/Series/Series.js';\nimport RendererRegistry from '../Core/Renderer/RendererRegistry.js';\nimport U from '../Core/Utilities.js';\nconst {\n  addEvent,\n  createElement,\n  defined,\n  merge,\n  pick\n} = U;\n/* eslint-disable no-invalid-this, valid-jsdoc */\naddEvent(Chart, 'afterSetChartSize', function (e) {\n  let scrollablePlotArea = this.options.chart.scrollablePlotArea,\n    scrollableMinWidth = scrollablePlotArea && scrollablePlotArea.minWidth,\n    scrollableMinHeight = scrollablePlotArea && scrollablePlotArea.minHeight,\n    scrollablePixelsX,\n    scrollablePixelsY,\n    corrections;\n  if (!this.renderer.forExport) {\n    // The amount of pixels to scroll, the difference between chart\n    // width and scrollable width\n    if (scrollableMinWidth) {\n      this.scrollablePixelsX = scrollablePixelsX = Math.max(0, scrollableMinWidth - this.chartWidth);\n      if (scrollablePixelsX) {\n        this.scrollablePlotBox = this.renderer.scrollablePlotBox = merge(this.plotBox);\n        this.plotBox.width = this.plotWidth += scrollablePixelsX;\n        if (this.inverted) {\n          this.clipBox.height += scrollablePixelsX;\n        } else {\n          this.clipBox.width += scrollablePixelsX;\n        }\n        corrections = {\n          // Corrections for right side\n          1: {\n            name: 'right',\n            value: scrollablePixelsX\n          }\n        };\n      }\n      // Currently we can only do either X or Y\n    } else if (scrollableMinHeight) {\n      this.scrollablePixelsY = scrollablePixelsY = Math.max(0, scrollableMinHeight - this.chartHeight);\n      if (defined(scrollablePixelsY)) {\n        this.scrollablePlotBox = this.renderer.scrollablePlotBox = merge(this.plotBox);\n        this.plotBox.height = this.plotHeight += scrollablePixelsY;\n        if (this.inverted) {\n          this.clipBox.width += scrollablePixelsY;\n        } else {\n          this.clipBox.height += scrollablePixelsY;\n        }\n        corrections = {\n          2: {\n            name: 'bottom',\n            value: scrollablePixelsY\n          }\n        };\n      }\n    }\n    if (corrections && !e.skipAxes) {\n      this.axes.forEach(function (axis) {\n        // For right and bottom axes, only fix the plot line length\n        if (corrections[axis.side]) {\n          // Get the plot lines right in getPlotLinePath,\n          // temporarily set it to the adjusted plot width.\n          axis.getPlotLinePath = function () {\n            let marginName = corrections[axis.side].name,\n              correctionValue = corrections[axis.side].value,\n              // axis.right or axis.bottom\n              margin = this[marginName],\n              path;\n            // Temporarily adjust\n            this[marginName] = margin - correctionValue;\n            path = Axis.prototype.getPlotLinePath.apply(this, arguments);\n            // Reset\n            this[marginName] = margin;\n            return path;\n          };\n        } else {\n          // Apply the corrected plotWidth\n          axis.setAxisSize();\n          axis.setAxisTranslation();\n        }\n      });\n    }\n  }\n});\naddEvent(Chart, 'render', function () {\n  if (this.scrollablePixelsX || this.scrollablePixelsY) {\n    if (this.setUpScrolling) {\n      this.setUpScrolling();\n    }\n    this.applyFixed();\n  } else if (this.fixedDiv) {\n    // Has been in scrollable mode\n    this.applyFixed();\n  }\n});\n/**\n * @private\n * @function Highcharts.Chart#setUpScrolling\n * @return {void}\n */\nChart.prototype.setUpScrolling = function () {\n  const css = {\n    WebkitOverflowScrolling: 'touch',\n    overflowX: 'hidden',\n    overflowY: 'hidden'\n  };\n  if (this.scrollablePixelsX) {\n    css.overflowX = 'auto';\n  }\n  if (this.scrollablePixelsY) {\n    css.overflowY = 'auto';\n  }\n  // Insert a container with position relative\n  // that scrolling and fixed container renders to (#10555)\n  this.scrollingParent = createElement('div', {\n    className: 'highcharts-scrolling-parent'\n  }, {\n    position: 'relative'\n  }, this.renderTo);\n  // Add the necessary divs to provide scrolling\n  this.scrollingContainer = createElement('div', {\n    'className': 'highcharts-scrolling'\n  }, css, this.scrollingParent);\n  // On scroll, reset the chart position because it applies to the scrolled\n  // container\n  let lastHoverPoint;\n  addEvent(this.scrollingContainer, 'scroll', () => {\n    if (this.pointer) {\n      delete this.pointer.chartPosition;\n      if (this.hoverPoint) {\n        lastHoverPoint = this.hoverPoint;\n      }\n      this.pointer.runPointActions(void 0, lastHoverPoint, true);\n    }\n  });\n  this.innerContainer = createElement('div', {\n    'className': 'highcharts-inner-container'\n  }, null, this.scrollingContainer);\n  // Now move the container inside\n  this.innerContainer.appendChild(this.container);\n  // Don't run again\n  this.setUpScrolling = null;\n};\n/**\n * These elements are moved over to the fixed renderer and stay fixed when the\n * user scrolls the chart\n * @private\n */\nChart.prototype.moveFixedElements = function () {\n  let container = this.container,\n    fixedRenderer = this.fixedRenderer,\n    fixedSelectors = ['.highcharts-breadcrumbs-group', '.highcharts-contextbutton', '.highcharts-credits', '.highcharts-legend', '.highcharts-legend-checkbox', '.highcharts-navigator-series', '.highcharts-navigator-xaxis', '.highcharts-navigator-yaxis', '.highcharts-navigator', '.highcharts-reset-zoom', '.highcharts-drillup-button', '.highcharts-scrollbar', '.highcharts-subtitle', '.highcharts-title'],\n    axisClass;\n  if (this.scrollablePixelsX && !this.inverted) {\n    axisClass = '.highcharts-yaxis';\n  } else if (this.scrollablePixelsX && this.inverted) {\n    axisClass = '.highcharts-xaxis';\n  } else if (this.scrollablePixelsY && !this.inverted) {\n    axisClass = '.highcharts-xaxis';\n  } else if (this.scrollablePixelsY && this.inverted) {\n    axisClass = '.highcharts-yaxis';\n  }\n  if (axisClass) {\n    fixedSelectors.push(`${axisClass}:not(.highcharts-radial-axis)`, `${axisClass}-labels:not(.highcharts-radial-axis-labels)`);\n  }\n  fixedSelectors.forEach(function (className) {\n    [].forEach.call(container.querySelectorAll(className), function (elem) {\n      (elem.namespaceURI === fixedRenderer.SVG_NS ? fixedRenderer.box : fixedRenderer.box.parentNode).appendChild(elem);\n      elem.style.pointerEvents = 'auto';\n    });\n  });\n};\n/**\n * @private\n * @function Highcharts.Chart#applyFixed\n * @return {void}\n */\nChart.prototype.applyFixed = function () {\n  const firstTime = !this.fixedDiv,\n    chartOptions = this.options.chart,\n    scrollableOptions = chartOptions.scrollablePlotArea,\n    Renderer = RendererRegistry.getRendererType();\n  let fixedRenderer, scrollableWidth, scrollableHeight;\n  // First render\n  if (firstTime) {\n    this.fixedDiv = createElement('div', {\n      className: 'highcharts-fixed'\n    }, {\n      position: 'absolute',\n      overflow: 'hidden',\n      pointerEvents: 'none',\n      zIndex: (chartOptions.style && chartOptions.style.zIndex || 0) + 2,\n      top: 0\n    }, null, true);\n    if (this.scrollingContainer) {\n      this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer);\n    }\n    this.renderTo.style.overflow = 'visible';\n    this.fixedRenderer = fixedRenderer = new Renderer(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style);\n    // Mask\n    this.scrollableMask = fixedRenderer.path().attr({\n      fill: this.options.chart.backgroundColor || '#fff',\n      'fill-opacity': pick(scrollableOptions.opacity, 0.85),\n      zIndex: -1\n    }).addClass('highcharts-scrollable-mask').add();\n    addEvent(this, 'afterShowResetZoom', this.moveFixedElements);\n    addEvent(this, 'afterApplyDrilldown', this.moveFixedElements);\n    addEvent(this, 'afterLayOutTitles', this.moveFixedElements);\n  } else {\n    // Set the size of the fixed renderer to the visible width\n    this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n  }\n  if (this.scrollableDirty || firstTime) {\n    this.scrollableDirty = false;\n    this.moveFixedElements();\n  }\n  // Increase the size of the scrollable renderer and background\n  scrollableWidth = this.chartWidth + (this.scrollablePixelsX || 0);\n  scrollableHeight = this.chartHeight + (this.scrollablePixelsY || 0);\n  stop(this.container);\n  this.container.style.width = scrollableWidth + 'px';\n  this.container.style.height = scrollableHeight + 'px';\n  this.renderer.boxWrapper.attr({\n    width: scrollableWidth,\n    height: scrollableHeight,\n    viewBox: [0, 0, scrollableWidth, scrollableHeight].join(' ')\n  });\n  this.chartBackground.attr({\n    width: scrollableWidth,\n    height: scrollableHeight\n  });\n  this.scrollingContainer.style.height = this.chartHeight + 'px';\n  // Set scroll position\n  if (firstTime) {\n    if (scrollableOptions.scrollPositionX) {\n      this.scrollingContainer.scrollLeft = this.scrollablePixelsX * scrollableOptions.scrollPositionX;\n    }\n    if (scrollableOptions.scrollPositionY) {\n      this.scrollingContainer.scrollTop = this.scrollablePixelsY * scrollableOptions.scrollPositionY;\n    }\n  }\n  // Mask behind the left and right side\n  let axisOffset = this.axisOffset,\n    maskTop = this.plotTop - axisOffset[0] - 1,\n    maskLeft = this.plotLeft - axisOffset[3] - 1,\n    maskBottom = this.plotTop + this.plotHeight + axisOffset[2] + 1,\n    maskRight = this.plotLeft + this.plotWidth + axisOffset[1] + 1,\n    maskPlotRight = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n    maskPlotBottom = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0),\n    d;\n  if (this.scrollablePixelsX) {\n    d = [\n    // Left side\n    ['M', 0, maskTop], ['L', this.plotLeft - 1, maskTop], ['L', this.plotLeft - 1, maskBottom], ['L', 0, maskBottom], ['Z'],\n    // Right side\n    ['M', maskPlotRight, maskTop], ['L', this.chartWidth, maskTop], ['L', this.chartWidth, maskBottom], ['L', maskPlotRight, maskBottom], ['Z']];\n  } else if (this.scrollablePixelsY) {\n    d = [\n    // Top side\n    ['M', maskLeft, 0], ['L', maskLeft, this.plotTop - 1], ['L', maskRight, this.plotTop - 1], ['L', maskRight, 0], ['Z'],\n    // Bottom side\n    ['M', maskLeft, maskPlotBottom], ['L', maskLeft, this.chartHeight], ['L', maskRight, this.chartHeight], ['L', maskRight, maskPlotBottom], ['Z']];\n  } else {\n    d = [['M', 0, 0]];\n  }\n  if (this.redrawTrigger !== 'adjustHeight') {\n    this.scrollableMask.attr({\n      d\n    });\n  }\n};\naddEvent(Axis, 'afterInit', function () {\n  this.chart.scrollableDirty = true;\n});\naddEvent(Series, 'show', function () {\n  this.chart.scrollableDirty = true;\n});\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Options for a scrollable plot area. This feature provides a minimum size for\n * the plot area of the chart. If the size gets smaller than this, typically\n * on mobile devices, a native browser scrollbar is presented. This scrollbar\n * provides smooth scrolling for the contents of the plot area, whereas the\n * title, legend and unaffected axes are fixed.\n *\n * Since v7.1.2, a scrollable plot area can be defined for either horizontal or\n * vertical scrolling, depending on whether the `minWidth` or `minHeight`\n * option is set.\n *\n * @sample highcharts/chart/scrollable-plotarea\n *         Scrollable plot area\n * @sample highcharts/chart/scrollable-plotarea-vertical\n *         Vertically scrollable plot area\n * @sample {gantt} gantt/chart/scrollable-plotarea-vertical\n *         Gantt chart with vertically scrollable plot area\n *\n * @since     6.1.0\n * @product   highcharts gantt\n * @apioption chart.scrollablePlotArea\n */\n/**\n * The minimum height for the plot area. If it gets smaller than this, the plot\n * area will become scrollable.\n *\n * @type      {number}\n * @since     7.1.2\n * @apioption chart.scrollablePlotArea.minHeight\n */\n/**\n * The minimum width for the plot area. If it gets smaller than this, the plot\n * area will become scrollable.\n *\n * @type      {number}\n * @since     6.1.0\n * @apioption chart.scrollablePlotArea.minWidth\n */\n/**\n * The initial scrolling position of the scrollable plot area. Ranges from 0 to\n * 1, where 0 aligns the plot area to the left and 1 aligns it to the right.\n * Typically we would use 1 if the chart has right aligned Y axes.\n *\n * @type      {number}\n * @since     6.1.0\n * @apioption chart.scrollablePlotArea.scrollPositionX\n */\n/**\n * The initial scrolling position of the scrollable plot area. Ranges from 0 to\n * 1, where 0 aligns the plot area to the top and 1 aligns it to the bottom.\n *\n * @type      {number}\n * @since     7.1.2\n * @apioption chart.scrollablePlotArea.scrollPositionY\n */\n/**\n * The opacity of mask applied on one of the sides of the plot\n * area.\n *\n * @sample {highcharts} highcharts/chart/scrollable-plotarea-opacity\n *         Disabled opacity for the mask\n *\n * @type        {number}\n * @default     0.85\n * @since       7.1.1\n * @apioption   chart.scrollablePlotArea.opacity\n */\n''; // keep doclets above in transpiled file","map":{"version":3,"names":["A","stop","Axis","Chart","Series","RendererRegistry","U","addEvent","createElement","defined","merge","pick","e","scrollablePlotArea","options","chart","scrollableMinWidth","minWidth","scrollableMinHeight","minHeight","scrollablePixelsX","scrollablePixelsY","corrections","renderer","forExport","Math","max","chartWidth","scrollablePlotBox","plotBox","width","plotWidth","inverted","clipBox","height","name","value","chartHeight","plotHeight","skipAxes","axes","forEach","axis","side","getPlotLinePath","marginName","correctionValue","margin","path","prototype","apply","arguments","setAxisSize","setAxisTranslation","setUpScrolling","applyFixed","fixedDiv","css","WebkitOverflowScrolling","overflowX","overflowY","scrollingParent","className","position","renderTo","scrollingContainer","lastHoverPoint","pointer","chartPosition","hoverPoint","runPointActions","innerContainer","appendChild","container","moveFixedElements","fixedRenderer","fixedSelectors","axisClass","push","call","querySelectorAll","elem","namespaceURI","SVG_NS","box","parentNode","style","pointerEvents","firstTime","chartOptions","scrollableOptions","Renderer","getRendererType","scrollableWidth","scrollableHeight","overflow","zIndex","top","insertBefore","scrollableMask","attr","fill","backgroundColor","opacity","addClass","add","setSize","scrollableDirty","boxWrapper","viewBox","join","chartBackground","scrollPositionX","scrollLeft","scrollPositionY","scrollTop","axisOffset","maskTop","plotTop","maskLeft","plotLeft","maskBottom","maskRight","maskPlotRight","maskPlotBottom","d","redrawTrigger"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Extensions/ScrollablePlotArea.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Highcharts feature to make the Y axis stay fixed when scrolling the chart\n *  horizontally on mobile devices. Supports left and right side axes.\n */\n/*\nWIP on vertical scrollable plot area (#9378). To do:\n- Bottom axis positioning\n- Test with Gantt\n- Look for size optimizing the code\n- API and demos\n */\n'use strict';\nimport A from '../Core/Animation/AnimationUtilities.js';\nconst { stop } = A;\nimport Axis from '../Core/Axis/Axis.js';\nimport Chart from '../Core/Chart/Chart.js';\nimport Series from '../Core/Series/Series.js';\nimport RendererRegistry from '../Core/Renderer/RendererRegistry.js';\nimport U from '../Core/Utilities.js';\nconst { addEvent, createElement, defined, merge, pick } = U;\n/* eslint-disable no-invalid-this, valid-jsdoc */\naddEvent(Chart, 'afterSetChartSize', function (e) {\n    let scrollablePlotArea = this.options.chart.scrollablePlotArea, scrollableMinWidth = scrollablePlotArea && scrollablePlotArea.minWidth, scrollableMinHeight = scrollablePlotArea && scrollablePlotArea.minHeight, scrollablePixelsX, scrollablePixelsY, corrections;\n    if (!this.renderer.forExport) {\n        // The amount of pixels to scroll, the difference between chart\n        // width and scrollable width\n        if (scrollableMinWidth) {\n            this.scrollablePixelsX = scrollablePixelsX = Math.max(0, scrollableMinWidth - this.chartWidth);\n            if (scrollablePixelsX) {\n                this.scrollablePlotBox = (this.renderer.scrollablePlotBox = merge(this.plotBox));\n                this.plotBox.width = this.plotWidth += scrollablePixelsX;\n                if (this.inverted) {\n                    this.clipBox.height += scrollablePixelsX;\n                }\n                else {\n                    this.clipBox.width += scrollablePixelsX;\n                }\n                corrections = {\n                    // Corrections for right side\n                    1: { name: 'right', value: scrollablePixelsX }\n                };\n            }\n            // Currently we can only do either X or Y\n        }\n        else if (scrollableMinHeight) {\n            this.scrollablePixelsY = scrollablePixelsY = Math.max(0, scrollableMinHeight - this.chartHeight);\n            if (defined(scrollablePixelsY)) {\n                this.scrollablePlotBox = (this.renderer.scrollablePlotBox = merge(this.plotBox));\n                this.plotBox.height = this.plotHeight += scrollablePixelsY;\n                if (this.inverted) {\n                    this.clipBox.width += scrollablePixelsY;\n                }\n                else {\n                    this.clipBox.height += scrollablePixelsY;\n                }\n                corrections = {\n                    2: { name: 'bottom', value: scrollablePixelsY }\n                };\n            }\n        }\n        if (corrections && !e.skipAxes) {\n            this.axes.forEach(function (axis) {\n                // For right and bottom axes, only fix the plot line length\n                if (corrections[axis.side]) {\n                    // Get the plot lines right in getPlotLinePath,\n                    // temporarily set it to the adjusted plot width.\n                    axis.getPlotLinePath = function () {\n                        let marginName = corrections[axis.side].name, correctionValue = corrections[axis.side].value, \n                        // axis.right or axis.bottom\n                        margin = this[marginName], path;\n                        // Temporarily adjust\n                        this[marginName] = margin - correctionValue;\n                        path = Axis.prototype.getPlotLinePath.apply(this, arguments);\n                        // Reset\n                        this[marginName] = margin;\n                        return path;\n                    };\n                }\n                else {\n                    // Apply the corrected plotWidth\n                    axis.setAxisSize();\n                    axis.setAxisTranslation();\n                }\n            });\n        }\n    }\n});\naddEvent(Chart, 'render', function () {\n    if (this.scrollablePixelsX || this.scrollablePixelsY) {\n        if (this.setUpScrolling) {\n            this.setUpScrolling();\n        }\n        this.applyFixed();\n    }\n    else if (this.fixedDiv) { // Has been in scrollable mode\n        this.applyFixed();\n    }\n});\n/**\n * @private\n * @function Highcharts.Chart#setUpScrolling\n * @return {void}\n */\nChart.prototype.setUpScrolling = function () {\n    const css = {\n        WebkitOverflowScrolling: 'touch',\n        overflowX: 'hidden',\n        overflowY: 'hidden'\n    };\n    if (this.scrollablePixelsX) {\n        css.overflowX = 'auto';\n    }\n    if (this.scrollablePixelsY) {\n        css.overflowY = 'auto';\n    }\n    // Insert a container with position relative\n    // that scrolling and fixed container renders to (#10555)\n    this.scrollingParent = createElement('div', {\n        className: 'highcharts-scrolling-parent'\n    }, {\n        position: 'relative'\n    }, this.renderTo);\n    // Add the necessary divs to provide scrolling\n    this.scrollingContainer = createElement('div', {\n        'className': 'highcharts-scrolling'\n    }, css, this.scrollingParent);\n    // On scroll, reset the chart position because it applies to the scrolled\n    // container\n    let lastHoverPoint;\n    addEvent(this.scrollingContainer, 'scroll', () => {\n        if (this.pointer) {\n            delete this.pointer.chartPosition;\n            if (this.hoverPoint) {\n                lastHoverPoint = this.hoverPoint;\n            }\n            this.pointer.runPointActions(void 0, lastHoverPoint, true);\n        }\n    });\n    this.innerContainer = createElement('div', {\n        'className': 'highcharts-inner-container'\n    }, null, this.scrollingContainer);\n    // Now move the container inside\n    this.innerContainer.appendChild(this.container);\n    // Don't run again\n    this.setUpScrolling = null;\n};\n/**\n * These elements are moved over to the fixed renderer and stay fixed when the\n * user scrolls the chart\n * @private\n */\nChart.prototype.moveFixedElements = function () {\n    let container = this.container, fixedRenderer = this.fixedRenderer, fixedSelectors = [\n        '.highcharts-breadcrumbs-group',\n        '.highcharts-contextbutton',\n        '.highcharts-credits',\n        '.highcharts-legend',\n        '.highcharts-legend-checkbox',\n        '.highcharts-navigator-series',\n        '.highcharts-navigator-xaxis',\n        '.highcharts-navigator-yaxis',\n        '.highcharts-navigator',\n        '.highcharts-reset-zoom',\n        '.highcharts-drillup-button',\n        '.highcharts-scrollbar',\n        '.highcharts-subtitle',\n        '.highcharts-title'\n    ], axisClass;\n    if (this.scrollablePixelsX && !this.inverted) {\n        axisClass = '.highcharts-yaxis';\n    }\n    else if (this.scrollablePixelsX && this.inverted) {\n        axisClass = '.highcharts-xaxis';\n    }\n    else if (this.scrollablePixelsY && !this.inverted) {\n        axisClass = '.highcharts-xaxis';\n    }\n    else if (this.scrollablePixelsY && this.inverted) {\n        axisClass = '.highcharts-yaxis';\n    }\n    if (axisClass) {\n        fixedSelectors.push(`${axisClass}:not(.highcharts-radial-axis)`, `${axisClass}-labels:not(.highcharts-radial-axis-labels)`);\n    }\n    fixedSelectors.forEach(function (className) {\n        [].forEach.call(container.querySelectorAll(className), function (elem) {\n            (elem.namespaceURI === fixedRenderer.SVG_NS ?\n                fixedRenderer.box :\n                fixedRenderer.box.parentNode).appendChild(elem);\n            elem.style.pointerEvents = 'auto';\n        });\n    });\n};\n/**\n * @private\n * @function Highcharts.Chart#applyFixed\n * @return {void}\n */\nChart.prototype.applyFixed = function () {\n    const firstTime = !this.fixedDiv, chartOptions = this.options.chart, scrollableOptions = chartOptions.scrollablePlotArea, Renderer = RendererRegistry.getRendererType();\n    let fixedRenderer, scrollableWidth, scrollableHeight;\n    // First render\n    if (firstTime) {\n        this.fixedDiv = createElement('div', {\n            className: 'highcharts-fixed'\n        }, {\n            position: 'absolute',\n            overflow: 'hidden',\n            pointerEvents: 'none',\n            zIndex: (chartOptions.style && chartOptions.style.zIndex || 0) + 2,\n            top: 0\n        }, null, true);\n        if (this.scrollingContainer) {\n            this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer);\n        }\n        this.renderTo.style.overflow = 'visible';\n        this.fixedRenderer = fixedRenderer = new Renderer(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style);\n        // Mask\n        this.scrollableMask = fixedRenderer\n            .path()\n            .attr({\n            fill: this.options.chart.backgroundColor || '#fff',\n            'fill-opacity': pick(scrollableOptions.opacity, 0.85),\n            zIndex: -1\n        })\n            .addClass('highcharts-scrollable-mask')\n            .add();\n        addEvent(this, 'afterShowResetZoom', this.moveFixedElements);\n        addEvent(this, 'afterApplyDrilldown', this.moveFixedElements);\n        addEvent(this, 'afterLayOutTitles', this.moveFixedElements);\n    }\n    else {\n        // Set the size of the fixed renderer to the visible width\n        this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n    }\n    if (this.scrollableDirty || firstTime) {\n        this.scrollableDirty = false;\n        this.moveFixedElements();\n    }\n    // Increase the size of the scrollable renderer and background\n    scrollableWidth = this.chartWidth + (this.scrollablePixelsX || 0);\n    scrollableHeight = this.chartHeight + (this.scrollablePixelsY || 0);\n    stop(this.container);\n    this.container.style.width = scrollableWidth + 'px';\n    this.container.style.height = scrollableHeight + 'px';\n    this.renderer.boxWrapper.attr({\n        width: scrollableWidth,\n        height: scrollableHeight,\n        viewBox: [0, 0, scrollableWidth, scrollableHeight].join(' ')\n    });\n    this.chartBackground.attr({\n        width: scrollableWidth,\n        height: scrollableHeight\n    });\n    this.scrollingContainer.style.height = this.chartHeight + 'px';\n    // Set scroll position\n    if (firstTime) {\n        if (scrollableOptions.scrollPositionX) {\n            this.scrollingContainer.scrollLeft =\n                this.scrollablePixelsX *\n                    scrollableOptions.scrollPositionX;\n        }\n        if (scrollableOptions.scrollPositionY) {\n            this.scrollingContainer.scrollTop =\n                this.scrollablePixelsY *\n                    scrollableOptions.scrollPositionY;\n        }\n    }\n    // Mask behind the left and right side\n    let axisOffset = this.axisOffset, maskTop = this.plotTop - axisOffset[0] - 1, maskLeft = this.plotLeft - axisOffset[3] - 1, maskBottom = this.plotTop + this.plotHeight + axisOffset[2] + 1, maskRight = this.plotLeft + this.plotWidth + axisOffset[1] + 1, maskPlotRight = this.plotLeft + this.plotWidth -\n        (this.scrollablePixelsX || 0), maskPlotBottom = this.plotTop + this.plotHeight -\n        (this.scrollablePixelsY || 0), d;\n    if (this.scrollablePixelsX) {\n        d = [\n            // Left side\n            ['M', 0, maskTop],\n            ['L', this.plotLeft - 1, maskTop],\n            ['L', this.plotLeft - 1, maskBottom],\n            ['L', 0, maskBottom],\n            ['Z'],\n            // Right side\n            ['M', maskPlotRight, maskTop],\n            ['L', this.chartWidth, maskTop],\n            ['L', this.chartWidth, maskBottom],\n            ['L', maskPlotRight, maskBottom],\n            ['Z']\n        ];\n    }\n    else if (this.scrollablePixelsY) {\n        d = [\n            // Top side\n            ['M', maskLeft, 0],\n            ['L', maskLeft, this.plotTop - 1],\n            ['L', maskRight, this.plotTop - 1],\n            ['L', maskRight, 0],\n            ['Z'],\n            // Bottom side\n            ['M', maskLeft, maskPlotBottom],\n            ['L', maskLeft, this.chartHeight],\n            ['L', maskRight, this.chartHeight],\n            ['L', maskRight, maskPlotBottom],\n            ['Z']\n        ];\n    }\n    else {\n        d = [['M', 0, 0]];\n    }\n    if (this.redrawTrigger !== 'adjustHeight') {\n        this.scrollableMask.attr({ d });\n    }\n};\naddEvent(Axis, 'afterInit', function () {\n    this.chart.scrollableDirty = true;\n});\naddEvent(Series, 'show', function () {\n    this.chart.scrollableDirty = true;\n});\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Options for a scrollable plot area. This feature provides a minimum size for\n * the plot area of the chart. If the size gets smaller than this, typically\n * on mobile devices, a native browser scrollbar is presented. This scrollbar\n * provides smooth scrolling for the contents of the plot area, whereas the\n * title, legend and unaffected axes are fixed.\n *\n * Since v7.1.2, a scrollable plot area can be defined for either horizontal or\n * vertical scrolling, depending on whether the `minWidth` or `minHeight`\n * option is set.\n *\n * @sample highcharts/chart/scrollable-plotarea\n *         Scrollable plot area\n * @sample highcharts/chart/scrollable-plotarea-vertical\n *         Vertically scrollable plot area\n * @sample {gantt} gantt/chart/scrollable-plotarea-vertical\n *         Gantt chart with vertically scrollable plot area\n *\n * @since     6.1.0\n * @product   highcharts gantt\n * @apioption chart.scrollablePlotArea\n */\n/**\n * The minimum height for the plot area. If it gets smaller than this, the plot\n * area will become scrollable.\n *\n * @type      {number}\n * @since     7.1.2\n * @apioption chart.scrollablePlotArea.minHeight\n */\n/**\n * The minimum width for the plot area. If it gets smaller than this, the plot\n * area will become scrollable.\n *\n * @type      {number}\n * @since     6.1.0\n * @apioption chart.scrollablePlotArea.minWidth\n */\n/**\n * The initial scrolling position of the scrollable plot area. Ranges from 0 to\n * 1, where 0 aligns the plot area to the left and 1 aligns it to the right.\n * Typically we would use 1 if the chart has right aligned Y axes.\n *\n * @type      {number}\n * @since     6.1.0\n * @apioption chart.scrollablePlotArea.scrollPositionX\n */\n/**\n * The initial scrolling position of the scrollable plot area. Ranges from 0 to\n * 1, where 0 aligns the plot area to the top and 1 aligns it to the bottom.\n *\n * @type      {number}\n * @since     7.1.2\n * @apioption chart.scrollablePlotArea.scrollPositionY\n */\n/**\n * The opacity of mask applied on one of the sides of the plot\n * area.\n *\n * @sample {highcharts} highcharts/chart/scrollable-plotarea-opacity\n *         Disabled opacity for the mask\n *\n * @type        {number}\n * @default     0.85\n * @since       7.1.1\n * @apioption   chart.scrollablePlotArea.opacity\n */\n(''); // keep doclets above in transpiled file\n"],"mappings":"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,KAAK,cAAc,EAAE;IACvC,IAAI,CAAC3B,cAAc,CAACC,IAAI,CAAC;MAAEyB;IAAE,CAAC,CAAC;EACnC;AACJ,CAAC;AACDtH,QAAQ,CAACL,IAAI,EAAE,WAAW,EAAE,YAAY;EACpC,IAAI,CAACa,KAAK,CAAC4F,eAAe,GAAG,IAAI;AACrC,CAAC,CAAC;AACFpG,QAAQ,CAACH,MAAM,EAAE,MAAM,EAAE,YAAY;EACjC,IAAI,CAACW,KAAK,CAAC4F,eAAe,GAAG,IAAI;AACrC,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACC,EAAE,CAAE,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}