{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport A from '../Animation/AnimationUtilities.js';\nconst {\n  getDeferredAnimation\n} = A;\nimport F from '../Templating.js';\nconst {\n  format\n} = F;\nimport U from '../Utilities.js';\nconst {\n  defined,\n  extend,\n  fireEvent,\n  isArray,\n  isString,\n  merge,\n  objectEach,\n  pick,\n  pInt,\n  splat\n} = U;\n/* *\n *\n *  Composition\n *\n * */\n/* eslint-disable valid-jsdoc */\nvar DataLabel;\n(function (DataLabel) {\n  /* *\n   *\n   *  Declarations\n   *\n   * */\n  /* *\n   *\n   *  Constants\n   *\n   * */\n  const composedMembers = [];\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Check if this series has data labels, either a series-level setting, or\n   * individual. In case of individual point labels, this method is overridden\n   * to always return true.\n   * @private\n   */\n  function hasDataLabels() {\n    return splat(this.options.dataLabels || {}).some(o => o?.enabled);\n  }\n  /**\n   * Align each individual data label.\n   * @private\n   */\n  function alignDataLabel(point, dataLabel, options, alignTo, isNew) {\n    const series = this,\n      chart = this.chart,\n      inverted = this.isCartesian && chart.inverted,\n      enabledDataSorting = this.enabledDataSorting,\n      plotX = point.plotX,\n      plotY = point.plotY,\n      rotation = options.rotation,\n      align = options.align,\n      isInsidePlot = defined(plotX) && defined(plotY) && chart.isInsidePlot(plotX, Math.round(plotY), {\n        inverted,\n        paneCoordinates: true,\n        series\n      }),\n      setStartPos = alignOptions => {\n        if (enabledDataSorting && series.xAxis && !justify) {\n          series.setDataLabelStartPos(point, dataLabel, isNew, isInsidePlot, alignOptions);\n        }\n      };\n    let baseline,\n      rotCorr,\n      // rotation correction\n      // Math.round for rounding errors (#2683), alignTo to allow column\n      // labels (#2700)\n      alignAttr,\n      // the final position;\n      justify = pick(options.overflow, enabledDataSorting ? 'none' : 'justify') === 'justify',\n      visible = this.visible && point.visible !== false && defined(plotX) && (point.series.forceDL || enabledDataSorting && !justify || isInsidePlot ||\n      // If the data label is inside the align box, it is\n      // enough that parts of the align box is inside the\n      // plot area (#12370). When stacking, it is always\n      // inside regardless of the option (#15148).\n      pick(options.inside, !!this.options.stacking) && alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, {\n        inverted,\n        paneCoordinates: true,\n        series\n      }));\n    const pos = point.pos();\n    if (visible && pos) {\n      if (rotation) {\n        dataLabel.attr({\n          align\n        });\n      }\n      let bBox = dataLabel.getBBox(true),\n        bBoxCorrection = [0, 0];\n      baseline = chart.renderer.fontMetrics(dataLabel).b;\n      // The alignment box is a singular point\n      alignTo = extend({\n        x: pos[0],\n        y: Math.round(pos[1]),\n        width: 0,\n        height: 0\n      }, alignTo);\n      // Add the text size for alignment calculation\n      extend(options, {\n        width: bBox.width,\n        height: bBox.height\n      });\n      // Allow a hook for changing alignment in the last moment, then do\n      // the alignment\n      if (rotation) {\n        justify = false; // Not supported for rotated text\n        rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723\n        alignAttr = {\n          x: alignTo.x + (options.x || 0) + alignTo.width / 2 + rotCorr.x,\n          y: alignTo.y + (options.y || 0) + {\n            top: 0,\n            middle: 0.5,\n            bottom: 1\n          }[options.verticalAlign] * alignTo.height\n        };\n        bBoxCorrection = [bBox.x - Number(dataLabel.attr('x')), bBox.y - Number(dataLabel.attr('y'))];\n        setStartPos(alignAttr); // data sorting\n        dataLabel[isNew ? 'attr' : 'animate'](alignAttr);\n      } else {\n        setStartPos(alignTo); // data sorting\n        dataLabel.align(options, void 0, alignTo);\n        alignAttr = dataLabel.alignAttr;\n      }\n      // Handle justify or crop\n      if (justify && alignTo.height >= 0) {\n        // #8830\n        this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);\n        // Now check that the data label is within the plot area\n      } else if (pick(options.crop, true)) {\n        let {\n          x,\n          y\n        } = alignAttr;\n        x += bBoxCorrection[0];\n        y += bBoxCorrection[1];\n        // Uncomment this block to visualize the bounding boxes used for\n        // determining visibility\n        /*\n        chart.renderer.rect(\n            chart.plotLeft + alignAttr.x + bBox.x,\n            chart.plotTop + alignAttr.y + bBox.y + 9999,\n            bBox.width,\n            bBox.height\n        ).attr({\n            stroke: 'rgba(0, 0, 0, 0.3)',\n            'stroke-width': 0.5\n        }).add();\n        chart.renderer.circle(\n            chart.plotLeft + alignAttr.x,\n            chart.plotTop + alignAttr.y,\n            2\n        ).attr({\n            fill: 'red',\n            zIndex: 20\n        }).add();\n        // */\n        visible = chart.isInsidePlot(x, y, {\n          paneCoordinates: true,\n          series\n        }) && chart.isInsidePlot(x + bBox.width, y + bBox.height, {\n          paneCoordinates: true,\n          series\n        });\n      }\n      // When we're using a shape, make it possible with a connector or an\n      // arrow pointing to thie point\n      if (options.shape && !rotation) {\n        dataLabel[isNew ? 'attr' : 'animate']({\n          anchorX: pos[0],\n          anchorY: pos[1]\n        });\n      }\n    }\n    // To use alignAttr property in hideOverlappingLabels\n    if (isNew && enabledDataSorting) {\n      dataLabel.placed = false;\n    }\n    // Show or hide based on the final aligned position\n    if (!visible && (!enabledDataSorting || justify)) {\n      dataLabel.hide();\n      dataLabel.placed = false; // don't animate back in\n    } else {\n      dataLabel.show();\n    }\n  }\n  /**\n   * Handle the dataLabels.filter option.\n   * @private\n   */\n  function applyFilter(point, options) {\n    const filter = options.filter;\n    if (filter) {\n      const op = filter.operator;\n      const prop = point[filter.property];\n      const val = filter.value;\n      if (op === '>' && prop > val || op === '<' && prop < val || op === '>=' && prop >= val || op === '<=' && prop <= val || op === '==' && prop == val ||\n      // eslint-disable-line eqeqeq\n      op === '===' && prop === val) {\n        return true;\n      }\n      return false;\n    }\n    return true;\n  }\n  /**\n   * @private\n   */\n  function compose(SeriesClass) {\n    if (U.pushUnique(composedMembers, SeriesClass)) {\n      const seriesProto = SeriesClass.prototype;\n      seriesProto.initDataLabelsGroup = initDataLabelsGroup;\n      seriesProto.initDataLabels = initDataLabels;\n      seriesProto.alignDataLabel = alignDataLabel;\n      seriesProto.drawDataLabels = drawDataLabels;\n      seriesProto.justifyDataLabel = justifyDataLabel;\n      seriesProto.setDataLabelStartPos = setDataLabelStartPos;\n      seriesProto.hasDataLabels = hasDataLabels;\n    }\n  }\n  DataLabel.compose = compose;\n  /**\n   * Create the SVGElement group for dataLabels\n   * @private\n   */\n  function initDataLabelsGroup() {\n    return this.plotGroup('dataLabelsGroup', 'data-labels', this.hasRendered ? 'inherit' : 'hidden',\n    // #5133, #10220\n    this.options.dataLabels.zIndex || 6);\n  }\n  /**\n   * Init the data labels with the correct animation\n   * @private\n   */\n  function initDataLabels(animationConfig) {\n    const series = this,\n      hasRendered = series.hasRendered || 0;\n    // Create a separate group for the data labels to avoid rotation\n    const dataLabelsGroup = this.initDataLabelsGroup().attr({\n      opacity: +hasRendered\n    }); // #3300\n    if (!hasRendered && dataLabelsGroup) {\n      if (series.visible) {\n        // #2597, #3023, #3024\n        dataLabelsGroup.show();\n      }\n      if (series.options.animation) {\n        dataLabelsGroup.animate({\n          opacity: 1\n        }, animationConfig);\n      } else {\n        dataLabelsGroup.attr({\n          opacity: 1\n        });\n      }\n    }\n    return dataLabelsGroup;\n  }\n  /**\n   * Draw the data labels\n   * @private\n   */\n  function drawDataLabels(points) {\n    points = points || this.points;\n    const series = this,\n      chart = series.chart,\n      seriesOptions = series.options,\n      renderer = chart.renderer,\n      {\n        backgroundColor,\n        plotBackgroundColor\n      } = chart.options.chart,\n      plotOptions = chart.options.plotOptions,\n      contrastColor = renderer.getContrast(isString(plotBackgroundColor) && plotBackgroundColor || isString(backgroundColor) && backgroundColor || \"#000000\" /* Palette.neutralColor100 */);\n    let seriesDlOptions = seriesOptions.dataLabels,\n      pointOptions,\n      dataLabelsGroup;\n    // Merge in plotOptions.dataLabels for series\n    seriesDlOptions = mergeArrays(mergeArrays(plotOptions?.series?.dataLabels, plotOptions?.[series.type]?.dataLabels), seriesDlOptions);\n    // Resolve the animation\n    const {\n        animation,\n        defer\n      } = splat(seriesDlOptions)[0],\n      animationConfig = defer ? getDeferredAnimation(chart, animation, series) : {\n        defer: 0,\n        duration: 0\n      };\n    fireEvent(this, 'drawDataLabels');\n    if (series.hasDataLabels?.()) {\n      dataLabelsGroup = this.initDataLabels(animationConfig);\n      // Make the labels for each point\n      points.forEach(point => {\n        const dataLabels = point.dataLabels || [];\n        // Merge in series options for the point.\n        // @note dataLabelAttribs (like pointAttribs) would eradicate\n        // the need for dlOptions, and simplify the section below.\n        pointOptions = splat(mergeArrays(seriesDlOptions,\n        // The dlOptions prop is used in treemaps\n        point.dlOptions || point.options?.dataLabels));\n        // Handle each individual data label for this point\n        pointOptions.forEach((labelOptions, i) => {\n          // Options for one datalabel\n          const labelEnabled = labelOptions.enabled && point.visible && (\n            // #2282, #4641, #7112, #10049\n            !point.isNull || point.dataLabelOnNull) && applyFilter(point, labelOptions),\n            style = labelOptions.style || {},\n            labelDistance = labelOptions.distance;\n          let labelConfig,\n            formatString,\n            labelText,\n            rotation,\n            attr = {},\n            dataLabel = dataLabels[i],\n            isNew = !dataLabel;\n          if (labelEnabled) {\n            // Create individual options structure that can be\n            // extended without affecting others\n            formatString = pick(labelOptions[point.formatPrefix + 'Format'], labelOptions.format);\n            labelConfig = point.getLabelConfig();\n            labelText = defined(formatString) ? format(formatString, labelConfig, chart) : (labelOptions[point.formatPrefix + 'Formatter'] || labelOptions.formatter).call(labelConfig, labelOptions);\n            rotation = labelOptions.rotation;\n            if (!chart.styledMode) {\n              // Determine the color\n              style.color = pick(labelOptions.color, style.color, isString(series.color) ? series.color : void 0, \"#000000\" /* Palette.neutralColor100 */);\n              // Get automated contrast color\n              if (style.color === 'contrast') {\n                point.contrastColor = renderer.getContrast(point.color || series.color);\n                style.color = !defined(labelDistance) && labelOptions.inside || pInt(labelDistance || 0) < 0 || seriesOptions.stacking ? point.contrastColor : contrastColor;\n              } else {\n                delete point.contrastColor;\n              }\n              if (seriesOptions.cursor) {\n                style.cursor = seriesOptions.cursor;\n              }\n            }\n            attr = {\n              r: labelOptions.borderRadius || 0,\n              rotation,\n              padding: labelOptions.padding,\n              zIndex: 1\n            };\n            if (!chart.styledMode) {\n              const {\n                backgroundColor,\n                borderColor\n              } = labelOptions;\n              attr.fill = backgroundColor === 'auto' ? point.color : backgroundColor;\n              attr.stroke = borderColor === 'auto' ? point.color : borderColor;\n              attr['stroke-width'] = labelOptions.borderWidth;\n            }\n            // Remove unused attributes (#947)\n            objectEach(attr, (val, name) => {\n              if (typeof val === 'undefined') {\n                delete attr[name];\n              }\n            });\n          }\n          // If the point is outside the plot area, or the label\n          // changes properties that we cannot change, destroy it and\n          // build a new one below. #678, #820.\n          if (dataLabel && (!labelEnabled || !defined(labelText) || !!dataLabel.div !== !!labelOptions.useHTML ||\n          // Change from no rotation to rotation and\n          // vice versa. Don't use defined() because\n          // rotation = 0 means also rotation = undefined\n          (!dataLabel.rotation || !labelOptions.rotation) && dataLabel.rotation !== labelOptions.rotation)) {\n            dataLabel = void 0;\n            isNew = true;\n          }\n          // Individual labels are disabled if the are explicitly\n          // disabled in the point options, or if they fall outside\n          // the plot area.\n          if (labelEnabled && defined(labelText)) {\n            if (!dataLabel) {\n              // Create new label element\n              dataLabel = rotation ?\n              // Labels don't rotate, use text element\n              renderer.text(labelText, 0, 0, labelOptions.useHTML).addClass('highcharts-data-label') :\n              // We can use label\n              renderer.label(labelText, 0, 0, labelOptions.shape, void 0, void 0, labelOptions.useHTML, void 0, 'data-label');\n              if (dataLabel) {\n                dataLabel.addClass(' highcharts-data-label-color-' + point.colorIndex + ' ' + (labelOptions.className || '') + (\n                // #3398\n                labelOptions.useHTML ? ' highcharts-tracker' : ''));\n              }\n            } else {\n              // Use old element and just update text\n              attr.text = labelText;\n            }\n            // Store data label options for later access\n            if (dataLabel) {\n              dataLabel.options = labelOptions;\n              dataLabel.attr(attr);\n              if (!chart.styledMode) {\n                // Styles must be applied before add in order to\n                // read text bounding box\n                dataLabel.css(style).shadow(labelOptions.shadow);\n              }\n              const textPathOptions = labelOptions[point.formatPrefix + 'TextPath'] || labelOptions.textPath;\n              if (textPathOptions && !labelOptions.useHTML) {\n                dataLabel.setTextPath(point.getDataLabelPath?.(dataLabel) || point.graphic, textPathOptions);\n                if (point.dataLabelPath && !textPathOptions.enabled) {\n                  // clean the DOM\n                  point.dataLabelPath = point.dataLabelPath.destroy();\n                }\n              }\n              if (!dataLabel.added) {\n                dataLabel.add(dataLabelsGroup);\n              }\n              // Now the data label is created and placed at 0,0,\n              // so we need to align it\n              series.alignDataLabel(point, dataLabel, labelOptions, void 0, isNew);\n              dataLabel.isActive = true;\n              if (dataLabels[i] && dataLabels[i] !== dataLabel) {\n                dataLabels[i].destroy();\n              }\n              dataLabels[i] = dataLabel;\n            }\n          }\n        });\n        // Destroy and remove the inactive ones\n        let j = dataLabels.length;\n        while (j--) {\n          // The item can be undefined if a disabled data label is\n          // succeeded by an enabled one (#19457)\n          if (!dataLabels[j] || !dataLabels[j].isActive) {\n            dataLabels[j]?.destroy();\n            dataLabels.splice(j, 1);\n          } else {\n            dataLabels[j].isActive = false;\n          }\n        }\n        // Write back\n        point.dataLabel = dataLabels[0];\n        point.dataLabels = dataLabels;\n      });\n    }\n    fireEvent(this, 'afterDrawDataLabels');\n  }\n  /**\n   * If data labels fall partly outside the plot area, align them back in, in\n   * a way that doesn't hide the point.\n   * @private\n   */\n  function justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew) {\n    const chart = this.chart,\n      align = options.align,\n      verticalAlign = options.verticalAlign,\n      padding = dataLabel.box ? 0 : dataLabel.padding || 0;\n    let {\n        x = 0,\n        y = 0\n      } = options,\n      off,\n      justified;\n    // Off left\n    off = (alignAttr.x || 0) + padding;\n    if (off < 0) {\n      if (align === 'right' && x >= 0) {\n        options.align = 'left';\n        options.inside = true;\n      } else {\n        x -= off;\n      }\n      justified = true;\n    }\n    // Off right\n    off = (alignAttr.x || 0) + bBox.width - padding;\n    if (off > chart.plotWidth) {\n      if (align === 'left' && x <= 0) {\n        options.align = 'right';\n        options.inside = true;\n      } else {\n        x += chart.plotWidth - off;\n      }\n      justified = true;\n    }\n    // Off top\n    off = alignAttr.y + padding;\n    if (off < 0) {\n      if (verticalAlign === 'bottom' && y >= 0) {\n        options.verticalAlign = 'top';\n        options.inside = true;\n      } else {\n        y -= off;\n      }\n      justified = true;\n    }\n    // Off bottom\n    off = (alignAttr.y || 0) + bBox.height - padding;\n    if (off > chart.plotHeight) {\n      if (verticalAlign === 'top' && y <= 0) {\n        options.verticalAlign = 'bottom';\n        options.inside = true;\n      } else {\n        y += chart.plotHeight - off;\n      }\n      justified = true;\n    }\n    if (justified) {\n      options.x = x;\n      options.y = y;\n      dataLabel.placed = !isNew;\n      dataLabel.align(options, void 0, alignTo);\n    }\n    return justified;\n  }\n  /**\n   * Merge two objects that can be arrays. If one of them is an array, the\n   * other is merged into each element. If both are arrays, each element is\n   * merged by index. If neither are arrays, we use normal merge.\n   * @private\n   */\n  function mergeArrays(one, two) {\n    let res = [],\n      i;\n    if (isArray(one) && !isArray(two)) {\n      res = one.map(function (el) {\n        return merge(el, two);\n      });\n    } else if (isArray(two) && !isArray(one)) {\n      res = two.map(function (el) {\n        return merge(one, el);\n      });\n    } else if (!isArray(one) && !isArray(two)) {\n      res = merge(one, two);\n    } else if (isArray(one) && isArray(two)) {\n      i = Math.max(one.length, two.length);\n      while (i--) {\n        res[i] = merge(one[i], two[i]);\n      }\n    }\n    return res;\n  }\n  /**\n   * Set starting position for data label sorting animation.\n   * @private\n   */\n  function setDataLabelStartPos(point, dataLabel, isNew, isInside, alignOptions) {\n    const chart = this.chart,\n      inverted = chart.inverted,\n      xAxis = this.xAxis,\n      reversed = xAxis.reversed,\n      labelCenter = ((inverted ? dataLabel.height : dataLabel.width) || 0) / 2,\n      pointWidth = point.pointWidth,\n      halfWidth = pointWidth ? pointWidth / 2 : 0;\n    dataLabel.startXPos = inverted ? alignOptions.x : reversed ? -labelCenter - halfWidth : xAxis.width - labelCenter + halfWidth;\n    dataLabel.startYPos = inverted ? reversed ? this.yAxis.height - labelCenter + halfWidth : -labelCenter - halfWidth : alignOptions.y;\n    // We need to handle visibility in case of sorting point outside plot\n    // area\n    if (!isInside) {\n      dataLabel.attr({\n        opacity: 1\n      }).animate({\n        opacity: 0\n      }, void 0, dataLabel.hide);\n    } else if (dataLabel.visibility === 'hidden') {\n      dataLabel.show();\n      dataLabel.attr({\n        opacity: 0\n      }).animate({\n        opacity: 1\n      });\n    }\n    // Save start position on first render, but do not change position\n    if (!chart.hasRendered) {\n      return;\n    }\n    // Set start position\n    if (isNew) {\n      dataLabel.attr({\n        x: dataLabel.startXPos,\n        y: dataLabel.startYPos\n      });\n    }\n    dataLabel.placed = true;\n  }\n})(DataLabel || (DataLabel = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default DataLabel;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Callback JavaScript function to format the data label as a string. Note that\n * if a `format` is defined, the format takes precedence and the formatter is\n * ignored.\n *\n * @callback Highcharts.DataLabelsFormatterCallbackFunction\n *\n * @param {Highcharts.PointLabelObject} this\n * Data label context to format\n *\n * @param {Highcharts.DataLabelsOptions} options\n * [API options](/highcharts/plotOptions.series.dataLabels) of the data label\n *\n * @return {number|string|null|undefined}\n * Formatted data label text\n */\n/**\n * Values for handling data labels that flow outside the plot area.\n *\n * @typedef {\"allow\"|\"justify\"} Highcharts.DataLabelsOverflowValue\n */\n''; // keeps doclets above in JS file","map":{"version":3,"names":["A","getDeferredAnimation","F","format","U","defined","extend","fireEvent","isArray","isString","merge","objectEach","pick","pInt","splat","DataLabel","composedMembers","hasDataLabels","options","dataLabels","some","o","enabled","alignDataLabel","point","dataLabel","alignTo","isNew","series","chart","inverted","isCartesian","enabledDataSorting","plotX","plotY","rotation","align","isInsidePlot","Math","round","paneCoordinates","setStartPos","alignOptions","xAxis","justify","setDataLabelStartPos","baseline","rotCorr","alignAttr","overflow","visible","forceDL","inside","stacking","x","y","height","pos","attr","bBox","getBBox","bBoxCorrection","renderer","fontMetrics","b","width","top","middle","bottom","verticalAlign","Number","justifyDataLabel","crop","shape","anchorX","anchorY","placed","hide","show","applyFilter","filter","op","operator","prop","property","val","value","compose","SeriesClass","pushUnique","seriesProto","prototype","initDataLabelsGroup","initDataLabels","drawDataLabels","plotGroup","hasRendered","zIndex","animationConfig","dataLabelsGroup","opacity","animation","animate","points","seriesOptions","backgroundColor","plotBackgroundColor","plotOptions","contrastColor","getContrast","seriesDlOptions","pointOptions","mergeArrays","type","defer","duration","forEach","dlOptions","labelOptions","i","labelEnabled","isNull","dataLabelOnNull","style","labelDistance","distance","labelConfig","formatString","labelText","formatPrefix","getLabelConfig","formatter","call","styledMode","color","cursor","r","borderRadius","padding","borderColor","fill","stroke","borderWidth","name","div","useHTML","text","addClass","label","colorIndex","className","css","shadow","textPathOptions","textPath","setTextPath","getDataLabelPath","graphic","dataLabelPath","destroy","added","add","isActive","j","length","splice","box","off","justified","plotWidth","plotHeight","one","two","res","map","el","max","isInside","reversed","labelCenter","pointWidth","halfWidth","startXPos","startYPos","yAxis","visibility"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Series/DataLabel.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport A from '../Animation/AnimationUtilities.js';\nconst { getDeferredAnimation } = A;\nimport F from '../Templating.js';\nconst { format } = F;\nimport U from '../Utilities.js';\nconst { defined, extend, fireEvent, isArray, isString, merge, objectEach, pick, pInt, splat } = U;\n/* *\n *\n *  Composition\n *\n * */\n/* eslint-disable valid-jsdoc */\nvar DataLabel;\n(function (DataLabel) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Constants\n     *\n     * */\n    const composedMembers = [];\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Check if this series has data labels, either a series-level setting, or\n     * individual. In case of individual point labels, this method is overridden\n     * to always return true.\n     * @private\n     */\n    function hasDataLabels() {\n        return splat(this.options.dataLabels || {}).some((o) => o?.enabled);\n    }\n    /**\n     * Align each individual data label.\n     * @private\n     */\n    function alignDataLabel(point, dataLabel, options, alignTo, isNew) {\n        const series = this, chart = this.chart, inverted = this.isCartesian && chart.inverted, enabledDataSorting = this.enabledDataSorting, plotX = point.plotX, plotY = point.plotY, rotation = options.rotation, align = options.align, isInsidePlot = defined(plotX) &&\n            defined(plotY) &&\n            chart.isInsidePlot(plotX, Math.round(plotY), {\n                inverted,\n                paneCoordinates: true,\n                series\n            }), setStartPos = (alignOptions) => {\n            if (enabledDataSorting && series.xAxis && !justify) {\n                series.setDataLabelStartPos(point, dataLabel, isNew, isInsidePlot, alignOptions);\n            }\n        };\n        let baseline, rotCorr, // rotation correction\n        // Math.round for rounding errors (#2683), alignTo to allow column\n        // labels (#2700)\n        alignAttr, // the final position;\n        justify = pick(options.overflow, (enabledDataSorting ? 'none' : 'justify')) === 'justify', visible = this.visible &&\n            point.visible !== false &&\n            defined(plotX) &&\n            (point.series.forceDL ||\n                (enabledDataSorting && !justify) ||\n                isInsidePlot ||\n                (\n                // If the data label is inside the align box, it is\n                // enough that parts of the align box is inside the\n                // plot area (#12370). When stacking, it is always\n                // inside regardless of the option (#15148).\n                pick(options.inside, !!this.options.stacking) &&\n                    alignTo &&\n                    chart.isInsidePlot(plotX, inverted ?\n                        alignTo.x + 1 :\n                        alignTo.y + alignTo.height - 1, {\n                        inverted,\n                        paneCoordinates: true,\n                        series\n                    })));\n        const pos = point.pos();\n        if (visible && pos) {\n            if (rotation) {\n                dataLabel.attr({ align });\n            }\n            let bBox = dataLabel.getBBox(true), bBoxCorrection = [0, 0];\n            baseline = chart.renderer.fontMetrics(dataLabel).b;\n            // The alignment box is a singular point\n            alignTo = extend({\n                x: pos[0],\n                y: Math.round(pos[1]),\n                width: 0,\n                height: 0\n            }, alignTo);\n            // Add the text size for alignment calculation\n            extend(options, {\n                width: bBox.width,\n                height: bBox.height\n            });\n            // Allow a hook for changing alignment in the last moment, then do\n            // the alignment\n            if (rotation) {\n                justify = false; // Not supported for rotated text\n                rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723\n                alignAttr = {\n                    x: (alignTo.x +\n                        (options.x || 0) +\n                        alignTo.width / 2 +\n                        rotCorr.x),\n                    y: (alignTo.y +\n                        (options.y || 0) +\n                        { top: 0, middle: 0.5, bottom: 1 }[options.verticalAlign] *\n                            alignTo.height)\n                };\n                bBoxCorrection = [\n                    bBox.x - Number(dataLabel.attr('x')),\n                    bBox.y - Number(dataLabel.attr('y'))\n                ];\n                setStartPos(alignAttr); // data sorting\n                dataLabel[isNew ? 'attr' : 'animate'](alignAttr);\n            }\n            else {\n                setStartPos(alignTo); // data sorting\n                dataLabel.align(options, void 0, alignTo);\n                alignAttr = dataLabel.alignAttr;\n            }\n            // Handle justify or crop\n            if (justify && alignTo.height >= 0) { // #8830\n                this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);\n                // Now check that the data label is within the plot area\n            }\n            else if (pick(options.crop, true)) {\n                let { x, y } = alignAttr;\n                x += bBoxCorrection[0];\n                y += bBoxCorrection[1];\n                // Uncomment this block to visualize the bounding boxes used for\n                // determining visibility\n                /*\n                chart.renderer.rect(\n                    chart.plotLeft + alignAttr.x + bBox.x,\n                    chart.plotTop + alignAttr.y + bBox.y + 9999,\n                    bBox.width,\n                    bBox.height\n                ).attr({\n                    stroke: 'rgba(0, 0, 0, 0.3)',\n                    'stroke-width': 0.5\n                }).add();\n                chart.renderer.circle(\n                    chart.plotLeft + alignAttr.x,\n                    chart.plotTop + alignAttr.y,\n                    2\n                ).attr({\n                    fill: 'red',\n                    zIndex: 20\n                }).add();\n                // */\n                visible =\n                    chart.isInsidePlot(x, y, {\n                        paneCoordinates: true,\n                        series\n                    }) &&\n                        chart.isInsidePlot(x + bBox.width, y + bBox.height, {\n                            paneCoordinates: true,\n                            series\n                        });\n            }\n            // When we're using a shape, make it possible with a connector or an\n            // arrow pointing to thie point\n            if (options.shape && !rotation) {\n                dataLabel[isNew ? 'attr' : 'animate']({\n                    anchorX: pos[0],\n                    anchorY: pos[1]\n                });\n            }\n        }\n        // To use alignAttr property in hideOverlappingLabels\n        if (isNew && enabledDataSorting) {\n            dataLabel.placed = false;\n        }\n        // Show or hide based on the final aligned position\n        if (!visible && (!enabledDataSorting || justify)) {\n            dataLabel.hide();\n            dataLabel.placed = false; // don't animate back in\n        }\n        else {\n            dataLabel.show();\n        }\n    }\n    /**\n     * Handle the dataLabels.filter option.\n     * @private\n     */\n    function applyFilter(point, options) {\n        const filter = options.filter;\n        if (filter) {\n            const op = filter.operator;\n            const prop = point[filter.property];\n            const val = filter.value;\n            if ((op === '>' && prop > val) ||\n                (op === '<' && prop < val) ||\n                (op === '>=' && prop >= val) ||\n                (op === '<=' && prop <= val) ||\n                (op === '==' && prop == val) || // eslint-disable-line eqeqeq\n                (op === '===' && prop === val)) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * @private\n     */\n    function compose(SeriesClass) {\n        if (U.pushUnique(composedMembers, SeriesClass)) {\n            const seriesProto = SeriesClass.prototype;\n            seriesProto.initDataLabelsGroup = initDataLabelsGroup;\n            seriesProto.initDataLabels = initDataLabels;\n            seriesProto.alignDataLabel = alignDataLabel;\n            seriesProto.drawDataLabels = drawDataLabels;\n            seriesProto.justifyDataLabel = justifyDataLabel;\n            seriesProto.setDataLabelStartPos = setDataLabelStartPos;\n            seriesProto.hasDataLabels = hasDataLabels;\n        }\n    }\n    DataLabel.compose = compose;\n    /**\n     * Create the SVGElement group for dataLabels\n     * @private\n     */\n    function initDataLabelsGroup() {\n        return this.plotGroup('dataLabelsGroup', 'data-labels', this.hasRendered ? 'inherit' : 'hidden', // #5133, #10220\n        this.options.dataLabels.zIndex || 6);\n    }\n    /**\n     * Init the data labels with the correct animation\n     * @private\n     */\n    function initDataLabels(animationConfig) {\n        const series = this, hasRendered = series.hasRendered || 0;\n        // Create a separate group for the data labels to avoid rotation\n        const dataLabelsGroup = this.initDataLabelsGroup()\n            .attr({ opacity: +hasRendered }); // #3300\n        if (!hasRendered && dataLabelsGroup) {\n            if (series.visible) { // #2597, #3023, #3024\n                dataLabelsGroup.show();\n            }\n            if (series.options.animation) {\n                dataLabelsGroup.animate({ opacity: 1 }, animationConfig);\n            }\n            else {\n                dataLabelsGroup.attr({ opacity: 1 });\n            }\n        }\n        return dataLabelsGroup;\n    }\n    /**\n     * Draw the data labels\n     * @private\n     */\n    function drawDataLabels(points) {\n        points = points || this.points;\n        const series = this, chart = series.chart, seriesOptions = series.options, renderer = chart.renderer, { backgroundColor, plotBackgroundColor } = chart.options.chart, plotOptions = chart.options.plotOptions, contrastColor = renderer.getContrast((isString(plotBackgroundColor) && plotBackgroundColor) ||\n            (isString(backgroundColor) && backgroundColor) ||\n            \"#000000\" /* Palette.neutralColor100 */);\n        let seriesDlOptions = seriesOptions.dataLabels, pointOptions, dataLabelsGroup;\n        // Merge in plotOptions.dataLabels for series\n        seriesDlOptions = mergeArrays(mergeArrays(plotOptions?.series?.dataLabels, plotOptions?.[series.type]?.dataLabels), seriesDlOptions);\n        // Resolve the animation\n        const { animation, defer } = splat(seriesDlOptions)[0], animationConfig = defer ?\n            getDeferredAnimation(chart, animation, series) :\n            { defer: 0, duration: 0 };\n        fireEvent(this, 'drawDataLabels');\n        if (series.hasDataLabels?.()) {\n            dataLabelsGroup = this.initDataLabels(animationConfig);\n            // Make the labels for each point\n            points.forEach((point) => {\n                const dataLabels = point.dataLabels || [];\n                // Merge in series options for the point.\n                // @note dataLabelAttribs (like pointAttribs) would eradicate\n                // the need for dlOptions, and simplify the section below.\n                pointOptions = splat(mergeArrays(seriesDlOptions, \n                // The dlOptions prop is used in treemaps\n                point.dlOptions || point.options?.dataLabels));\n                // Handle each individual data label for this point\n                pointOptions.forEach((labelOptions, i) => {\n                    // Options for one datalabel\n                    const labelEnabled = (labelOptions.enabled &&\n                        point.visible &&\n                        // #2282, #4641, #7112, #10049\n                        (!point.isNull || point.dataLabelOnNull) &&\n                        applyFilter(point, labelOptions)), style = labelOptions.style || {}, labelDistance = labelOptions.distance;\n                    let labelConfig, formatString, labelText, rotation, attr = {}, dataLabel = dataLabels[i], isNew = !dataLabel;\n                    if (labelEnabled) {\n                        // Create individual options structure that can be\n                        // extended without affecting others\n                        formatString = pick(labelOptions[point.formatPrefix + 'Format'], labelOptions.format);\n                        labelConfig = point.getLabelConfig();\n                        labelText = defined(formatString) ?\n                            format(formatString, labelConfig, chart) :\n                            (labelOptions[point.formatPrefix + 'Formatter'] ||\n                                labelOptions.formatter).call(labelConfig, labelOptions);\n                        rotation = labelOptions.rotation;\n                        if (!chart.styledMode) {\n                            // Determine the color\n                            style.color = pick(labelOptions.color, style.color, isString(series.color) ? series.color : void 0, \"#000000\" /* Palette.neutralColor100 */);\n                            // Get automated contrast color\n                            if (style.color === 'contrast') {\n                                point.contrastColor = renderer.getContrast((point.color || series.color));\n                                style.color = ((!defined(labelDistance) &&\n                                    labelOptions.inside) ||\n                                    pInt(labelDistance || 0) < 0 ||\n                                    seriesOptions.stacking) ?\n                                    point.contrastColor :\n                                    contrastColor;\n                            }\n                            else {\n                                delete point.contrastColor;\n                            }\n                            if (seriesOptions.cursor) {\n                                style.cursor = seriesOptions.cursor;\n                            }\n                        }\n                        attr = {\n                            r: labelOptions.borderRadius || 0,\n                            rotation,\n                            padding: labelOptions.padding,\n                            zIndex: 1\n                        };\n                        if (!chart.styledMode) {\n                            const { backgroundColor, borderColor } = labelOptions;\n                            attr.fill = backgroundColor === 'auto' ?\n                                point.color :\n                                backgroundColor;\n                            attr.stroke = borderColor === 'auto' ?\n                                point.color :\n                                borderColor;\n                            attr['stroke-width'] = labelOptions.borderWidth;\n                        }\n                        // Remove unused attributes (#947)\n                        objectEach(attr, (val, name) => {\n                            if (typeof val === 'undefined') {\n                                delete attr[name];\n                            }\n                        });\n                    }\n                    // If the point is outside the plot area, or the label\n                    // changes properties that we cannot change, destroy it and\n                    // build a new one below. #678, #820.\n                    if (dataLabel && (!labelEnabled ||\n                        !defined(labelText) ||\n                        !!dataLabel.div !== !!labelOptions.useHTML ||\n                        (\n                        // Change from no rotation to rotation and\n                        // vice versa. Don't use defined() because\n                        // rotation = 0 means also rotation = undefined\n                        (!dataLabel.rotation ||\n                            !labelOptions.rotation) &&\n                            dataLabel.rotation !== labelOptions.rotation))) {\n                        dataLabel = void 0;\n                        isNew = true;\n                    }\n                    // Individual labels are disabled if the are explicitly\n                    // disabled in the point options, or if they fall outside\n                    // the plot area.\n                    if (labelEnabled && defined(labelText)) {\n                        if (!dataLabel) {\n                            // Create new label element\n                            dataLabel = rotation ?\n                                // Labels don't rotate, use text element\n                                renderer.text(labelText, 0, 0, labelOptions.useHTML)\n                                    .addClass('highcharts-data-label') :\n                                // We can use label\n                                renderer.label(labelText, 0, 0, labelOptions.shape, void 0, void 0, labelOptions.useHTML, void 0, 'data-label');\n                            if (dataLabel) {\n                                dataLabel.addClass(' highcharts-data-label-color-' +\n                                    point.colorIndex +\n                                    ' ' + (labelOptions.className || '') +\n                                    ( // #3398\n                                    labelOptions.useHTML ?\n                                        ' highcharts-tracker' :\n                                        ''));\n                            }\n                        }\n                        else {\n                            // Use old element and just update text\n                            attr.text = labelText;\n                        }\n                        // Store data label options for later access\n                        if (dataLabel) {\n                            dataLabel.options = labelOptions;\n                            dataLabel.attr(attr);\n                            if (!chart.styledMode) {\n                                // Styles must be applied before add in order to\n                                // read text bounding box\n                                dataLabel.css(style).shadow(labelOptions.shadow);\n                            }\n                            const textPathOptions = labelOptions[point.formatPrefix + 'TextPath'] || labelOptions.textPath;\n                            if (textPathOptions && !labelOptions.useHTML) {\n                                dataLabel.setTextPath(point.getDataLabelPath?.(dataLabel) ||\n                                    point.graphic, textPathOptions);\n                                if (point.dataLabelPath &&\n                                    !textPathOptions.enabled) {\n                                    // clean the DOM\n                                    point.dataLabelPath = (point.dataLabelPath.destroy());\n                                }\n                            }\n                            if (!dataLabel.added) {\n                                dataLabel.add(dataLabelsGroup);\n                            }\n                            // Now the data label is created and placed at 0,0,\n                            // so we need to align it\n                            series.alignDataLabel(point, dataLabel, labelOptions, void 0, isNew);\n                            dataLabel.isActive = true;\n                            if (dataLabels[i] && dataLabels[i] !== dataLabel) {\n                                dataLabels[i].destroy();\n                            }\n                            dataLabels[i] = dataLabel;\n                        }\n                    }\n                });\n                // Destroy and remove the inactive ones\n                let j = dataLabels.length;\n                while (j--) {\n                    // The item can be undefined if a disabled data label is\n                    // succeeded by an enabled one (#19457)\n                    if (!dataLabels[j] || !dataLabels[j].isActive) {\n                        dataLabels[j]?.destroy();\n                        dataLabels.splice(j, 1);\n                    }\n                    else {\n                        dataLabels[j].isActive = false;\n                    }\n                }\n                // Write back\n                point.dataLabel = dataLabels[0];\n                point.dataLabels = dataLabels;\n            });\n        }\n        fireEvent(this, 'afterDrawDataLabels');\n    }\n    /**\n     * If data labels fall partly outside the plot area, align them back in, in\n     * a way that doesn't hide the point.\n     * @private\n     */\n    function justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew) {\n        const chart = this.chart, align = options.align, verticalAlign = options.verticalAlign, padding = dataLabel.box ? 0 : (dataLabel.padding || 0);\n        let { x = 0, y = 0 } = options, off, justified;\n        // Off left\n        off = (alignAttr.x || 0) + padding;\n        if (off < 0) {\n            if (align === 'right' && x >= 0) {\n                options.align = 'left';\n                options.inside = true;\n            }\n            else {\n                x -= off;\n            }\n            justified = true;\n        }\n        // Off right\n        off = (alignAttr.x || 0) + bBox.width - padding;\n        if (off > chart.plotWidth) {\n            if (align === 'left' && x <= 0) {\n                options.align = 'right';\n                options.inside = true;\n            }\n            else {\n                x += chart.plotWidth - off;\n            }\n            justified = true;\n        }\n        // Off top\n        off = alignAttr.y + padding;\n        if (off < 0) {\n            if (verticalAlign === 'bottom' && y >= 0) {\n                options.verticalAlign = 'top';\n                options.inside = true;\n            }\n            else {\n                y -= off;\n            }\n            justified = true;\n        }\n        // Off bottom\n        off = (alignAttr.y || 0) + bBox.height - padding;\n        if (off > chart.plotHeight) {\n            if (verticalAlign === 'top' && y <= 0) {\n                options.verticalAlign = 'bottom';\n                options.inside = true;\n            }\n            else {\n                y += chart.plotHeight - off;\n            }\n            justified = true;\n        }\n        if (justified) {\n            options.x = x;\n            options.y = y;\n            dataLabel.placed = !isNew;\n            dataLabel.align(options, void 0, alignTo);\n        }\n        return justified;\n    }\n    /**\n     * Merge two objects that can be arrays. If one of them is an array, the\n     * other is merged into each element. If both are arrays, each element is\n     * merged by index. If neither are arrays, we use normal merge.\n     * @private\n     */\n    function mergeArrays(one, two) {\n        let res = [], i;\n        if (isArray(one) && !isArray(two)) {\n            res = one.map(function (el) {\n                return merge(el, two);\n            });\n        }\n        else if (isArray(two) && !isArray(one)) {\n            res = two.map(function (el) {\n                return merge(one, el);\n            });\n        }\n        else if (!isArray(one) && !isArray(two)) {\n            res = merge(one, two);\n        }\n        else if (isArray(one) && isArray(two)) {\n            i = Math.max(one.length, two.length);\n            while (i--) {\n                res[i] = merge(one[i], two[i]);\n            }\n        }\n        return res;\n    }\n    /**\n     * Set starting position for data label sorting animation.\n     * @private\n     */\n    function setDataLabelStartPos(point, dataLabel, isNew, isInside, alignOptions) {\n        const chart = this.chart, inverted = chart.inverted, xAxis = this.xAxis, reversed = xAxis.reversed, labelCenter = ((inverted ? dataLabel.height : dataLabel.width) || 0) / 2, pointWidth = point.pointWidth, halfWidth = pointWidth ? pointWidth / 2 : 0;\n        dataLabel.startXPos = inverted ?\n            alignOptions.x :\n            (reversed ?\n                -labelCenter - halfWidth :\n                xAxis.width - labelCenter + halfWidth);\n        dataLabel.startYPos = inverted ?\n            (reversed ?\n                this.yAxis.height - labelCenter + halfWidth :\n                -labelCenter - halfWidth) : alignOptions.y;\n        // We need to handle visibility in case of sorting point outside plot\n        // area\n        if (!isInside) {\n            dataLabel\n                .attr({ opacity: 1 })\n                .animate({ opacity: 0 }, void 0, dataLabel.hide);\n        }\n        else if (dataLabel.visibility === 'hidden') {\n            dataLabel.show();\n            dataLabel\n                .attr({ opacity: 0 })\n                .animate({ opacity: 1 });\n        }\n        // Save start position on first render, but do not change position\n        if (!chart.hasRendered) {\n            return;\n        }\n        // Set start position\n        if (isNew) {\n            dataLabel.attr({ x: dataLabel.startXPos, y: dataLabel.startYPos });\n        }\n        dataLabel.placed = true;\n    }\n})(DataLabel || (DataLabel = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default DataLabel;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Callback JavaScript function to format the data label as a string. Note that\n * if a `format` is defined, the format takes precedence and the formatter is\n * ignored.\n *\n * @callback Highcharts.DataLabelsFormatterCallbackFunction\n *\n * @param {Highcharts.PointLabelObject} this\n * Data label context to format\n *\n * @param {Highcharts.DataLabelsOptions} options\n * [API options](/highcharts/plotOptions.series.dataLabels) of the data label\n *\n * @return {number|string|null|undefined}\n * Formatted data label text\n */\n/**\n * Values for handling data labels that flow outside the plot area.\n *\n * @typedef {\"allow\"|\"justify\"} Highcharts.DataLabelsOverflowValue\n */\n''; // keeps doclets above in JS file\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}