{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport D from './Defaults.js';\nconst {\n  defaultOptions,\n  defaultTime\n} = D;\nimport U from './Utilities.js';\nconst {\n  extend,\n  getNestedProperty,\n  isArray,\n  isNumber,\n  isObject,\n  isString,\n  pick,\n  pInt\n} = U;\nconst helpers = {\n  // Built-in helpers\n  add: (a, b) => a + b,\n  divide: (a, b) => b !== 0 ? a / b : '',\n  // eslint-disable-next-line eqeqeq\n  eq: (a, b) => a == b,\n  each: function (arr) {\n    const match = arguments[arguments.length - 1];\n    return isArray(arr) ? arr.map((item, i) => format(match.body, extend(isObject(item) ? item : {\n      '@this': item\n    }, {\n      '@index': i,\n      '@first': i === 0,\n      '@last': i === arr.length - 1\n    }))).join('') : false;\n  },\n  ge: (a, b) => a >= b,\n  gt: (a, b) => a > b,\n  'if': condition => !!condition,\n  le: (a, b) => a <= b,\n  lt: (a, b) => a < b,\n  multiply: (a, b) => a * b,\n  // eslint-disable-next-line eqeqeq\n  ne: (a, b) => a != b,\n  subtract: (a, b) => a - b,\n  unless: condition => !condition\n};\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970) into a\n * human readable date string. The format is a subset of the formats for PHP's\n * [strftime](https://www.php.net/manual/en/function.strftime.php) function.\n * Additional formats can be given in the {@link Highcharts.dateFormats} hook.\n *\n * Since v6.0.5, all internal dates are formatted through the\n * {@link Highcharts.Chart#time} instance to respect chart-level time settings.\n * The `Highcharts.dateFormat` function only reflects global time settings set\n * with `setOptions`.\n *\n * Supported format keys:\n * - `%a`: Short weekday, like 'Mon'\n * - `%A`: Long weekday, like 'Monday'\n * - `%d`: Two digit day of the month, 01 to 31\n * - `%e`: Day of the month, 1 through 31\n * - `%w`: Day of the week, 0 through 6\n * - `%b`: Short month, like 'Jan'\n * - `%B`: Long month, like 'January'\n * - `%m`: Two digit month number, 01 through 12\n * - `%y`: Two digits year, like 09 for 2009\n * - `%Y`: Four digits year, like 2009\n * - `%H`: Two digits hours in 24h format, 00 through 23\n * - `%k`: Hours in 24h format, 0 through 23\n * - `%I`: Two digits hours in 12h format, 00 through 11\n * - `%l`: Hours in 12h format, 1 through 12\n * - `%M`: Two digits minutes, 00 through 59\n * - `%p`: Upper case AM or PM\n * - `%P`: Lower case AM or PM\n * - `%S`: Two digits seconds, 00 through 59\n * - `%L`: Milliseconds (naming from Ruby)\n *\n * @function Highcharts.dateFormat\n *\n * @param {string} format\n *        The desired format where various time representations are prefixed\n *        with `%`.\n *\n * @param {number} timestamp\n *        The JavaScript timestamp.\n *\n * @param {boolean} [capitalize=false]\n *        Upper case first letter in the return.\n *\n * @return {string}\n *         The formatted date.\n */\nfunction dateFormat(format, timestamp, capitalize) {\n  return defaultTime.dateFormat(format, timestamp, capitalize);\n}\n/**\n * Format a string according to a subset of the rules of Python's String.format\n * method.\n *\n * @example\n * let s = Highcharts.format(\n *     'The {color} fox was {len:.2f} feet long',\n *     { color: 'red', len: Math.PI }\n * );\n * // => The red fox was 3.14 feet long\n *\n * @function Highcharts.format\n *\n * @param {string} str\n *        The string to format.\n *\n * @param {Record<string, *>} ctx\n *        The context, a collection of key-value pairs where each key is\n *        replaced by its value.\n *\n * @param {Highcharts.Chart} [chart]\n *        A `Chart` instance used to get numberFormatter and time.\n *\n * @return {string}\n *         The formatted string.\n */\nfunction format(str = '', ctx, chart) {\n  const regex = /\\{([a-zA-Z0-9\\:\\.\\,;\\-\\/<>%_@\"'= #\\(\\)]+)\\}/g,\n    // The sub expression regex is the same as the top expression regex,\n    // but except parens and block helpers (#), and surrounded by parens\n    // instead of curly brackets.\n    subRegex = /\\(([a-zA-Z0-9\\:\\.\\,;\\-\\/<>%_@\"'= ]+)\\)/g,\n    matches = [],\n    floatRegex = /f$/,\n    decRegex = /\\.([0-9])/,\n    lang = defaultOptions.lang,\n    time = chart && chart.time || defaultTime,\n    numberFormatter = chart && chart.numberFormatter || numberFormat;\n  /*\n   * Get a literal or variable value inside a template expression. May be\n   * extended with other types like string or null if needed, but keep it\n   * small for now.\n   */\n  const resolveProperty = (key = '') => {\n    let n;\n    // Literals\n    if (key === 'true') {\n      return true;\n    }\n    if (key === 'false') {\n      return false;\n    }\n    if ((n = Number(key)).toString() === key) {\n      return n;\n    }\n    // Variables and constants\n    return getNestedProperty(key, ctx);\n  };\n  let match,\n    currentMatch,\n    depth = 0,\n    hasSub;\n  // Parse and create tree\n  while ((match = regex.exec(str)) !== null) {\n    // When a sub expression is found, it is evaluated first, and the\n    // results recursively evaluated until no subexpression exists.\n    const subMatch = subRegex.exec(match[1]);\n    if (subMatch) {\n      match = subMatch;\n      hasSub = true;\n    }\n    if (!currentMatch || !currentMatch.isBlock) {\n      currentMatch = {\n        ctx,\n        expression: match[1],\n        find: match[0],\n        isBlock: match[1].charAt(0) === '#',\n        start: match.index,\n        startInner: match.index + match[0].length,\n        length: match[0].length\n      };\n    }\n    // Identify helpers\n    const fn = match[1].split(' ')[0].replace('#', '');\n    if (helpers[fn]) {\n      // Block helper, only 0 level is handled\n      if (currentMatch.isBlock && fn === currentMatch.fn) {\n        depth++;\n      }\n      if (!currentMatch.fn) {\n        currentMatch.fn = fn;\n      }\n    }\n    // Closing a block helper\n    const startingElseSection = match[1] === 'else';\n    if (currentMatch.isBlock && currentMatch.fn && (match[1] === `/${currentMatch.fn}` || startingElseSection)) {\n      if (!depth) {\n        // === 0\n        const start = currentMatch.startInner,\n          body = str.substr(start, match.index - start);\n        // Either closing without an else section, or when encountering\n        // an else section\n        if (currentMatch.body === void 0) {\n          currentMatch.body = body;\n          currentMatch.startInner = match.index + match[0].length;\n          // The body exists already, so this is the else section\n        } else {\n          currentMatch.elseBody = body;\n        }\n        currentMatch.find += body + match[0];\n        if (!startingElseSection) {\n          matches.push(currentMatch);\n          currentMatch = void 0;\n        }\n      } else if (!startingElseSection) {\n        depth--;\n      }\n      // Common expression\n    } else if (!currentMatch.isBlock) {\n      matches.push(currentMatch);\n    }\n    // Evaluate sub-matches one by one to prevent orphaned block closers\n    if (subMatch && !currentMatch?.isBlock) {\n      break;\n    }\n  }\n  // Execute\n  matches.forEach(match => {\n    const {\n      body,\n      elseBody,\n      expression,\n      fn\n    } = match;\n    let replacement, i;\n    // Helper function\n    if (fn) {\n      // Pass the helpers the amount of arguments defined by the function,\n      // then the match as the last argument.\n      const args = [match],\n        parts = expression.split(' ');\n      i = helpers[fn].length;\n      while (i--) {\n        args.unshift(resolveProperty(parts[i + 1]));\n      }\n      replacement = helpers[fn].apply(ctx, args);\n      // Block helpers may return true or false. They may also return a\n      // string, like the `each` helper.\n      if (match.isBlock && typeof replacement === 'boolean') {\n        replacement = format(replacement ? body : elseBody, ctx);\n      }\n      // Simple variable replacement\n    } else {\n      const valueAndFormat = expression.split(':');\n      replacement = resolveProperty(valueAndFormat.shift() || '');\n      // Format the replacement\n      if (valueAndFormat.length && typeof replacement === 'number') {\n        const segment = valueAndFormat.join(':');\n        if (floatRegex.test(segment)) {\n          // float\n          const decimals = parseInt((segment.match(decRegex) || ['', '-1'])[1], 10);\n          if (replacement !== null) {\n            replacement = numberFormatter(replacement, decimals, lang.decimalPoint, segment.indexOf(',') > -1 ? lang.thousandsSep : '');\n          }\n        } else {\n          replacement = time.dateFormat(segment, replacement);\n        }\n      }\n    }\n    str = str.replace(match.find, pick(replacement, ''));\n  });\n  return hasSub ? format(str, ctx, chart) : str;\n}\n/**\n * Format a number and return a string based on input settings.\n *\n * @sample highcharts/members/highcharts-numberformat/\n *         Custom number format\n *\n * @function Highcharts.numberFormat\n *\n * @param {number} number\n *        The input number to format.\n *\n * @param {number} decimals\n *        The amount of decimals. A value of -1 preserves the amount in the\n *        input number.\n *\n * @param {string} [decimalPoint]\n *        The decimal point, defaults to the one given in the lang options, or\n *        a dot.\n *\n * @param {string} [thousandsSep]\n *        The thousands separator, defaults to the one given in the lang\n *        options, or a space character.\n *\n * @return {string}\n *         The formatted number.\n */\nfunction numberFormat(number, decimals, decimalPoint, thousandsSep) {\n  number = +number || 0;\n  decimals = +decimals;\n  let ret, fractionDigits;\n  const lang = defaultOptions.lang,\n    origDec = (number.toString().split('.')[1] || '').split('e')[0].length,\n    exponent = number.toString().split('e'),\n    firstDecimals = decimals;\n  if (decimals === -1) {\n    // Preserve decimals. Not huge numbers (#3793).\n    decimals = Math.min(origDec, 20);\n  } else if (!isNumber(decimals)) {\n    decimals = 2;\n  } else if (decimals && exponent[1] && exponent[1] < 0) {\n    // Expose decimals from exponential notation (#7042)\n    fractionDigits = decimals + +exponent[1];\n    if (fractionDigits >= 0) {\n      // remove too small part of the number while keeping the notation\n      exponent[0] = (+exponent[0]).toExponential(fractionDigits).split('e')[0];\n      decimals = fractionDigits;\n    } else {\n      // fractionDigits < 0\n      exponent[0] = exponent[0].split('.')[0] || 0;\n      if (decimals < 20) {\n        // use number instead of exponential notation (#7405)\n        number = (exponent[0] * Math.pow(10, exponent[1])).toFixed(decimals);\n      } else {\n        // or zero\n        number = 0;\n      }\n      exponent[1] = 0;\n    }\n  }\n  // Add another decimal to avoid rounding errors of float numbers. (#4573)\n  // Then use toFixed to handle rounding.\n  const roundedNumber = (Math.abs(exponent[1] ? exponent[0] : number) + Math.pow(10, -Math.max(decimals, origDec) - 1)).toFixed(decimals);\n  // A string containing the positive integer component of the number\n  const strinteger = String(pInt(roundedNumber));\n  // Leftover after grouping into thousands. Can be 0, 1 or 2.\n  const thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;\n  // Language\n  decimalPoint = pick(decimalPoint, lang.decimalPoint);\n  thousandsSep = pick(thousandsSep, lang.thousandsSep);\n  // Start building the return\n  ret = number < 0 ? '-' : '';\n  // Add the leftover after grouping into thousands. For example, in the\n  // number 42 000 000, this line adds 42.\n  ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';\n  if (+exponent[1] < 0 && !firstDecimals) {\n    ret = '0';\n  } else {\n    // Add the remaining thousands groups, joined by the thousands separator\n    ret += strinteger.substr(thousands).replace(/(\\d{3})(?=\\d)/g, '$1' + thousandsSep);\n  }\n  // Add the decimal point and the decimal component\n  if (decimals) {\n    // Get the decimal component\n    ret += decimalPoint + roundedNumber.slice(-decimals);\n  }\n  if (exponent[1] && +ret !== 0) {\n    ret += 'e' + exponent[1];\n  }\n  return ret;\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst Templating = {\n  dateFormat,\n  format,\n  helpers,\n  numberFormat\n};\nexport default Templating;","map":{"version":3,"names":["D","defaultOptions","defaultTime","U","extend","getNestedProperty","isArray","isNumber","isObject","isString","pick","pInt","helpers","add","a","b","divide","eq","each","arr","match","arguments","length","map","item","i","format","body","join","ge","gt","condition","le","lt","multiply","ne","subtract","unless","dateFormat","timestamp","capitalize","str","ctx","chart","regex","subRegex","matches","floatRegex","decRegex","lang","time","numberFormatter","numberFormat","resolveProperty","key","n","Number","toString","currentMatch","depth","hasSub","exec","subMatch","isBlock","expression","find","charAt","start","index","startInner","fn","split","replace","startingElseSection","substr","elseBody","push","forEach","replacement","args","parts","unshift","apply","valueAndFormat","shift","segment","test","decimals","parseInt","decimalPoint","indexOf","thousandsSep","number","ret","fractionDigits","origDec","exponent","firstDecimals","Math","min","toExponential","pow","toFixed","roundedNumber","abs","max","strinteger","String","thousands","slice","Templating"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Templating.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport D from './Defaults.js';\nconst { defaultOptions, defaultTime } = D;\nimport U from './Utilities.js';\nconst { extend, getNestedProperty, isArray, isNumber, isObject, isString, pick, pInt } = U;\nconst helpers = {\n    // Built-in helpers\n    add: (a, b) => a + b,\n    divide: (a, b) => (b !== 0 ? a / b : ''),\n    // eslint-disable-next-line eqeqeq\n    eq: (a, b) => a == b,\n    each: function (arr) {\n        const match = arguments[arguments.length - 1];\n        return isArray(arr) ?\n            arr.map((item, i) => format(match.body, extend(isObject(item) ? item : { '@this': item }, {\n                '@index': i,\n                '@first': i === 0,\n                '@last': i === arr.length - 1\n            }))).join('') :\n            false;\n    },\n    ge: (a, b) => a >= b,\n    gt: (a, b) => a > b,\n    'if': (condition) => !!condition,\n    le: (a, b) => a <= b,\n    lt: (a, b) => a < b,\n    multiply: (a, b) => a * b,\n    // eslint-disable-next-line eqeqeq\n    ne: (a, b) => a != b,\n    subtract: (a, b) => a - b,\n    unless: (condition) => !condition\n};\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970) into a\n * human readable date string. The format is a subset of the formats for PHP's\n * [strftime](https://www.php.net/manual/en/function.strftime.php) function.\n * Additional formats can be given in the {@link Highcharts.dateFormats} hook.\n *\n * Since v6.0.5, all internal dates are formatted through the\n * {@link Highcharts.Chart#time} instance to respect chart-level time settings.\n * The `Highcharts.dateFormat` function only reflects global time settings set\n * with `setOptions`.\n *\n * Supported format keys:\n * - `%a`: Short weekday, like 'Mon'\n * - `%A`: Long weekday, like 'Monday'\n * - `%d`: Two digit day of the month, 01 to 31\n * - `%e`: Day of the month, 1 through 31\n * - `%w`: Day of the week, 0 through 6\n * - `%b`: Short month, like 'Jan'\n * - `%B`: Long month, like 'January'\n * - `%m`: Two digit month number, 01 through 12\n * - `%y`: Two digits year, like 09 for 2009\n * - `%Y`: Four digits year, like 2009\n * - `%H`: Two digits hours in 24h format, 00 through 23\n * - `%k`: Hours in 24h format, 0 through 23\n * - `%I`: Two digits hours in 12h format, 00 through 11\n * - `%l`: Hours in 12h format, 1 through 12\n * - `%M`: Two digits minutes, 00 through 59\n * - `%p`: Upper case AM or PM\n * - `%P`: Lower case AM or PM\n * - `%S`: Two digits seconds, 00 through 59\n * - `%L`: Milliseconds (naming from Ruby)\n *\n * @function Highcharts.dateFormat\n *\n * @param {string} format\n *        The desired format where various time representations are prefixed\n *        with `%`.\n *\n * @param {number} timestamp\n *        The JavaScript timestamp.\n *\n * @param {boolean} [capitalize=false]\n *        Upper case first letter in the return.\n *\n * @return {string}\n *         The formatted date.\n */\nfunction dateFormat(format, timestamp, capitalize) {\n    return defaultTime.dateFormat(format, timestamp, capitalize);\n}\n/**\n * Format a string according to a subset of the rules of Python's String.format\n * method.\n *\n * @example\n * let s = Highcharts.format(\n *     'The {color} fox was {len:.2f} feet long',\n *     { color: 'red', len: Math.PI }\n * );\n * // => The red fox was 3.14 feet long\n *\n * @function Highcharts.format\n *\n * @param {string} str\n *        The string to format.\n *\n * @param {Record<string, *>} ctx\n *        The context, a collection of key-value pairs where each key is\n *        replaced by its value.\n *\n * @param {Highcharts.Chart} [chart]\n *        A `Chart` instance used to get numberFormatter and time.\n *\n * @return {string}\n *         The formatted string.\n */\nfunction format(str = '', ctx, chart) {\n    const regex = /\\{([a-zA-Z0-9\\:\\.\\,;\\-\\/<>%_@\"'= #\\(\\)]+)\\}/g, \n    // The sub expression regex is the same as the top expression regex,\n    // but except parens and block helpers (#), and surrounded by parens\n    // instead of curly brackets.\n    subRegex = /\\(([a-zA-Z0-9\\:\\.\\,;\\-\\/<>%_@\"'= ]+)\\)/g, matches = [], floatRegex = /f$/, decRegex = /\\.([0-9])/, lang = defaultOptions.lang, time = chart && chart.time || defaultTime, numberFormatter = chart && chart.numberFormatter || numberFormat;\n    /*\n     * Get a literal or variable value inside a template expression. May be\n     * extended with other types like string or null if needed, but keep it\n     * small for now.\n     */\n    const resolveProperty = (key = '') => {\n        let n;\n        // Literals\n        if (key === 'true') {\n            return true;\n        }\n        if (key === 'false') {\n            return false;\n        }\n        if ((n = Number(key)).toString() === key) {\n            return n;\n        }\n        // Variables and constants\n        return getNestedProperty(key, ctx);\n    };\n    let match, currentMatch, depth = 0, hasSub;\n    // Parse and create tree\n    while ((match = regex.exec(str)) !== null) {\n        // When a sub expression is found, it is evaluated first, and the\n        // results recursively evaluated until no subexpression exists.\n        const subMatch = subRegex.exec(match[1]);\n        if (subMatch) {\n            match = subMatch;\n            hasSub = true;\n        }\n        if (!currentMatch || !currentMatch.isBlock) {\n            currentMatch = {\n                ctx,\n                expression: match[1],\n                find: match[0],\n                isBlock: match[1].charAt(0) === '#',\n                start: match.index,\n                startInner: match.index + match[0].length,\n                length: match[0].length\n            };\n        }\n        // Identify helpers\n        const fn = match[1].split(' ')[0].replace('#', '');\n        if (helpers[fn]) {\n            // Block helper, only 0 level is handled\n            if (currentMatch.isBlock && fn === currentMatch.fn) {\n                depth++;\n            }\n            if (!currentMatch.fn) {\n                currentMatch.fn = fn;\n            }\n        }\n        // Closing a block helper\n        const startingElseSection = match[1] === 'else';\n        if (currentMatch.isBlock &&\n            currentMatch.fn && (match[1] === `/${currentMatch.fn}` ||\n            startingElseSection)) {\n            if (!depth) { // === 0\n                const start = currentMatch.startInner, body = str.substr(start, match.index - start);\n                // Either closing without an else section, or when encountering\n                // an else section\n                if (currentMatch.body === void 0) {\n                    currentMatch.body = body;\n                    currentMatch.startInner = match.index + match[0].length;\n                    // The body exists already, so this is the else section\n                }\n                else {\n                    currentMatch.elseBody = body;\n                }\n                currentMatch.find += body + match[0];\n                if (!startingElseSection) {\n                    matches.push(currentMatch);\n                    currentMatch = void 0;\n                }\n            }\n            else if (!startingElseSection) {\n                depth--;\n            }\n            // Common expression\n        }\n        else if (!currentMatch.isBlock) {\n            matches.push(currentMatch);\n        }\n        // Evaluate sub-matches one by one to prevent orphaned block closers\n        if (subMatch && !currentMatch?.isBlock) {\n            break;\n        }\n    }\n    // Execute\n    matches.forEach((match) => {\n        const { body, elseBody, expression, fn } = match;\n        let replacement, i;\n        // Helper function\n        if (fn) {\n            // Pass the helpers the amount of arguments defined by the function,\n            // then the match as the last argument.\n            const args = [match], parts = expression.split(' ');\n            i = helpers[fn].length;\n            while (i--) {\n                args.unshift(resolveProperty(parts[i + 1]));\n            }\n            replacement = helpers[fn].apply(ctx, args);\n            // Block helpers may return true or false. They may also return a\n            // string, like the `each` helper.\n            if (match.isBlock && typeof replacement === 'boolean') {\n                replacement = format(replacement ? body : elseBody, ctx);\n            }\n            // Simple variable replacement\n        }\n        else {\n            const valueAndFormat = expression.split(':');\n            replacement = resolveProperty(valueAndFormat.shift() || '');\n            // Format the replacement\n            if (valueAndFormat.length && typeof replacement === 'number') {\n                const segment = valueAndFormat.join(':');\n                if (floatRegex.test(segment)) { // float\n                    const decimals = parseInt((segment.match(decRegex) || ['', '-1'])[1], 10);\n                    if (replacement !== null) {\n                        replacement = numberFormatter(replacement, decimals, lang.decimalPoint, segment.indexOf(',') > -1 ? lang.thousandsSep : '');\n                    }\n                }\n                else {\n                    replacement = time.dateFormat(segment, replacement);\n                }\n            }\n        }\n        str = str.replace(match.find, pick(replacement, ''));\n    });\n    return hasSub ? format(str, ctx, chart) : str;\n}\n/**\n * Format a number and return a string based on input settings.\n *\n * @sample highcharts/members/highcharts-numberformat/\n *         Custom number format\n *\n * @function Highcharts.numberFormat\n *\n * @param {number} number\n *        The input number to format.\n *\n * @param {number} decimals\n *        The amount of decimals. A value of -1 preserves the amount in the\n *        input number.\n *\n * @param {string} [decimalPoint]\n *        The decimal point, defaults to the one given in the lang options, or\n *        a dot.\n *\n * @param {string} [thousandsSep]\n *        The thousands separator, defaults to the one given in the lang\n *        options, or a space character.\n *\n * @return {string}\n *         The formatted number.\n */\nfunction numberFormat(number, decimals, decimalPoint, thousandsSep) {\n    number = +number || 0;\n    decimals = +decimals;\n    let ret, fractionDigits;\n    const lang = defaultOptions.lang, origDec = (number.toString().split('.')[1] || '').split('e')[0].length, exponent = number.toString().split('e'), firstDecimals = decimals;\n    if (decimals === -1) {\n        // Preserve decimals. Not huge numbers (#3793).\n        decimals = Math.min(origDec, 20);\n    }\n    else if (!isNumber(decimals)) {\n        decimals = 2;\n    }\n    else if (decimals && exponent[1] && exponent[1] < 0) {\n        // Expose decimals from exponential notation (#7042)\n        fractionDigits = decimals + +exponent[1];\n        if (fractionDigits >= 0) {\n            // remove too small part of the number while keeping the notation\n            exponent[0] = (+exponent[0]).toExponential(fractionDigits)\n                .split('e')[0];\n            decimals = fractionDigits;\n        }\n        else {\n            // fractionDigits < 0\n            exponent[0] = exponent[0].split('.')[0] || 0;\n            if (decimals < 20) {\n                // use number instead of exponential notation (#7405)\n                number = (exponent[0] * Math.pow(10, exponent[1]))\n                    .toFixed(decimals);\n            }\n            else {\n                // or zero\n                number = 0;\n            }\n            exponent[1] = 0;\n        }\n    }\n    // Add another decimal to avoid rounding errors of float numbers. (#4573)\n    // Then use toFixed to handle rounding.\n    const roundedNumber = (Math.abs(exponent[1] ? exponent[0] : number) +\n        Math.pow(10, -Math.max(decimals, origDec) - 1)).toFixed(decimals);\n    // A string containing the positive integer component of the number\n    const strinteger = String(pInt(roundedNumber));\n    // Leftover after grouping into thousands. Can be 0, 1 or 2.\n    const thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;\n    // Language\n    decimalPoint = pick(decimalPoint, lang.decimalPoint);\n    thousandsSep = pick(thousandsSep, lang.thousandsSep);\n    // Start building the return\n    ret = number < 0 ? '-' : '';\n    // Add the leftover after grouping into thousands. For example, in the\n    // number 42 000 000, this line adds 42.\n    ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';\n    if (+exponent[1] < 0 && !firstDecimals) {\n        ret = '0';\n    }\n    else {\n        // Add the remaining thousands groups, joined by the thousands separator\n        ret += strinteger\n            .substr(thousands)\n            .replace(/(\\d{3})(?=\\d)/g, '$1' + thousandsSep);\n    }\n    // Add the decimal point and the decimal component\n    if (decimals) {\n        // Get the decimal component\n        ret += decimalPoint + roundedNumber.slice(-decimals);\n    }\n    if (exponent[1] && +ret !== 0) {\n        ret += 'e' + exponent[1];\n    }\n    return ret;\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst Templating = {\n    dateFormat,\n    format,\n    helpers,\n    numberFormat\n};\nexport default Templating;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}