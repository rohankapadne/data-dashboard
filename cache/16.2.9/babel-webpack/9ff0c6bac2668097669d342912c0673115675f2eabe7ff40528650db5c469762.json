{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport F from './Templating.js';\nconst {\n  format\n} = F;\nimport H from './Globals.js';\nconst {\n  doc,\n  isSafari\n} = H;\nimport R from './Renderer/RendererUtilities.js';\nconst {\n  distribute\n} = R;\nimport RendererRegistry from './Renderer/RendererRegistry.js';\nimport U from './Utilities.js';\nconst {\n  addEvent,\n  clamp,\n  css,\n  discardElement,\n  extend,\n  fireEvent,\n  isArray,\n  isNumber,\n  isString,\n  merge,\n  pick,\n  splat,\n  syncTimeout\n} = U;\n/* *\n *\n *  Class\n *\n * */\n/* eslint-disable no-invalid-this, valid-jsdoc */\n/**\n * Tooltip of a chart.\n *\n * @class\n * @name Highcharts.Tooltip\n *\n * @param {Highcharts.Chart} chart\n * The chart instance.\n *\n * @param {Highcharts.TooltipOptions} options\n * Tooltip options.\n */\nclass Tooltip {\n  /* *\n   *\n   *  Constructors\n   *\n   * */\n  constructor(chart, options) {\n    /* *\n     *\n     *  Properties\n     *\n     * */\n    this.allowShared = true;\n    this.crosshairs = [];\n    this.distance = 0;\n    this.isHidden = true;\n    this.isSticky = false;\n    this.now = {};\n    this.options = {};\n    this.outside = false;\n    this.chart = chart;\n    this.init(chart, options);\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * Build the body (lines) of the tooltip by iterating over the items and\n   * returning one entry for each item, abstracting this functionality allows\n   * to easily overwrite and extend it.\n   *\n   * @private\n   * @function Highcharts.Tooltip#bodyFormatter\n   */\n  bodyFormatter(items) {\n    return items.map(function (item) {\n      const tooltipOptions = item.series.tooltipOptions;\n      return (tooltipOptions[(item.point.formatPrefix || 'point') + 'Formatter'] || item.point.tooltipFormatter).call(item.point, tooltipOptions[(item.point.formatPrefix || 'point') + 'Format'] || '');\n    });\n  }\n  /**\n   * Destroy the single tooltips in a split tooltip.\n   * If the tooltip is active then it is not destroyed, unless forced to.\n   *\n   * @private\n   * @function Highcharts.Tooltip#cleanSplit\n   *\n   * @param {boolean} [force]\n   * Force destroy all tooltips.\n   */\n  cleanSplit(force) {\n    this.chart.series.forEach(function (series) {\n      const tt = series && series.tt;\n      if (tt) {\n        if (!tt.isActive || force) {\n          series.tt = tt.destroy();\n        } else {\n          tt.isActive = false;\n        }\n      }\n    });\n  }\n  /**\n   * In case no user defined formatter is given, this will be used. Note that\n   * the context here is an object holding point, series, x, y etc.\n   *\n   * @function Highcharts.Tooltip#defaultFormatter\n   *\n   * @param {Highcharts.Tooltip} tooltip\n   *\n   * @return {string|Array<string>}\n   * Returns a string (single tooltip and shared)\n   * or an array of strings (split tooltip)\n   */\n  defaultFormatter(tooltip) {\n    const items = this.points || splat(this);\n    let s;\n    // Build the header\n    s = [tooltip.tooltipFooterHeaderFormatter(items[0])];\n    // build the values\n    s = s.concat(tooltip.bodyFormatter(items));\n    // footer\n    s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));\n    return s;\n  }\n  /**\n   * Removes and destroys the tooltip and its elements.\n   *\n   * @function Highcharts.Tooltip#destroy\n   */\n  destroy() {\n    // Destroy and clear local variables\n    if (this.label) {\n      this.label = this.label.destroy();\n    }\n    if (this.split) {\n      this.cleanSplit(true);\n      if (this.tt) {\n        this.tt = this.tt.destroy();\n      }\n    }\n    if (this.renderer) {\n      this.renderer = this.renderer.destroy();\n      discardElement(this.container);\n    }\n    U.clearTimeout(this.hideTimer);\n    U.clearTimeout(this.tooltipTimeout);\n  }\n  /**\n   * Extendable method to get the anchor position of the tooltip\n   * from a point or set of points\n   *\n   * @private\n   * @function Highcharts.Tooltip#getAnchor\n   */\n  getAnchor(points, mouseEvent) {\n    const chart = this.chart,\n      pointer = chart.pointer,\n      inverted = chart.inverted,\n      plotTop = chart.plotTop,\n      plotLeft = chart.plotLeft;\n    let ret;\n    points = splat(points);\n    // If reversedStacks are false the tooltip position should be taken from\n    // the last point (#17948)\n    if (points[0].series && points[0].series.yAxis && !points[0].series.yAxis.options.reversedStacks) {\n      points = points.slice().reverse();\n    }\n    // When tooltip follows mouse, relate the position to the mouse\n    if (this.followPointer && mouseEvent) {\n      if (typeof mouseEvent.chartX === 'undefined') {\n        mouseEvent = pointer.normalize(mouseEvent);\n      }\n      ret = [mouseEvent.chartX - plotLeft, mouseEvent.chartY - plotTop];\n      // Some series types use a specificly calculated tooltip position for\n      // each point\n    } else if (points[0].tooltipPos) {\n      ret = points[0].tooltipPos;\n      // Calculate the average position and adjust for axis positions\n    } else {\n      let chartX = 0,\n        chartY = 0;\n      points.forEach(function (point) {\n        const pos = point.pos(true);\n        if (pos) {\n          chartX += pos[0];\n          chartY += pos[1];\n        }\n      });\n      chartX /= points.length;\n      chartY /= points.length;\n      // When shared, place the tooltip next to the mouse (#424)\n      if (this.shared && points.length > 1 && mouseEvent) {\n        if (inverted) {\n          chartX = mouseEvent.chartX;\n        } else {\n          chartY = mouseEvent.chartY;\n        }\n      }\n      // Use the average position for multiple points\n      ret = [chartX - plotLeft, chartY - plotTop];\n    }\n    return ret.map(Math.round);\n  }\n  /**\n   * Get the CSS class names for the tooltip's label. Styles the label\n   * by `colorIndex` or user-defined CSS.\n   *\n   * @function Highcharts.Tooltip#getClassName\n   *\n   * @return {string}\n   *         The class names.\n   */\n  getClassName(point, isSplit, isHeader) {\n    const options = this.options,\n      series = point.series,\n      seriesOptions = series.options;\n    return [options.className, 'highcharts-label', isHeader && 'highcharts-tooltip-header', isSplit ? 'highcharts-tooltip-box' : 'highcharts-tooltip', !isHeader && 'highcharts-color-' + pick(point.colorIndex, series.colorIndex), seriesOptions && seriesOptions.className].filter(isString).join(' ');\n  }\n  /**\n   * Creates the Tooltip label element if it does not exist, then returns it.\n   *\n   * @function Highcharts.Tooltip#getLabel\n   *\n   * @return {Highcharts.SVGElement}\n   * Tooltip label\n   */\n  getLabel() {\n    const tooltip = this,\n      styledMode = this.chart.styledMode,\n      options = this.options,\n      doSplit = this.split && this.allowShared;\n    let container = this.container,\n      renderer = this.chart.renderer;\n    // If changing from a split tooltip to a non-split tooltip, we must\n    // destroy it in order to get the SVG right. #13868.\n    if (this.label) {\n      const wasSplit = !this.label.hasClass('highcharts-label');\n      if (!doSplit && wasSplit || doSplit && !wasSplit) {\n        this.destroy();\n      }\n    }\n    if (!this.label) {\n      if (this.outside) {\n        const chartStyle = this.chart.options.chart.style,\n          Renderer = RendererRegistry.getRendererType();\n        /**\n         * Reference to the tooltip's container, when\n         * [Highcharts.Tooltip#outside] is set to true, otherwise\n         * it's undefined.\n         *\n         * @name Highcharts.Tooltip#container\n         * @type {Highcharts.HTMLDOMElement|undefined}\n         */\n        this.container = container = H.doc.createElement('div');\n        container.className = 'highcharts-tooltip-container';\n        // We need to set pointerEvents = 'none' as otherwise it makes\n        // the area under the tooltip non-hoverable even after the\n        // tooltip disappears, #19035.\n        css(container, {\n          position: 'absolute',\n          top: '1px',\n          pointerEvents: 'none',\n          zIndex: Math.max(this.options.style.zIndex || 0, (chartStyle && chartStyle.zIndex || 0) + 3)\n        });\n        /**\n         * Reference to the tooltip's renderer, when\n         * [Highcharts.Tooltip#outside] is set to true, otherwise\n         * it's undefined.\n         *\n         * @name Highcharts.Tooltip#renderer\n         * @type {Highcharts.SVGRenderer|undefined}\n         */\n        this.renderer = renderer = new Renderer(container, 0, 0, chartStyle, void 0, void 0, renderer.styledMode);\n      }\n      // Create the label\n      if (doSplit) {\n        this.label = renderer.g('tooltip');\n      } else {\n        this.label = renderer.label('', 0, 0, options.shape, void 0, void 0, options.useHTML, void 0, 'tooltip').attr({\n          padding: options.padding,\n          r: options.borderRadius\n        });\n        if (!styledMode) {\n          this.label.attr({\n            fill: options.backgroundColor,\n            'stroke-width': options.borderWidth || 0\n          })\n          // #2301, #2657\n          .css(options.style).css({\n            pointerEvents: options.style.pointerEvents || (this.shouldStickOnContact() ? 'auto' : 'none')\n          });\n        }\n      }\n      // Split tooltip use updateTooltipContainer to position the tooltip\n      // container.\n      if (tooltip.outside) {\n        const label = this.label;\n        const {\n          xSetter,\n          ySetter\n        } = label;\n        label.xSetter = function (value) {\n          xSetter.call(label, tooltip.distance);\n          if (container) {\n            container.style.left = value + 'px';\n          }\n        };\n        label.ySetter = function (value) {\n          ySetter.call(label, tooltip.distance);\n          if (container) {\n            container.style.top = value + 'px';\n          }\n        };\n      }\n      this.label.attr({\n        zIndex: 8\n      }).shadow(options.shadow).add();\n    }\n    if (container && !container.parentElement) {\n      H.doc.body.appendChild(container);\n    }\n    return this.label;\n  }\n  /**\n   * Get the total area available area to place the tooltip\n   *\n   * @private\n   */\n  getPlayingField() {\n    const {\n        body,\n        documentElement\n      } = doc,\n      {\n        chart,\n        distance,\n        outside\n      } = this;\n    return {\n      width: outside ?\n      // Substract distance to prevent scrollbars\n      Math.max(body.scrollWidth, documentElement.scrollWidth, body.offsetWidth, documentElement.offsetWidth, documentElement.clientWidth) - 2 * distance : chart.chartWidth,\n      height: outside ? Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, documentElement.clientHeight) : chart.chartHeight\n    };\n  }\n  /**\n   * Place the tooltip in a chart without spilling over and not covering the\n   * point itself.\n   *\n   * @function Highcharts.Tooltip#getPosition\n   *\n   * @param {number} boxWidth\n   *        Width of the tooltip box.\n   *\n   * @param {number} boxHeight\n   *        Height of the tooltip box.\n   *\n   * @param {Highcharts.Point} point\n   *        Tooltip related point.\n   *\n   * @return {Highcharts.PositionObject}\n   *         Recommended position of the tooltip.\n   */\n  getPosition(boxWidth, boxHeight, point) {\n    const chart = this.chart,\n      distance = this.distance,\n      ret = {},\n      // Don't use h if chart isn't inverted (#7242) ???\n      h = chart.inverted && point.h || 0,\n      // #4117 ???\n      outside = this.outside,\n      playingField = this.getPlayingField(),\n      outerWidth = playingField.width,\n      outerHeight = playingField.height,\n      chartPosition = chart.pointer.getChartPosition(),\n      scaleX = val =>\n      // eslint-disable-line no-confusing-arrow\n      val * chartPosition.scaleX,\n      scaleY = val =>\n      // eslint-disable-line no-confusing-arrow\n      val * chartPosition.scaleY,\n      // Build parameter arrays for firstDimension()/secondDimension()\n      buildDimensionArray = dim => {\n        const isX = dim === 'x';\n        return [dim, isX ? outerWidth : outerHeight, isX ? boxWidth : boxHeight].concat(outside ? [\n        // If we are using tooltip.outside, we need to scale the\n        // position to match scaling of the container in case there\n        // is a transform/zoom on the container. #11329\n        isX ? scaleX(boxWidth) : scaleY(boxHeight), isX ? chartPosition.left - distance + scaleX(point.plotX + chart.plotLeft) : chartPosition.top - distance + scaleY(point.plotY + chart.plotTop), 0, isX ? outerWidth : outerHeight] : [\n        // Not outside, no scaling is needed\n        isX ? boxWidth : boxHeight, isX ? point.plotX + chart.plotLeft : point.plotY + chart.plotTop, isX ? chart.plotLeft : chart.plotTop, isX ? chart.plotLeft + chart.plotWidth : chart.plotTop + chart.plotHeight]);\n      };\n    let first = buildDimensionArray('y'),\n      second = buildDimensionArray('x'),\n      swapped;\n    // Handle negative points or reversed axis (#13780)\n    let flipped = !!point.negative;\n    if (!chart.polar && chart.hoverSeries && chart.hoverSeries.yAxis && chart.hoverSeries.yAxis.reversed) {\n      flipped = !flipped;\n    }\n    // The far side is right or bottom\n    const preferFarSide = !this.followPointer && pick(point.ttBelow, !chart.inverted === flipped),\n      // #4984\n      /*\n       * Handle the preferred dimension. When the preferred dimension is\n       * tooltip on top or bottom of the point, it will look for space\n       * there.\n       *\n       * @private\n       */\n      firstDimension = function (dim, outerSize, innerSize, scaledInnerSize,\n      // #11329\n      point, min, max) {\n        const scaledDist = outside ? dim === 'y' ? scaleY(distance) : scaleX(distance) : distance,\n          scaleDiff = (innerSize - scaledInnerSize) / 2,\n          roomLeft = scaledInnerSize < point - distance,\n          roomRight = point + distance + scaledInnerSize < outerSize,\n          alignedLeft = point - scaledDist - innerSize + scaleDiff,\n          alignedRight = point + scaledDist - scaleDiff;\n        if (preferFarSide && roomRight) {\n          ret[dim] = alignedRight;\n        } else if (!preferFarSide && roomLeft) {\n          ret[dim] = alignedLeft;\n        } else if (roomLeft) {\n          ret[dim] = Math.min(max - scaledInnerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);\n        } else if (roomRight) {\n          ret[dim] = Math.max(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);\n        } else {\n          return false;\n        }\n      },\n      /*\n       * Handle the secondary dimension. If the preferred dimension is\n       * tooltip on top or bottom of the point, the second dimension is to\n       * align the tooltip above the point, trying to align center but\n       * allowing left or right align within the chart box.\n       *\n       * @private\n       */\n      secondDimension = function (dim, outerSize, innerSize, scaledInnerSize,\n      // #11329\n      point) {\n        let retVal;\n        // Too close to the edge, return false and swap dimensions\n        if (point < distance || point > outerSize - distance) {\n          retVal = false;\n          // Align left/top\n        } else if (point < innerSize / 2) {\n          ret[dim] = 1;\n          // Align right/bottom\n        } else if (point > outerSize - scaledInnerSize / 2) {\n          ret[dim] = outerSize - scaledInnerSize - 2;\n          // Align center\n        } else {\n          ret[dim] = point - innerSize / 2;\n        }\n        return retVal;\n      },\n      /*\n       * Swap the dimensions\n       */\n      swap = function (count) {\n        const temp = first;\n        first = second;\n        second = temp;\n        swapped = count;\n      },\n      run = function () {\n        if (firstDimension.apply(0, first) !== false) {\n          if (secondDimension.apply(0, second) === false && !swapped) {\n            swap(true);\n            run();\n          }\n        } else if (!swapped) {\n          swap(true);\n          run();\n        } else {\n          ret.x = ret.y = 0;\n        }\n      };\n    // Under these conditions, prefer the tooltip on the side of the point\n    if (chart.inverted || this.len > 1) {\n      swap();\n    }\n    run();\n    return ret;\n  }\n  /**\n   * Hides the tooltip with a fade out animation.\n   *\n   * @function Highcharts.Tooltip#hide\n   *\n   * @param {number} [delay]\n   *        The fade out in milliseconds. If no value is provided the value\n   *        of the tooltip.hideDelay option is used. A value of 0 disables\n   *        the fade out animation.\n   */\n  hide(delay) {\n    const tooltip = this;\n    // Disallow duplicate timers (#1728, #1766)\n    U.clearTimeout(this.hideTimer);\n    delay = pick(delay, this.options.hideDelay);\n    if (!this.isHidden) {\n      this.hideTimer = syncTimeout(function () {\n        const label = tooltip.getLabel();\n        // If there is a delay, fade out with the default duration. If\n        // the hideDelay is 0, we assume no animation is wanted, so we\n        // pass 0 duration. #12994.\n        tooltip.getLabel().animate({\n          opacity: 0\n        }, {\n          duration: delay ? 150 : delay,\n          complete: () => {\n            // #3088, assuming we're only using this for tooltips\n            label.hide();\n            // Clear the container for outside tooltip (#18490)\n            if (tooltip.container) {\n              tooltip.container.remove();\n            }\n          }\n        });\n        tooltip.isHidden = true;\n      }, delay);\n    }\n  }\n  /**\n   * Initialize tooltip.\n   *\n   * @private\n   * @function Highcharts.Tooltip#init\n   *\n   * @param {Highcharts.Chart} chart\n   *        The chart instance.\n   *\n   * @param {Highcharts.TooltipOptions} options\n   *        Tooltip options.\n   */\n  init(chart, options) {\n    /**\n     * Chart of the tooltip.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#chart\n     * @type {Highcharts.Chart}\n     */\n    this.chart = chart;\n    /**\n     * Used tooltip options.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#options\n     * @type {Highcharts.TooltipOptions}\n     */\n    this.options = options;\n    /**\n     * List of crosshairs.\n     *\n     * @private\n     * @readonly\n     * @name Highcharts.Tooltip#crosshairs\n     * @type {Array<null>}\n     */\n    this.crosshairs = [];\n    /**\n     * Current values of x and y when animating.\n     *\n     * @private\n     * @readonly\n     * @name Highcharts.Tooltip#now\n     * @type {Highcharts.PositionObject}\n     */\n    this.now = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Tooltips are initially hidden.\n     *\n     * @private\n     * @readonly\n     * @name Highcharts.Tooltip#isHidden\n     * @type {boolean}\n     */\n    this.isHidden = true;\n    /**\n     * True, if the tooltip is split into one label per series, with the\n     * header close to the axis.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#split\n     * @type {boolean|undefined}\n     */\n    this.split = options.split && !chart.inverted && !chart.polar;\n    /**\n     * When the tooltip is shared, the entire plot area will capture mouse\n     * movement or touch events.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#shared\n     * @type {boolean|undefined}\n     */\n    this.shared = options.shared || this.split;\n    /**\n     * Whether to allow the tooltip to render outside the chart's SVG\n     * element box. By default (false), the tooltip is rendered within the\n     * chart's SVG element, which results in the tooltip being aligned\n     * inside the chart area.\n     *\n     * @readonly\n     * @name Highcharts.Tooltip#outside\n     * @type {boolean}\n     *\n     * @todo\n     * Split tooltip does not support outside in the first iteration. Should\n     * not be too complicated to implement.\n     */\n    this.outside = pick(options.outside, Boolean(chart.scrollablePixelsX || chart.scrollablePixelsY));\n  }\n  shouldStickOnContact(pointerEvent) {\n    return !!(!this.followPointer && this.options.stickOnContact && (!pointerEvent || this.chart.pointer.inClass(pointerEvent.target, 'highcharts-tooltip')));\n  }\n  /**\n   * Moves the tooltip with a soft animation to a new position.\n   *\n   * @private\n   * @function Highcharts.Tooltip#move\n   *\n   * @param {number} x\n   *\n   * @param {number} y\n   *\n   * @param {number} anchorX\n   *\n   * @param {number} anchorY\n   */\n  move(x, y, anchorX, anchorY) {\n    const tooltip = this,\n      now = tooltip.now,\n      animate = tooltip.options.animation !== false && !tooltip.isHidden && (\n      // When we get close to the target position, abort animation and\n      // land on the right place (#3056)\n      Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),\n      skipAnchor = tooltip.followPointer || tooltip.len > 1;\n    // Get intermediate values for animation\n    extend(now, {\n      x: animate ? (2 * now.x + x) / 3 : x,\n      y: animate ? (now.y + y) / 2 : y,\n      anchorX: skipAnchor ? void 0 : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n      anchorY: skipAnchor ? void 0 : animate ? (now.anchorY + anchorY) / 2 : anchorY\n    });\n    // Move to the intermediate value\n    tooltip.getLabel().attr(now);\n    tooltip.drawTracker();\n    // Run on next tick of the mouse tracker\n    if (animate) {\n      // Never allow two timeouts\n      U.clearTimeout(this.tooltipTimeout);\n      // Set the fixed interval ticking for the smooth tooltip\n      this.tooltipTimeout = setTimeout(function () {\n        // The interval function may still be running during destroy,\n        // so check that the chart is really there before calling.\n        if (tooltip) {\n          tooltip.move(x, y, anchorX, anchorY);\n        }\n      }, 32);\n    }\n  }\n  /**\n   * Refresh the tooltip's text and position.\n   *\n   * @function Highcharts.Tooltip#refresh\n   *\n   * @param {Highcharts.Point|Array<Highcharts.Point>} pointOrPoints\n   *        Either a point or an array of points.\n   *\n   * @param {Highcharts.PointerEventObject} [mouseEvent]\n   *        Mouse event, that is responsible for the refresh and should be\n   *        used for the tooltip update.\n   */\n  refresh(pointOrPoints, mouseEvent) {\n    const tooltip = this,\n      chart = this.chart,\n      options = tooltip.options,\n      pointer = chart.pointer,\n      points = splat(pointOrPoints),\n      point = points[0],\n      pointConfig = [],\n      formatString = options.format,\n      formatter = options.formatter || tooltip.defaultFormatter,\n      shared = tooltip.shared,\n      styledMode = chart.styledMode;\n    let formatterContext = {};\n    if (!options.enabled || !point.series) {\n      // #16820\n      return;\n    }\n    U.clearTimeout(this.hideTimer);\n    // A switch saying if this specific tooltip configuration allows shared\n    // or split modes\n    tooltip.allowShared = !(!isArray(pointOrPoints) && pointOrPoints.series && pointOrPoints.series.noSharedTooltip);\n    // get the reference point coordinates (pie charts use tooltipPos)\n    tooltip.followPointer = !tooltip.split && point.series.tooltipOptions.followPointer;\n    const anchor = tooltip.getAnchor(pointOrPoints, mouseEvent),\n      x = anchor[0],\n      y = anchor[1];\n    // shared tooltip, array is sent over\n    if (shared && tooltip.allowShared) {\n      pointer.applyInactiveState(points);\n      // Now set hover state for the choosen ones:\n      points.forEach(function (item) {\n        item.setState('hover');\n        pointConfig.push(item.getLabelConfig());\n      });\n      formatterContext = point.getLabelConfig();\n      formatterContext.points = pointConfig;\n      // single point tooltip\n    } else {\n      formatterContext = point.getLabelConfig();\n    }\n    this.len = pointConfig.length; // #6128\n    const text = isString(formatString) ? format(formatString, formatterContext, chart) : formatter.call(formatterContext, tooltip);\n    // register the current series\n    const currentSeries = point.series;\n    this.distance = pick(currentSeries.tooltipOptions.distance, 16);\n    // update the inner HTML\n    if (text === false) {\n      this.hide();\n    } else {\n      // update text\n      if (tooltip.split && tooltip.allowShared) {\n        // #13868\n        this.renderSplit(text, points);\n      } else {\n        let checkX = x;\n        let checkY = y;\n        if (mouseEvent && pointer.isDirectTouch) {\n          checkX = mouseEvent.chartX - chart.plotLeft;\n          checkY = mouseEvent.chartY - chart.plotTop;\n        }\n        // #11493, #13095\n        if (chart.polar || currentSeries.options.clip === false || points.some(p =>\n        // #16004\n        pointer.isDirectTouch ||\n        // ##17929\n        p.series.shouldShowTooltip(checkX, checkY))) {\n          const label = tooltip.getLabel();\n          // Prevent the tooltip from flowing over the chart box\n          // (#6659)\n          if (!options.style.width || styledMode) {\n            label.css({\n              width: (this.outside ? this.getPlayingField() : chart.spacingBox).width + 'px'\n            });\n          }\n          label.attr({\n            text: text && text.join ? text.join('') : text\n          });\n          // Set the stroke color of the box to reflect the point\n          label.addClass(tooltip.getClassName(point), true);\n          if (!styledMode) {\n            label.attr({\n              stroke: options.borderColor || point.color || currentSeries.color || \"#666666\" /* Palette.neutralColor60 */\n            });\n          }\n\n          tooltip.updatePosition({\n            plotX: x,\n            plotY: y,\n            negative: point.negative,\n            ttBelow: point.ttBelow,\n            h: anchor[2] || 0\n          });\n        } else {\n          tooltip.hide();\n          return;\n        }\n      }\n      // show it\n      if (tooltip.isHidden && tooltip.label) {\n        tooltip.label.attr({\n          opacity: 1\n        }).show();\n      }\n      tooltip.isHidden = false;\n    }\n    fireEvent(this, 'refresh');\n  }\n  /**\n   * Render the split tooltip. Loops over each point's text and adds\n   * a label next to the point, then uses the distribute function to\n   * find best non-overlapping positions.\n   *\n   * @private\n   * @function Highcharts.Tooltip#renderSplit\n   *\n   * @param {string|Array<(boolean|string)>} labels\n   *\n   * @param {Array<Highcharts.Point>} points\n   */\n  renderSplit(labels, points) {\n    const tooltip = this;\n    const {\n      chart,\n      chart: {\n        chartWidth,\n        chartHeight,\n        plotHeight,\n        plotLeft,\n        plotTop,\n        pointer,\n        scrollablePixelsY = 0,\n        scrollablePixelsX,\n        scrollingContainer: {\n          scrollLeft,\n          scrollTop\n        } = {\n          scrollLeft: 0,\n          scrollTop: 0\n        },\n        styledMode\n      },\n      distance,\n      options,\n      options: {\n        positioner\n      }\n    } = tooltip;\n    // The area which the tooltip should be limited to. Limit to scrollable\n    // plot area if enabled, otherwise limit to the chart container. If\n    // outside is true it should be the whole viewport\n    const bounds = tooltip.outside && typeof scrollablePixelsX !== 'number' ? doc.documentElement.getBoundingClientRect() : {\n      left: scrollLeft,\n      right: scrollLeft + chartWidth,\n      top: scrollTop,\n      bottom: scrollTop + chartHeight\n    };\n    const tooltipLabel = tooltip.getLabel();\n    const ren = this.renderer || chart.renderer;\n    const headerTop = Boolean(chart.xAxis[0] && chart.xAxis[0].opposite);\n    const {\n      left: chartLeft,\n      top: chartTop\n    } = pointer.getChartPosition();\n    let distributionBoxTop = plotTop + scrollTop;\n    let headerHeight = 0;\n    let adjustedPlotHeight = plotHeight - scrollablePixelsY;\n    /**\n     * Calculates the anchor position for the partial tooltip\n     *\n     * @private\n     * @param {Highcharts.Point} point The point related to the tooltip\n     * @return {Object} Returns an object with anchorX and anchorY\n     */\n    function getAnchor(point) {\n      const {\n        isHeader,\n        plotX = 0,\n        plotY = 0,\n        series\n      } = point;\n      let anchorX;\n      let anchorY;\n      if (isHeader) {\n        // Set anchorX to plotX\n        anchorX = Math.max(plotLeft + plotX, plotLeft);\n        // Set anchorY to center of visible plot area.\n        anchorY = plotTop + plotHeight / 2;\n      } else {\n        const {\n          xAxis,\n          yAxis\n        } = series;\n        // Set anchorX to plotX. Limit to within xAxis.\n        anchorX = xAxis.pos + clamp(plotX, -distance, xAxis.len + distance);\n        // Set anchorY, limit to the scrollable plot area\n        if (series.shouldShowTooltip(0, yAxis.pos - plotTop + plotY, {\n          ignoreX: true\n        })) {\n          anchorY = yAxis.pos + plotY;\n        }\n      }\n      // Limit values to plot area\n      anchorX = clamp(anchorX, bounds.left - distance, bounds.right + distance);\n      return {\n        anchorX,\n        anchorY\n      };\n    }\n    /**\n     * Calculates the position of the partial tooltip\n     *\n     * @private\n     * @param {number} anchorX\n     * The partial tooltip anchor x position\n     *\n     * @param {number} anchorY\n     * The partial tooltip anchor y position\n     *\n     * @param {boolean|undefined} isHeader\n     * Whether the partial tooltip is a header\n     *\n     * @param {number} boxWidth\n     * Width of the partial tooltip\n     *\n     * @return {Highcharts.PositionObject}\n     * Returns the partial tooltip x and y position\n     */\n    function defaultPositioner(anchorX, anchorY, isHeader, boxWidth, alignedLeft = true) {\n      let y;\n      let x;\n      if (isHeader) {\n        y = headerTop ? 0 : adjustedPlotHeight;\n        x = clamp(anchorX - boxWidth / 2, bounds.left, bounds.right - boxWidth - (tooltip.outside ? chartLeft : 0));\n      } else {\n        y = anchorY - distributionBoxTop;\n        x = alignedLeft ? anchorX - boxWidth - distance : anchorX + distance;\n        x = clamp(x, alignedLeft ? x : bounds.left, bounds.right);\n      }\n      // NOTE: y is relative to distributionBoxTop\n      return {\n        x,\n        y\n      };\n    }\n    /**\n     * Updates the attributes and styling of the partial tooltip. Creates a\n     * new partial tooltip if it does not exists.\n     *\n     * @private\n     * @param {Highcharts.SVGElement|undefined} partialTooltip\n     *  The partial tooltip to update\n     * @param {Highcharts.Point} point\n     *  The point related to the partial tooltip\n     * @param {boolean|string} str The text for the partial tooltip\n     * @return {Highcharts.SVGElement} Returns the updated partial tooltip\n     */\n    function updatePartialTooltip(partialTooltip, point, str) {\n      let tt = partialTooltip;\n      const {\n        isHeader,\n        series\n      } = point;\n      if (!tt) {\n        const attribs = {\n          padding: options.padding,\n          r: options.borderRadius\n        };\n        if (!styledMode) {\n          attribs.fill = options.backgroundColor;\n          attribs['stroke-width'] = options.borderWidth ?? 1;\n        }\n        tt = ren.label('', 0, 0, options[isHeader ? 'headerShape' : 'shape'], void 0, void 0, options.useHTML).addClass(tooltip.getClassName(point, true, isHeader)).attr(attribs).add(tooltipLabel);\n      }\n      tt.isActive = true;\n      tt.attr({\n        text: str\n      });\n      if (!styledMode) {\n        tt.css(options.style).attr({\n          stroke: options.borderColor || point.color || series.color || \"#333333\" /* Palette.neutralColor80 */\n        });\n      }\n\n      return tt;\n    }\n    // Graceful degradation for legacy formatters\n    if (isString(labels)) {\n      labels = [false, labels];\n    }\n    // Create the individual labels for header and points, ignore footer\n    let boxes = labels.slice(0, points.length + 1).reduce(function (boxes, str, i) {\n      if (str !== false && str !== '') {\n        const point = points[i - 1] || {\n          // Item 0 is the header. Instead of this, we could also\n          // use the crosshair label\n          isHeader: true,\n          plotX: points[0].plotX,\n          plotY: plotHeight,\n          series: {}\n        };\n        const isHeader = point.isHeader;\n        // Store the tooltip label referance on the series\n        const owner = isHeader ? tooltip : point.series;\n        const tt = owner.tt = updatePartialTooltip(owner.tt, point, str.toString());\n        // Get X position now, so we can move all to the other side in\n        // case of overflow\n        const bBox = tt.getBBox();\n        const boxWidth = bBox.width + tt.strokeWidth();\n        if (isHeader) {\n          headerHeight = bBox.height;\n          adjustedPlotHeight += headerHeight;\n          if (headerTop) {\n            distributionBoxTop -= headerHeight;\n          }\n        }\n        const {\n          anchorX,\n          anchorY\n        } = getAnchor(point);\n        if (typeof anchorY === 'number') {\n          const size = bBox.height + 1;\n          const boxPosition = positioner ? positioner.call(tooltip, boxWidth, size, point) : defaultPositioner(anchorX, anchorY, isHeader, boxWidth);\n          boxes.push({\n            // 0-align to the top, 1-align to the bottom\n            align: positioner ? 0 : void 0,\n            anchorX,\n            anchorY,\n            boxWidth,\n            point,\n            rank: pick(boxPosition.rank, isHeader ? 1 : 0),\n            size,\n            target: boxPosition.y,\n            tt,\n            x: boxPosition.x\n          });\n        } else {\n          // Hide tooltips which anchorY is outside the visible plot\n          // area\n          tt.isActive = false;\n        }\n      }\n      return boxes;\n    }, []);\n    // Realign the tooltips towards the right if there is not enough space\n    // to the left and there is space to to the right\n    if (!positioner && boxes.some(box => {\n      // Always realign if the beginning of a label is outside bounds\n      const {\n        outside\n      } = tooltip;\n      const boxStart = (outside ? chartLeft : 0) + box.anchorX;\n      if (boxStart < bounds.left && boxStart + box.boxWidth < bounds.right) {\n        return true;\n      }\n      // Otherwise, check if there is more space available to the right\n      return boxStart < chartLeft - bounds.left + box.boxWidth && bounds.right - boxStart > boxStart;\n    })) {\n      boxes = boxes.map(box => {\n        const {\n          x,\n          y\n        } = defaultPositioner(box.anchorX, box.anchorY, box.point.isHeader, box.boxWidth, false);\n        return extend(box, {\n          target: y,\n          x\n        });\n      });\n    }\n    // Clean previous run (for missing points)\n    tooltip.cleanSplit();\n    // Distribute and put in place\n    distribute(boxes, adjustedPlotHeight);\n    const boxExtremes = {\n      left: chartLeft,\n      right: chartLeft\n    };\n    // Get the extremes from series tooltips\n    boxes.forEach(function (box) {\n      const {\n        x,\n        boxWidth,\n        isHeader\n      } = box;\n      if (!isHeader) {\n        if (tooltip.outside && chartLeft + x < boxExtremes.left) {\n          boxExtremes.left = chartLeft + x;\n        }\n        if (!isHeader && tooltip.outside && boxExtremes.left + boxWidth > boxExtremes.right) {\n          boxExtremes.right = chartLeft + x;\n        }\n      }\n    });\n    boxes.forEach(function (box) {\n      const {\n        x,\n        anchorX,\n        anchorY,\n        pos,\n        point: {\n          isHeader\n        }\n      } = box;\n      const attributes = {\n        visibility: typeof pos === 'undefined' ? 'hidden' : 'inherit',\n        x,\n        /* NOTE: y should equal pos to be consistent with !split\n         * tooltip, but is currently relative to plotTop. Is left as is\n         * to avoid breaking change. Remove distributionBoxTop to make\n         * it consistent.\n         */\n        y: (pos || 0) + distributionBoxTop,\n        anchorX,\n        anchorY\n      };\n      // Handle left-aligned tooltips overflowing the chart area\n      if (tooltip.outside && x < anchorX) {\n        const offset = chartLeft - boxExtremes.left;\n        // Skip this if there is no overflow\n        if (offset > 0) {\n          if (!isHeader) {\n            attributes.x = x + offset;\n            attributes.anchorX = anchorX + offset;\n          }\n          if (isHeader) {\n            attributes.x = (boxExtremes.right - boxExtremes.left) / 2;\n            attributes.anchorX = anchorX + offset;\n          }\n        }\n      }\n      // Put the label in place\n      box.tt.attr(attributes);\n    });\n    /* If we have a seperate tooltip container, then update the necessary\n     * container properties.\n     * Test that tooltip has its own container and renderer before executing\n     * the operation.\n     */\n    const {\n      container,\n      outside,\n      renderer\n    } = tooltip;\n    if (outside && container && renderer) {\n      // Set container size to fit the bounds\n      const {\n        width,\n        height,\n        x,\n        y\n      } = tooltipLabel.getBBox();\n      renderer.setSize(width + x, height + y, false);\n      // Position the tooltip container to the chart container\n      container.style.left = boxExtremes.left + 'px';\n      container.style.top = chartTop + 'px';\n    }\n    // Workaround for #18927, artefacts left by the shadows of split\n    // tooltips in Safari v16 (2023). Check again with later versions if we\n    // can remove this.\n    if (isSafari) {\n      tooltipLabel.attr({\n        // Force a redraw of the whole group by chaning the opacity\n        // slightly\n        opacity: tooltipLabel.opacity === 1 ? 0.999 : 1\n      });\n    }\n  }\n  /**\n   * If the `stickOnContact` option is active, this will add a tracker shape.\n   *\n   * @private\n   * @function Highcharts.Tooltip#drawTracker\n   */\n  drawTracker() {\n    const tooltip = this;\n    if (!this.shouldStickOnContact()) {\n      if (tooltip.tracker) {\n        tooltip.tracker = tooltip.tracker.destroy();\n      }\n      return;\n    }\n    const chart = tooltip.chart;\n    const label = tooltip.label;\n    const points = tooltip.shared ? chart.hoverPoints : chart.hoverPoint;\n    if (!label || !points) {\n      return;\n    }\n    const box = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    // Combine anchor and tooltip\n    const anchorPos = this.getAnchor(points);\n    const labelBBox = label.getBBox();\n    anchorPos[0] += chart.plotLeft - (label.translateX || 0);\n    anchorPos[1] += chart.plotTop - (label.translateY || 0);\n    // When the mouse pointer is between the anchor point and the label,\n    // the label should stick.\n    box.x = Math.min(0, anchorPos[0]);\n    box.y = Math.min(0, anchorPos[1]);\n    box.width = anchorPos[0] < 0 ? Math.max(Math.abs(anchorPos[0]), labelBBox.width - anchorPos[0]) : Math.max(Math.abs(anchorPos[0]), labelBBox.width);\n    box.height = anchorPos[1] < 0 ? Math.max(Math.abs(anchorPos[1]), labelBBox.height - Math.abs(anchorPos[1])) : Math.max(Math.abs(anchorPos[1]), labelBBox.height);\n    if (tooltip.tracker) {\n      tooltip.tracker.attr(box);\n    } else {\n      tooltip.tracker = label.renderer.rect(box).addClass('highcharts-tracker').add(label);\n      if (!chart.styledMode) {\n        tooltip.tracker.attr({\n          fill: 'rgba(0,0,0,0)'\n        });\n      }\n    }\n  }\n  /**\n   * @private\n   */\n  styledModeFormat(formatString) {\n    return formatString.replace('style=\"font-size: 0.8em\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex} ' + '{series.options.className} ' + '{point.options.className}\"');\n  }\n  /**\n   * Format the footer/header of the tooltip\n   * #3397: abstraction to enable formatting of footer and header\n   *\n   * @private\n   * @function Highcharts.Tooltip#tooltipFooterHeaderFormatter\n   */\n  tooltipFooterHeaderFormatter(labelConfig, isFooter) {\n    const series = labelConfig.series,\n      tooltipOptions = series.tooltipOptions,\n      xAxis = series.xAxis,\n      dateTime = xAxis && xAxis.dateTime,\n      e = {\n        isFooter: isFooter,\n        labelConfig: labelConfig\n      };\n    let xDateFormat = tooltipOptions.xDateFormat,\n      formatString = tooltipOptions[isFooter ? 'footerFormat' : 'headerFormat'];\n    fireEvent(this, 'headerFormatter', e, function (e) {\n      // Guess the best date format based on the closest point distance\n      // (#568, #3418)\n      if (dateTime && !xDateFormat && isNumber(labelConfig.key)) {\n        xDateFormat = dateTime.getXDateFormat(labelConfig.key, tooltipOptions.dateTimeLabelFormats);\n      }\n      // Insert the footer date format if any\n      if (dateTime && xDateFormat) {\n        (labelConfig.point && labelConfig.point.tooltipDateKeys || ['key']).forEach(function (key) {\n          formatString = formatString.replace('{point.' + key + '}', '{point.' + key + ':' + xDateFormat + '}');\n        });\n      }\n      // Replace default header style with class name\n      if (series.chart.styledMode) {\n        formatString = this.styledModeFormat(formatString);\n      }\n      e.text = format(formatString, {\n        point: labelConfig,\n        series: series\n      }, this.chart);\n    });\n    return e.text;\n  }\n  /**\n   * Updates the tooltip with the provided tooltip options.\n   *\n   * @function Highcharts.Tooltip#update\n   *\n   * @param {Highcharts.TooltipOptions} options\n   *        The tooltip options to update.\n   */\n  update(options) {\n    this.destroy();\n    this.init(this.chart, merge(true, this.options, options));\n  }\n  /**\n   * Find the new position and perform the move\n   *\n   * @private\n   * @function Highcharts.Tooltip#updatePosition\n   *\n   * @param {Highcharts.Point} point\n   */\n  updatePosition(point) {\n    const {\n        chart,\n        container,\n        distance,\n        options,\n        renderer\n      } = this,\n      {\n        height = 0,\n        width = 0\n      } = this.getLabel(),\n      pointer = chart.pointer,\n      // Needed for outside: true (#11688)\n      {\n        left,\n        top,\n        scaleX,\n        scaleY\n      } = pointer.getChartPosition(),\n      pos = (options.positioner || this.getPosition).call(this, width, height, point);\n    let anchorX = (point.plotX || 0) + chart.plotLeft,\n      anchorY = (point.plotY || 0) + chart.plotTop,\n      pad;\n    // Set the renderer size dynamically to prevent document size to change.\n    // Renderer only exists when tooltip is outside.\n    if (renderer && container) {\n      // Corrects positions, occurs with tooltip positioner (#16944)\n      if (options.positioner) {\n        pos.x += left - distance;\n        pos.y += top - distance;\n      }\n      // Pad it by the border width and distance. Add 2 to make room for\n      // the default shadow (#19314).\n      pad = (options.borderWidth || 0) + 2 * distance + 2;\n      renderer.setSize(width + pad, height + pad, false);\n      // Anchor and tooltip container need scaling if chart container has\n      // scale transform/css zoom. #11329.\n      if (scaleX !== 1 || scaleY !== 1) {\n        css(container, {\n          transform: `scale(${scaleX}, ${scaleY})`\n        });\n        anchorX *= scaleX;\n        anchorY *= scaleY;\n      }\n      anchorX += left - pos.x;\n      anchorY += top - pos.y;\n    }\n    // Do the move\n    this.move(Math.round(pos.x), Math.round(pos.y || 0),\n    // Can be undefined (#3977)\n    anchorX, anchorY);\n  }\n}\n/* *\n *\n *  Class namespace\n *\n * */\n(function (Tooltip) {\n  /* *\n   *\n   *  Declarations\n   *\n   * */\n  /* *\n   *\n   *  Constants\n   *\n   * */\n  const composedMembers = [];\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * @private\n   */\n  function compose(PointerClass) {\n    if (U.pushUnique(composedMembers, PointerClass)) {\n      addEvent(PointerClass, 'afterInit', function () {\n        const chart = this.chart;\n        if (chart.options.tooltip) {\n          /**\n           * Tooltip object for points of series.\n           *\n           * @name Highcharts.Chart#tooltip\n           * @type {Highcharts.Tooltip}\n           */\n          chart.tooltip = new Tooltip(chart, chart.options.tooltip);\n        }\n      });\n    }\n  }\n  Tooltip.compose = compose;\n})(Tooltip || (Tooltip = {}));\n/* *\n *\n *  Default export\n *\n * */\nexport default Tooltip;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Callback function to format the text of the tooltip from scratch.\n *\n * In case of single or shared tooltips, a string should be be returned. In case\n * of splitted tooltips, it should return an array where the first item is the\n * header, and subsequent items are mapped to the points. Return `false` to\n * disable tooltip for a specific point on series.\n *\n * @callback Highcharts.TooltipFormatterCallbackFunction\n *\n * @param {Highcharts.TooltipFormatterContextObject} this\n * Context to format\n *\n * @param {Highcharts.Tooltip} tooltip\n * The tooltip instance\n *\n * @return {false|string|Array<(string|null|undefined)>|null|undefined}\n * Formatted text or false\n */\n/**\n * Configuration for the tooltip formatters.\n *\n * @interface Highcharts.TooltipFormatterContextObject\n * @extends Highcharts.PointLabelObject\n */ /**\n    * Array of points in shared tooltips.\n    * @name Highcharts.TooltipFormatterContextObject#points\n    * @type {Array<Highcharts.TooltipFormatterContextObject>|undefined}\n    */\n/**\n * A callback function to place the tooltip in a specific position.\n *\n * @callback Highcharts.TooltipPositionerCallbackFunction\n *\n * @param {Highcharts.Tooltip} this\n * Tooltip context of the callback.\n *\n * @param {number} labelWidth\n * Width of the tooltip.\n *\n * @param {number} labelHeight\n * Height of the tooltip.\n *\n * @param {Highcharts.TooltipPositionerPointObject} point\n * Point information for positioning a tooltip.\n *\n * @return {Highcharts.PositionObject}\n * New position for the tooltip.\n */\n/**\n * Point information for positioning a tooltip.\n *\n * @interface Highcharts.TooltipPositionerPointObject\n * @extends Highcharts.Point\n */ /**\n    * If `tooltip.split` option is enabled and positioner is called for each of the\n    * boxes separately, this property indicates the call on the xAxis header, which\n    * is not a point itself.\n    * @name Highcharts.TooltipPositionerPointObject#isHeader\n    * @type {boolean}\n    */ /**\n       * The reference point relative to the plot area. Add chart.plotLeft to get the\n       * full coordinates.\n       * @name Highcharts.TooltipPositionerPointObject#plotX\n       * @type {number}\n       */ /**\n          * The reference point relative to the plot area. Add chart.plotTop to get the\n          * full coordinates.\n          * @name Highcharts.TooltipPositionerPointObject#plotY\n          * @type {number}\n          */\n/**\n * @typedef {\"callout\"|\"circle\"|\"rect\"} Highcharts.TooltipShapeValue\n */\n''; // keeps doclets above in JS file","map":{"version":3,"names":["F","format","H","doc","isSafari","R","distribute","RendererRegistry","U","addEvent","clamp","css","discardElement","extend","fireEvent","isArray","isNumber","isString","merge","pick","splat","syncTimeout","Tooltip","constructor","chart","options","allowShared","crosshairs","distance","isHidden","isSticky","now","outside","init","bodyFormatter","items","map","item","tooltipOptions","series","point","formatPrefix","tooltipFormatter","call","cleanSplit","force","forEach","tt","isActive","destroy","defaultFormatter","tooltip","points","s","tooltipFooterHeaderFormatter","concat","push","label","split","renderer","container","clearTimeout","hideTimer","tooltipTimeout","getAnchor","mouseEvent","pointer","inverted","plotTop","plotLeft","ret","yAxis","reversedStacks","slice","reverse","followPointer","chartX","normalize","chartY","tooltipPos","pos","length","shared","Math","round","getClassName","isSplit","isHeader","seriesOptions","className","colorIndex","filter","join","getLabel","styledMode","doSplit","wasSplit","hasClass","chartStyle","style","Renderer","getRendererType","createElement","position","top","pointerEvents","zIndex","max","g","shape","useHTML","attr","padding","r","borderRadius","fill","backgroundColor","borderWidth","shouldStickOnContact","xSetter","ySetter","value","left","shadow","add","parentElement","body","appendChild","getPlayingField","documentElement","width","scrollWidth","offsetWidth","clientWidth","chartWidth","height","scrollHeight","offsetHeight","clientHeight","chartHeight","getPosition","boxWidth","boxHeight","h","playingField","outerWidth","outerHeight","chartPosition","getChartPosition","scaleX","val","scaleY","buildDimensionArray","dim","isX","plotX","plotY","plotWidth","plotHeight","first","second","swapped","flipped","negative","polar","hoverSeries","reversed","preferFarSide","ttBelow","firstDimension","outerSize","innerSize","scaledInnerSize","min","scaledDist","scaleDiff","roomLeft","roomRight","alignedLeft","alignedRight","secondDimension","retVal","swap","count","temp","run","apply","x","y","len","hide","delay","hideDelay","animate","opacity","duration","complete","remove","Boolean","scrollablePixelsX","scrollablePixelsY","pointerEvent","stickOnContact","inClass","target","move","anchorX","anchorY","animation","abs","skipAnchor","drawTracker","setTimeout","refresh","pointOrPoints","pointConfig","formatString","formatter","formatterContext","enabled","noSharedTooltip","anchor","applyInactiveState","setState","getLabelConfig","text","currentSeries","renderSplit","checkX","checkY","isDirectTouch","clip","some","p","shouldShowTooltip","spacingBox","addClass","stroke","borderColor","color","updatePosition","show","labels","scrollingContainer","scrollLeft","scrollTop","positioner","bounds","getBoundingClientRect","right","bottom","tooltipLabel","ren","headerTop","xAxis","opposite","chartLeft","chartTop","distributionBoxTop","headerHeight","adjustedPlotHeight","ignoreX","defaultPositioner","updatePartialTooltip","partialTooltip","str","attribs","boxes","reduce","i","owner","toString","bBox","getBBox","strokeWidth","size","boxPosition","align","rank","box","boxStart","boxExtremes","attributes","visibility","offset","setSize","tracker","hoverPoints","hoverPoint","anchorPos","labelBBox","translateX","translateY","rect","styledModeFormat","replace","labelConfig","isFooter","dateTime","e","xDateFormat","key","getXDateFormat","dateTimeLabelFormats","tooltipDateKeys","update","pad","transform","composedMembers","compose","PointerClass","pushUnique"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Tooltip.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport F from './Templating.js';\nconst { format } = F;\nimport H from './Globals.js';\nconst { doc, isSafari } = H;\nimport R from './Renderer/RendererUtilities.js';\nconst { distribute } = R;\nimport RendererRegistry from './Renderer/RendererRegistry.js';\nimport U from './Utilities.js';\nconst { addEvent, clamp, css, discardElement, extend, fireEvent, isArray, isNumber, isString, merge, pick, splat, syncTimeout } = U;\n/* *\n *\n *  Class\n *\n * */\n/* eslint-disable no-invalid-this, valid-jsdoc */\n/**\n * Tooltip of a chart.\n *\n * @class\n * @name Highcharts.Tooltip\n *\n * @param {Highcharts.Chart} chart\n * The chart instance.\n *\n * @param {Highcharts.TooltipOptions} options\n * Tooltip options.\n */\nclass Tooltip {\n    /* *\n     *\n     *  Constructors\n     *\n     * */\n    constructor(chart, options) {\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        this.allowShared = true;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = true;\n        this.isSticky = false;\n        this.now = {};\n        this.options = {};\n        this.outside = false;\n        this.chart = chart;\n        this.init(chart, options);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Build the body (lines) of the tooltip by iterating over the items and\n     * returning one entry for each item, abstracting this functionality allows\n     * to easily overwrite and extend it.\n     *\n     * @private\n     * @function Highcharts.Tooltip#bodyFormatter\n     */\n    bodyFormatter(items) {\n        return items.map(function (item) {\n            const tooltipOptions = item.series.tooltipOptions;\n            return (tooltipOptions[(item.point.formatPrefix || 'point') + 'Formatter'] ||\n                item.point.tooltipFormatter).call(item.point, tooltipOptions[(item.point.formatPrefix || 'point') + 'Format'] || '');\n        });\n    }\n    /**\n     * Destroy the single tooltips in a split tooltip.\n     * If the tooltip is active then it is not destroyed, unless forced to.\n     *\n     * @private\n     * @function Highcharts.Tooltip#cleanSplit\n     *\n     * @param {boolean} [force]\n     * Force destroy all tooltips.\n     */\n    cleanSplit(force) {\n        this.chart.series.forEach(function (series) {\n            const tt = series && series.tt;\n            if (tt) {\n                if (!tt.isActive || force) {\n                    series.tt = tt.destroy();\n                }\n                else {\n                    tt.isActive = false;\n                }\n            }\n        });\n    }\n    /**\n     * In case no user defined formatter is given, this will be used. Note that\n     * the context here is an object holding point, series, x, y etc.\n     *\n     * @function Highcharts.Tooltip#defaultFormatter\n     *\n     * @param {Highcharts.Tooltip} tooltip\n     *\n     * @return {string|Array<string>}\n     * Returns a string (single tooltip and shared)\n     * or an array of strings (split tooltip)\n     */\n    defaultFormatter(tooltip) {\n        const items = this.points || splat(this);\n        let s;\n        // Build the header\n        s = [tooltip.tooltipFooterHeaderFormatter(items[0])];\n        // build the values\n        s = s.concat(tooltip.bodyFormatter(items));\n        // footer\n        s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));\n        return s;\n    }\n    /**\n     * Removes and destroys the tooltip and its elements.\n     *\n     * @function Highcharts.Tooltip#destroy\n     */\n    destroy() {\n        // Destroy and clear local variables\n        if (this.label) {\n            this.label = this.label.destroy();\n        }\n        if (this.split) {\n            this.cleanSplit(true);\n            if (this.tt) {\n                this.tt = this.tt.destroy();\n            }\n        }\n        if (this.renderer) {\n            this.renderer = this.renderer.destroy();\n            discardElement(this.container);\n        }\n        U.clearTimeout(this.hideTimer);\n        U.clearTimeout(this.tooltipTimeout);\n    }\n    /**\n     * Extendable method to get the anchor position of the tooltip\n     * from a point or set of points\n     *\n     * @private\n     * @function Highcharts.Tooltip#getAnchor\n     */\n    getAnchor(points, mouseEvent) {\n        const chart = this.chart, pointer = chart.pointer, inverted = chart.inverted, plotTop = chart.plotTop, plotLeft = chart.plotLeft;\n        let ret;\n        points = splat(points);\n        // If reversedStacks are false the tooltip position should be taken from\n        // the last point (#17948)\n        if (points[0].series &&\n            points[0].series.yAxis &&\n            !points[0].series.yAxis.options.reversedStacks) {\n            points = points.slice().reverse();\n        }\n        // When tooltip follows mouse, relate the position to the mouse\n        if (this.followPointer && mouseEvent) {\n            if (typeof mouseEvent.chartX === 'undefined') {\n                mouseEvent = pointer.normalize(mouseEvent);\n            }\n            ret = [\n                mouseEvent.chartX - plotLeft,\n                mouseEvent.chartY - plotTop\n            ];\n            // Some series types use a specificly calculated tooltip position for\n            // each point\n        }\n        else if (points[0].tooltipPos) {\n            ret = points[0].tooltipPos;\n            // Calculate the average position and adjust for axis positions\n        }\n        else {\n            let chartX = 0, chartY = 0;\n            points.forEach(function (point) {\n                const pos = point.pos(true);\n                if (pos) {\n                    chartX += pos[0];\n                    chartY += pos[1];\n                }\n            });\n            chartX /= points.length;\n            chartY /= points.length;\n            // When shared, place the tooltip next to the mouse (#424)\n            if (this.shared && points.length > 1 && mouseEvent) {\n                if (inverted) {\n                    chartX = mouseEvent.chartX;\n                }\n                else {\n                    chartY = mouseEvent.chartY;\n                }\n            }\n            // Use the average position for multiple points\n            ret = [chartX - plotLeft, chartY - plotTop];\n        }\n        return ret.map(Math.round);\n    }\n    /**\n     * Get the CSS class names for the tooltip's label. Styles the label\n     * by `colorIndex` or user-defined CSS.\n     *\n     * @function Highcharts.Tooltip#getClassName\n     *\n     * @return {string}\n     *         The class names.\n     */\n    getClassName(point, isSplit, isHeader) {\n        const options = this.options, series = point.series, seriesOptions = series.options;\n        return [\n            options.className,\n            'highcharts-label',\n            isHeader && 'highcharts-tooltip-header',\n            isSplit ? 'highcharts-tooltip-box' : 'highcharts-tooltip',\n            !isHeader && 'highcharts-color-' + pick(point.colorIndex, series.colorIndex),\n            (seriesOptions && seriesOptions.className)\n        ].filter(isString).join(' ');\n    }\n    /**\n     * Creates the Tooltip label element if it does not exist, then returns it.\n     *\n     * @function Highcharts.Tooltip#getLabel\n     *\n     * @return {Highcharts.SVGElement}\n     * Tooltip label\n     */\n    getLabel() {\n        const tooltip = this, styledMode = this.chart.styledMode, options = this.options, doSplit = this.split && this.allowShared;\n        let container = this.container, renderer = this.chart.renderer;\n        // If changing from a split tooltip to a non-split tooltip, we must\n        // destroy it in order to get the SVG right. #13868.\n        if (this.label) {\n            const wasSplit = !this.label.hasClass('highcharts-label');\n            if ((!doSplit && wasSplit) || (doSplit && !wasSplit)) {\n                this.destroy();\n            }\n        }\n        if (!this.label) {\n            if (this.outside) {\n                const chartStyle = this.chart.options.chart.style, Renderer = RendererRegistry.getRendererType();\n                /**\n                 * Reference to the tooltip's container, when\n                 * [Highcharts.Tooltip#outside] is set to true, otherwise\n                 * it's undefined.\n                 *\n                 * @name Highcharts.Tooltip#container\n                 * @type {Highcharts.HTMLDOMElement|undefined}\n                 */\n                this.container = container = H.doc.createElement('div');\n                container.className = 'highcharts-tooltip-container';\n                // We need to set pointerEvents = 'none' as otherwise it makes\n                // the area under the tooltip non-hoverable even after the\n                // tooltip disappears, #19035.\n                css(container, {\n                    position: 'absolute',\n                    top: '1px',\n                    pointerEvents: 'none',\n                    zIndex: Math.max(this.options.style.zIndex || 0, (chartStyle && chartStyle.zIndex || 0) + 3)\n                });\n                /**\n                 * Reference to the tooltip's renderer, when\n                 * [Highcharts.Tooltip#outside] is set to true, otherwise\n                 * it's undefined.\n                 *\n                 * @name Highcharts.Tooltip#renderer\n                 * @type {Highcharts.SVGRenderer|undefined}\n                 */\n                this.renderer = renderer = new Renderer(container, 0, 0, chartStyle, void 0, void 0, renderer.styledMode);\n            }\n            // Create the label\n            if (doSplit) {\n                this.label = renderer.g('tooltip');\n            }\n            else {\n                this.label = renderer\n                    .label('', 0, 0, options.shape, void 0, void 0, options.useHTML, void 0, 'tooltip')\n                    .attr({\n                    padding: options.padding,\n                    r: options.borderRadius\n                });\n                if (!styledMode) {\n                    this.label\n                        .attr({\n                        fill: options.backgroundColor,\n                        'stroke-width': options.borderWidth || 0\n                    })\n                        // #2301, #2657\n                        .css(options.style)\n                        .css({\n                        pointerEvents: (options.style.pointerEvents ||\n                            (this.shouldStickOnContact() ? 'auto' : 'none'))\n                    });\n                }\n            }\n            // Split tooltip use updateTooltipContainer to position the tooltip\n            // container.\n            if (tooltip.outside) {\n                const label = this.label;\n                const { xSetter, ySetter } = label;\n                label.xSetter = function (value) {\n                    xSetter.call(label, tooltip.distance);\n                    if (container) {\n                        container.style.left = value + 'px';\n                    }\n                };\n                label.ySetter = function (value) {\n                    ySetter.call(label, tooltip.distance);\n                    if (container) {\n                        container.style.top = value + 'px';\n                    }\n                };\n            }\n            this.label\n                .attr({ zIndex: 8 })\n                .shadow(options.shadow)\n                .add();\n        }\n        if (container && !container.parentElement) {\n            H.doc.body.appendChild(container);\n        }\n        return this.label;\n    }\n    /**\n     * Get the total area available area to place the tooltip\n     *\n     * @private\n     */\n    getPlayingField() {\n        const { body, documentElement } = doc, { chart, distance, outside } = this;\n        return {\n            width: outside ?\n                // Substract distance to prevent scrollbars\n                Math.max(body.scrollWidth, documentElement.scrollWidth, body.offsetWidth, documentElement.offsetWidth, documentElement.clientWidth) - 2 * distance :\n                chart.chartWidth,\n            height: outside ?\n                Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, documentElement.clientHeight) :\n                chart.chartHeight\n        };\n    }\n    /**\n     * Place the tooltip in a chart without spilling over and not covering the\n     * point itself.\n     *\n     * @function Highcharts.Tooltip#getPosition\n     *\n     * @param {number} boxWidth\n     *        Width of the tooltip box.\n     *\n     * @param {number} boxHeight\n     *        Height of the tooltip box.\n     *\n     * @param {Highcharts.Point} point\n     *        Tooltip related point.\n     *\n     * @return {Highcharts.PositionObject}\n     *         Recommended position of the tooltip.\n     */\n    getPosition(boxWidth, boxHeight, point) {\n        const chart = this.chart, distance = this.distance, ret = {}, \n        // Don't use h if chart isn't inverted (#7242) ???\n        h = (chart.inverted && point.h) || 0, // #4117 ???\n        outside = this.outside, playingField = this.getPlayingField(), outerWidth = playingField.width, outerHeight = playingField.height, chartPosition = chart.pointer.getChartPosition(), scaleX = (val) => ( // eslint-disable-line no-confusing-arrow\n        val * chartPosition.scaleX), scaleY = (val) => ( // eslint-disable-line no-confusing-arrow\n        val * chartPosition.scaleY), \n        // Build parameter arrays for firstDimension()/secondDimension()\n        buildDimensionArray = (dim) => {\n            const isX = dim === 'x';\n            return [\n                dim,\n                isX ? outerWidth : outerHeight,\n                isX ? boxWidth : boxHeight\n            ].concat(outside ? [\n                // If we are using tooltip.outside, we need to scale the\n                // position to match scaling of the container in case there\n                // is a transform/zoom on the container. #11329\n                isX ? scaleX(boxWidth) : scaleY(boxHeight),\n                isX ? chartPosition.left - distance +\n                    scaleX(point.plotX + chart.plotLeft) :\n                    chartPosition.top - distance +\n                        scaleY(point.plotY + chart.plotTop),\n                0,\n                isX ? outerWidth : outerHeight\n            ] : [\n                // Not outside, no scaling is needed\n                isX ? boxWidth : boxHeight,\n                isX ? point.plotX + chart.plotLeft :\n                    point.plotY + chart.plotTop,\n                isX ? chart.plotLeft : chart.plotTop,\n                isX ? chart.plotLeft + chart.plotWidth :\n                    chart.plotTop + chart.plotHeight\n            ]);\n        };\n        let first = buildDimensionArray('y'), second = buildDimensionArray('x'), swapped;\n        // Handle negative points or reversed axis (#13780)\n        let flipped = !!point.negative;\n        if (!chart.polar &&\n            chart.hoverSeries &&\n            chart.hoverSeries.yAxis &&\n            chart.hoverSeries.yAxis.reversed) {\n            flipped = !flipped;\n        }\n        // The far side is right or bottom\n        const preferFarSide = !this.followPointer &&\n            pick(point.ttBelow, !chart.inverted === flipped), // #4984\n        /*\n         * Handle the preferred dimension. When the preferred dimension is\n         * tooltip on top or bottom of the point, it will look for space\n         * there.\n         *\n         * @private\n         */\n        firstDimension = function (dim, outerSize, innerSize, scaledInnerSize, // #11329\n        point, min, max) {\n            const scaledDist = outside ?\n                (dim === 'y' ? scaleY(distance) : scaleX(distance)) :\n                distance, scaleDiff = (innerSize - scaledInnerSize) / 2, roomLeft = scaledInnerSize < point - distance, roomRight = point + distance + scaledInnerSize < outerSize, alignedLeft = point - scaledDist - innerSize + scaleDiff, alignedRight = point + scaledDist - scaleDiff;\n            if (preferFarSide && roomRight) {\n                ret[dim] = alignedRight;\n            }\n            else if (!preferFarSide && roomLeft) {\n                ret[dim] = alignedLeft;\n            }\n            else if (roomLeft) {\n                ret[dim] = Math.min(max - scaledInnerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);\n            }\n            else if (roomRight) {\n                ret[dim] = Math.max(min, alignedRight + h + innerSize > outerSize ?\n                    alignedRight :\n                    alignedRight + h);\n            }\n            else {\n                return false;\n            }\n        }, \n        /*\n         * Handle the secondary dimension. If the preferred dimension is\n         * tooltip on top or bottom of the point, the second dimension is to\n         * align the tooltip above the point, trying to align center but\n         * allowing left or right align within the chart box.\n         *\n         * @private\n         */\n        secondDimension = function (dim, outerSize, innerSize, scaledInnerSize, // #11329\n        point) {\n            let retVal;\n            // Too close to the edge, return false and swap dimensions\n            if (point < distance || point > outerSize - distance) {\n                retVal = false;\n                // Align left/top\n            }\n            else if (point < innerSize / 2) {\n                ret[dim] = 1;\n                // Align right/bottom\n            }\n            else if (point > outerSize - scaledInnerSize / 2) {\n                ret[dim] = outerSize - scaledInnerSize - 2;\n                // Align center\n            }\n            else {\n                ret[dim] = point - innerSize / 2;\n            }\n            return retVal;\n        }, \n        /*\n         * Swap the dimensions\n         */\n        swap = function (count) {\n            const temp = first;\n            first = second;\n            second = temp;\n            swapped = count;\n        }, run = function () {\n            if (firstDimension.apply(0, first) !== false) {\n                if (secondDimension.apply(0, second) === false &&\n                    !swapped) {\n                    swap(true);\n                    run();\n                }\n            }\n            else if (!swapped) {\n                swap(true);\n                run();\n            }\n            else {\n                ret.x = ret.y = 0;\n            }\n        };\n        // Under these conditions, prefer the tooltip on the side of the point\n        if (chart.inverted || this.len > 1) {\n            swap();\n        }\n        run();\n        return ret;\n    }\n    /**\n     * Hides the tooltip with a fade out animation.\n     *\n     * @function Highcharts.Tooltip#hide\n     *\n     * @param {number} [delay]\n     *        The fade out in milliseconds. If no value is provided the value\n     *        of the tooltip.hideDelay option is used. A value of 0 disables\n     *        the fade out animation.\n     */\n    hide(delay) {\n        const tooltip = this;\n        // Disallow duplicate timers (#1728, #1766)\n        U.clearTimeout(this.hideTimer);\n        delay = pick(delay, this.options.hideDelay);\n        if (!this.isHidden) {\n            this.hideTimer = syncTimeout(function () {\n                const label = tooltip.getLabel();\n                // If there is a delay, fade out with the default duration. If\n                // the hideDelay is 0, we assume no animation is wanted, so we\n                // pass 0 duration. #12994.\n                tooltip.getLabel().animate({\n                    opacity: 0\n                }, {\n                    duration: delay ? 150 : delay,\n                    complete: () => {\n                        // #3088, assuming we're only using this for tooltips\n                        label.hide();\n                        // Clear the container for outside tooltip (#18490)\n                        if (tooltip.container) {\n                            tooltip.container.remove();\n                        }\n                    }\n                });\n                tooltip.isHidden = true;\n            }, delay);\n        }\n    }\n    /**\n     * Initialize tooltip.\n     *\n     * @private\n     * @function Highcharts.Tooltip#init\n     *\n     * @param {Highcharts.Chart} chart\n     *        The chart instance.\n     *\n     * @param {Highcharts.TooltipOptions} options\n     *        Tooltip options.\n     */\n    init(chart, options) {\n        /**\n         * Chart of the tooltip.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#chart\n         * @type {Highcharts.Chart}\n         */\n        this.chart = chart;\n        /**\n         * Used tooltip options.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#options\n         * @type {Highcharts.TooltipOptions}\n         */\n        this.options = options;\n        /**\n         * List of crosshairs.\n         *\n         * @private\n         * @readonly\n         * @name Highcharts.Tooltip#crosshairs\n         * @type {Array<null>}\n         */\n        this.crosshairs = [];\n        /**\n         * Current values of x and y when animating.\n         *\n         * @private\n         * @readonly\n         * @name Highcharts.Tooltip#now\n         * @type {Highcharts.PositionObject}\n         */\n        this.now = { x: 0, y: 0 };\n        /**\n         * Tooltips are initially hidden.\n         *\n         * @private\n         * @readonly\n         * @name Highcharts.Tooltip#isHidden\n         * @type {boolean}\n         */\n        this.isHidden = true;\n        /**\n         * True, if the tooltip is split into one label per series, with the\n         * header close to the axis.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#split\n         * @type {boolean|undefined}\n         */\n        this.split = options.split && !chart.inverted && !chart.polar;\n        /**\n         * When the tooltip is shared, the entire plot area will capture mouse\n         * movement or touch events.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#shared\n         * @type {boolean|undefined}\n         */\n        this.shared = options.shared || this.split;\n        /**\n         * Whether to allow the tooltip to render outside the chart's SVG\n         * element box. By default (false), the tooltip is rendered within the\n         * chart's SVG element, which results in the tooltip being aligned\n         * inside the chart area.\n         *\n         * @readonly\n         * @name Highcharts.Tooltip#outside\n         * @type {boolean}\n         *\n         * @todo\n         * Split tooltip does not support outside in the first iteration. Should\n         * not be too complicated to implement.\n         */\n        this.outside = pick(options.outside, Boolean(chart.scrollablePixelsX || chart.scrollablePixelsY));\n    }\n    shouldStickOnContact(pointerEvent) {\n        return !!(!this.followPointer &&\n            this.options.stickOnContact &&\n            (!pointerEvent || this.chart.pointer.inClass(pointerEvent.target, 'highcharts-tooltip')));\n    }\n    /**\n     * Moves the tooltip with a soft animation to a new position.\n     *\n     * @private\n     * @function Highcharts.Tooltip#move\n     *\n     * @param {number} x\n     *\n     * @param {number} y\n     *\n     * @param {number} anchorX\n     *\n     * @param {number} anchorY\n     */\n    move(x, y, anchorX, anchorY) {\n        const tooltip = this, now = tooltip.now, animate = tooltip.options.animation !== false &&\n            !tooltip.isHidden &&\n            // When we get close to the target position, abort animation and\n            // land on the right place (#3056)\n            (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1), skipAnchor = tooltip.followPointer || tooltip.len > 1;\n        // Get intermediate values for animation\n        extend(now, {\n            x: animate ? (2 * now.x + x) / 3 : x,\n            y: animate ? (now.y + y) / 2 : y,\n            anchorX: skipAnchor ?\n                void 0 :\n                animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n            anchorY: skipAnchor ?\n                void 0 :\n                animate ? (now.anchorY + anchorY) / 2 : anchorY\n        });\n        // Move to the intermediate value\n        tooltip.getLabel().attr(now);\n        tooltip.drawTracker();\n        // Run on next tick of the mouse tracker\n        if (animate) {\n            // Never allow two timeouts\n            U.clearTimeout(this.tooltipTimeout);\n            // Set the fixed interval ticking for the smooth tooltip\n            this.tooltipTimeout = setTimeout(function () {\n                // The interval function may still be running during destroy,\n                // so check that the chart is really there before calling.\n                if (tooltip) {\n                    tooltip.move(x, y, anchorX, anchorY);\n                }\n            }, 32);\n        }\n    }\n    /**\n     * Refresh the tooltip's text and position.\n     *\n     * @function Highcharts.Tooltip#refresh\n     *\n     * @param {Highcharts.Point|Array<Highcharts.Point>} pointOrPoints\n     *        Either a point or an array of points.\n     *\n     * @param {Highcharts.PointerEventObject} [mouseEvent]\n     *        Mouse event, that is responsible for the refresh and should be\n     *        used for the tooltip update.\n     */\n    refresh(pointOrPoints, mouseEvent) {\n        const tooltip = this, chart = this.chart, options = tooltip.options, pointer = chart.pointer, points = splat(pointOrPoints), point = points[0], pointConfig = [], formatString = options.format, formatter = options.formatter || tooltip.defaultFormatter, shared = tooltip.shared, styledMode = chart.styledMode;\n        let formatterContext = {};\n        if (!options.enabled || !point.series) { // #16820\n            return;\n        }\n        U.clearTimeout(this.hideTimer);\n        // A switch saying if this specific tooltip configuration allows shared\n        // or split modes\n        tooltip.allowShared = !(!isArray(pointOrPoints) &&\n            pointOrPoints.series &&\n            pointOrPoints.series.noSharedTooltip);\n        // get the reference point coordinates (pie charts use tooltipPos)\n        tooltip.followPointer = (!tooltip.split && point.series.tooltipOptions.followPointer);\n        const anchor = tooltip.getAnchor(pointOrPoints, mouseEvent), x = anchor[0], y = anchor[1];\n        // shared tooltip, array is sent over\n        if (shared && tooltip.allowShared) {\n            pointer.applyInactiveState(points);\n            // Now set hover state for the choosen ones:\n            points.forEach(function (item) {\n                item.setState('hover');\n                pointConfig.push(item.getLabelConfig());\n            });\n            formatterContext = point.getLabelConfig();\n            formatterContext.points = pointConfig;\n            // single point tooltip\n        }\n        else {\n            formatterContext = point.getLabelConfig();\n        }\n        this.len = pointConfig.length; // #6128\n        const text = isString(formatString) ?\n            format(formatString, formatterContext, chart) :\n            formatter.call(formatterContext, tooltip);\n        // register the current series\n        const currentSeries = point.series;\n        this.distance = pick(currentSeries.tooltipOptions.distance, 16);\n        // update the inner HTML\n        if (text === false) {\n            this.hide();\n        }\n        else {\n            // update text\n            if (tooltip.split && tooltip.allowShared) { // #13868\n                this.renderSplit(text, points);\n            }\n            else {\n                let checkX = x;\n                let checkY = y;\n                if (mouseEvent && pointer.isDirectTouch) {\n                    checkX = mouseEvent.chartX - chart.plotLeft;\n                    checkY = mouseEvent.chartY - chart.plotTop;\n                }\n                // #11493, #13095\n                if (chart.polar ||\n                    currentSeries.options.clip === false ||\n                    points.some((p) => // #16004\n                     pointer.isDirectTouch || // ##17929\n                        p.series.shouldShowTooltip(checkX, checkY))) {\n                    const label = tooltip.getLabel();\n                    // Prevent the tooltip from flowing over the chart box\n                    // (#6659)\n                    if (!options.style.width || styledMode) {\n                        label.css({\n                            width: (this.outside ?\n                                this.getPlayingField() :\n                                chart.spacingBox).width + 'px'\n                        });\n                    }\n                    label.attr({\n                        text: text && text.join ?\n                            text.join('') :\n                            text\n                    });\n                    // Set the stroke color of the box to reflect the point\n                    label.addClass(tooltip.getClassName(point), true);\n                    if (!styledMode) {\n                        label.attr({\n                            stroke: (options.borderColor ||\n                                point.color ||\n                                currentSeries.color ||\n                                \"#666666\" /* Palette.neutralColor60 */)\n                        });\n                    }\n                    tooltip.updatePosition({\n                        plotX: x,\n                        plotY: y,\n                        negative: point.negative,\n                        ttBelow: point.ttBelow,\n                        h: anchor[2] || 0\n                    });\n                }\n                else {\n                    tooltip.hide();\n                    return;\n                }\n            }\n            // show it\n            if (tooltip.isHidden && tooltip.label) {\n                tooltip.label.attr({\n                    opacity: 1\n                }).show();\n            }\n            tooltip.isHidden = false;\n        }\n        fireEvent(this, 'refresh');\n    }\n    /**\n     * Render the split tooltip. Loops over each point's text and adds\n     * a label next to the point, then uses the distribute function to\n     * find best non-overlapping positions.\n     *\n     * @private\n     * @function Highcharts.Tooltip#renderSplit\n     *\n     * @param {string|Array<(boolean|string)>} labels\n     *\n     * @param {Array<Highcharts.Point>} points\n     */\n    renderSplit(labels, points) {\n        const tooltip = this;\n        const { chart, chart: { chartWidth, chartHeight, plotHeight, plotLeft, plotTop, pointer, scrollablePixelsY = 0, scrollablePixelsX, scrollingContainer: { scrollLeft, scrollTop } = { scrollLeft: 0, scrollTop: 0 }, styledMode }, distance, options, options: { positioner } } = tooltip;\n        // The area which the tooltip should be limited to. Limit to scrollable\n        // plot area if enabled, otherwise limit to the chart container. If\n        // outside is true it should be the whole viewport\n        const bounds = (tooltip.outside &&\n            typeof scrollablePixelsX !== 'number') ?\n            doc.documentElement.getBoundingClientRect() : {\n            left: scrollLeft,\n            right: scrollLeft + chartWidth,\n            top: scrollTop,\n            bottom: scrollTop + chartHeight\n        };\n        const tooltipLabel = tooltip.getLabel();\n        const ren = this.renderer || chart.renderer;\n        const headerTop = Boolean(chart.xAxis[0] && chart.xAxis[0].opposite);\n        const { left: chartLeft, top: chartTop } = pointer.getChartPosition();\n        let distributionBoxTop = plotTop + scrollTop;\n        let headerHeight = 0;\n        let adjustedPlotHeight = plotHeight - scrollablePixelsY;\n        /**\n         * Calculates the anchor position for the partial tooltip\n         *\n         * @private\n         * @param {Highcharts.Point} point The point related to the tooltip\n         * @return {Object} Returns an object with anchorX and anchorY\n         */\n        function getAnchor(point) {\n            const { isHeader, plotX = 0, plotY = 0, series } = point;\n            let anchorX;\n            let anchorY;\n            if (isHeader) {\n                // Set anchorX to plotX\n                anchorX = Math.max(plotLeft + plotX, plotLeft);\n                // Set anchorY to center of visible plot area.\n                anchorY = plotTop + plotHeight / 2;\n            }\n            else {\n                const { xAxis, yAxis } = series;\n                // Set anchorX to plotX. Limit to within xAxis.\n                anchorX = xAxis.pos + clamp(plotX, -distance, xAxis.len + distance);\n                // Set anchorY, limit to the scrollable plot area\n                if (series.shouldShowTooltip(0, yAxis.pos - plotTop + plotY, {\n                    ignoreX: true\n                })) {\n                    anchorY = yAxis.pos + plotY;\n                }\n            }\n            // Limit values to plot area\n            anchorX = clamp(anchorX, bounds.left - distance, bounds.right + distance);\n            return { anchorX, anchorY };\n        }\n        /**\n         * Calculates the position of the partial tooltip\n         *\n         * @private\n         * @param {number} anchorX\n         * The partial tooltip anchor x position\n         *\n         * @param {number} anchorY\n         * The partial tooltip anchor y position\n         *\n         * @param {boolean|undefined} isHeader\n         * Whether the partial tooltip is a header\n         *\n         * @param {number} boxWidth\n         * Width of the partial tooltip\n         *\n         * @return {Highcharts.PositionObject}\n         * Returns the partial tooltip x and y position\n         */\n        function defaultPositioner(anchorX, anchorY, isHeader, boxWidth, alignedLeft = true) {\n            let y;\n            let x;\n            if (isHeader) {\n                y = headerTop ? 0 : adjustedPlotHeight;\n                x = clamp(anchorX - (boxWidth / 2), bounds.left, bounds.right - boxWidth - (tooltip.outside ? chartLeft : 0));\n            }\n            else {\n                y = anchorY - distributionBoxTop;\n                x = alignedLeft ?\n                    anchorX - boxWidth - distance :\n                    anchorX + distance;\n                x = clamp(x, alignedLeft ? x : bounds.left, bounds.right);\n            }\n            // NOTE: y is relative to distributionBoxTop\n            return { x, y };\n        }\n        /**\n         * Updates the attributes and styling of the partial tooltip. Creates a\n         * new partial tooltip if it does not exists.\n         *\n         * @private\n         * @param {Highcharts.SVGElement|undefined} partialTooltip\n         *  The partial tooltip to update\n         * @param {Highcharts.Point} point\n         *  The point related to the partial tooltip\n         * @param {boolean|string} str The text for the partial tooltip\n         * @return {Highcharts.SVGElement} Returns the updated partial tooltip\n         */\n        function updatePartialTooltip(partialTooltip, point, str) {\n            let tt = partialTooltip;\n            const { isHeader, series } = point;\n            if (!tt) {\n                const attribs = {\n                    padding: options.padding,\n                    r: options.borderRadius\n                };\n                if (!styledMode) {\n                    attribs.fill = options.backgroundColor;\n                    attribs['stroke-width'] = options.borderWidth ?? 1;\n                }\n                tt = ren\n                    .label('', 0, 0, (options[isHeader ? 'headerShape' : 'shape']), void 0, void 0, options.useHTML)\n                    .addClass(tooltip.getClassName(point, true, isHeader))\n                    .attr(attribs)\n                    .add(tooltipLabel);\n            }\n            tt.isActive = true;\n            tt.attr({\n                text: str\n            });\n            if (!styledMode) {\n                tt.css(options.style)\n                    .attr({\n                    stroke: (options.borderColor ||\n                        point.color ||\n                        series.color ||\n                        \"#333333\" /* Palette.neutralColor80 */)\n                });\n            }\n            return tt;\n        }\n        // Graceful degradation for legacy formatters\n        if (isString(labels)) {\n            labels = [false, labels];\n        }\n        // Create the individual labels for header and points, ignore footer\n        let boxes = labels.slice(0, points.length + 1).reduce(function (boxes, str, i) {\n            if (str !== false && str !== '') {\n                const point = (points[i - 1] ||\n                    {\n                        // Item 0 is the header. Instead of this, we could also\n                        // use the crosshair label\n                        isHeader: true,\n                        plotX: points[0].plotX,\n                        plotY: plotHeight,\n                        series: {}\n                    });\n                const isHeader = point.isHeader;\n                // Store the tooltip label referance on the series\n                const owner = isHeader ? tooltip : point.series;\n                const tt = owner.tt = updatePartialTooltip(owner.tt, point, str.toString());\n                // Get X position now, so we can move all to the other side in\n                // case of overflow\n                const bBox = tt.getBBox();\n                const boxWidth = bBox.width + tt.strokeWidth();\n                if (isHeader) {\n                    headerHeight = bBox.height;\n                    adjustedPlotHeight += headerHeight;\n                    if (headerTop) {\n                        distributionBoxTop -= headerHeight;\n                    }\n                }\n                const { anchorX, anchorY } = getAnchor(point);\n                if (typeof anchorY === 'number') {\n                    const size = bBox.height + 1;\n                    const boxPosition = (positioner ?\n                        positioner.call(tooltip, boxWidth, size, point) :\n                        defaultPositioner(anchorX, anchorY, isHeader, boxWidth));\n                    boxes.push({\n                        // 0-align to the top, 1-align to the bottom\n                        align: positioner ? 0 : void 0,\n                        anchorX,\n                        anchorY,\n                        boxWidth,\n                        point,\n                        rank: pick(boxPosition.rank, isHeader ? 1 : 0),\n                        size,\n                        target: boxPosition.y,\n                        tt,\n                        x: boxPosition.x\n                    });\n                }\n                else {\n                    // Hide tooltips which anchorY is outside the visible plot\n                    // area\n                    tt.isActive = false;\n                }\n            }\n            return boxes;\n        }, []);\n        // Realign the tooltips towards the right if there is not enough space\n        // to the left and there is space to to the right\n        if (!positioner && boxes.some((box) => {\n            // Always realign if the beginning of a label is outside bounds\n            const { outside } = tooltip;\n            const boxStart = (outside ? chartLeft : 0) + box.anchorX;\n            if (boxStart < bounds.left &&\n                boxStart + box.boxWidth < bounds.right) {\n                return true;\n            }\n            // Otherwise, check if there is more space available to the right\n            return boxStart < (chartLeft - bounds.left) + box.boxWidth &&\n                bounds.right - boxStart > boxStart;\n        })) {\n            boxes = boxes.map((box) => {\n                const { x, y } = defaultPositioner(box.anchorX, box.anchorY, box.point.isHeader, box.boxWidth, false);\n                return extend(box, {\n                    target: y,\n                    x\n                });\n            });\n        }\n        // Clean previous run (for missing points)\n        tooltip.cleanSplit();\n        // Distribute and put in place\n        distribute(boxes, adjustedPlotHeight);\n        const boxExtremes = {\n            left: chartLeft,\n            right: chartLeft\n        };\n        // Get the extremes from series tooltips\n        boxes.forEach(function (box) {\n            const { x, boxWidth, isHeader } = box;\n            if (!isHeader) {\n                if (tooltip.outside && chartLeft + x < boxExtremes.left) {\n                    boxExtremes.left = chartLeft + x;\n                }\n                if (!isHeader &&\n                    tooltip.outside &&\n                    boxExtremes.left + boxWidth > boxExtremes.right) {\n                    boxExtremes.right = chartLeft + x;\n                }\n            }\n        });\n        boxes.forEach(function (box) {\n            const { x, anchorX, anchorY, pos, point: { isHeader } } = box;\n            const attributes = {\n                visibility: typeof pos === 'undefined' ? 'hidden' : 'inherit',\n                x,\n                /* NOTE: y should equal pos to be consistent with !split\n                 * tooltip, but is currently relative to plotTop. Is left as is\n                 * to avoid breaking change. Remove distributionBoxTop to make\n                 * it consistent.\n                 */\n                y: (pos || 0) + distributionBoxTop,\n                anchorX,\n                anchorY\n            };\n            // Handle left-aligned tooltips overflowing the chart area\n            if (tooltip.outside && x < anchorX) {\n                const offset = chartLeft - boxExtremes.left;\n                // Skip this if there is no overflow\n                if (offset > 0) {\n                    if (!isHeader) {\n                        attributes.x = x + offset;\n                        attributes.anchorX = anchorX + offset;\n                    }\n                    if (isHeader) {\n                        attributes.x = (boxExtremes.right - boxExtremes.left) / 2;\n                        attributes.anchorX = anchorX + offset;\n                    }\n                }\n            }\n            // Put the label in place\n            box.tt.attr(attributes);\n        });\n        /* If we have a seperate tooltip container, then update the necessary\n         * container properties.\n         * Test that tooltip has its own container and renderer before executing\n         * the operation.\n         */\n        const { container, outside, renderer } = tooltip;\n        if (outside && container && renderer) {\n            // Set container size to fit the bounds\n            const { width, height, x, y } = tooltipLabel.getBBox();\n            renderer.setSize(width + x, height + y, false);\n            // Position the tooltip container to the chart container\n            container.style.left = boxExtremes.left + 'px';\n            container.style.top = chartTop + 'px';\n        }\n        // Workaround for #18927, artefacts left by the shadows of split\n        // tooltips in Safari v16 (2023). Check again with later versions if we\n        // can remove this.\n        if (isSafari) {\n            tooltipLabel.attr({\n                // Force a redraw of the whole group by chaning the opacity\n                // slightly\n                opacity: tooltipLabel.opacity === 1 ? 0.999 : 1\n            });\n        }\n    }\n    /**\n     * If the `stickOnContact` option is active, this will add a tracker shape.\n     *\n     * @private\n     * @function Highcharts.Tooltip#drawTracker\n     */\n    drawTracker() {\n        const tooltip = this;\n        if (!this.shouldStickOnContact()) {\n            if (tooltip.tracker) {\n                tooltip.tracker = tooltip.tracker.destroy();\n            }\n            return;\n        }\n        const chart = tooltip.chart;\n        const label = tooltip.label;\n        const points = tooltip.shared ? chart.hoverPoints : chart.hoverPoint;\n        if (!label || !points) {\n            return;\n        }\n        const box = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        };\n        // Combine anchor and tooltip\n        const anchorPos = this.getAnchor(points);\n        const labelBBox = label.getBBox();\n        anchorPos[0] += chart.plotLeft - (label.translateX || 0);\n        anchorPos[1] += chart.plotTop - (label.translateY || 0);\n        // When the mouse pointer is between the anchor point and the label,\n        // the label should stick.\n        box.x = Math.min(0, anchorPos[0]);\n        box.y = Math.min(0, anchorPos[1]);\n        box.width = (anchorPos[0] < 0 ?\n            Math.max(Math.abs(anchorPos[0]), (labelBBox.width - anchorPos[0])) :\n            Math.max(Math.abs(anchorPos[0]), labelBBox.width));\n        box.height = (anchorPos[1] < 0 ?\n            Math.max(Math.abs(anchorPos[1]), (labelBBox.height - Math.abs(anchorPos[1]))) :\n            Math.max(Math.abs(anchorPos[1]), labelBBox.height));\n        if (tooltip.tracker) {\n            tooltip.tracker.attr(box);\n        }\n        else {\n            tooltip.tracker = label.renderer\n                .rect(box)\n                .addClass('highcharts-tracker')\n                .add(label);\n            if (!chart.styledMode) {\n                tooltip.tracker.attr({\n                    fill: 'rgba(0,0,0,0)'\n                });\n            }\n        }\n    }\n    /**\n     * @private\n     */\n    styledModeFormat(formatString) {\n        return formatString\n            .replace('style=\"font-size: 0.8em\"', 'class=\"highcharts-header\"')\n            .replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex} ' +\n            '{series.options.className} ' +\n            '{point.options.className}\"');\n    }\n    /**\n     * Format the footer/header of the tooltip\n     * #3397: abstraction to enable formatting of footer and header\n     *\n     * @private\n     * @function Highcharts.Tooltip#tooltipFooterHeaderFormatter\n     */\n    tooltipFooterHeaderFormatter(labelConfig, isFooter) {\n        const series = labelConfig.series, tooltipOptions = series.tooltipOptions, xAxis = series.xAxis, dateTime = xAxis && xAxis.dateTime, e = {\n            isFooter: isFooter,\n            labelConfig: labelConfig\n        };\n        let xDateFormat = tooltipOptions.xDateFormat, formatString = tooltipOptions[isFooter ? 'footerFormat' : 'headerFormat'];\n        fireEvent(this, 'headerFormatter', e, function (e) {\n            // Guess the best date format based on the closest point distance\n            // (#568, #3418)\n            if (dateTime && !xDateFormat && isNumber(labelConfig.key)) {\n                xDateFormat = dateTime.getXDateFormat(labelConfig.key, tooltipOptions.dateTimeLabelFormats);\n            }\n            // Insert the footer date format if any\n            if (dateTime && xDateFormat) {\n                ((labelConfig.point && labelConfig.point.tooltipDateKeys) ||\n                    ['key']).forEach(function (key) {\n                    formatString = formatString.replace('{point.' + key + '}', '{point.' + key + ':' + xDateFormat + '}');\n                });\n            }\n            // Replace default header style with class name\n            if (series.chart.styledMode) {\n                formatString = this.styledModeFormat(formatString);\n            }\n            e.text = format(formatString, {\n                point: labelConfig,\n                series: series\n            }, this.chart);\n        });\n        return e.text;\n    }\n    /**\n     * Updates the tooltip with the provided tooltip options.\n     *\n     * @function Highcharts.Tooltip#update\n     *\n     * @param {Highcharts.TooltipOptions} options\n     *        The tooltip options to update.\n     */\n    update(options) {\n        this.destroy();\n        this.init(this.chart, merge(true, this.options, options));\n    }\n    /**\n     * Find the new position and perform the move\n     *\n     * @private\n     * @function Highcharts.Tooltip#updatePosition\n     *\n     * @param {Highcharts.Point} point\n     */\n    updatePosition(point) {\n        const { chart, container, distance, options, renderer } = this, { height = 0, width = 0 } = this.getLabel(), pointer = chart.pointer, \n        // Needed for outside: true (#11688)\n        { left, top, scaleX, scaleY } = pointer.getChartPosition(), pos = (options.positioner || this.getPosition).call(this, width, height, point);\n        let anchorX = (point.plotX || 0) + chart.plotLeft, anchorY = (point.plotY || 0) + chart.plotTop, pad;\n        // Set the renderer size dynamically to prevent document size to change.\n        // Renderer only exists when tooltip is outside.\n        if (renderer && container) {\n            // Corrects positions, occurs with tooltip positioner (#16944)\n            if (options.positioner) {\n                pos.x += left - distance;\n                pos.y += top - distance;\n            }\n            // Pad it by the border width and distance. Add 2 to make room for\n            // the default shadow (#19314).\n            pad = (options.borderWidth || 0) + 2 * distance + 2;\n            renderer.setSize(width + pad, height + pad, false);\n            // Anchor and tooltip container need scaling if chart container has\n            // scale transform/css zoom. #11329.\n            if (scaleX !== 1 || scaleY !== 1) {\n                css(container, {\n                    transform: `scale(${scaleX}, ${scaleY})`\n                });\n                anchorX *= scaleX;\n                anchorY *= scaleY;\n            }\n            anchorX += left - pos.x;\n            anchorY += top - pos.y;\n        }\n        // Do the move\n        this.move(Math.round(pos.x), Math.round(pos.y || 0), // Can be undefined (#3977)\n        anchorX, anchorY);\n    }\n}\n/* *\n *\n *  Class namespace\n *\n * */\n(function (Tooltip) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Constants\n     *\n     * */\n    const composedMembers = [];\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * @private\n     */\n    function compose(PointerClass) {\n        if (U.pushUnique(composedMembers, PointerClass)) {\n            addEvent(PointerClass, 'afterInit', function () {\n                const chart = this.chart;\n                if (chart.options.tooltip) {\n                    /**\n                     * Tooltip object for points of series.\n                     *\n                     * @name Highcharts.Chart#tooltip\n                     * @type {Highcharts.Tooltip}\n                     */\n                    chart.tooltip = new Tooltip(chart, chart.options.tooltip);\n                }\n            });\n        }\n    }\n    Tooltip.compose = compose;\n})(Tooltip || (Tooltip = {}));\n/* *\n *\n *  Default export\n *\n * */\nexport default Tooltip;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Callback function to format the text of the tooltip from scratch.\n *\n * In case of single or shared tooltips, a string should be be returned. In case\n * of splitted tooltips, it should return an array where the first item is the\n * header, and subsequent items are mapped to the points. Return `false` to\n * disable tooltip for a specific point on series.\n *\n * @callback Highcharts.TooltipFormatterCallbackFunction\n *\n * @param {Highcharts.TooltipFormatterContextObject} this\n * Context to format\n *\n * @param {Highcharts.Tooltip} tooltip\n * The tooltip instance\n *\n * @return {false|string|Array<(string|null|undefined)>|null|undefined}\n * Formatted text or false\n */\n/**\n * Configuration for the tooltip formatters.\n *\n * @interface Highcharts.TooltipFormatterContextObject\n * @extends Highcharts.PointLabelObject\n */ /**\n* Array of points in shared tooltips.\n* @name Highcharts.TooltipFormatterContextObject#points\n* @type {Array<Highcharts.TooltipFormatterContextObject>|undefined}\n*/\n/**\n * A callback function to place the tooltip in a specific position.\n *\n * @callback Highcharts.TooltipPositionerCallbackFunction\n *\n * @param {Highcharts.Tooltip} this\n * Tooltip context of the callback.\n *\n * @param {number} labelWidth\n * Width of the tooltip.\n *\n * @param {number} labelHeight\n * Height of the tooltip.\n *\n * @param {Highcharts.TooltipPositionerPointObject} point\n * Point information for positioning a tooltip.\n *\n * @return {Highcharts.PositionObject}\n * New position for the tooltip.\n */\n/**\n * Point information for positioning a tooltip.\n *\n * @interface Highcharts.TooltipPositionerPointObject\n * @extends Highcharts.Point\n */ /**\n* If `tooltip.split` option is enabled and positioner is called for each of the\n* boxes separately, this property indicates the call on the xAxis header, which\n* is not a point itself.\n* @name Highcharts.TooltipPositionerPointObject#isHeader\n* @type {boolean}\n*/ /**\n* The reference point relative to the plot area. Add chart.plotLeft to get the\n* full coordinates.\n* @name Highcharts.TooltipPositionerPointObject#plotX\n* @type {number}\n*/ /**\n* The reference point relative to the plot area. Add chart.plotTop to get the\n* full coordinates.\n* @name Highcharts.TooltipPositionerPointObject#plotY\n* @type {number}\n*/\n/**\n * @typedef {\"callout\"|\"circle\"|\"rect\"} Highcharts.TooltipShapeValue\n */\n''; // keeps doclets above in JS file\n"],"mappings":"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AC1C,CAAC,CAAC;QACFuD,OAAO,IAAIzD,MAAM;QACjB0D,OAAO,IAAIxD,MAAM;MACrB;MACAuD,OAAO,IAAIpF,IAAI,GAAG1C,GAAG,CAAC2G,CAAC;MACvBoB,OAAO,IAAIvG,GAAG,GAAGxB,GAAG,CAAC4G,CAAC;IAC1B;IACA;IACA,IAAI,CAACiB,IAAI,CAAC1H,IAAI,CAACC,KAAK,CAACJ,GAAG,CAAC2G,CAAC,CAAC,EAAExG,IAAI,CAACC,KAAK,CAACJ,GAAG,CAAC4G,CAAC,IAAI,CAAC,CAAC;IAAE;IACrDkB,OAAO,EAAEC,OAAO,CAAC;EACrB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,UAAUzL,OAAO,EAAE;EAChB;AACJ;AACA;AACA;AACA;EACI;AACJ;AACA;AACA;AACA;EACI,MAAM8R,eAAe,GAAG,EAAE;EAC1B;AACJ;AACA;AACA;AACA;EACI;AACJ;AACA;EACI,SAASC,OAAOA,CAACC,YAAY,EAAE;IAC3B,IAAI9S,CAAC,CAAC+S,UAAU,CAACH,eAAe,EAAEE,YAAY,CAAC,EAAE;MAC7C7S,QAAQ,CAAC6S,YAAY,EAAE,WAAW,EAAE,YAAY;QAC5C,MAAM9R,KAAK,GAAG,IAAI,CAACA,KAAK;QACxB,IAAIA,KAAK,CAACC,OAAO,CAAC0B,OAAO,EAAE;UACvB;AACpB;AACA;AACA;AACA;AACA;UACoB3B,KAAK,CAAC2B,OAAO,GAAG,IAAI7B,OAAO,CAACE,KAAK,EAAEA,KAAK,CAACC,OAAO,CAAC0B,OAAO,CAAC;QAC7D;MACJ,CAAC,CAAC;IACN;EACJ;EACA7B,OAAO,CAAC+R,OAAO,GAAGA,OAAO;AAC7B,CAAC,EAAE/R,OAAO,KAAKA,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7B;AACA;AACA;AACA;AACA;AACA,eAAeA,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GALA,CAKI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GALA,CAKI;AACJ;AACA;AACA;AACA;AACA;AACA,MANI,CAMD;AACH;AACA;AACA;AACA;AACA,SALG,CAKA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}