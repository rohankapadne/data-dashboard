{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport H from './Globals.js';\nconst {\n  win\n} = H;\nimport U from './Utilities.js';\nconst {\n  defined,\n  error,\n  extend,\n  isObject,\n  merge,\n  objectEach,\n  pad,\n  pick,\n  splat,\n  timeUnits\n} = U;\n/* *\n *\n *  Constants\n *\n * */\nconst hasNewSafariBug = H.isSafari && win.Intl && win.Intl.DateTimeFormat.prototype.formatRange;\n// To do: Remove this when we no longer need support for Safari < v14.1\nconst hasOldSafariBug = H.isSafari && win.Intl && !win.Intl.DateTimeFormat.prototype.formatRange;\n/* *\n *\n *  Class\n *\n * */\n/* eslint-disable no-invalid-this, valid-jsdoc */\n/**\n * The Time class. Time settings are applied in general for each page using\n * `Highcharts.setOptions`, or individually for each Chart item through the\n * [time](https://api.highcharts.com/highcharts/time) options set.\n *\n * The Time object is available from {@link Highcharts.Chart#time},\n * which refers to  `Highcharts.time` if no individual time settings are\n * applied.\n *\n * @example\n * // Apply time settings globally\n * Highcharts.setOptions({\n *     time: {\n *         timezone: 'Europe/London'\n *     }\n * });\n *\n * // Apply time settings by instance\n * let chart = Highcharts.chart('container', {\n *     time: {\n *         timezone: 'America/New_York'\n *     },\n *     series: [{\n *         data: [1, 4, 3, 5]\n *     }]\n * });\n *\n * // Use the Time object\n * console.log(\n *        'Current time in New York',\n *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())\n * );\n *\n * @since 6.0.5\n *\n * @class\n * @name Highcharts.Time\n *\n * @param {Highcharts.TimeOptions} [options]\n * Time options as defined in [chart.options.time](/highcharts/time).\n */\nclass Time {\n  /* *\n   *\n   *  Constructors\n   *\n   * */\n  constructor(options) {\n    /* *\n     *\n     *  Properties\n     *\n     * */\n    this.options = {};\n    this.useUTC = false;\n    this.variableTimezone = false;\n    this.Date = win.Date;\n    /**\n     * Get the time zone offset based on the current timezone information as\n     * set in the global options.\n     *\n     * @function Highcharts.Time#getTimezoneOffset\n     *\n     * @param {number} timestamp\n     *        The JavaScript timestamp to inspect.\n     *\n     * @return {number}\n     *         The timezone offset in minutes compared to UTC.\n     */\n    this.getTimezoneOffset = this.timezoneOffsetFunction();\n    this.update(options);\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * Time units used in `Time.get` and `Time.set`\n   *\n   * @typedef {\"Date\"|\"Day\"|\"FullYear\"|\"Hours\"|\"Milliseconds\"|\"Minutes\"|\"Month\"|\"Seconds\"} Highcharts.TimeUnitValue\n   */\n  /**\n   * Get the value of a date object in given units, and subject to the Time\n   * object's current timezone settings. This function corresponds directly to\n   * JavaScripts `Date.getXXX / Date.getUTCXXX`, so instead of calling\n   * `date.getHours()` or `date.getUTCHours()` we will call\n   * `time.get('Hours')`.\n   *\n   * @function Highcharts.Time#get\n   *\n   * @param {Highcharts.TimeUnitValue} unit\n   * @param {Date} date\n   *\n   * @return {number}\n   *        The given time unit\n   */\n  get(unit, date) {\n    if (this.variableTimezone || this.timezoneOffset) {\n      const realMs = date.getTime();\n      const ms = realMs - this.getTimezoneOffset(date);\n      date.setTime(ms); // Temporary adjust to timezone\n      const ret = date['getUTC' + unit]();\n      date.setTime(realMs); // Reset\n      return ret;\n    }\n    // UTC time with no timezone handling\n    if (this.useUTC) {\n      return date['getUTC' + unit]();\n    }\n    // Else, local time\n    return date['get' + unit]();\n  }\n  /**\n   * Set the value of a date object in given units, and subject to the Time\n   * object's current timezone settings. This function corresponds directly to\n   * JavaScripts `Date.setXXX / Date.setUTCXXX`, so instead of calling\n   * `date.setHours(0)` or `date.setUTCHours(0)` we will call\n   * `time.set('Hours', 0)`.\n   *\n   * @function Highcharts.Time#set\n   *\n   * @param {Highcharts.TimeUnitValue} unit\n   * @param {Date} date\n   * @param {number} value\n   *\n   * @return {number}\n   *        The epoch milliseconds of the updated date\n   */\n  set(unit, date, value) {\n    // UTC time with timezone handling\n    if (this.variableTimezone || this.timezoneOffset) {\n      // For lower order time units, just set it directly using UTC\n      // time\n      if (unit === 'Milliseconds' || unit === 'Seconds' || unit === 'Minutes' && this.getTimezoneOffset(date) % 3600000 === 0 // #13961\n      ) {\n        return date['setUTC' + unit](value);\n      }\n      // Higher order time units need to take the time zone into\n      // account\n      // Adjust by timezone\n      const offset = this.getTimezoneOffset(date);\n      let ms = date.getTime() - offset;\n      date.setTime(ms);\n      date['setUTC' + unit](value);\n      const newOffset = this.getTimezoneOffset(date);\n      ms = date.getTime() + newOffset;\n      return date.setTime(ms);\n    }\n    // UTC time with no timezone handling\n    if (this.useUTC ||\n    // leap calculation in UTC only\n    hasNewSafariBug && unit === 'FullYear') {\n      return date['setUTC' + unit](value);\n    }\n    // Else, local time\n    return date['set' + unit](value);\n  }\n  /**\n   * Update the Time object with current options. It is called internally on\n   * initializing Highcharts, after running `Highcharts.setOptions` and on\n   * `Chart.update`.\n   *\n   * @private\n   * @function Highcharts.Time#update\n   *\n   * @param {Highcharts.TimeOptions} [options]\n   *\n   */\n  update(options = {}) {\n    const useUTC = pick(options.useUTC, true);\n    this.options = options = merge(true, this.options, options);\n    // Allow using a different Date class\n    this.Date = options.Date || win.Date || Date;\n    this.useUTC = useUTC;\n    this.timezoneOffset = useUTC && options.timezoneOffset || void 0;\n    this.getTimezoneOffset = this.timezoneOffsetFunction();\n    /*\n     * The time object has options allowing for variable time zones, meaning\n     * the axis ticks or series data needs to consider this.\n     */\n    this.variableTimezone = useUTC && !!(options.getTimezoneOffset || options.timezone);\n  }\n  /**\n   * Make a time and returns milliseconds. Interprets the inputs as UTC time,\n   * local time or a specific timezone time depending on the current time\n   * settings.\n   *\n   * @function Highcharts.Time#makeTime\n   *\n   * @param {number} year\n   *        The year\n   *\n   * @param {number} month\n   *        The month. Zero-based, so January is 0.\n   *\n   * @param {number} [date=1]\n   *        The day of the month\n   *\n   * @param {number} [hours=0]\n   *        The hour of the day, 0-23.\n   *\n   * @param {number} [minutes=0]\n   *        The minutes\n   *\n   * @param {number} [seconds=0]\n   *        The seconds\n   *\n   * @return {number}\n   *         The time in milliseconds since January 1st 1970.\n   */\n  makeTime(year, month, date, hours, minutes, seconds) {\n    let d, offset, newOffset;\n    if (this.useUTC) {\n      d = this.Date.UTC.apply(0, arguments);\n      offset = this.getTimezoneOffset(d);\n      d += offset;\n      newOffset = this.getTimezoneOffset(d);\n      if (offset !== newOffset) {\n        d += newOffset - offset;\n        // A special case for transitioning from summer time to winter time.\n        // When the clock is set back, the same time is repeated twice, i.e.\n        // 02:30 am is repeated since the clock is set back from 3 am to\n        // 2 am. We need to make the same time as local Date does.\n      } else if (offset - 36e5 === this.getTimezoneOffset(d - 36e5) && !hasOldSafariBug) {\n        d -= 36e5;\n      }\n    } else {\n      d = new this.Date(year, month, pick(date, 1), pick(hours, 0), pick(minutes, 0), pick(seconds, 0)).getTime();\n    }\n    return d;\n  }\n  /**\n   * Sets the getTimezoneOffset function. If the `timezone` option is set, a\n   * default getTimezoneOffset function with that timezone is returned. If\n   * a `getTimezoneOffset` option is defined, it is returned. If neither are\n   * specified, the function using the `timezoneOffset` option or 0 offset is\n   * returned.\n   *\n   * @private\n   * @function Highcharts.Time#timezoneOffsetFunction\n   *\n   * @return {Function}\n   *         A getTimezoneOffset function\n   */\n  timezoneOffsetFunction() {\n    const time = this,\n      options = this.options,\n      getTimezoneOffset = options.getTimezoneOffset,\n      moment = options.moment || win.moment;\n    if (!this.useUTC) {\n      return function (timestamp) {\n        return new Date(timestamp.toString()).getTimezoneOffset() * 60000;\n      };\n    }\n    if (options.timezone) {\n      if (!moment) {\n        // getTimezoneOffset-function stays undefined because it depends\n        // on Moment.js\n        error(25);\n      } else {\n        return function (timestamp) {\n          return -moment.tz(timestamp, options.timezone).utcOffset() * 60000;\n        };\n      }\n    }\n    // If not timezone is set, look for the getTimezoneOffset callback\n    if (this.useUTC && getTimezoneOffset) {\n      return function (timestamp) {\n        return getTimezoneOffset(timestamp.valueOf()) * 60000;\n      };\n    }\n    // Last, use the `timezoneOffset` option if set\n    return function () {\n      return (time.timezoneOffset || 0) * 60000;\n    };\n  }\n  /**\n   * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970)\n   * into a human readable date string. The available format keys are listed\n   * below. Additional formats can be given in the\n   * {@link Highcharts.dateFormats} hook.\n   *\n   * Supported format keys:\n   * - `%a`: Short weekday, like 'Mon'\n   * - `%A`: Long weekday, like 'Monday'\n   * - `%d`: Two digit day of the month, 01 to 31\n   * - `%e`: Day of the month, 1 through 31\n   * - `%w`: Day of the week, 0 through 6\n   * - `%b`: Short month, like 'Jan'\n   * - `%B`: Long month, like 'January'\n   * - `%m`: Two digit month number, 01 through 12\n   * - `%y`: Two digits year, like 09 for 2009\n   * - `%Y`: Four digits year, like 2009\n   * - `%H`: Two digits hours in 24h format, 00 through 23\n   * - `%k`: Hours in 24h format, 0 through 23\n   * - `%I`: Two digits hours in 12h format, 00 through 11\n   * - `%l`: Hours in 12h format, 1 through 12\n   * - `%M`: Two digits minutes, 00 through 59\n   * - `%p`: Upper case AM or PM\n   * - `%P`: Lower case AM or PM\n   * - `%S`: Two digits seconds, 00 through 59\n   * - `%L`: Milliseconds (naming from Ruby)\n   *\n   * @example\n   * const time = new Highcharts.Time();\n   * const s = time.dateFormat('%Y-%m-%d %H:%M:%S', Date.UTC(2020, 0, 1));\n   * console.log(s); // => 2020-01-01 00:00:00\n   *\n   * @function Highcharts.Time#dateFormat\n   *\n   * @param {string} format\n   *        The desired format where various time representations are\n   *        prefixed with %.\n   *\n   * @param {number} [timestamp]\n   *        The JavaScript timestamp.\n   *\n   * @param {boolean} [capitalize=false]\n   *        Upper case first letter in the return.\n   *\n   * @return {string}\n   *         The formatted date.\n   */\n  dateFormat(format, timestamp, capitalize) {\n    if (!defined(timestamp) || isNaN(timestamp)) {\n      return H.defaultOptions.lang && H.defaultOptions.lang.invalidDate || '';\n    }\n    format = pick(format, '%Y-%m-%d %H:%M:%S');\n    const time = this,\n      date = new this.Date(timestamp),\n      // get the basic time values\n      hours = this.get('Hours', date),\n      day = this.get('Day', date),\n      dayOfMonth = this.get('Date', date),\n      month = this.get('Month', date),\n      fullYear = this.get('FullYear', date),\n      lang = H.defaultOptions.lang,\n      langWeekdays = lang && lang.weekdays,\n      shortWeekdays = lang && lang.shortWeekdays,\n      // List all format keys. Custom formats can be added from the\n      // outside.\n      replacements = extend({\n        // Day\n        // Short weekday, like 'Mon'\n        a: shortWeekdays ? shortWeekdays[day] : langWeekdays[day].substr(0, 3),\n        // Long weekday, like 'Monday'\n        A: langWeekdays[day],\n        // Two digit day of the month, 01 to 31\n        d: pad(dayOfMonth),\n        // Day of the month, 1 through 31\n        e: pad(dayOfMonth, 2, ' '),\n        // Day of the week, 0 through 6\n        w: day,\n        // Week (none implemented)\n        // 'W': weekNumber(),\n        // Month\n        // Short month, like 'Jan'\n        b: lang.shortMonths[month],\n        // Long month, like 'January'\n        B: lang.months[month],\n        // Two digit month number, 01 through 12\n        m: pad(month + 1),\n        // Month number, 1 through 12 (#8150)\n        o: month + 1,\n        // Year\n        // Two digits year, like 09 for 2009\n        y: fullYear.toString().substr(2, 2),\n        // Four digits year, like 2009\n        Y: fullYear,\n        // Time\n        // Two digits hours in 24h format, 00 through 23\n        H: pad(hours),\n        // Hours in 24h format, 0 through 23\n        k: hours,\n        // Two digits hours in 12h format, 00 through 11\n        I: pad(hours % 12 || 12),\n        // Hours in 12h format, 1 through 12\n        l: hours % 12 || 12,\n        // Two digits minutes, 00 through 59\n        M: pad(this.get('Minutes', date)),\n        // Upper case AM or PM\n        p: hours < 12 ? 'AM' : 'PM',\n        // Lower case AM or PM\n        P: hours < 12 ? 'am' : 'pm',\n        // Two digits seconds, 00 through  59\n        S: pad(this.get('Seconds', date)),\n        // Milliseconds (naming from Ruby)\n        L: pad(Math.floor(timestamp % 1000), 3)\n      }, H.dateFormats);\n    // Do the replaces\n    objectEach(replacements, function (val, key) {\n      // Regex would do it in one line, but this is faster\n      while (format.indexOf('%' + key) !== -1) {\n        format = format.replace('%' + key, typeof val === 'function' ? val.call(time, timestamp) : val);\n      }\n    });\n    // Optionally capitalize the string and return\n    return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;\n  }\n  /**\n   * Resolve legacy formats of dateTimeLabelFormats (strings and arrays) into\n   * an object.\n   * @private\n   * @param {string|Array<T>|Highcharts.Dictionary<T>} f\n   * General format description\n   * @return {Highcharts.Dictionary<T>}\n   * The object definition\n   */\n  resolveDTLFormat(f) {\n    if (!isObject(f, true)) {\n      // check for string or array\n      f = splat(f);\n      return {\n        main: f[0],\n        from: f[1],\n        to: f[2]\n      };\n    }\n    return f;\n  }\n  /**\n   * Return an array with time positions distributed on round time values\n   * right and right after min and max. Used in datetime axes as well as for\n   * grouping data on a datetime axis.\n   *\n   * @function Highcharts.Time#getTimeTicks\n   *\n   * @param {Highcharts.TimeNormalizedObject} normalizedInterval\n   *        The interval in axis values (ms) and the count\n   *\n   * @param {number} [min]\n   *        The minimum in axis values\n   *\n   * @param {number} [max]\n   *        The maximum in axis values\n   *\n   * @param {number} [startOfWeek=1]\n   *\n   * @return {Highcharts.AxisTickPositionsArray}\n   * Time positions\n   */\n  getTimeTicks(normalizedInterval, min, max, startOfWeek) {\n    const time = this,\n      Date = time.Date,\n      tickPositions = [],\n      higherRanks = {},\n      // When crossing DST, use the max. Resolves #6278.\n      minDate = new Date(min),\n      interval = normalizedInterval.unitRange,\n      count = normalizedInterval.count || 1;\n    let i, minYear,\n      // used in months and years as a basis for Date.UTC()\n      variableDayLength, minDay;\n    startOfWeek = pick(startOfWeek, 1);\n    if (defined(min)) {\n      // #1300\n      time.set('Milliseconds', minDate, interval >= timeUnits.second ? 0 :\n      // #3935\n      count * Math.floor(time.get('Milliseconds', minDate) / count)); // #3652, #3654\n      if (interval >= timeUnits.second) {\n        // second\n        time.set('Seconds', minDate, interval >= timeUnits.minute ? 0 :\n        // #3935\n        count * Math.floor(time.get('Seconds', minDate) / count));\n      }\n      if (interval >= timeUnits.minute) {\n        // minute\n        time.set('Minutes', minDate, interval >= timeUnits.hour ? 0 : count * Math.floor(time.get('Minutes', minDate) / count));\n      }\n      if (interval >= timeUnits.hour) {\n        // hour\n        time.set('Hours', minDate, interval >= timeUnits.day ? 0 : count * Math.floor(time.get('Hours', minDate) / count));\n      }\n      if (interval >= timeUnits.day) {\n        // day\n        time.set('Date', minDate, interval >= timeUnits.month ? 1 : Math.max(1, count * Math.floor(time.get('Date', minDate) / count)));\n      }\n      if (interval >= timeUnits.month) {\n        // month\n        time.set('Month', minDate, interval >= timeUnits.year ? 0 : count * Math.floor(time.get('Month', minDate) / count));\n        minYear = time.get('FullYear', minDate);\n      }\n      if (interval >= timeUnits.year) {\n        // year\n        minYear -= minYear % count;\n        time.set('FullYear', minDate, minYear);\n      }\n      // week is a special case that runs outside the hierarchy\n      if (interval === timeUnits.week) {\n        // get start of current week, independent of count\n        minDay = time.get('Day', minDate);\n        time.set('Date', minDate, time.get('Date', minDate) - minDay + startOfWeek + (\n        // We don't want to skip days that are before\n        // startOfWeek (#7051)\n        minDay < startOfWeek ? -7 : 0));\n      }\n      // Get basics for variable time spans\n      minYear = time.get('FullYear', minDate);\n      const minMonth = time.get('Month', minDate),\n        minDateDate = time.get('Date', minDate),\n        minHours = time.get('Hours', minDate);\n      // Redefine min to the floored/rounded minimum time (#7432)\n      min = minDate.getTime();\n      // Handle local timezone offset\n      if ((time.variableTimezone || !time.useUTC) && defined(max)) {\n        // Detect whether we need to take the DST crossover into\n        // consideration. If we're crossing over DST, the day length may\n        // be 23h or 25h and we need to compute the exact clock time for\n        // each tick instead of just adding hours. This comes at a cost,\n        // so first we find out if it is needed (#4951).\n        variableDayLength =\n        // Long range, assume we're crossing over.\n        max - min > 4 * timeUnits.month ||\n        // Short range, check if min and max are in different time\n        // zones.\n        time.getTimezoneOffset(min) !== time.getTimezoneOffset(max);\n      }\n      // Iterate and add tick positions at appropriate values\n      let t = minDate.getTime();\n      i = 1;\n      while (t < max) {\n        tickPositions.push(t);\n        // if the interval is years, use Date.UTC to increase years\n        if (interval === timeUnits.year) {\n          t = time.makeTime(minYear + i * count, 0);\n          // if the interval is months, use Date.UTC to increase months\n        } else if (interval === timeUnits.month) {\n          t = time.makeTime(minYear, minMonth + i * count);\n          // if we're using global time, the interval is not fixed as it\n          // jumps one hour at the DST crossover\n        } else if (variableDayLength && (interval === timeUnits.day || interval === timeUnits.week)) {\n          t = time.makeTime(minYear, minMonth, minDateDate + i * count * (interval === timeUnits.day ? 1 : 7));\n        } else if (variableDayLength && interval === timeUnits.hour && count > 1) {\n          // make sure higher ranks are preserved across DST (#6797,\n          // #7621)\n          t = time.makeTime(minYear, minMonth, minDateDate, minHours + i * count);\n          // else, the interval is fixed and we use simple addition\n        } else {\n          t += interval * count;\n        }\n        i++;\n      }\n      // push the last time\n      tickPositions.push(t);\n      // Handle higher ranks. Mark new days if the time is on midnight\n      // (#950, #1649, #1760, #3349). Use a reasonable dropout threshold\n      // to prevent looping over dense data grouping (#6156).\n      if (interval <= timeUnits.hour && tickPositions.length < 10000) {\n        tickPositions.forEach(function (t) {\n          if (\n          // Speed optimization, no need to run dateFormat unless\n          // we're on a full or half hour\n          t % 1800000 === 0 &&\n          // Check for local or global midnight\n          time.dateFormat('%H%M%S%L', t) === '000000000') {\n            higherRanks[t] = 'day';\n          }\n        });\n      }\n    }\n    // record information on the chosen unit - for dynamic label formatter\n    tickPositions.info = extend(normalizedInterval, {\n      higherRanks,\n      totalRange: interval * count\n    });\n    return tickPositions;\n  }\n  /**\n   * Get the optimal date format for a point, based on a range.\n   *\n   * @private\n   * @function Highcharts.Time#getDateFormat\n   *\n   * @param {number} range\n   *        The time range\n   *\n   * @param {number} timestamp\n   *        The timestamp of the date\n   *\n   * @param {number} startOfWeek\n   *        An integer representing the first day of the week, where 0 is\n   *        Sunday.\n   *\n   * @param {Highcharts.Dictionary<string>} dateTimeLabelFormats\n   *        A map of time units to formats.\n   *\n   * @return {string}\n   *         The optimal date format for a point.\n   */\n  getDateFormat(range, timestamp, startOfWeek, dateTimeLabelFormats) {\n    const dateStr = this.dateFormat('%m-%d %H:%M:%S.%L', timestamp),\n      blank = '01-01 00:00:00.000',\n      strpos = {\n        millisecond: 15,\n        second: 12,\n        minute: 9,\n        hour: 6,\n        day: 3\n      };\n    let n = 'millisecond',\n      // for sub-millisecond data, #4223\n      lastN = n;\n    for (n in timeUnits) {\n      // eslint-disable-line guard-for-in\n      // If the range is exactly one week and we're looking at a\n      // Sunday/Monday, go for the week format\n      if (range === timeUnits.week && +this.dateFormat('%w', timestamp) === startOfWeek && dateStr.substr(6) === blank.substr(6)) {\n        n = 'week';\n        break;\n      }\n      // The first format that is too great for the range\n      if (timeUnits[n] > range) {\n        n = lastN;\n        break;\n      }\n      // If the point is placed every day at 23:59, we need to show\n      // the minutes as well. #2637.\n      if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {\n        break;\n      }\n      // Weeks are outside the hierarchy, only apply them on\n      // Mondays/Sundays like in the first condition\n      if (n !== 'week') {\n        lastN = n;\n      }\n    }\n    return this.resolveDTLFormat(dateTimeLabelFormats[n]).main;\n  }\n}\n/* *\n *\n * Default export\n *\n * */\nexport default Time;\n/* *\n *\n * API Declarations\n *\n * */\n/**\n * Normalized interval.\n *\n * @interface Highcharts.TimeNormalizedObject\n */ /**\n    * The count.\n    *\n    * @name Highcharts.TimeNormalizedObject#count\n    * @type {number|undefined}\n    */ /**\n       * The interval in axis values (ms).\n       *\n       * @name Highcharts.TimeNormalizedObject#unitRange\n       * @type {number}\n       */\n/**\n * Function of an additional date format specifier.\n *\n * @callback Highcharts.TimeFormatCallbackFunction\n *\n * @param {number} timestamp\n *        The time to format.\n *\n * @return {string}\n *         The formatted portion of the date.\n */\n/**\n * Time ticks.\n *\n * @interface Highcharts.AxisTickPositionsArray\n * @extends global.Array<number>\n */ /**\n    * @name Highcharts.AxisTickPositionsArray#info\n    * @type {Highcharts.TimeTicksInfoObject|undefined}\n    */\n/**\n * A callback to return the time zone offset for a given datetime. It\n * takes the timestamp in terms of milliseconds since January 1 1970,\n * and returns the timezone offset in minutes. This provides a hook\n * for drawing time based charts in specific time zones using their\n * local DST crossover dates, with the help of external libraries.\n *\n * @callback Highcharts.TimezoneOffsetCallbackFunction\n *\n * @param {number} timestamp\n * Timestamp in terms of milliseconds since January 1 1970.\n *\n * @return {number}\n * Timezone offset in minutes.\n */\n/**\n * Allows to manually load the `moment.js` library from Highcharts options\n * instead of the `window`.\n * In case of loading the library from a `script` tag,\n * this option is not needed, it will be loaded from there by default.\n *\n * @type      {Function}\n * @since     8.2.0\n * @apioption time.moment\n */\n''; // keeps doclets above in JS file","map":{"version":3,"names":["H","win","U","defined","error","extend","isObject","merge","objectEach","pad","pick","splat","timeUnits","hasNewSafariBug","isSafari","Intl","DateTimeFormat","prototype","formatRange","hasOldSafariBug","Time","constructor","options","useUTC","variableTimezone","Date","getTimezoneOffset","timezoneOffsetFunction","update","get","unit","date","timezoneOffset","realMs","getTime","ms","setTime","ret","set","value","offset","newOffset","timezone","makeTime","year","month","hours","minutes","seconds","d","UTC","apply","arguments","time","moment","timestamp","toString","tz","utcOffset","valueOf","dateFormat","format","capitalize","isNaN","defaultOptions","lang","invalidDate","day","dayOfMonth","fullYear","langWeekdays","weekdays","shortWeekdays","replacements","a","substr","A","e","w","b","shortMonths","B","months","m","o","y","Y","k","I","l","M","p","P","S","L","Math","floor","dateFormats","val","key","indexOf","replace","call","toUpperCase","resolveDTLFormat","f","main","from","to","getTimeTicks","normalizedInterval","min","max","startOfWeek","tickPositions","higherRanks","minDate","interval","unitRange","count","i","minYear","variableDayLength","minDay","second","minute","hour","week","minMonth","minDateDate","minHours","t","push","length","forEach","info","totalRange","getDateFormat","range","dateTimeLabelFormats","dateStr","blank","strpos","millisecond","n","lastN"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Time.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport H from './Globals.js';\nconst { win } = H;\nimport U from './Utilities.js';\nconst { defined, error, extend, isObject, merge, objectEach, pad, pick, splat, timeUnits } = U;\n/* *\n *\n *  Constants\n *\n * */\nconst hasNewSafariBug = H.isSafari &&\n    win.Intl &&\n    win.Intl.DateTimeFormat.prototype.formatRange;\n// To do: Remove this when we no longer need support for Safari < v14.1\nconst hasOldSafariBug = H.isSafari &&\n    win.Intl &&\n    !win.Intl.DateTimeFormat.prototype.formatRange;\n/* *\n *\n *  Class\n *\n * */\n/* eslint-disable no-invalid-this, valid-jsdoc */\n/**\n * The Time class. Time settings are applied in general for each page using\n * `Highcharts.setOptions`, or individually for each Chart item through the\n * [time](https://api.highcharts.com/highcharts/time) options set.\n *\n * The Time object is available from {@link Highcharts.Chart#time},\n * which refers to  `Highcharts.time` if no individual time settings are\n * applied.\n *\n * @example\n * // Apply time settings globally\n * Highcharts.setOptions({\n *     time: {\n *         timezone: 'Europe/London'\n *     }\n * });\n *\n * // Apply time settings by instance\n * let chart = Highcharts.chart('container', {\n *     time: {\n *         timezone: 'America/New_York'\n *     },\n *     series: [{\n *         data: [1, 4, 3, 5]\n *     }]\n * });\n *\n * // Use the Time object\n * console.log(\n *        'Current time in New York',\n *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())\n * );\n *\n * @since 6.0.5\n *\n * @class\n * @name Highcharts.Time\n *\n * @param {Highcharts.TimeOptions} [options]\n * Time options as defined in [chart.options.time](/highcharts/time).\n */\nclass Time {\n    /* *\n     *\n     *  Constructors\n     *\n     * */\n    constructor(options) {\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        this.options = {};\n        this.useUTC = false;\n        this.variableTimezone = false;\n        this.Date = win.Date;\n        /**\n         * Get the time zone offset based on the current timezone information as\n         * set in the global options.\n         *\n         * @function Highcharts.Time#getTimezoneOffset\n         *\n         * @param {number} timestamp\n         *        The JavaScript timestamp to inspect.\n         *\n         * @return {number}\n         *         The timezone offset in minutes compared to UTC.\n         */\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(options);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Time units used in `Time.get` and `Time.set`\n     *\n     * @typedef {\"Date\"|\"Day\"|\"FullYear\"|\"Hours\"|\"Milliseconds\"|\"Minutes\"|\"Month\"|\"Seconds\"} Highcharts.TimeUnitValue\n     */\n    /**\n     * Get the value of a date object in given units, and subject to the Time\n     * object's current timezone settings. This function corresponds directly to\n     * JavaScripts `Date.getXXX / Date.getUTCXXX`, so instead of calling\n     * `date.getHours()` or `date.getUTCHours()` we will call\n     * `time.get('Hours')`.\n     *\n     * @function Highcharts.Time#get\n     *\n     * @param {Highcharts.TimeUnitValue} unit\n     * @param {Date} date\n     *\n     * @return {number}\n     *        The given time unit\n     */\n    get(unit, date) {\n        if (this.variableTimezone || this.timezoneOffset) {\n            const realMs = date.getTime();\n            const ms = realMs - this.getTimezoneOffset(date);\n            date.setTime(ms); // Temporary adjust to timezone\n            const ret = date['getUTC' + unit]();\n            date.setTime(realMs); // Reset\n            return ret;\n        }\n        // UTC time with no timezone handling\n        if (this.useUTC) {\n            return date['getUTC' + unit]();\n        }\n        // Else, local time\n        return date['get' + unit]();\n    }\n    /**\n     * Set the value of a date object in given units, and subject to the Time\n     * object's current timezone settings. This function corresponds directly to\n     * JavaScripts `Date.setXXX / Date.setUTCXXX`, so instead of calling\n     * `date.setHours(0)` or `date.setUTCHours(0)` we will call\n     * `time.set('Hours', 0)`.\n     *\n     * @function Highcharts.Time#set\n     *\n     * @param {Highcharts.TimeUnitValue} unit\n     * @param {Date} date\n     * @param {number} value\n     *\n     * @return {number}\n     *        The epoch milliseconds of the updated date\n     */\n    set(unit, date, value) {\n        // UTC time with timezone handling\n        if (this.variableTimezone || this.timezoneOffset) {\n            // For lower order time units, just set it directly using UTC\n            // time\n            if (unit === 'Milliseconds' ||\n                unit === 'Seconds' ||\n                (unit === 'Minutes' &&\n                    this.getTimezoneOffset(date) % 3600000 === 0) // #13961\n            ) {\n                return date['setUTC' + unit](value);\n            }\n            // Higher order time units need to take the time zone into\n            // account\n            // Adjust by timezone\n            const offset = this.getTimezoneOffset(date);\n            let ms = date.getTime() - offset;\n            date.setTime(ms);\n            date['setUTC' + unit](value);\n            const newOffset = this.getTimezoneOffset(date);\n            ms = date.getTime() + newOffset;\n            return date.setTime(ms);\n        }\n        // UTC time with no timezone handling\n        if (this.useUTC ||\n            // leap calculation in UTC only\n            (hasNewSafariBug && unit === 'FullYear')) {\n            return date['setUTC' + unit](value);\n        }\n        // Else, local time\n        return date['set' + unit](value);\n    }\n    /**\n     * Update the Time object with current options. It is called internally on\n     * initializing Highcharts, after running `Highcharts.setOptions` and on\n     * `Chart.update`.\n     *\n     * @private\n     * @function Highcharts.Time#update\n     *\n     * @param {Highcharts.TimeOptions} [options]\n     *\n     */\n    update(options = {}) {\n        const useUTC = pick(options.useUTC, true);\n        this.options = options = merge(true, this.options, options);\n        // Allow using a different Date class\n        this.Date = options.Date || win.Date || Date;\n        this.useUTC = useUTC;\n        this.timezoneOffset = (useUTC && options.timezoneOffset) || void 0;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        /*\n         * The time object has options allowing for variable time zones, meaning\n         * the axis ticks or series data needs to consider this.\n         */\n        this.variableTimezone = useUTC && !!(options.getTimezoneOffset ||\n            options.timezone);\n    }\n    /**\n     * Make a time and returns milliseconds. Interprets the inputs as UTC time,\n     * local time or a specific timezone time depending on the current time\n     * settings.\n     *\n     * @function Highcharts.Time#makeTime\n     *\n     * @param {number} year\n     *        The year\n     *\n     * @param {number} month\n     *        The month. Zero-based, so January is 0.\n     *\n     * @param {number} [date=1]\n     *        The day of the month\n     *\n     * @param {number} [hours=0]\n     *        The hour of the day, 0-23.\n     *\n     * @param {number} [minutes=0]\n     *        The minutes\n     *\n     * @param {number} [seconds=0]\n     *        The seconds\n     *\n     * @return {number}\n     *         The time in milliseconds since January 1st 1970.\n     */\n    makeTime(year, month, date, hours, minutes, seconds) {\n        let d, offset, newOffset;\n        if (this.useUTC) {\n            d = this.Date.UTC.apply(0, arguments);\n            offset = this.getTimezoneOffset(d);\n            d += offset;\n            newOffset = this.getTimezoneOffset(d);\n            if (offset !== newOffset) {\n                d += newOffset - offset;\n                // A special case for transitioning from summer time to winter time.\n                // When the clock is set back, the same time is repeated twice, i.e.\n                // 02:30 am is repeated since the clock is set back from 3 am to\n                // 2 am. We need to make the same time as local Date does.\n            }\n            else if (offset - 36e5 === this.getTimezoneOffset(d - 36e5) &&\n                !hasOldSafariBug) {\n                d -= 36e5;\n            }\n        }\n        else {\n            d = new this.Date(year, month, pick(date, 1), pick(hours, 0), pick(minutes, 0), pick(seconds, 0)).getTime();\n        }\n        return d;\n    }\n    /**\n     * Sets the getTimezoneOffset function. If the `timezone` option is set, a\n     * default getTimezoneOffset function with that timezone is returned. If\n     * a `getTimezoneOffset` option is defined, it is returned. If neither are\n     * specified, the function using the `timezoneOffset` option or 0 offset is\n     * returned.\n     *\n     * @private\n     * @function Highcharts.Time#timezoneOffsetFunction\n     *\n     * @return {Function}\n     *         A getTimezoneOffset function\n     */\n    timezoneOffsetFunction() {\n        const time = this, options = this.options, getTimezoneOffset = options.getTimezoneOffset, moment = options.moment || win.moment;\n        if (!this.useUTC) {\n            return function (timestamp) {\n                return new Date(timestamp.toString()).getTimezoneOffset() * 60000;\n            };\n        }\n        if (options.timezone) {\n            if (!moment) {\n                // getTimezoneOffset-function stays undefined because it depends\n                // on Moment.js\n                error(25);\n            }\n            else {\n                return function (timestamp) {\n                    return -moment.tz(timestamp, options.timezone).utcOffset() * 60000;\n                };\n            }\n        }\n        // If not timezone is set, look for the getTimezoneOffset callback\n        if (this.useUTC && getTimezoneOffset) {\n            return function (timestamp) {\n                return getTimezoneOffset(timestamp.valueOf()) * 60000;\n            };\n        }\n        // Last, use the `timezoneOffset` option if set\n        return function () {\n            return (time.timezoneOffset || 0) * 60000;\n        };\n    }\n    /**\n     * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970)\n     * into a human readable date string. The available format keys are listed\n     * below. Additional formats can be given in the\n     * {@link Highcharts.dateFormats} hook.\n     *\n     * Supported format keys:\n     * - `%a`: Short weekday, like 'Mon'\n     * - `%A`: Long weekday, like 'Monday'\n     * - `%d`: Two digit day of the month, 01 to 31\n     * - `%e`: Day of the month, 1 through 31\n     * - `%w`: Day of the week, 0 through 6\n     * - `%b`: Short month, like 'Jan'\n     * - `%B`: Long month, like 'January'\n     * - `%m`: Two digit month number, 01 through 12\n     * - `%y`: Two digits year, like 09 for 2009\n     * - `%Y`: Four digits year, like 2009\n     * - `%H`: Two digits hours in 24h format, 00 through 23\n     * - `%k`: Hours in 24h format, 0 through 23\n     * - `%I`: Two digits hours in 12h format, 00 through 11\n     * - `%l`: Hours in 12h format, 1 through 12\n     * - `%M`: Two digits minutes, 00 through 59\n     * - `%p`: Upper case AM or PM\n     * - `%P`: Lower case AM or PM\n     * - `%S`: Two digits seconds, 00 through 59\n     * - `%L`: Milliseconds (naming from Ruby)\n     *\n     * @example\n     * const time = new Highcharts.Time();\n     * const s = time.dateFormat('%Y-%m-%d %H:%M:%S', Date.UTC(2020, 0, 1));\n     * console.log(s); // => 2020-01-01 00:00:00\n     *\n     * @function Highcharts.Time#dateFormat\n     *\n     * @param {string} format\n     *        The desired format where various time representations are\n     *        prefixed with %.\n     *\n     * @param {number} [timestamp]\n     *        The JavaScript timestamp.\n     *\n     * @param {boolean} [capitalize=false]\n     *        Upper case first letter in the return.\n     *\n     * @return {string}\n     *         The formatted date.\n     */\n    dateFormat(format, timestamp, capitalize) {\n        if (!defined(timestamp) || isNaN(timestamp)) {\n            return (H.defaultOptions.lang &&\n                H.defaultOptions.lang.invalidDate ||\n                '');\n        }\n        format = pick(format, '%Y-%m-%d %H:%M:%S');\n        const time = this, date = new this.Date(timestamp), \n        // get the basic time values\n        hours = this.get('Hours', date), day = this.get('Day', date), dayOfMonth = this.get('Date', date), month = this.get('Month', date), fullYear = this.get('FullYear', date), lang = H.defaultOptions.lang, langWeekdays = (lang && lang.weekdays), shortWeekdays = (lang && lang.shortWeekdays), \n        // List all format keys. Custom formats can be added from the\n        // outside.\n        replacements = extend({\n            // Day\n            // Short weekday, like 'Mon'\n            a: shortWeekdays ?\n                shortWeekdays[day] :\n                langWeekdays[day].substr(0, 3),\n            // Long weekday, like 'Monday'\n            A: langWeekdays[day],\n            // Two digit day of the month, 01 to 31\n            d: pad(dayOfMonth),\n            // Day of the month, 1 through 31\n            e: pad(dayOfMonth, 2, ' '),\n            // Day of the week, 0 through 6\n            w: day,\n            // Week (none implemented)\n            // 'W': weekNumber(),\n            // Month\n            // Short month, like 'Jan'\n            b: lang.shortMonths[month],\n            // Long month, like 'January'\n            B: lang.months[month],\n            // Two digit month number, 01 through 12\n            m: pad(month + 1),\n            // Month number, 1 through 12 (#8150)\n            o: month + 1,\n            // Year\n            // Two digits year, like 09 for 2009\n            y: fullYear.toString().substr(2, 2),\n            // Four digits year, like 2009\n            Y: fullYear,\n            // Time\n            // Two digits hours in 24h format, 00 through 23\n            H: pad(hours),\n            // Hours in 24h format, 0 through 23\n            k: hours,\n            // Two digits hours in 12h format, 00 through 11\n            I: pad((hours % 12) || 12),\n            // Hours in 12h format, 1 through 12\n            l: (hours % 12) || 12,\n            // Two digits minutes, 00 through 59\n            M: pad(this.get('Minutes', date)),\n            // Upper case AM or PM\n            p: hours < 12 ? 'AM' : 'PM',\n            // Lower case AM or PM\n            P: hours < 12 ? 'am' : 'pm',\n            // Two digits seconds, 00 through  59\n            S: pad(this.get('Seconds', date)),\n            // Milliseconds (naming from Ruby)\n            L: pad(Math.floor(timestamp % 1000), 3)\n        }, H.dateFormats);\n        // Do the replaces\n        objectEach(replacements, function (val, key) {\n            // Regex would do it in one line, but this is faster\n            while (format.indexOf('%' + key) !== -1) {\n                format = format.replace('%' + key, typeof val === 'function' ? val.call(time, timestamp) : val);\n            }\n        });\n        // Optionally capitalize the string and return\n        return capitalize ?\n            (format.substr(0, 1).toUpperCase() +\n                format.substr(1)) :\n            format;\n    }\n    /**\n     * Resolve legacy formats of dateTimeLabelFormats (strings and arrays) into\n     * an object.\n     * @private\n     * @param {string|Array<T>|Highcharts.Dictionary<T>} f\n     * General format description\n     * @return {Highcharts.Dictionary<T>}\n     * The object definition\n     */\n    resolveDTLFormat(f) {\n        if (!isObject(f, true)) { // check for string or array\n            f = splat(f);\n            return {\n                main: f[0],\n                from: f[1],\n                to: f[2]\n            };\n        }\n        return f;\n    }\n    /**\n     * Return an array with time positions distributed on round time values\n     * right and right after min and max. Used in datetime axes as well as for\n     * grouping data on a datetime axis.\n     *\n     * @function Highcharts.Time#getTimeTicks\n     *\n     * @param {Highcharts.TimeNormalizedObject} normalizedInterval\n     *        The interval in axis values (ms) and the count\n     *\n     * @param {number} [min]\n     *        The minimum in axis values\n     *\n     * @param {number} [max]\n     *        The maximum in axis values\n     *\n     * @param {number} [startOfWeek=1]\n     *\n     * @return {Highcharts.AxisTickPositionsArray}\n     * Time positions\n     */\n    getTimeTicks(normalizedInterval, min, max, startOfWeek) {\n        const time = this, Date = time.Date, tickPositions = [], higherRanks = {}, \n        // When crossing DST, use the max. Resolves #6278.\n        minDate = new Date(min), interval = normalizedInterval.unitRange, count = normalizedInterval.count || 1;\n        let i, minYear, // used in months and years as a basis for Date.UTC()\n        variableDayLength, minDay;\n        startOfWeek = pick(startOfWeek, 1);\n        if (defined(min)) { // #1300\n            time.set('Milliseconds', minDate, interval >= timeUnits.second ?\n                0 : // #3935\n                count * Math.floor(time.get('Milliseconds', minDate) / count)); // #3652, #3654\n            if (interval >= timeUnits.second) { // second\n                time.set('Seconds', minDate, interval >= timeUnits.minute ?\n                    0 : // #3935\n                    count * Math.floor(time.get('Seconds', minDate) / count));\n            }\n            if (interval >= timeUnits.minute) { // minute\n                time.set('Minutes', minDate, interval >= timeUnits.hour ?\n                    0 :\n                    count * Math.floor(time.get('Minutes', minDate) / count));\n            }\n            if (interval >= timeUnits.hour) { // hour\n                time.set('Hours', minDate, interval >= timeUnits.day ?\n                    0 :\n                    count * Math.floor(time.get('Hours', minDate) / count));\n            }\n            if (interval >= timeUnits.day) { // day\n                time.set('Date', minDate, interval >= timeUnits.month ?\n                    1 :\n                    Math.max(1, count * Math.floor(time.get('Date', minDate) / count)));\n            }\n            if (interval >= timeUnits.month) { // month\n                time.set('Month', minDate, interval >= timeUnits.year ? 0 :\n                    count * Math.floor(time.get('Month', minDate) / count));\n                minYear = time.get('FullYear', minDate);\n            }\n            if (interval >= timeUnits.year) { // year\n                minYear -= minYear % count;\n                time.set('FullYear', minDate, minYear);\n            }\n            // week is a special case that runs outside the hierarchy\n            if (interval === timeUnits.week) {\n                // get start of current week, independent of count\n                minDay = time.get('Day', minDate);\n                time.set('Date', minDate, (time.get('Date', minDate) -\n                    minDay + startOfWeek +\n                    // We don't want to skip days that are before\n                    // startOfWeek (#7051)\n                    (minDay < startOfWeek ? -7 : 0)));\n            }\n            // Get basics for variable time spans\n            minYear = time.get('FullYear', minDate);\n            const minMonth = time.get('Month', minDate), minDateDate = time.get('Date', minDate), minHours = time.get('Hours', minDate);\n            // Redefine min to the floored/rounded minimum time (#7432)\n            min = minDate.getTime();\n            // Handle local timezone offset\n            if ((time.variableTimezone || !time.useUTC) && defined(max)) {\n                // Detect whether we need to take the DST crossover into\n                // consideration. If we're crossing over DST, the day length may\n                // be 23h or 25h and we need to compute the exact clock time for\n                // each tick instead of just adding hours. This comes at a cost,\n                // so first we find out if it is needed (#4951).\n                variableDayLength = (\n                // Long range, assume we're crossing over.\n                max - min > 4 * timeUnits.month ||\n                    // Short range, check if min and max are in different time\n                    // zones.\n                    time.getTimezoneOffset(min) !==\n                        time.getTimezoneOffset(max));\n            }\n            // Iterate and add tick positions at appropriate values\n            let t = minDate.getTime();\n            i = 1;\n            while (t < max) {\n                tickPositions.push(t);\n                // if the interval is years, use Date.UTC to increase years\n                if (interval === timeUnits.year) {\n                    t = time.makeTime(minYear + i * count, 0);\n                    // if the interval is months, use Date.UTC to increase months\n                }\n                else if (interval === timeUnits.month) {\n                    t = time.makeTime(minYear, minMonth + i * count);\n                    // if we're using global time, the interval is not fixed as it\n                    // jumps one hour at the DST crossover\n                }\n                else if (variableDayLength &&\n                    (interval === timeUnits.day || interval === timeUnits.week)) {\n                    t = time.makeTime(minYear, minMonth, minDateDate +\n                        i * count * (interval === timeUnits.day ? 1 : 7));\n                }\n                else if (variableDayLength &&\n                    interval === timeUnits.hour &&\n                    count > 1) {\n                    // make sure higher ranks are preserved across DST (#6797,\n                    // #7621)\n                    t = time.makeTime(minYear, minMonth, minDateDate, minHours + i * count);\n                    // else, the interval is fixed and we use simple addition\n                }\n                else {\n                    t += interval * count;\n                }\n                i++;\n            }\n            // push the last time\n            tickPositions.push(t);\n            // Handle higher ranks. Mark new days if the time is on midnight\n            // (#950, #1649, #1760, #3349). Use a reasonable dropout threshold\n            // to prevent looping over dense data grouping (#6156).\n            if (interval <= timeUnits.hour && tickPositions.length < 10000) {\n                tickPositions.forEach(function (t) {\n                    if (\n                    // Speed optimization, no need to run dateFormat unless\n                    // we're on a full or half hour\n                    t % 1800000 === 0 &&\n                        // Check for local or global midnight\n                        time.dateFormat('%H%M%S%L', t) === '000000000') {\n                        higherRanks[t] = 'day';\n                    }\n                });\n            }\n        }\n        // record information on the chosen unit - for dynamic label formatter\n        tickPositions.info = extend(normalizedInterval, {\n            higherRanks,\n            totalRange: interval * count\n        });\n        return tickPositions;\n    }\n    /**\n     * Get the optimal date format for a point, based on a range.\n     *\n     * @private\n     * @function Highcharts.Time#getDateFormat\n     *\n     * @param {number} range\n     *        The time range\n     *\n     * @param {number} timestamp\n     *        The timestamp of the date\n     *\n     * @param {number} startOfWeek\n     *        An integer representing the first day of the week, where 0 is\n     *        Sunday.\n     *\n     * @param {Highcharts.Dictionary<string>} dateTimeLabelFormats\n     *        A map of time units to formats.\n     *\n     * @return {string}\n     *         The optimal date format for a point.\n     */\n    getDateFormat(range, timestamp, startOfWeek, dateTimeLabelFormats) {\n        const dateStr = this.dateFormat('%m-%d %H:%M:%S.%L', timestamp), blank = '01-01 00:00:00.000', strpos = {\n            millisecond: 15,\n            second: 12,\n            minute: 9,\n            hour: 6,\n            day: 3\n        };\n        let n = 'millisecond', \n        // for sub-millisecond data, #4223\n        lastN = n;\n        for (n in timeUnits) { // eslint-disable-line guard-for-in\n            // If the range is exactly one week and we're looking at a\n            // Sunday/Monday, go for the week format\n            if (range === timeUnits.week &&\n                +this.dateFormat('%w', timestamp) === startOfWeek &&\n                dateStr.substr(6) === blank.substr(6)) {\n                n = 'week';\n                break;\n            }\n            // The first format that is too great for the range\n            if (timeUnits[n] > range) {\n                n = lastN;\n                break;\n            }\n            // If the point is placed every day at 23:59, we need to show\n            // the minutes as well. #2637.\n            if (strpos[n] &&\n                dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {\n                break;\n            }\n            // Weeks are outside the hierarchy, only apply them on\n            // Mondays/Sundays like in the first condition\n            if (n !== 'week') {\n                lastN = n;\n            }\n        }\n        return this.resolveDTLFormat(dateTimeLabelFormats[n]).main;\n    }\n}\n/* *\n *\n * Default export\n *\n * */\nexport default Time;\n/* *\n *\n * API Declarations\n *\n * */\n/**\n * Normalized interval.\n *\n * @interface Highcharts.TimeNormalizedObject\n */ /**\n* The count.\n*\n* @name Highcharts.TimeNormalizedObject#count\n* @type {number|undefined}\n*/ /**\n* The interval in axis values (ms).\n*\n* @name Highcharts.TimeNormalizedObject#unitRange\n* @type {number}\n*/\n/**\n * Function of an additional date format specifier.\n *\n * @callback Highcharts.TimeFormatCallbackFunction\n *\n * @param {number} timestamp\n *        The time to format.\n *\n * @return {string}\n *         The formatted portion of the date.\n */\n/**\n * Time ticks.\n *\n * @interface Highcharts.AxisTickPositionsArray\n * @extends global.Array<number>\n */ /**\n* @name Highcharts.AxisTickPositionsArray#info\n* @type {Highcharts.TimeTicksInfoObject|undefined}\n*/\n/**\n * A callback to return the time zone offset for a given datetime. It\n * takes the timestamp in terms of milliseconds since January 1 1970,\n * and returns the timezone offset in minutes. This provides a hook\n * for drawing time based charts in specific time zones using their\n * local DST crossover dates, with the help of external libraries.\n *\n * @callback Highcharts.TimezoneOffsetCallbackFunction\n *\n * @param {number} timestamp\n * Timestamp in terms of milliseconds since January 1 1970.\n *\n * @return {number}\n * Timezone offset in minutes.\n */\n/**\n * Allows to manually load the `moment.js` library from Highcharts options\n * instead of the `window`.\n * In case of loading the library from a `script` tag,\n * this option is not needed, it will be loaded from there by default.\n *\n * @type      {Function}\n * @since     8.2.0\n * @apioption time.moment\n */\n''; // keeps doclets above in JS file\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AACZ,OAAOA,CAAC,MAAM,cAAc;AAC5B,MAAM;EAAEC;AAAI,CAAC,GAAGD,CAAC;AACjB,OAAOE,CAAC,MAAM,gBAAgB;AAC9B,MAAM;EAAEC,OAAO;EAAEC,KAAK;EAAEC,MAAM;EAAEC,QAAQ;EAAEC,KAAK;EAAEC,UAAU;EAAEC,GAAG;EAAEC,IAAI;EAAEC,KAAK;EAAEC;AAAU,CAAC,GAAGV,CAAC;AAC9F;AACA;AACA;AACA;AACA;AACA,MAAMW,eAAe,GAAGb,CAAC,CAACc,QAAQ,IAC9Bb,GAAG,CAACc,IAAI,IACRd,GAAG,CAACc,IAAI,CAACC,cAAc,CAACC,SAAS,CAACC,WAAW;AACjD;AACA,MAAMC,eAAe,GAAGnB,CAAC,CAACc,QAAQ,IAC9Bb,GAAG,CAACc,IAAI,IACR,CAACd,GAAG,CAACc,IAAI,CAACC,cAAc,CAACC,SAAS,CAACC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,IAAI,CAAC;EACP;AACJ;AACA;AACA;AACA;EACIC,WAAWA,CAACC,OAAO,EAAE;IACjB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACA,OAAO,GAAG,CAAC,CAAC;IACjB,IAAI,CAACC,MAAM,GAAG,KAAK;IACnB,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACC,IAAI,GAAGxB,GAAG,CAACwB,IAAI;IACpB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAACC,sBAAsB,CAAC,CAAC;IACtD,IAAI,CAACC,MAAM,CAACN,OAAO,CAAC;EACxB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"},"metadata":{},"sourceType":"module","externalDependencies":[]}