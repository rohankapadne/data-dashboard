{"ast":null,"code":"/* *\n *\n *  (c) 2010-2020 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport AST from '../HTML/AST.js';\nimport H from '../../Globals.js';\nconst {\n  doc,\n  SVG_NS,\n  win\n} = H;\nimport U from '../../Utilities.js';\nconst {\n  attr,\n  extend,\n  fireEvent,\n  isString,\n  objectEach,\n  pick\n} = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * SVG Text Builder\n * @private\n * @class\n * @name Highcharts.TextBuilder\n */\nclass TextBuilder {\n  constructor(svgElement) {\n    const textStyles = svgElement.styles;\n    this.renderer = svgElement.renderer;\n    this.svgElement = svgElement;\n    this.width = svgElement.textWidth;\n    this.textLineHeight = textStyles && textStyles.lineHeight;\n    this.textOutline = textStyles && textStyles.textOutline;\n    this.ellipsis = Boolean(textStyles && textStyles.textOverflow === 'ellipsis');\n    this.noWrap = Boolean(textStyles && textStyles.whiteSpace === 'nowrap');\n  }\n  /**\n   * Build an SVG representation of the pseudo HTML given in the object's\n   * svgElement.\n   *\n   * @private\n   *\n   * @return {void}.\n   */\n  buildSVG() {\n    const wrapper = this.svgElement,\n      textNode = wrapper.element,\n      renderer = wrapper.renderer,\n      textStr = pick(wrapper.textStr, '').toString(),\n      hasMarkup = textStr.indexOf('<') !== -1,\n      childNodes = textNode.childNodes,\n      tempParent = !wrapper.added && renderer.box,\n      regexMatchBreaks = /<br.*?>/g,\n      // The buildText code is quite heavy, so if we're not changing\n      // something that affects the text, skip it (#6113).\n      textCache = [textStr, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, wrapper.getStyle('font-size'), this.width].join(',');\n    if (textCache === wrapper.textCache) {\n      return;\n    }\n    wrapper.textCache = textCache;\n    delete wrapper.actualWidth;\n    // Remove old text\n    for (let i = childNodes.length; i--;) {\n      textNode.removeChild(childNodes[i]);\n    }\n    // Simple strings, add text directly and return\n    if (!hasMarkup && !this.ellipsis && !this.width && !wrapper.textPath && (textStr.indexOf(' ') === -1 || this.noWrap && !regexMatchBreaks.test(textStr))) {\n      textNode.appendChild(doc.createTextNode(this.unescapeEntities(textStr)));\n      // Complex strings, add more logic\n    } else if (textStr !== '') {\n      if (tempParent) {\n        // attach it to the DOM to read offset width and font size\n        tempParent.appendChild(textNode);\n      }\n      // Step 1. Parse the markup safely and directly into a tree\n      // structure.\n      const ast = new AST(textStr);\n      // Step 2. Do as many as we can of the modifications to the tree\n      // structure before it is added to the DOM\n      this.modifyTree(ast.nodes);\n      ast.addToDOM(textNode);\n      // Step 3. Some modifications can't be done until the structure is\n      // in the DOM, because we need to read computed metrics.\n      this.modifyDOM();\n      // Add title if an ellipsis was added\n      if (this.ellipsis && (textNode.textContent || '').indexOf('\\u2026') !== -1) {\n        wrapper.attr('title', this.unescapeEntities(wrapper.textStr || '', ['&lt;', '&gt;']) // #7179\n        );\n      }\n\n      if (tempParent) {\n        tempParent.removeChild(textNode);\n      }\n    }\n    // Apply the text outline\n    if (isString(this.textOutline) && wrapper.applyTextOutline) {\n      wrapper.applyTextOutline(this.textOutline);\n    }\n  }\n  /**\n   * Modify the DOM of the generated SVG structure. This function only does\n   * operations that cannot be done until the elements are attached to the\n   * DOM, like doing layout based on rendered metrics of the added elements.\n   *\n   * @private\n   *\n   */\n  modifyDOM() {\n    const wrapper = this.svgElement;\n    const x = attr(wrapper.element, 'x');\n    wrapper.firstLineMetrics = void 0;\n    // Remove empty tspans (including breaks) from the beginning because\n    // SVG's getBBox doesn't count empty lines. The use case is tooltip\n    // where the header is empty. By doing this in the DOM rather than in\n    // the AST, we can inspect the textContent directly and don't have to\n    // recurse down to look for valid content.\n    let firstChild;\n    while (firstChild = wrapper.element.firstChild) {\n      if (/^[\\s\\u200B]*$/.test(firstChild.textContent || ' ')) {\n        wrapper.element.removeChild(firstChild);\n      } else {\n        break;\n      }\n    }\n    // Modify hard line breaks by applying the rendered line height\n    [].forEach.call(wrapper.element.querySelectorAll('tspan.highcharts-br'), (br, i) => {\n      if (br.nextSibling && br.previousSibling) {\n        // #5261\n        if (i === 0 && br.previousSibling.nodeType === 1) {\n          wrapper.firstLineMetrics = wrapper.renderer.fontMetrics(br.previousSibling);\n        }\n        attr(br, {\n          // Since the break is inserted in front of the next\n          // line, we need to use the next sibling for the line\n          // height\n          dy: this.getLineHeight(br.nextSibling),\n          x\n        });\n      }\n    });\n    // Constrain the line width, either by ellipsis or wrapping\n    const width = this.width || 0;\n    if (!width) {\n      return;\n    }\n    // Insert soft line breaks into each text node\n    const modifyTextNode = (textNode, parentElement) => {\n      const text = textNode.textContent || '';\n      const words = text.replace(/([^\\^])-/g, '$1- ') // Split on hyphens\n      // .trim()\n      .split(' '); // #1273\n      const hasWhiteSpace = !this.noWrap && (words.length > 1 || wrapper.element.childNodes.length > 1);\n      const dy = this.getLineHeight(parentElement);\n      let lineNo = 0;\n      let startAt = wrapper.actualWidth;\n      if (this.ellipsis) {\n        if (text) {\n          this.truncate(textNode, text, void 0, 0,\n          // Target width\n          Math.max(0,\n          // Substract the font face to make room for the\n          // ellipsis itself\n          width - 0.8 * dy),\n          // Build the text to test for\n          (text, currentIndex) => text.substring(0, currentIndex) + '\\u2026');\n        }\n      } else if (hasWhiteSpace) {\n        const lines = [];\n        // Remove preceding siblings in order to make the text length\n        // calculation correct in the truncate function\n        const precedingSiblings = [];\n        while (parentElement.firstChild && parentElement.firstChild !== textNode) {\n          precedingSiblings.push(parentElement.firstChild);\n          parentElement.removeChild(parentElement.firstChild);\n        }\n        while (words.length) {\n          // Apply the previous line\n          if (words.length && !this.noWrap && lineNo > 0) {\n            lines.push(textNode.textContent || '');\n            textNode.textContent = words.join(' ').replace(/- /g, '-');\n          }\n          // For each line, truncate the remaining\n          // words into the line length.\n          this.truncate(textNode, void 0, words, lineNo === 0 ? startAt || 0 : 0, width,\n          // Build the text to test for\n          (t, currentIndex) => words.slice(0, currentIndex).join(' ').replace(/- /g, '-'));\n          startAt = wrapper.actualWidth;\n          lineNo++;\n        }\n        // Reinsert the preceding child nodes\n        precedingSiblings.forEach(childNode => {\n          parentElement.insertBefore(childNode, textNode);\n        });\n        // Insert the previous lines before the original text node\n        lines.forEach(line => {\n          // Insert the line\n          parentElement.insertBefore(doc.createTextNode(line), textNode);\n          // Insert a break\n          const br = doc.createElementNS(SVG_NS, 'tspan');\n          br.textContent = '\\u200B'; // zero-width space\n          attr(br, {\n            dy,\n            x\n          });\n          parentElement.insertBefore(br, textNode);\n        });\n      }\n    };\n    // Recurse down the DOM tree and handle line breaks for each text node\n    const modifyChildren = node => {\n      const childNodes = [].slice.call(node.childNodes);\n      childNodes.forEach(childNode => {\n        if (childNode.nodeType === win.Node.TEXT_NODE) {\n          modifyTextNode(childNode, node);\n        } else {\n          // Reset word-wrap width readings after hard breaks\n          if (childNode.className.baseVal.indexOf('highcharts-br') !== -1) {\n            wrapper.actualWidth = 0;\n          }\n          // Recurse down to child node\n          modifyChildren(childNode);\n        }\n      });\n    };\n    modifyChildren(wrapper.element);\n  }\n  /**\n   * Get the rendered line height of a <text>, <tspan> or pure text node.\n   *\n   * @param {DOMElementType|Text} node The node to check for\n   *\n   * @return {number} The rendered line height\n   */\n  getLineHeight(node) {\n    // If the node is a text node, use its parent\n    const element = node.nodeType === win.Node.TEXT_NODE ? node.parentElement : node;\n    return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(element || this.svgElement.element).h;\n  }\n  /**\n   * Transform a pseudo HTML AST node tree into an SVG structure. We do as\n   * much heavy lifting as we can here, before doing the final processing in\n   * the modifyDOM function. The original data is mutated.\n   *\n   * @private\n   *\n   * @param {ASTNode[]} nodes The AST nodes\n   *\n   */\n  modifyTree(nodes) {\n    const modifyChild = (node, i) => {\n      const {\n          attributes = {},\n          children,\n          style = {},\n          tagName\n        } = node,\n        styledMode = this.renderer.styledMode;\n      // Apply styling to text tags\n      if (tagName === 'b' || tagName === 'strong') {\n        if (styledMode) {\n          // eslint-disable-next-line dot-notation\n          attributes['class'] = 'highcharts-strong';\n        } else {\n          style.fontWeight = 'bold';\n        }\n      } else if (tagName === 'i' || tagName === 'em') {\n        if (styledMode) {\n          // eslint-disable-next-line dot-notation\n          attributes['class'] = 'highcharts-emphasized';\n        } else {\n          style.fontStyle = 'italic';\n        }\n      }\n      // Modify styling\n      if (style && style.color) {\n        style.fill = style.color;\n      }\n      // Handle breaks\n      if (tagName === 'br') {\n        attributes['class'] = 'highcharts-br'; // eslint-disable-line dot-notation\n        node.textContent = '\\u200B'; // zero-width space\n        // Trim whitespace off the beginning of new lines\n        const nextNode = nodes[i + 1];\n        if (nextNode && nextNode.textContent) {\n          nextNode.textContent = nextNode.textContent.replace(/^ +/gm, '');\n        }\n        // If an anchor has direct text node children, the text is unable to\n        // wrap because there is no `getSubStringLength` function on the\n        // element. Therefore we need to wrap the child text node or nodes\n        // in a tspan. #16173.\n      } else if (tagName === 'a' && children && children.some(child => child.tagName === '#text')) {\n        node.children = [{\n          children,\n          tagName: 'tspan'\n        }];\n      }\n      if (tagName !== '#text' && tagName !== 'a') {\n        node.tagName = 'tspan';\n      }\n      extend(node, {\n        attributes,\n        style\n      });\n      // Recurse\n      if (children) {\n        children.filter(c => c.tagName !== '#text').forEach(modifyChild);\n      }\n    };\n    nodes.forEach(modifyChild);\n    fireEvent(this.svgElement, 'afterModifyTree', {\n      nodes\n    });\n  }\n  /*\n   * Truncate the text node contents to a given length. Used when the css\n   * width is set. If the `textOverflow` is `ellipsis`, the text is truncated\n   * character by character to the given length. If not, the text is\n   * word-wrapped line by line.\n   */\n  truncate(textNode, text, words, startAt, width, getString) {\n    const svgElement = this.svgElement;\n    const {\n      renderer,\n      rotation\n    } = svgElement;\n    // Cache the lengths to avoid checking the same twice\n    const lengths = [];\n    // Word wrap cannot be truncated to shorter than one word, ellipsis\n    // text can be completely blank.\n    let minIndex = words ? 1 : 0;\n    let maxIndex = (text || words || '').length;\n    let currentIndex = maxIndex;\n    let str;\n    let actualWidth;\n    const getSubStringLength = function (charEnd, concatenatedEnd) {\n      // charEnd is used when finding the character-by-character\n      // break for ellipsis, concatenatedEnd is used for word-by-word\n      // break for word wrapping.\n      const end = concatenatedEnd || charEnd;\n      const parentNode = textNode.parentNode;\n      if (parentNode && typeof lengths[end] === 'undefined') {\n        // Modern browsers\n        if (parentNode.getSubStringLength) {\n          // Fails with DOM exception on unit-tests/legend/members\n          // of unknown reason. Desired width is 0, text content\n          // is \"5\" and end is 1.\n          try {\n            lengths[end] = startAt + parentNode.getSubStringLength(0, words ? end + 1 : end);\n          } catch (e) {\n            '';\n          }\n        }\n      }\n      return lengths[end];\n    };\n    svgElement.rotation = 0; // discard rotation when computing box\n    actualWidth = getSubStringLength(textNode.textContent.length);\n    if (startAt + actualWidth > width) {\n      // Do a binary search for the index where to truncate the text\n      while (minIndex <= maxIndex) {\n        currentIndex = Math.ceil((minIndex + maxIndex) / 2);\n        // When checking words for word-wrap, we need to build the\n        // string and measure the subStringLength at the concatenated\n        // word length.\n        if (words) {\n          str = getString(words, currentIndex);\n        }\n        actualWidth = getSubStringLength(currentIndex, str && str.length - 1);\n        if (minIndex === maxIndex) {\n          // Complete\n          minIndex = maxIndex + 1;\n        } else if (actualWidth > width) {\n          // Too large. Set max index to current.\n          maxIndex = currentIndex - 1;\n        } else {\n          // Within width. Set min index to current.\n          minIndex = currentIndex;\n        }\n      }\n      // If max index was 0 it means the shortest possible text was also\n      // too large. For ellipsis that means only the ellipsis, while for\n      // word wrap it means the whole first word.\n      if (maxIndex === 0) {\n        // Remove ellipsis\n        textNode.textContent = '';\n        // If the new text length is one less than the original, we don't\n        // need the ellipsis\n      } else if (!(text && maxIndex === text.length - 1)) {\n        textNode.textContent = str || getString(text || words, currentIndex);\n      }\n    }\n    // When doing line wrapping, prepare for the next line by removing the\n    // items from this line.\n    if (words) {\n      words.splice(0, currentIndex);\n    }\n    svgElement.actualWidth = actualWidth;\n    svgElement.rotation = rotation; // Apply rotation again.\n  }\n  /*\n   * Un-escape HTML entities based on the public `renderer.escapes` list\n   *\n   * @private\n   *\n   * @param {string} inputStr The string to unescape\n   * @param {Array<string>} [except] Exceptions\n   *\n   * @return {string} The processed string\n   */\n  unescapeEntities(inputStr, except) {\n    objectEach(this.renderer.escapes, function (value, key) {\n      if (!except || except.indexOf(value) === -1) {\n        inputStr = inputStr.toString().replace(new RegExp(value, 'g'), key);\n      }\n    });\n    return inputStr;\n  }\n}\nexport default TextBuilder;","map":{"version":3,"names":["AST","H","doc","SVG_NS","win","U","attr","extend","fireEvent","isString","objectEach","pick","TextBuilder","constructor","svgElement","textStyles","styles","renderer","width","textWidth","textLineHeight","lineHeight","textOutline","ellipsis","Boolean","textOverflow","noWrap","whiteSpace","buildSVG","wrapper","textNode","element","textStr","toString","hasMarkup","indexOf","childNodes","tempParent","added","box","regexMatchBreaks","textCache","getStyle","join","actualWidth","i","length","removeChild","textPath","test","appendChild","createTextNode","unescapeEntities","ast","modifyTree","nodes","addToDOM","modifyDOM","textContent","applyTextOutline","x","firstLineMetrics","firstChild","forEach","call","querySelectorAll","br","nextSibling","previousSibling","nodeType","fontMetrics","dy","getLineHeight","modifyTextNode","parentElement","text","words","replace","split","hasWhiteSpace","lineNo","startAt","truncate","Math","max","currentIndex","substring","lines","precedingSiblings","push","t","slice","childNode","insertBefore","line","createElementNS","modifyChildren","node","Node","TEXT_NODE","className","baseVal","parseInt","h","modifyChild","attributes","children","style","tagName","styledMode","fontWeight","fontStyle","color","fill","nextNode","some","child","filter","c","getString","rotation","lengths","minIndex","maxIndex","str","getSubStringLength","charEnd","concatenatedEnd","end","parentNode","e","ceil","splice","inputStr","except","escapes","value","key","RegExp"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Renderer/SVG/TextBuilder.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2020 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport AST from '../HTML/AST.js';\nimport H from '../../Globals.js';\nconst { doc, SVG_NS, win } = H;\nimport U from '../../Utilities.js';\nconst { attr, extend, fireEvent, isString, objectEach, pick } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * SVG Text Builder\n * @private\n * @class\n * @name Highcharts.TextBuilder\n */\nclass TextBuilder {\n    constructor(svgElement) {\n        const textStyles = svgElement.styles;\n        this.renderer = svgElement.renderer;\n        this.svgElement = svgElement;\n        this.width = svgElement.textWidth;\n        this.textLineHeight = textStyles && textStyles.lineHeight;\n        this.textOutline = textStyles && textStyles.textOutline;\n        this.ellipsis = Boolean(textStyles && textStyles.textOverflow === 'ellipsis');\n        this.noWrap = Boolean(textStyles && textStyles.whiteSpace === 'nowrap');\n    }\n    /**\n     * Build an SVG representation of the pseudo HTML given in the object's\n     * svgElement.\n     *\n     * @private\n     *\n     * @return {void}.\n     */\n    buildSVG() {\n        const wrapper = this.svgElement, textNode = wrapper.element, renderer = wrapper.renderer, textStr = pick(wrapper.textStr, '').toString(), hasMarkup = textStr.indexOf('<') !== -1, childNodes = textNode.childNodes, tempParent = !wrapper.added && renderer.box, regexMatchBreaks = /<br.*?>/g, \n        // The buildText code is quite heavy, so if we're not changing\n        // something that affects the text, skip it (#6113).\n        textCache = [\n            textStr,\n            this.ellipsis,\n            this.noWrap,\n            this.textLineHeight,\n            this.textOutline,\n            wrapper.getStyle('font-size'),\n            this.width\n        ].join(',');\n        if (textCache === wrapper.textCache) {\n            return;\n        }\n        wrapper.textCache = textCache;\n        delete wrapper.actualWidth;\n        // Remove old text\n        for (let i = childNodes.length; i--;) {\n            textNode.removeChild(childNodes[i]);\n        }\n        // Simple strings, add text directly and return\n        if (!hasMarkup &&\n            !this.ellipsis &&\n            !this.width &&\n            !wrapper.textPath &&\n            (textStr.indexOf(' ') === -1 ||\n                (this.noWrap && !regexMatchBreaks.test(textStr)))) {\n            textNode.appendChild(doc.createTextNode(this.unescapeEntities(textStr)));\n            // Complex strings, add more logic\n        }\n        else if (textStr !== '') {\n            if (tempParent) {\n                // attach it to the DOM to read offset width and font size\n                tempParent.appendChild(textNode);\n            }\n            // Step 1. Parse the markup safely and directly into a tree\n            // structure.\n            const ast = new AST(textStr);\n            // Step 2. Do as many as we can of the modifications to the tree\n            // structure before it is added to the DOM\n            this.modifyTree(ast.nodes);\n            ast.addToDOM(textNode);\n            // Step 3. Some modifications can't be done until the structure is\n            // in the DOM, because we need to read computed metrics.\n            this.modifyDOM();\n            // Add title if an ellipsis was added\n            if (this.ellipsis &&\n                (textNode.textContent || '').indexOf('\\u2026') !== -1) {\n                wrapper.attr('title', this.unescapeEntities(wrapper.textStr || '', ['&lt;', '&gt;']) // #7179\n                );\n            }\n            if (tempParent) {\n                tempParent.removeChild(textNode);\n            }\n        }\n        // Apply the text outline\n        if (isString(this.textOutline) && wrapper.applyTextOutline) {\n            wrapper.applyTextOutline(this.textOutline);\n        }\n    }\n    /**\n     * Modify the DOM of the generated SVG structure. This function only does\n     * operations that cannot be done until the elements are attached to the\n     * DOM, like doing layout based on rendered metrics of the added elements.\n     *\n     * @private\n     *\n     */\n    modifyDOM() {\n        const wrapper = this.svgElement;\n        const x = attr(wrapper.element, 'x');\n        wrapper.firstLineMetrics = void 0;\n        // Remove empty tspans (including breaks) from the beginning because\n        // SVG's getBBox doesn't count empty lines. The use case is tooltip\n        // where the header is empty. By doing this in the DOM rather than in\n        // the AST, we can inspect the textContent directly and don't have to\n        // recurse down to look for valid content.\n        let firstChild;\n        while ((firstChild = wrapper.element.firstChild)) {\n            if (/^[\\s\\u200B]*$/.test(firstChild.textContent || ' ')) {\n                wrapper.element.removeChild(firstChild);\n            }\n            else {\n                break;\n            }\n        }\n        // Modify hard line breaks by applying the rendered line height\n        [].forEach.call(wrapper.element.querySelectorAll('tspan.highcharts-br'), (br, i) => {\n            if (br.nextSibling && br.previousSibling) { // #5261\n                if (i === 0 && br.previousSibling.nodeType === 1) {\n                    wrapper.firstLineMetrics = wrapper.renderer\n                        .fontMetrics(br.previousSibling);\n                }\n                attr(br, {\n                    // Since the break is inserted in front of the next\n                    // line, we need to use the next sibling for the line\n                    // height\n                    dy: this.getLineHeight(br.nextSibling),\n                    x\n                });\n            }\n        });\n        // Constrain the line width, either by ellipsis or wrapping\n        const width = this.width || 0;\n        if (!width) {\n            return;\n        }\n        // Insert soft line breaks into each text node\n        const modifyTextNode = (textNode, parentElement) => {\n            const text = textNode.textContent || '';\n            const words = text\n                .replace(/([^\\^])-/g, '$1- ') // Split on hyphens\n                // .trim()\n                .split(' '); // #1273\n            const hasWhiteSpace = !this.noWrap && (words.length > 1 || wrapper.element.childNodes.length > 1);\n            const dy = this.getLineHeight(parentElement);\n            let lineNo = 0;\n            let startAt = wrapper.actualWidth;\n            if (this.ellipsis) {\n                if (text) {\n                    this.truncate(textNode, text, void 0, 0, \n                    // Target width\n                    Math.max(0, \n                    // Substract the font face to make room for the\n                    // ellipsis itself\n                    width - 0.8 * dy), \n                    // Build the text to test for\n                    (text, currentIndex) => text.substring(0, currentIndex) + '\\u2026');\n                }\n            }\n            else if (hasWhiteSpace) {\n                const lines = [];\n                // Remove preceding siblings in order to make the text length\n                // calculation correct in the truncate function\n                const precedingSiblings = [];\n                while (parentElement.firstChild &&\n                    parentElement.firstChild !== textNode) {\n                    precedingSiblings.push(parentElement.firstChild);\n                    parentElement.removeChild(parentElement.firstChild);\n                }\n                while (words.length) {\n                    // Apply the previous line\n                    if (words.length && !this.noWrap && lineNo > 0) {\n                        lines.push(textNode.textContent || '');\n                        textNode.textContent = words.join(' ')\n                            .replace(/- /g, '-');\n                    }\n                    // For each line, truncate the remaining\n                    // words into the line length.\n                    this.truncate(textNode, void 0, words, lineNo === 0 ? (startAt || 0) : 0, width, \n                    // Build the text to test for\n                    (t, currentIndex) => words\n                        .slice(0, currentIndex)\n                        .join(' ')\n                        .replace(/- /g, '-'));\n                    startAt = wrapper.actualWidth;\n                    lineNo++;\n                }\n                // Reinsert the preceding child nodes\n                precedingSiblings.forEach((childNode) => {\n                    parentElement.insertBefore(childNode, textNode);\n                });\n                // Insert the previous lines before the original text node\n                lines.forEach((line) => {\n                    // Insert the line\n                    parentElement.insertBefore(doc.createTextNode(line), textNode);\n                    // Insert a break\n                    const br = doc.createElementNS(SVG_NS, 'tspan');\n                    br.textContent = '\\u200B'; // zero-width space\n                    attr(br, { dy, x });\n                    parentElement.insertBefore(br, textNode);\n                });\n            }\n        };\n        // Recurse down the DOM tree and handle line breaks for each text node\n        const modifyChildren = ((node) => {\n            const childNodes = [].slice.call(node.childNodes);\n            childNodes.forEach((childNode) => {\n                if (childNode.nodeType === win.Node.TEXT_NODE) {\n                    modifyTextNode(childNode, node);\n                }\n                else {\n                    // Reset word-wrap width readings after hard breaks\n                    if (childNode.className.baseVal\n                        .indexOf('highcharts-br') !== -1) {\n                        wrapper.actualWidth = 0;\n                    }\n                    // Recurse down to child node\n                    modifyChildren(childNode);\n                }\n            });\n        });\n        modifyChildren(wrapper.element);\n    }\n    /**\n     * Get the rendered line height of a <text>, <tspan> or pure text node.\n     *\n     * @param {DOMElementType|Text} node The node to check for\n     *\n     * @return {number} The rendered line height\n     */\n    getLineHeight(node) {\n        // If the node is a text node, use its parent\n        const element = (node.nodeType === win.Node.TEXT_NODE) ?\n            node.parentElement :\n            node;\n        return this.textLineHeight ?\n            parseInt(this.textLineHeight.toString(), 10) :\n            this.renderer.fontMetrics(element || this.svgElement.element).h;\n    }\n    /**\n     * Transform a pseudo HTML AST node tree into an SVG structure. We do as\n     * much heavy lifting as we can here, before doing the final processing in\n     * the modifyDOM function. The original data is mutated.\n     *\n     * @private\n     *\n     * @param {ASTNode[]} nodes The AST nodes\n     *\n     */\n    modifyTree(nodes) {\n        const modifyChild = (node, i) => {\n            const { attributes = {}, children, style = {}, tagName } = node, styledMode = this.renderer.styledMode;\n            // Apply styling to text tags\n            if (tagName === 'b' || tagName === 'strong') {\n                if (styledMode) {\n                    // eslint-disable-next-line dot-notation\n                    attributes['class'] = 'highcharts-strong';\n                }\n                else {\n                    style.fontWeight = 'bold';\n                }\n            }\n            else if (tagName === 'i' || tagName === 'em') {\n                if (styledMode) {\n                    // eslint-disable-next-line dot-notation\n                    attributes['class'] = 'highcharts-emphasized';\n                }\n                else {\n                    style.fontStyle = 'italic';\n                }\n            }\n            // Modify styling\n            if (style && style.color) {\n                style.fill = style.color;\n            }\n            // Handle breaks\n            if (tagName === 'br') {\n                attributes['class'] = 'highcharts-br'; // eslint-disable-line dot-notation\n                node.textContent = '\\u200B'; // zero-width space\n                // Trim whitespace off the beginning of new lines\n                const nextNode = nodes[i + 1];\n                if (nextNode && nextNode.textContent) {\n                    nextNode.textContent =\n                        nextNode.textContent.replace(/^ +/gm, '');\n                }\n                // If an anchor has direct text node children, the text is unable to\n                // wrap because there is no `getSubStringLength` function on the\n                // element. Therefore we need to wrap the child text node or nodes\n                // in a tspan. #16173.\n            }\n            else if (tagName === 'a' &&\n                children &&\n                children.some((child) => child.tagName === '#text')) {\n                node.children = [{ children, tagName: 'tspan' }];\n            }\n            if (tagName !== '#text' && tagName !== 'a') {\n                node.tagName = 'tspan';\n            }\n            extend(node, { attributes, style });\n            // Recurse\n            if (children) {\n                children\n                    .filter((c) => c.tagName !== '#text')\n                    .forEach(modifyChild);\n            }\n        };\n        nodes.forEach(modifyChild);\n        fireEvent(this.svgElement, 'afterModifyTree', { nodes });\n    }\n    /*\n     * Truncate the text node contents to a given length. Used when the css\n     * width is set. If the `textOverflow` is `ellipsis`, the text is truncated\n     * character by character to the given length. If not, the text is\n     * word-wrapped line by line.\n     */\n    truncate(textNode, text, words, startAt, width, getString) {\n        const svgElement = this.svgElement;\n        const { renderer, rotation } = svgElement;\n        // Cache the lengths to avoid checking the same twice\n        const lengths = [];\n        // Word wrap cannot be truncated to shorter than one word, ellipsis\n        // text can be completely blank.\n        let minIndex = words ? 1 : 0;\n        let maxIndex = (text || words || '').length;\n        let currentIndex = maxIndex;\n        let str;\n        let actualWidth;\n        const getSubStringLength = function (charEnd, concatenatedEnd) {\n            // charEnd is used when finding the character-by-character\n            // break for ellipsis, concatenatedEnd is used for word-by-word\n            // break for word wrapping.\n            const end = concatenatedEnd || charEnd;\n            const parentNode = textNode.parentNode;\n            if (parentNode && typeof lengths[end] === 'undefined') {\n                // Modern browsers\n                if (parentNode.getSubStringLength) {\n                    // Fails with DOM exception on unit-tests/legend/members\n                    // of unknown reason. Desired width is 0, text content\n                    // is \"5\" and end is 1.\n                    try {\n                        lengths[end] = startAt +\n                            parentNode.getSubStringLength(0, words ? end + 1 : end);\n                    }\n                    catch (e) {\n                        '';\n                    }\n                }\n            }\n            return lengths[end];\n        };\n        svgElement.rotation = 0; // discard rotation when computing box\n        actualWidth = getSubStringLength(textNode.textContent.length);\n        if (startAt + actualWidth > width) {\n            // Do a binary search for the index where to truncate the text\n            while (minIndex <= maxIndex) {\n                currentIndex = Math.ceil((minIndex + maxIndex) / 2);\n                // When checking words for word-wrap, we need to build the\n                // string and measure the subStringLength at the concatenated\n                // word length.\n                if (words) {\n                    str = getString(words, currentIndex);\n                }\n                actualWidth = getSubStringLength(currentIndex, str && str.length - 1);\n                if (minIndex === maxIndex) {\n                    // Complete\n                    minIndex = maxIndex + 1;\n                }\n                else if (actualWidth > width) {\n                    // Too large. Set max index to current.\n                    maxIndex = currentIndex - 1;\n                }\n                else {\n                    // Within width. Set min index to current.\n                    minIndex = currentIndex;\n                }\n            }\n            // If max index was 0 it means the shortest possible text was also\n            // too large. For ellipsis that means only the ellipsis, while for\n            // word wrap it means the whole first word.\n            if (maxIndex === 0) {\n                // Remove ellipsis\n                textNode.textContent = '';\n                // If the new text length is one less than the original, we don't\n                // need the ellipsis\n            }\n            else if (!(text && maxIndex === text.length - 1)) {\n                textNode.textContent = str || getString(text || words, currentIndex);\n            }\n        }\n        // When doing line wrapping, prepare for the next line by removing the\n        // items from this line.\n        if (words) {\n            words.splice(0, currentIndex);\n        }\n        svgElement.actualWidth = actualWidth;\n        svgElement.rotation = rotation; // Apply rotation again.\n    }\n    /*\n     * Un-escape HTML entities based on the public `renderer.escapes` list\n     *\n     * @private\n     *\n     * @param {string} inputStr The string to unescape\n     * @param {Array<string>} [except] Exceptions\n     *\n     * @return {string} The processed string\n     */\n    unescapeEntities(inputStr, except) {\n        objectEach(this.renderer.escapes, function (value, key) {\n            if (!except || except.indexOf(value) === -1) {\n                inputStr = inputStr.toString().replace(new RegExp(value, 'g'), key);\n            }\n        });\n        return inputStr;\n    }\n}\nexport default TextBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}