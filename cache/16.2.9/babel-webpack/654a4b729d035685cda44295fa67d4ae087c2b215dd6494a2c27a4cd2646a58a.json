{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport DataLabel from '../../Core/Series/DataLabel.js';\nimport H from '../../Core/Globals.js';\nconst {\n  noop\n} = H;\nimport R from '../../Core/Renderer/RendererUtilities.js';\nconst {\n  distribute\n} = R;\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst {\n  series: Series\n} = SeriesRegistry;\nimport U from '../../Core/Utilities.js';\nconst {\n  arrayMax,\n  clamp,\n  defined,\n  pick,\n  relativeLength\n} = U;\n/* *\n *\n *  Composition\n *\n * */\nvar ColumnDataLabel;\n(function (ColumnDataLabel) {\n  /* *\n   *\n   *  Constants\n   *\n   * */\n  const composedMembers = [];\n  const dataLabelPositioners = {\n    // Based on the value computed in Highcharts' distribute algorithm.\n    radialDistributionY: function (point, dataLabel) {\n      return (dataLabel.dataLabelPosition?.top || 0) + point.distributeBox.pos;\n    },\n    // Get the x - use the natural x position for labels near the top and\n    // bottom, to prevent the top and botton slice connectors from touching\n    // each other on either side. Based on the value computed in Highcharts'\n    // distribute algorithm.\n    radialDistributionX: function (series, point, y, naturalY, dataLabel) {\n      const pos = dataLabel.dataLabelPosition;\n      return series.getX(y < (pos?.top || 0) + 2 || y > (pos?.bottom || 0) - 2 ? naturalY : y, point.half, point, dataLabel);\n    },\n    // The dataLabels.distance determines the x position of the label\n    justify: function (point, dataLabel, radius, seriesCenter) {\n      return seriesCenter[0] + (point.half ? -1 : 1) * (radius + (dataLabel.dataLabelPosition?.distance || 0));\n    },\n    // Left edges of the left-half labels touch the left edge of the plot\n    // area. Right edges of the right-half labels touch the right edge of\n    // the plot area.\n    alignToPlotEdges: function (dataLabel, half, plotWidth, plotLeft) {\n      const dataLabelWidth = dataLabel.getBBox().width;\n      return half ? dataLabelWidth + plotLeft : plotWidth - dataLabelWidth - plotLeft;\n    },\n    // Connectors of each side end in the same x position. Labels are\n    // aligned to them. Left edge of the widest left-half label touches the\n    // left edge of the plot area. Right edge of the widest right-half label\n    // touches the right edge of the plot area.\n    alignToConnectors: function (points, half, plotWidth, plotLeft) {\n      let maxDataLabelWidth = 0,\n        dataLabelWidth;\n      // find widest data label\n      points.forEach(function (point) {\n        dataLabelWidth = point.dataLabel.getBBox().width;\n        if (dataLabelWidth > maxDataLabelWidth) {\n          maxDataLabelWidth = dataLabelWidth;\n        }\n      });\n      return half ? maxDataLabelWidth + plotLeft : plotWidth - maxDataLabelWidth - plotLeft;\n    }\n  };\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /* eslint-disable valid-jsdoc */\n  /** @private */\n  function compose(PieSeriesClass) {\n    DataLabel.compose(Series);\n    if (U.pushUnique(composedMembers, PieSeriesClass)) {\n      const pieProto = PieSeriesClass.prototype;\n      pieProto.dataLabelPositioners = dataLabelPositioners;\n      pieProto.alignDataLabel = noop;\n      pieProto.drawDataLabels = drawDataLabels;\n      pieProto.getDataLabelPosition = getDataLabelPosition;\n      pieProto.placeDataLabels = placeDataLabels;\n      pieProto.verifyDataLabelOverflow = verifyDataLabelOverflow;\n    }\n  }\n  ColumnDataLabel.compose = compose;\n  /** @private */\n  function getDataLabelPosition(point, distance) {\n    const {\n        center,\n        options\n      } = this,\n      r = center[2] / 2,\n      angle = point.angle || 0,\n      cosAngle = Math.cos(angle),\n      sinAngle = Math.sin(angle),\n      x = center[0] + cosAngle * r,\n      y = center[1] + sinAngle * r,\n      finalConnectorOffset = Math.min((options.slicedOffset || 0) + (options.borderWidth || 0), distance / 5); // #1678\n    return {\n      natural: {\n        // Initial position of the data label - it's utilized for\n        // finding the final position for the label\n        x: x + cosAngle * distance,\n        y: y + sinAngle * distance\n      },\n      computed: {\n        // Used for generating connector path - initialized later in\n        // drawDataLabels function x: undefined, y: undefined\n      },\n      // Left - pie on the left side of the data label\n      // Right - pie on the right side of the data label\n      // Center - data label overlaps the pie\n      alignment: distance < 0 ? 'center' : point.half ? 'right' : 'left',\n      connectorPosition: {\n        breakAt: {\n          x: x + cosAngle * finalConnectorOffset,\n          y: y + sinAngle * finalConnectorOffset\n        },\n        touchingSliceAt: {\n          x,\n          y\n        }\n      },\n      distance\n    };\n  }\n  /**\n   * Override the base drawDataLabels method by pie specific functionality\n   * @private\n   */\n  function drawDataLabels() {\n    const series = this,\n      points = series.points,\n      chart = series.chart,\n      plotWidth = chart.plotWidth,\n      plotHeight = chart.plotHeight,\n      plotLeft = chart.plotLeft,\n      maxWidth = Math.round(chart.chartWidth / 3),\n      seriesCenter = series.center,\n      radius = seriesCenter[2] / 2,\n      centerY = seriesCenter[1],\n      halves = [[], [] // Left\n      ],\n      overflow = [0, 0, 0, 0],\n      // Top, right, bottom, left\n      dataLabelPositioners = series.dataLabelPositioners;\n    let connector,\n      dataLabelWidth,\n      labelHeight,\n      maxLabelDistance = 0;\n    // Get out if not enabled\n    if (!series.visible || !series.hasDataLabels?.()) {\n      return;\n    }\n    // Reset all labels that have been shortened\n    points.forEach(point => {\n      (point.dataLabels || []).forEach(dataLabel => {\n        if (dataLabel.shortened) {\n          dataLabel.attr({\n            width: 'auto'\n          }).css({\n            width: 'auto',\n            textOverflow: 'clip'\n          });\n          dataLabel.shortened = false;\n        }\n      });\n    });\n    // Run parent method\n    Series.prototype.drawDataLabels.apply(series);\n    points.forEach(point => {\n      (point.dataLabels || []).forEach((dataLabel, i) => {\n        const r = seriesCenter[2] / 2,\n          dataLabelOptions = dataLabel.options,\n          distance = relativeLength(dataLabelOptions?.distance || 0, r);\n        // Arrange points for collision detection\n        if (i === 0) {\n          halves[point.half].push(point);\n        }\n        // Avoid long labels squeezing the pie size too far down\n        if (!defined(dataLabelOptions?.style?.width)) {\n          if (dataLabel.getBBox().width > maxWidth) {\n            dataLabel.css({\n              // Use a fraction of the maxWidth to avoid wrapping\n              // close to the end of the string.\n              width: Math.round(maxWidth * 0.7) + 'px'\n            });\n            dataLabel.shortened = true;\n          }\n        }\n        dataLabel.dataLabelPosition = this.getDataLabelPosition(point, distance);\n        maxLabelDistance = Math.max(maxLabelDistance, distance);\n      });\n    });\n    /* Loop over the points in each half, starting from the top and bottom\n     * of the pie to detect overlapping labels.\n     */\n    halves.forEach((points, halfIdx) => {\n      const length = points.length,\n        positions = [];\n      let top,\n        bottom,\n        size = 0,\n        distributionLength;\n      if (!length) {\n        return;\n      }\n      // Sort by angle\n      series.sortByAngle(points, halfIdx - 0.5);\n      // Only do anti-collision when we have dataLabels outside the pie\n      // and have connectors. (#856)\n      if (maxLabelDistance > 0) {\n        top = Math.max(0, centerY - radius - maxLabelDistance);\n        bottom = Math.min(centerY + radius + maxLabelDistance, chart.plotHeight);\n        points.forEach(point => {\n          // Check if specific points' label is outside the pie\n          (point.dataLabels || []).forEach((dataLabel, i) => {\n            const labelPosition = dataLabel.dataLabelPosition;\n            if (labelPosition && labelPosition.distance > 0) {\n              // The point.top depends on point.labelDistance\n              // value. Used for calculation of y value in getX\n              // method\n              labelPosition.top = Math.max(0, centerY - radius - labelPosition.distance);\n              labelPosition.bottom = Math.min(centerY + radius + labelPosition.distance, chart.plotHeight);\n              size = dataLabel.getBBox().height || 21;\n              point.distributeBox = {\n                target: (dataLabel.dataLabelPosition?.natural.y || 0) - labelPosition.top + size / 2,\n                size,\n                rank: point.y\n              };\n              positions.push(point.distributeBox);\n            }\n          });\n        });\n        distributionLength = bottom + size - top;\n        distribute(positions, distributionLength, distributionLength / 5);\n      }\n      // Now the used slots are sorted, fill them up sequentially\n      points.forEach(point => {\n        (point.dataLabels || []).forEach(dataLabel => {\n          const dataLabelOptions = dataLabel.options || {},\n            distributeBox = point.distributeBox,\n            labelPosition = dataLabel.dataLabelPosition,\n            naturalY = labelPosition?.natural.y || 0,\n            connectorPadding = dataLabelOptions.connectorPadding || 0;\n          let x = 0,\n            y = naturalY,\n            visibility = 'inherit';\n          if (labelPosition) {\n            if (positions && defined(distributeBox) && labelPosition.distance > 0) {\n              if (typeof distributeBox.pos === 'undefined') {\n                visibility = 'hidden';\n              } else {\n                labelHeight = distributeBox.size;\n                // Find label's y position\n                y = dataLabelPositioners.radialDistributionY(point, dataLabel);\n              }\n            }\n            // Find label's x position. The justify option is\n            // undocumented in the API - preserve support for it\n            if (dataLabelOptions.justify) {\n              x = dataLabelPositioners.justify(point, dataLabel, radius, seriesCenter);\n            } else {\n              switch (dataLabelOptions.alignTo) {\n                case 'connectors':\n                  x = dataLabelPositioners.alignToConnectors(points, halfIdx, plotWidth, plotLeft);\n                  break;\n                case 'plotEdges':\n                  x = dataLabelPositioners.alignToPlotEdges(dataLabel, halfIdx, plotWidth, plotLeft);\n                  break;\n                default:\n                  x = dataLabelPositioners.radialDistributionX(series, point, y, naturalY, dataLabel);\n              }\n            }\n            // Record the placement and visibility\n            labelPosition.attribs = {\n              visibility,\n              align: labelPosition.alignment\n            };\n            labelPosition.posAttribs = {\n              x: x + (dataLabelOptions.x || 0) + (\n              // (#12985)\n              {\n                left: connectorPadding,\n                right: -connectorPadding\n              }[labelPosition.alignment] || 0),\n              y: y + (dataLabelOptions.y || 0) -\n              // (#12985)\n              // Vertically center\n              dataLabel.getBBox().height / 2\n            };\n            labelPosition.computed.x = x;\n            labelPosition.computed.y = y;\n            // Detect overflowing data labels\n            if (pick(dataLabelOptions.crop, true)) {\n              dataLabelWidth = dataLabel.getBBox().width;\n              let sideOverflow;\n              // Overflow left\n              if (x - dataLabelWidth < connectorPadding && halfIdx === 1 // Left half\n              ) {\n                sideOverflow = Math.round(dataLabelWidth - x + connectorPadding);\n                overflow[3] = Math.max(sideOverflow, overflow[3]);\n                // Overflow right\n              } else if (x + dataLabelWidth > plotWidth - connectorPadding && halfIdx === 0 // Right half\n              ) {\n                sideOverflow = Math.round(x + dataLabelWidth - plotWidth + connectorPadding);\n                overflow[1] = Math.max(sideOverflow, overflow[1]);\n              }\n              // Overflow top\n              if (y - labelHeight / 2 < 0) {\n                overflow[0] = Math.max(Math.round(-y + labelHeight / 2), overflow[0]);\n                // Overflow left\n              } else if (y + labelHeight / 2 > plotHeight) {\n                overflow[2] = Math.max(Math.round(y + labelHeight / 2 - plotHeight), overflow[2]);\n              }\n              labelPosition.sideOverflow = sideOverflow;\n            }\n          }\n        }); // For each data label of the point\n      }); // For each point\n    }); // For each half\n    // Do not apply the final placement and draw the connectors until we\n    // have verified that labels are not spilling over.\n    if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {\n      // Place the labels in the final position\n      this.placeDataLabels();\n      this.points.forEach(point => {\n        (point.dataLabels || []).forEach(dataLabel => {\n          // #8864: every connector can have individual options\n          const {\n              connectorColor,\n              connectorWidth = 1\n            } = dataLabel.options || {},\n            labelPosition = dataLabel.dataLabelPosition;\n          // Draw the connector\n          if (connectorWidth) {\n            let isNew;\n            connector = dataLabel.connector;\n            if (labelPosition && labelPosition.distance > 0) {\n              isNew = !connector;\n              if (!connector) {\n                dataLabel.connector = connector = chart.renderer.path().addClass('highcharts-data-label-connector ' + ' highcharts-color-' + point.colorIndex + (point.className ? ' ' + point.className : '')).add(series.dataLabelsGroup);\n              }\n              if (!chart.styledMode) {\n                connector.attr({\n                  'stroke-width': connectorWidth,\n                  'stroke': connectorColor || point.color || \"#666666\" /* Palette.neutralColor60 */\n                });\n              }\n\n              connector[isNew ? 'attr' : 'animate']({\n                d: point.getConnectorPath(dataLabel)\n              });\n              connector.attr({\n                visibility: labelPosition.attribs?.visibility\n              });\n            } else if (connector) {\n              dataLabel.connector = connector.destroy();\n            }\n          }\n        });\n      });\n    }\n  }\n  /**\n   * Perform the final placement of the data labels after we have verified\n   * that they fall within the plot area.\n   * @private\n   */\n  function placeDataLabels() {\n    this.points.forEach(point => {\n      (point.dataLabels || []).forEach(dataLabel => {\n        const labelPosition = dataLabel.dataLabelPosition;\n        if (labelPosition) {\n          // Shorten data labels with ellipsis if they still overflow\n          // after the pie has reached minSize (#223).\n          if (labelPosition.sideOverflow) {\n            dataLabel.css({\n              width: Math.max(dataLabel.getBBox().width - labelPosition.sideOverflow, 0) + 'px',\n              textOverflow: (dataLabel.options?.style || {}).textOverflow || 'ellipsis'\n            });\n            dataLabel.shortened = true;\n          }\n          dataLabel.attr(labelPosition.attribs);\n          dataLabel[dataLabel.moved ? 'animate' : 'attr'](labelPosition.posAttribs);\n          dataLabel.moved = true;\n        } else if (dataLabel) {\n          dataLabel.attr({\n            y: -9999\n          });\n        }\n      });\n      // Clear for update\n      delete point.distributeBox;\n    }, this);\n  }\n  /**\n   * Verify whether the data labels are allowed to draw, or we should run more\n   * translation and data label positioning to keep them inside the plot area.\n   * Returns true when data labels are ready to draw.\n   * @private\n   */\n  function verifyDataLabelOverflow(overflow) {\n    let center = this.center,\n      options = this.options,\n      centerOption = options.center,\n      minSize = options.minSize || 80,\n      newSize = minSize,\n      // If a size is set, return true and don't try to shrink the pie\n      // to fit the labels.\n      ret = options.size !== null;\n    if (!ret) {\n      // Handle horizontal size and center\n      if (centerOption[0] !== null) {\n        // Fixed center\n        newSize = Math.max(center[2] - Math.max(overflow[1], overflow[3]), minSize);\n      } else {\n        // Auto center\n        newSize = Math.max(\n        // horizontal overflow\n        center[2] - overflow[1] - overflow[3], minSize);\n        // horizontal center\n        center[0] += (overflow[3] - overflow[1]) / 2;\n      }\n      // Handle vertical size and center\n      if (centerOption[1] !== null) {\n        // Fixed center\n        newSize = clamp(newSize, minSize, center[2] - Math.max(overflow[0], overflow[2]));\n      } else {\n        // Auto center\n        newSize = clamp(newSize, minSize,\n        // vertical overflow\n        center[2] - overflow[0] - overflow[2]);\n        // vertical center\n        center[1] += (overflow[0] - overflow[2]) / 2;\n      }\n      // If the size must be decreased, we need to run translate and\n      // drawDataLabels again\n      if (newSize < center[2]) {\n        center[2] = newSize;\n        center[3] = Math.min(\n        // #3632\n        options.thickness ? Math.max(0, newSize - options.thickness * 2) : Math.max(0, relativeLength(options.innerSize || 0, newSize)), newSize); // #6647\n        this.translate(center);\n        if (this.drawDataLabels) {\n          this.drawDataLabels();\n        }\n        // Else, return true to indicate that the pie and its labels is\n        // within the plot area\n      } else {\n        ret = true;\n      }\n    }\n    return ret;\n  }\n})(ColumnDataLabel || (ColumnDataLabel = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default ColumnDataLabel;","map":{"version":3,"names":["DataLabel","H","noop","R","distribute","SeriesRegistry","series","Series","U","arrayMax","clamp","defined","pick","relativeLength","ColumnDataLabel","composedMembers","dataLabelPositioners","radialDistributionY","point","dataLabel","dataLabelPosition","top","distributeBox","pos","radialDistributionX","y","naturalY","getX","bottom","half","justify","radius","seriesCenter","distance","alignToPlotEdges","plotWidth","plotLeft","dataLabelWidth","getBBox","width","alignToConnectors","points","maxDataLabelWidth","forEach","compose","PieSeriesClass","pushUnique","pieProto","prototype","alignDataLabel","drawDataLabels","getDataLabelPosition","placeDataLabels","verifyDataLabelOverflow","center","options","r","angle","cosAngle","Math","cos","sinAngle","sin","x","finalConnectorOffset","min","slicedOffset","borderWidth","natural","computed","alignment","connectorPosition","breakAt","touchingSliceAt","chart","plotHeight","maxWidth","round","chartWidth","centerY","halves","overflow","connector","labelHeight","maxLabelDistance","visible","hasDataLabels","dataLabels","shortened","attr","css","textOverflow","apply","i","dataLabelOptions","push","style","max","halfIdx","length","positions","size","distributionLength","sortByAngle","labelPosition","height","target","rank","connectorPadding","visibility","alignTo","attribs","align","posAttribs","left","right","crop","sideOverflow","connectorColor","connectorWidth","isNew","renderer","path","addClass","colorIndex","className","add","dataLabelsGroup","styledMode","color","d","getConnectorPath","destroy","moved","centerOption","minSize","newSize","ret","thickness","innerSize","translate"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Series/Pie/PieDataLabel.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport DataLabel from '../../Core/Series/DataLabel.js';\nimport H from '../../Core/Globals.js';\nconst { noop } = H;\nimport R from '../../Core/Renderer/RendererUtilities.js';\nconst { distribute } = R;\nimport SeriesRegistry from '../../Core/Series/SeriesRegistry.js';\nconst { series: Series } = SeriesRegistry;\nimport U from '../../Core/Utilities.js';\nconst { arrayMax, clamp, defined, pick, relativeLength } = U;\n/* *\n *\n *  Composition\n *\n * */\nvar ColumnDataLabel;\n(function (ColumnDataLabel) {\n    /* *\n     *\n     *  Constants\n     *\n     * */\n    const composedMembers = [];\n    const dataLabelPositioners = {\n        // Based on the value computed in Highcharts' distribute algorithm.\n        radialDistributionY: function (point, dataLabel) {\n            return (dataLabel.dataLabelPosition?.top || 0) +\n                point.distributeBox.pos;\n        },\n        // Get the x - use the natural x position for labels near the top and\n        // bottom, to prevent the top and botton slice connectors from touching\n        // each other on either side. Based on the value computed in Highcharts'\n        // distribute algorithm.\n        radialDistributionX: function (series, point, y, naturalY, dataLabel) {\n            const pos = dataLabel.dataLabelPosition;\n            return series.getX(y < (pos?.top || 0) + 2 || y > (pos?.bottom || 0) - 2 ?\n                naturalY :\n                y, point.half, point, dataLabel);\n        },\n        // The dataLabels.distance determines the x position of the label\n        justify: function (point, dataLabel, radius, seriesCenter) {\n            return seriesCenter[0] + (point.half ? -1 : 1) *\n                (radius + (dataLabel.dataLabelPosition?.distance || 0));\n        },\n        // Left edges of the left-half labels touch the left edge of the plot\n        // area. Right edges of the right-half labels touch the right edge of\n        // the plot area.\n        alignToPlotEdges: function (dataLabel, half, plotWidth, plotLeft) {\n            const dataLabelWidth = dataLabel.getBBox().width;\n            return half ? dataLabelWidth + plotLeft :\n                plotWidth - dataLabelWidth - plotLeft;\n        },\n        // Connectors of each side end in the same x position. Labels are\n        // aligned to them. Left edge of the widest left-half label touches the\n        // left edge of the plot area. Right edge of the widest right-half label\n        // touches the right edge of the plot area.\n        alignToConnectors: function (points, half, plotWidth, plotLeft) {\n            let maxDataLabelWidth = 0, dataLabelWidth;\n            // find widest data label\n            points.forEach(function (point) {\n                dataLabelWidth = point.dataLabel.getBBox().width;\n                if (dataLabelWidth > maxDataLabelWidth) {\n                    maxDataLabelWidth = dataLabelWidth;\n                }\n            });\n            return half ? maxDataLabelWidth + plotLeft :\n                plotWidth - maxDataLabelWidth - plotLeft;\n        }\n    };\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    /** @private */\n    function compose(PieSeriesClass) {\n        DataLabel.compose(Series);\n        if (U.pushUnique(composedMembers, PieSeriesClass)) {\n            const pieProto = PieSeriesClass.prototype;\n            pieProto.dataLabelPositioners = dataLabelPositioners;\n            pieProto.alignDataLabel = noop;\n            pieProto.drawDataLabels = drawDataLabels;\n            pieProto.getDataLabelPosition = getDataLabelPosition;\n            pieProto.placeDataLabels = placeDataLabels;\n            pieProto.verifyDataLabelOverflow = verifyDataLabelOverflow;\n        }\n    }\n    ColumnDataLabel.compose = compose;\n    /** @private */\n    function getDataLabelPosition(point, distance) {\n        const { center, options } = this, r = center[2] / 2, angle = point.angle || 0, cosAngle = Math.cos(angle), sinAngle = Math.sin(angle), x = center[0] + cosAngle * r, y = center[1] + sinAngle * r, finalConnectorOffset = Math.min((options.slicedOffset || 0) + (options.borderWidth || 0), distance / 5); // #1678\n        return {\n            natural: {\n                // Initial position of the data label - it's utilized for\n                // finding the final position for the label\n                x: x + cosAngle * distance,\n                y: y + sinAngle * distance\n            },\n            computed: {\n            // Used for generating connector path - initialized later in\n            // drawDataLabels function x: undefined, y: undefined\n            },\n            // Left - pie on the left side of the data label\n            // Right - pie on the right side of the data label\n            // Center - data label overlaps the pie\n            alignment: distance < 0 ? 'center' : point.half ? 'right' : 'left',\n            connectorPosition: {\n                breakAt: {\n                    x: x + cosAngle * finalConnectorOffset,\n                    y: y + sinAngle * finalConnectorOffset\n                },\n                touchingSliceAt: {\n                    x,\n                    y\n                }\n            },\n            distance\n        };\n    }\n    /**\n     * Override the base drawDataLabels method by pie specific functionality\n     * @private\n     */\n    function drawDataLabels() {\n        const series = this, points = series.points, chart = series.chart, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotLeft = chart.plotLeft, maxWidth = Math.round(chart.chartWidth / 3), seriesCenter = series.center, radius = seriesCenter[2] / 2, centerY = seriesCenter[1], halves = [\n            [],\n            [] // Left\n        ], overflow = [0, 0, 0, 0], // Top, right, bottom, left\n        dataLabelPositioners = series.dataLabelPositioners;\n        let connector, dataLabelWidth, labelHeight, maxLabelDistance = 0;\n        // Get out if not enabled\n        if (!series.visible || !series.hasDataLabels?.()) {\n            return;\n        }\n        // Reset all labels that have been shortened\n        points.forEach((point) => {\n            (point.dataLabels || []).forEach((dataLabel) => {\n                if (dataLabel.shortened) {\n                    dataLabel\n                        .attr({\n                        width: 'auto'\n                    }).css({\n                        width: 'auto',\n                        textOverflow: 'clip'\n                    });\n                    dataLabel.shortened = false;\n                }\n            });\n        });\n        // Run parent method\n        Series.prototype.drawDataLabels.apply(series);\n        points.forEach((point) => {\n            (point.dataLabels || []).forEach((dataLabel, i) => {\n                const r = seriesCenter[2] / 2, dataLabelOptions = dataLabel.options, distance = relativeLength(dataLabelOptions?.distance || 0, r);\n                // Arrange points for collision detection\n                if (i === 0) {\n                    halves[point.half].push(point);\n                }\n                // Avoid long labels squeezing the pie size too far down\n                if (!defined(dataLabelOptions?.style?.width)) {\n                    if (dataLabel.getBBox().width > maxWidth) {\n                        dataLabel.css({\n                            // Use a fraction of the maxWidth to avoid wrapping\n                            // close to the end of the string.\n                            width: Math.round(maxWidth * 0.7) + 'px'\n                        });\n                        dataLabel.shortened = true;\n                    }\n                }\n                dataLabel.dataLabelPosition = this.getDataLabelPosition(point, distance);\n                maxLabelDistance = Math.max(maxLabelDistance, distance);\n            });\n        });\n        /* Loop over the points in each half, starting from the top and bottom\n         * of the pie to detect overlapping labels.\n         */\n        halves.forEach((points, halfIdx) => {\n            const length = points.length, positions = [];\n            let top, bottom, size = 0, distributionLength;\n            if (!length) {\n                return;\n            }\n            // Sort by angle\n            series.sortByAngle(points, halfIdx - 0.5);\n            // Only do anti-collision when we have dataLabels outside the pie\n            // and have connectors. (#856)\n            if (maxLabelDistance > 0) {\n                top = Math.max(0, centerY - radius - maxLabelDistance);\n                bottom = Math.min(centerY + radius + maxLabelDistance, chart.plotHeight);\n                points.forEach((point) => {\n                    // Check if specific points' label is outside the pie\n                    (point.dataLabels || []).forEach((dataLabel, i) => {\n                        const labelPosition = dataLabel.dataLabelPosition;\n                        if (labelPosition &&\n                            labelPosition.distance > 0) {\n                            // The point.top depends on point.labelDistance\n                            // value. Used for calculation of y value in getX\n                            // method\n                            labelPosition.top = Math.max(0, centerY - radius - labelPosition.distance);\n                            labelPosition.bottom = Math.min(centerY + radius + labelPosition.distance, chart.plotHeight);\n                            size = dataLabel.getBBox().height || 21;\n                            point.distributeBox = {\n                                target: ((dataLabel.dataLabelPosition\n                                    ?.natural.y || 0) -\n                                    labelPosition.top +\n                                    size / 2),\n                                size,\n                                rank: point.y\n                            };\n                            positions.push(point.distributeBox);\n                        }\n                    });\n                });\n                distributionLength = bottom + size - top;\n                distribute(positions, distributionLength, distributionLength / 5);\n            }\n            // Now the used slots are sorted, fill them up sequentially\n            points.forEach((point) => {\n                (point.dataLabels || []).forEach((dataLabel) => {\n                    const dataLabelOptions = (dataLabel.options || {}), distributeBox = point.distributeBox, labelPosition = dataLabel.dataLabelPosition, naturalY = labelPosition?.natural.y || 0, connectorPadding = dataLabelOptions\n                        .connectorPadding || 0;\n                    let x = 0, y = naturalY, visibility = 'inherit';\n                    if (labelPosition) {\n                        if (positions &&\n                            defined(distributeBox) &&\n                            labelPosition.distance > 0) {\n                            if (typeof distributeBox.pos === 'undefined') {\n                                visibility = 'hidden';\n                            }\n                            else {\n                                labelHeight = distributeBox.size;\n                                // Find label's y position\n                                y = dataLabelPositioners\n                                    .radialDistributionY(point, dataLabel);\n                            }\n                        }\n                        // Find label's x position. The justify option is\n                        // undocumented in the API - preserve support for it\n                        if (dataLabelOptions.justify) {\n                            x = dataLabelPositioners.justify(point, dataLabel, radius, seriesCenter);\n                        }\n                        else {\n                            switch (dataLabelOptions.alignTo) {\n                                case 'connectors':\n                                    x = dataLabelPositioners.alignToConnectors(points, halfIdx, plotWidth, plotLeft);\n                                    break;\n                                case 'plotEdges':\n                                    x = dataLabelPositioners.alignToPlotEdges(dataLabel, halfIdx, plotWidth, plotLeft);\n                                    break;\n                                default:\n                                    x = dataLabelPositioners.radialDistributionX(series, point, y, naturalY, dataLabel);\n                            }\n                        }\n                        // Record the placement and visibility\n                        labelPosition.attribs = {\n                            visibility,\n                            align: labelPosition.alignment\n                        };\n                        labelPosition.posAttribs = {\n                            x: x +\n                                (dataLabelOptions.x || 0) + // (#12985)\n                                ({\n                                    left: connectorPadding,\n                                    right: -connectorPadding\n                                }[labelPosition.alignment] || 0),\n                            y: y +\n                                (dataLabelOptions.y || 0) - // (#12985)\n                                // Vertically center\n                                dataLabel.getBBox().height / 2\n                        };\n                        labelPosition.computed.x = x;\n                        labelPosition.computed.y = y;\n                        // Detect overflowing data labels\n                        if (pick(dataLabelOptions.crop, true)) {\n                            dataLabelWidth = dataLabel.getBBox().width;\n                            let sideOverflow;\n                            // Overflow left\n                            if (x - dataLabelWidth < connectorPadding &&\n                                halfIdx === 1 // Left half\n                            ) {\n                                sideOverflow = Math.round(dataLabelWidth - x + connectorPadding);\n                                overflow[3] = Math.max(sideOverflow, overflow[3]);\n                                // Overflow right\n                            }\n                            else if (x + dataLabelWidth >\n                                plotWidth - connectorPadding &&\n                                halfIdx === 0 // Right half\n                            ) {\n                                sideOverflow = Math.round(x +\n                                    dataLabelWidth -\n                                    plotWidth +\n                                    connectorPadding);\n                                overflow[1] = Math.max(sideOverflow, overflow[1]);\n                            }\n                            // Overflow top\n                            if (y - labelHeight / 2 < 0) {\n                                overflow[0] = Math.max(Math.round(-y + labelHeight / 2), overflow[0]);\n                                // Overflow left\n                            }\n                            else if (y + labelHeight / 2 > plotHeight) {\n                                overflow[2] = Math.max(Math.round(y + labelHeight / 2 - plotHeight), overflow[2]);\n                            }\n                            labelPosition.sideOverflow = sideOverflow;\n                        }\n                    }\n                }); // For each data label of the point\n            }); // For each point\n        }); // For each half\n        // Do not apply the final placement and draw the connectors until we\n        // have verified that labels are not spilling over.\n        if (arrayMax(overflow) === 0 ||\n            this.verifyDataLabelOverflow(overflow)) {\n            // Place the labels in the final position\n            this.placeDataLabels();\n            this.points.forEach((point) => {\n                (point.dataLabels || []).forEach((dataLabel) => {\n                    // #8864: every connector can have individual options\n                    const { connectorColor, connectorWidth = 1 } = (dataLabel.options || {}), labelPosition = dataLabel.dataLabelPosition;\n                    // Draw the connector\n                    if (connectorWidth) {\n                        let isNew;\n                        connector = dataLabel.connector;\n                        if (labelPosition && labelPosition.distance > 0) {\n                            isNew = !connector;\n                            if (!connector) {\n                                dataLabel.connector = connector = chart.renderer\n                                    .path()\n                                    .addClass('highcharts-data-label-connector ' +\n                                    ' highcharts-color-' +\n                                    point.colorIndex +\n                                    (point.className ?\n                                        ' ' + point.className :\n                                        ''))\n                                    .add(series.dataLabelsGroup);\n                            }\n                            if (!chart.styledMode) {\n                                connector.attr({\n                                    'stroke-width': connectorWidth,\n                                    'stroke': (connectorColor ||\n                                        point.color ||\n                                        \"#666666\" /* Palette.neutralColor60 */)\n                                });\n                            }\n                            connector[isNew ? 'attr' : 'animate']({\n                                d: point.getConnectorPath(dataLabel)\n                            });\n                            connector.attr({\n                                visibility: labelPosition.attribs?.visibility\n                            });\n                        }\n                        else if (connector) {\n                            dataLabel.connector = connector.destroy();\n                        }\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Perform the final placement of the data labels after we have verified\n     * that they fall within the plot area.\n     * @private\n     */\n    function placeDataLabels() {\n        this.points.forEach((point) => {\n            (point.dataLabels || []).forEach((dataLabel) => {\n                const labelPosition = dataLabel.dataLabelPosition;\n                if (labelPosition) {\n                    // Shorten data labels with ellipsis if they still overflow\n                    // after the pie has reached minSize (#223).\n                    if (labelPosition.sideOverflow) {\n                        dataLabel.css({\n                            width: (Math.max(dataLabel.getBBox().width -\n                                labelPosition.sideOverflow, 0)) + 'px',\n                            textOverflow: ((dataLabel.options?.style || {})\n                                .textOverflow ||\n                                'ellipsis')\n                        });\n                        dataLabel.shortened = true;\n                    }\n                    dataLabel.attr(labelPosition.attribs);\n                    dataLabel[dataLabel.moved ? 'animate' : 'attr'](labelPosition.posAttribs);\n                    dataLabel.moved = true;\n                }\n                else if (dataLabel) {\n                    dataLabel.attr({ y: -9999 });\n                }\n            });\n            // Clear for update\n            delete point.distributeBox;\n        }, this);\n    }\n    /**\n     * Verify whether the data labels are allowed to draw, or we should run more\n     * translation and data label positioning to keep them inside the plot area.\n     * Returns true when data labels are ready to draw.\n     * @private\n     */\n    function verifyDataLabelOverflow(overflow) {\n        let center = this.center, options = this.options, centerOption = options.center, minSize = options.minSize || 80, newSize = minSize, \n        // If a size is set, return true and don't try to shrink the pie\n        // to fit the labels.\n        ret = options.size !== null;\n        if (!ret) {\n            // Handle horizontal size and center\n            if (centerOption[0] !== null) { // Fixed center\n                newSize = Math.max(center[2] -\n                    Math.max(overflow[1], overflow[3]), minSize);\n            }\n            else { // Auto center\n                newSize = Math.max(\n                // horizontal overflow\n                center[2] - overflow[1] - overflow[3], minSize);\n                // horizontal center\n                center[0] += (overflow[3] - overflow[1]) / 2;\n            }\n            // Handle vertical size and center\n            if (centerOption[1] !== null) { // Fixed center\n                newSize = clamp(newSize, minSize, center[2] - Math.max(overflow[0], overflow[2]));\n            }\n            else { // Auto center\n                newSize = clamp(newSize, minSize, \n                // vertical overflow\n                center[2] - overflow[0] - overflow[2]);\n                // vertical center\n                center[1] += (overflow[0] - overflow[2]) / 2;\n            }\n            // If the size must be decreased, we need to run translate and\n            // drawDataLabels again\n            if (newSize < center[2]) {\n                center[2] = newSize;\n                center[3] = Math.min(// #3632\n                options.thickness ?\n                    Math.max(0, newSize - options.thickness * 2) :\n                    Math.max(0, relativeLength(options.innerSize || 0, newSize)), newSize); // #6647\n                this.translate(center);\n                if (this.drawDataLabels) {\n                    this.drawDataLabels();\n                }\n                // Else, return true to indicate that the pie and its labels is\n                // within the plot area\n            }\n            else {\n                ret = true;\n            }\n        }\n        return ret;\n    }\n})(ColumnDataLabel || (ColumnDataLabel = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default ColumnDataLabel;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}