{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport A from '../../Animation/AnimationUtilities.js';\nconst {\n  animate,\n  animObject,\n  stop\n} = A;\nimport Color from '../../Color/Color.js';\nimport H from '../../Globals.js';\nconst {\n  deg2rad,\n  doc,\n  noop,\n  svg,\n  SVG_NS,\n  win\n} = H;\nimport U from '../../Utilities.js';\nconst {\n  addEvent,\n  attr,\n  createElement,\n  css,\n  defined,\n  erase,\n  extend,\n  fireEvent,\n  isArray,\n  isFunction,\n  isObject,\n  isString,\n  merge,\n  objectEach,\n  pick,\n  pInt,\n  syncTimeout,\n  uniqueKey\n} = U;\n/* *\n *\n *  Class\n *\n * */\n/* eslint-disable no-invalid-this, valid-jsdoc */\n/**\n * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the\n * rendering layer of Highcharts. Combined with the\n * {@link Highcharts.SVGRenderer}\n * object, these prototypes allow freeform annotation in the charts or even in\n * HTML pages without instanciating a chart. The SVGElement can also wrap HTML\n * labels, when `text` or `label` elements are created with the `useHTML`\n * parameter.\n *\n * The SVGElement instances are created through factory functions on the\n * {@link Highcharts.SVGRenderer}\n * object, like\n * {@link Highcharts.SVGRenderer#rect|rect},\n * {@link Highcharts.SVGRenderer#path|path},\n * {@link Highcharts.SVGRenderer#text|text},\n * {@link Highcharts.SVGRenderer#label|label},\n * {@link Highcharts.SVGRenderer#g|g}\n * and more.\n *\n * @class\n * @name Highcharts.SVGElement\n */\nclass SVGElement {\n  constructor() {\n    /* *\n     *\n     *  Properties\n     *\n     * */\n    this.element = void 0;\n    this.onEvents = {};\n    this.opacity = 1; // Default base for animation\n    this.renderer = void 0;\n    this.SVG_NS = SVG_NS;\n  }\n  // @todo public zIndex?: number;\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * Get the current value of an attribute or pseudo attribute,\n   * used mainly for animation. Called internally from\n   * the {@link Highcharts.SVGRenderer#attr} function.\n   *\n   * @private\n   * @function Highcharts.SVGElement#_defaultGetter\n   *\n   * @param {string} key\n   *        Property key.\n   *\n   * @return {number|string}\n   *         Property value.\n   */\n  _defaultGetter(key) {\n    let ret = pick(this[key + 'Value'],\n    // align getter\n    this[key], this.element ? this.element.getAttribute(key) : null, 0);\n    if (/^[\\-0-9\\.]+$/.test(ret)) {\n      // is numerical\n      ret = parseFloat(ret);\n    }\n    return ret;\n  }\n  /**\n   * @private\n   * @function Highcharts.SVGElement#_defaultSetter\n   *\n   * @param {string} value\n   *\n   * @param {string} key\n   *\n   * @param {Highcharts.SVGDOMElement} element\n   *\n   */\n  _defaultSetter(value, key, element) {\n    element.setAttribute(key, value);\n  }\n  /**\n   * Add the element to the DOM. All elements must be added this way.\n   *\n   * @sample highcharts/members/renderer-g\n   *         Elements added to a group\n   *\n   * @function Highcharts.SVGElement#add\n   *\n   * @param {Highcharts.SVGElement} [parent]\n   *        The parent item to add it to. If undefined, the element is added\n   *        to the {@link Highcharts.SVGRenderer.box}.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  add(parent) {\n    const renderer = this.renderer,\n      element = this.element;\n    let inserted;\n    if (parent) {\n      this.parentGroup = parent;\n    }\n    // Build formatted text\n    if (typeof this.textStr !== 'undefined' && this.element.nodeName === 'text' // Not for SVGLabel instances\n    ) {\n      renderer.buildText(this);\n    }\n    // Mark as added\n    this.added = true;\n    // If we're adding to renderer root, or other elements in the group\n    // have a z index, we need to handle it\n    if (!parent || parent.handleZ || this.zIndex) {\n      inserted = this.zIndexSetter();\n    }\n    // If zIndex is not handled, append at the end\n    if (!inserted) {\n      (parent ? parent.element : renderer.box).appendChild(element);\n    }\n    // fire an event for internal hooks\n    if (this.onAdd) {\n      this.onAdd();\n    }\n    return this;\n  }\n  /**\n   * Add a class name to an element.\n   *\n   * @function Highcharts.SVGElement#addClass\n   *\n   * @param {string} className\n   * The new class name to add.\n   *\n   * @param {boolean} [replace=false]\n   * When true, the existing class name(s) will be overwritten with the new\n   * one. When false, the new one is added.\n   *\n   * @return {Highcharts.SVGElement}\n   * Return the SVG element for chainability.\n   */\n  addClass(className, replace) {\n    const currentClassName = replace ? '' : this.attr('class') || '';\n    // Trim the string and remove duplicates\n    className = (className || '').split(/ /g).reduce(function (newClassName, name) {\n      if (currentClassName.indexOf(name) === -1) {\n        newClassName.push(name);\n      }\n      return newClassName;\n    }, currentClassName ? [currentClassName] : []).join(' ');\n    if (className !== currentClassName) {\n      this.attr('class', className);\n    }\n    return this;\n  }\n  /**\n   * This method is executed in the end of `attr()`, after setting all\n   * attributes in the hash. In can be used to efficiently consolidate\n   * multiple attributes in one SVG property -- e.g., translate, rotate and\n   * scale are merged in one \"transform\" attribute in the SVG node.\n   *\n   * @private\n   * @function Highcharts.SVGElement#afterSetters\n   */\n  afterSetters() {\n    // Update transform. Do this outside the loop to prevent redundant\n    // updating for batch setting of attributes.\n    if (this.doTransform) {\n      this.updateTransform();\n      this.doTransform = false;\n    }\n  }\n  /**\n   * Align the element relative to the chart or another box.\n   *\n   * @function Highcharts.SVGElement#align\n   *\n   * @param {Highcharts.AlignObject} [alignOptions]\n   *        The alignment options. The function can be called without this\n   *        parameter in order to re-align an element after the box has been\n   *        updated.\n   *\n   * @param {boolean} [alignByTranslate]\n   *        Align element by translation.\n   *\n   * @param {string|Highcharts.BBoxObject} [box]\n   *        The box to align to, needs a width and height. When the box is a\n   *        string, it refers to an object in the Renderer. For example, when\n   *        box is `spacingBox`, it refers to `Renderer.spacingBox` which\n   *        holds `width`, `height`, `x` and `y` properties.\n   *\n   * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.\n   */\n  align(alignOptions, alignByTranslate, box) {\n    const attribs = {},\n      renderer = this.renderer,\n      alignedObjects = renderer.alignedObjects;\n    let x, y, alignTo, alignFactor, vAlignFactor;\n    // First call on instanciate\n    if (alignOptions) {\n      this.alignOptions = alignOptions;\n      this.alignByTranslate = alignByTranslate;\n      if (!box || isString(box)) {\n        this.alignTo = alignTo = box || 'renderer';\n        // prevent duplicates, like legendGroup after resize\n        erase(alignedObjects, this);\n        alignedObjects.push(this);\n        box = void 0; // reassign it below\n      }\n      // When called on resize, no arguments are supplied\n    } else {\n      alignOptions = this.alignOptions;\n      alignByTranslate = this.alignByTranslate;\n      alignTo = this.alignTo;\n    }\n    box = pick(box, renderer[alignTo], alignTo === 'scrollablePlotBox' ? renderer.plotBox : void 0, renderer);\n    // Assign variables\n    const align = alignOptions.align,\n      vAlign = alignOptions.verticalAlign;\n    // default: left align\n    x = (box.x || 0) + (alignOptions.x || 0);\n    // default: top align\n    y = (box.y || 0) + (alignOptions.y || 0);\n    // Align\n    if (align === 'right') {\n      alignFactor = 1;\n    } else if (align === 'center') {\n      alignFactor = 2;\n    }\n    if (alignFactor) {\n      x += (box.width - (alignOptions.width || 0)) / alignFactor;\n    }\n    attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);\n    // Vertical align\n    if (vAlign === 'bottom') {\n      vAlignFactor = 1;\n    } else if (vAlign === 'middle') {\n      vAlignFactor = 2;\n    }\n    if (vAlignFactor) {\n      y += (box.height - (alignOptions.height || 0)) / vAlignFactor;\n    }\n    attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);\n    // Animate only if already placed\n    this[this.placed ? 'animate' : 'attr'](attribs);\n    this.placed = true;\n    this.alignAttr = attribs;\n    return this;\n  }\n  /**\n   * @private\n   * @function Highcharts.SVGElement#alignSetter\n   * @param {\"left\"|\"center\"|\"right\"} value\n   */\n  alignSetter(value) {\n    const convert = {\n      left: 'start',\n      center: 'middle',\n      right: 'end'\n    };\n    if (convert[value]) {\n      this.alignValue = value;\n      this.element.setAttribute('text-anchor', convert[value]);\n    }\n  }\n  /**\n   * Animate to given attributes or CSS properties.\n   *\n   * @sample highcharts/members/element-on/\n   *         Setting some attributes by animation\n   *\n   * @function Highcharts.SVGElement#animate\n   *\n   * @param {Highcharts.SVGAttributes} params\n   *        SVG attributes or CSS to animate.\n   *\n   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [options]\n   *        Animation options.\n   *\n   * @param {Function} [complete]\n   *        Function to perform at the end of animation.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  animate(params, options, complete) {\n    const animOptions = animObject(pick(options, this.renderer.globalAnimation, true)),\n      deferTime = animOptions.defer;\n    // When the page is hidden save resources in the background by not\n    // running animation at all (#9749).\n    if (doc.hidden) {\n      animOptions.duration = 0;\n    }\n    if (animOptions.duration !== 0) {\n      // allows using a callback with the global animation without\n      // overwriting it\n      if (complete) {\n        animOptions.complete = complete;\n      }\n      // If defer option is defined delay the animation #12901\n      syncTimeout(() => {\n        if (this.element) {\n          animate(this, params, animOptions);\n        }\n      }, deferTime);\n    } else {\n      this.attr(params, void 0, complete || animOptions.complete);\n      // Call the end step synchronously\n      objectEach(params, function (val, prop) {\n        if (animOptions.step) {\n          animOptions.step.call(this, val, {\n            prop: prop,\n            pos: 1,\n            elem: this\n          });\n        }\n      }, this);\n    }\n    return this;\n  }\n  /**\n   * Apply a text outline through a custom CSS property, by copying the text\n   * element and apply stroke to the copy. Used internally. Contrast checks at\n   * [example](https://jsfiddle.net/highcharts/43soe9m1/2/).\n   *\n   * @example\n   * // Specific color\n   * text.css({\n   *    textOutline: '1px black'\n   * });\n   * // Automatic contrast\n   * text.css({\n   *    color: '#000000', // black text\n   *    textOutline: '1px contrast' // => white outline\n   * });\n   *\n   * @private\n   * @function Highcharts.SVGElement#applyTextOutline\n   *\n   * @param {string} textOutline\n   *        A custom CSS `text-outline` setting, defined by `width color`.\n   */\n  applyTextOutline(textOutline) {\n    const elem = this.element,\n      hasContrast = textOutline.indexOf('contrast') !== -1,\n      styles = {};\n    // When the text shadow is set to contrast, use dark stroke for light\n    // text and vice versa.\n    if (hasContrast) {\n      styles.textOutline = textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));\n    }\n    // Extract the stroke width and color\n    const parts = textOutline.split(' ');\n    const color = parts[parts.length - 1];\n    let strokeWidth = parts[0];\n    if (strokeWidth && strokeWidth !== 'none' && H.svg) {\n      this.fakeTS = true; // Fake text shadow\n      // Since the stroke is applied on center of the actual outline, we\n      // need to double it to get the correct stroke-width outside the\n      // glyphs.\n      strokeWidth = strokeWidth.replace(/(^[\\d\\.]+)(.*?)$/g, function (match, digit, unit) {\n        return 2 * Number(digit) + unit;\n      });\n      // Remove shadows from previous runs.\n      this.removeTextOutline();\n      const outline = doc.createElementNS(SVG_NS, 'tspan');\n      attr(outline, {\n        'class': 'highcharts-text-outline',\n        fill: color,\n        stroke: color,\n        'stroke-width': strokeWidth,\n        'stroke-linejoin': 'round'\n      });\n      // For each of the tspans and text nodes, create a copy in the\n      // outline.\n      const parentElem = elem.querySelector('textPath') || elem;\n      [].forEach.call(parentElem.childNodes, childNode => {\n        const clone = childNode.cloneNode(true);\n        if (clone.removeAttribute) {\n          ['fill', 'stroke', 'stroke-width', 'stroke'].forEach(prop => clone.removeAttribute(prop));\n        }\n        outline.appendChild(clone);\n      });\n      // Collect the sum of dy from all children, included nested ones\n      let totalHeight = 0;\n      [].forEach.call(parentElem.querySelectorAll('text tspan'), element => {\n        totalHeight += Number(element.getAttribute('dy'));\n      });\n      // Insert an absolutely positioned break before the original text\n      // to keep it in place\n      const br = doc.createElementNS(SVG_NS, 'tspan');\n      br.textContent = '\\u200B';\n      // Reset the position for the following text\n      attr(br, {\n        x: Number(elem.getAttribute('x')),\n        dy: -totalHeight\n      });\n      // Insert the outline\n      outline.appendChild(br);\n      parentElem.insertBefore(outline, parentElem.firstChild);\n    }\n  }\n  /**\n   * @function Highcharts.SVGElement#attr\n   * @param {string} key\n   * @return {number|string}\n   */ /**\n      * Apply native and custom attributes to the SVG elements.\n      *\n      * In order to set the rotation center for rotation, set x and y to 0 and\n      * use `translateX` and `translateY` attributes to position the element\n      * instead.\n      *\n      * Attributes frequently used in Highcharts are `fill`, `stroke`,\n      * `stroke-width`.\n      *\n      * @sample highcharts/members/renderer-rect/\n      *         Setting some attributes\n      *\n      * @example\n      * // Set multiple attributes\n      * element.attr({\n      *     stroke: 'red',\n      *     fill: 'blue',\n      *     x: 10,\n      *     y: 10\n      * });\n      *\n      * // Set a single attribute\n      * element.attr('stroke', 'red');\n      *\n      * // Get an attribute\n      * element.attr('stroke'); // => 'red'\n      *\n      * @function Highcharts.SVGElement#attr\n      *\n      * @param {string|Highcharts.SVGAttributes} [hash]\n      *        The native and custom SVG attributes.\n      *\n      * @param {number|string|Highcharts.SVGPathArray} [val]\n      *        If the type of the first argument is `string`, the second can be a\n      *        value, which will serve as a single attribute setter. If the first\n      *        argument is a string and the second is undefined, the function\n      *        serves as a getter and the current value of the property is\n      *        returned.\n      *\n      * @param {Function} [complete]\n      *        A callback function to execute after setting the attributes. This\n      *        makes the function compliant and interchangeable with the\n      *        {@link SVGElement#animate} function.\n      *\n      * @param {boolean} [continueAnimation=true]\n      *        Used internally when `.attr` is called as part of an animation\n      *        step. Otherwise, calling `.attr` for an attribute will stop\n      *        animation for that attribute.\n      *\n      * @return {Highcharts.SVGElement}\n      *         If used as a setter, it returns the current\n      *         {@link Highcharts.SVGElement} so the calls can be chained. If\n      *         used as a getter, the current value of the attribute is returned.\n      */\n  attr(hash, val, complete, continueAnimation) {\n    const element = this.element,\n      symbolCustomAttribs = SVGElement.symbolCustomAttribs;\n    let key,\n      hasSetSymbolSize,\n      ret = this,\n      skipAttr,\n      setter;\n    // single key-value pair\n    if (typeof hash === 'string' && typeof val !== 'undefined') {\n      key = hash;\n      hash = {};\n      hash[key] = val;\n    }\n    // used as a getter: first argument is a string, second is undefined\n    if (typeof hash === 'string') {\n      ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);\n      // setter\n    } else {\n      objectEach(hash, function eachAttribute(val, key) {\n        skipAttr = false;\n        // Unless .attr is from the animator update, stop current\n        // running animation of this property\n        if (!continueAnimation) {\n          stop(this, key);\n        }\n        // Special handling of symbol attributes\n        if (this.symbolName && symbolCustomAttribs.indexOf(key) !== -1) {\n          if (!hasSetSymbolSize) {\n            this.symbolAttr(hash);\n            hasSetSymbolSize = true;\n          }\n          skipAttr = true;\n        }\n        if (this.rotation && (key === 'x' || key === 'y')) {\n          this.doTransform = true;\n        }\n        if (!skipAttr) {\n          setter = this[key + 'Setter'] || this._defaultSetter;\n          setter.call(this, val, key, element);\n        }\n      }, this);\n      this.afterSetters();\n    }\n    // In accordance with animate, run a complete callback\n    if (complete) {\n      complete.call(this);\n    }\n    return ret;\n  }\n  /**\n   * Apply a clipping rectangle to this element.\n   *\n   * @function Highcharts.SVGElement#clip\n   *\n   * @param {Highcharts.ClipRectElement} [clipRect]\n   *        The clipping rectangle. If skipped, the current clip is removed.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVG element to allow chaining.\n   */\n  clip(clipRect) {\n    return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : 'none');\n  }\n  /**\n   * Calculate the coordinates needed for drawing a rectangle crisply and\n   * return the calculated attributes.\n   *\n   * @function Highcharts.SVGElement#crisp\n   *\n   * @param {Highcharts.RectangleObject} rect\n   * Rectangle to crisp.\n   *\n   * @param {number} [strokeWidth]\n   * The stroke width to consider when computing crisp positioning. It can\n   * also be set directly on the rect parameter.\n   *\n   * @return {Highcharts.RectangleObject}\n   * The modified rectangle arguments.\n   */\n  crisp(rect, strokeWidth) {\n    const wrapper = this;\n    strokeWidth = strokeWidth || rect.strokeWidth || 0;\n    // Math.round because strokeWidth can sometimes have roundoff errors\n    const normalizer = Math.round(strokeWidth) % 2 / 2;\n    // normalize for crisp edges\n    rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;\n    rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;\n    rect.width = Math.floor((rect.width || wrapper.width || 0) - 2 * normalizer);\n    rect.height = Math.floor((rect.height || wrapper.height || 0) - 2 * normalizer);\n    if (defined(rect.strokeWidth)) {\n      rect.strokeWidth = strokeWidth;\n    }\n    return rect;\n  }\n  /**\n   * Build and apply an SVG gradient out of a common JavaScript configuration\n   * object. This function is called from the attribute setters. An event\n   * hook is added for supporting other complex color types.\n   *\n   * @private\n   * @function Highcharts.SVGElement#complexColor\n   *\n   * @param {Highcharts.GradientColorObject|Highcharts.PatternObject} colorOptions\n   * The gradient or pattern options structure.\n   *\n   * @param {string} prop\n   * The property to apply, can either be `fill` or `stroke`.\n   *\n   * @param {Highcharts.SVGDOMElement} elem\n   * SVG element to apply the gradient on.\n   */\n  complexColor(colorOptions, prop, elem) {\n    const renderer = this.renderer;\n    let colorObject,\n      gradName,\n      gradAttr,\n      radAttr,\n      gradients,\n      stops,\n      stopColor,\n      stopOpacity,\n      radialReference,\n      id,\n      key = [],\n      value;\n    fireEvent(this.renderer, 'complexColor', {\n      args: arguments\n    }, function () {\n      // Apply linear or radial gradients\n      if (colorOptions.radialGradient) {\n        gradName = 'radialGradient';\n      } else if (colorOptions.linearGradient) {\n        gradName = 'linearGradient';\n      }\n      if (gradName) {\n        gradAttr = colorOptions[gradName];\n        gradients = renderer.gradients;\n        stops = colorOptions.stops;\n        radialReference = elem.radialReference;\n        // Keep < 2.2 kompatibility\n        if (isArray(gradAttr)) {\n          colorOptions[gradName] = gradAttr = {\n            x1: gradAttr[0],\n            y1: gradAttr[1],\n            x2: gradAttr[2],\n            y2: gradAttr[3],\n            gradientUnits: 'userSpaceOnUse'\n          };\n        }\n        // Correct the radial gradient for the radial reference system\n        if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {\n          // Save the radial attributes for updating\n          radAttr = gradAttr;\n          gradAttr = merge(gradAttr, renderer.getRadialAttr(radialReference, radAttr), {\n            gradientUnits: 'userSpaceOnUse'\n          });\n        }\n        // Build the unique key to detect whether we need to create a\n        // new element (#1282)\n        objectEach(gradAttr, function (value, n) {\n          if (n !== 'id') {\n            key.push(n, value);\n          }\n        });\n        objectEach(stops, function (val) {\n          key.push(val);\n        });\n        key = key.join(',');\n        // Check if a gradient object with the same config object is\n        // created within this renderer\n        if (gradients[key]) {\n          id = gradients[key].attr('id');\n        } else {\n          // Set the id and create the element\n          gradAttr.id = id = uniqueKey();\n          const gradientObject = gradients[key] = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);\n          gradientObject.radAttr = radAttr;\n          // The gradient needs to keep a list of stops to be able to\n          // destroy them\n          gradientObject.stops = [];\n          stops.forEach(function (stop) {\n            if (stop[1].indexOf('rgba') === 0) {\n              colorObject = Color.parse(stop[1]);\n              stopColor = colorObject.get('rgb');\n              stopOpacity = colorObject.get('a');\n            } else {\n              stopColor = stop[1];\n              stopOpacity = 1;\n            }\n            const stopObject = renderer.createElement('stop').attr({\n              offset: stop[0],\n              'stop-color': stopColor,\n              'stop-opacity': stopOpacity\n            }).add(gradientObject);\n            // Add the stop element to the gradient\n            gradientObject.stops.push(stopObject);\n          });\n        }\n        // Set the reference to the gradient object\n        value = 'url(' + renderer.url + '#' + id + ')';\n        elem.setAttribute(prop, value);\n        elem.gradient = key;\n        // Allow the color to be concatenated into tooltips formatters\n        // etc. (#2995)\n        colorOptions.toString = function () {\n          return value;\n        };\n      }\n    });\n  }\n  /**\n   * Set styles for the element. In addition to CSS styles supported by\n   * native SVG and HTML elements, there are also some custom made for\n   * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text\n   * elements.\n   *\n   * @sample highcharts/members/renderer-text-on-chart/\n   *         Styled text\n   *\n   * @function Highcharts.SVGElement#css\n   *\n   * @param {Highcharts.CSSObject} styles\n   *        The new CSS styles.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Return the SVG element for chaining.\n   */\n  css(styles) {\n    const oldStyles = this.styles,\n      newStyles = {},\n      elem = this.element;\n    let textWidth,\n      hasNew = !oldStyles;\n    // Filter out existing styles to increase performance (#2640)\n    if (oldStyles) {\n      objectEach(styles, function (value, n) {\n        if (oldStyles && oldStyles[n] !== value) {\n          newStyles[n] = value;\n          hasNew = true;\n        }\n      });\n    }\n    if (hasNew) {\n      // Merge the new styles with the old ones\n      if (oldStyles) {\n        styles = extend(oldStyles, newStyles);\n      }\n      // Get the text width from style\n      // Previously set, unset it (#8234)\n      if (styles.width === null || styles.width === 'auto') {\n        delete this.textWidth;\n        // Apply new\n      } else if (elem.nodeName.toLowerCase() === 'text' && styles.width) {\n        textWidth = this.textWidth = pInt(styles.width);\n      }\n      // store object\n      this.styles = styles;\n      if (textWidth && !svg && this.renderer.forExport) {\n        delete styles.width;\n      }\n      const stylesToApply = merge(styles);\n      if (elem.namespaceURI === this.SVG_NS) {\n        // These CSS properties are interpreted internally by the SVG\n        // renderer, but are not supported by SVG and should not be\n        // added to the DOM. In styled mode, no CSS should find its way\n        // to the DOM whatsoever (#6173, #6474).\n        ['textOutline', 'textOverflow', 'width'].forEach(key => stylesToApply && delete stylesToApply[key]);\n        // SVG requires fill for text\n        if (stylesToApply.color) {\n          stylesToApply.fill = stylesToApply.color;\n        }\n      }\n      css(elem, stylesToApply);\n    }\n    if (this.added) {\n      // Rebuild text after added. Cache mechanisms in the buildText will\n      // prevent building if there are no significant changes.\n      if (this.element.nodeName === 'text') {\n        this.renderer.buildText(this);\n      }\n      // Apply text outline after added\n      if (styles.textOutline) {\n        this.applyTextOutline(styles.textOutline);\n      }\n    }\n    return this;\n  }\n  /**\n   * @private\n   * @function Highcharts.SVGElement#dashstyleSetter\n   * @param {string} value\n   */\n  dashstyleSetter(value) {\n    let i,\n      strokeWidth = this['stroke-width'];\n    // If \"inherit\", like maps in IE, assume 1 (#4981). With HC5 and the new\n    // strokeWidth function, we should be able to use that instead.\n    if (strokeWidth === 'inherit') {\n      strokeWidth = 1;\n    }\n    value = value && value.toLowerCase();\n    if (value) {\n      const v = value.replace('shortdashdotdot', '3,1,1,1,1,1,').replace('shortdashdot', '3,1,1,1').replace('shortdot', '1,1,').replace('shortdash', '3,1,').replace('longdash', '8,3,').replace(/dot/g, '1,3,').replace('dash', '4,3,').replace(/,$/, '').split(','); // ending comma\n      i = v.length;\n      while (i--) {\n        v[i] = '' + pInt(v[i]) * pick(strokeWidth, NaN);\n      }\n      value = v.join(',').replace(/NaN/g, 'none'); // #3226\n      this.element.setAttribute('stroke-dasharray', value);\n    }\n  }\n  /**\n   * Destroy the element and element wrapper and clear up the DOM and event\n   * hooks.\n   *\n   * @function Highcharts.SVGElement#destroy\n   */\n  destroy() {\n    const wrapper = this,\n      element = wrapper.element || {},\n      renderer = wrapper.renderer,\n      ownerSVGElement = element.ownerSVGElement;\n    let parentToClean = element.nodeName === 'SPAN' && wrapper.parentGroup || void 0,\n      grandParent,\n      i;\n    // remove events\n    element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;\n    stop(wrapper); // stop running animations\n    if (wrapper.clipPath && ownerSVGElement) {\n      const clipPath = wrapper.clipPath;\n      // Look for existing references to this clipPath and remove them\n      // before destroying the element (#6196).\n      // The upper case version is for Edge\n      [].forEach.call(ownerSVGElement.querySelectorAll('[clip-path],[CLIP-PATH]'), function (el) {\n        if (el.getAttribute('clip-path').indexOf(clipPath.element.id) > -1) {\n          el.removeAttribute('clip-path');\n        }\n      });\n      wrapper.clipPath = clipPath.destroy();\n    }\n    wrapper.connector = wrapper.connector?.destroy();\n    // Destroy stops in case this is a gradient object @todo old code?\n    if (wrapper.stops) {\n      for (i = 0; i < wrapper.stops.length; i++) {\n        wrapper.stops[i].destroy();\n      }\n      wrapper.stops.length = 0;\n      wrapper.stops = void 0;\n    }\n    // remove element\n    wrapper.safeRemoveChild(element);\n    // In case of useHTML, clean up empty containers emulating SVG groups\n    // (#1960, #2393, #2697).\n    while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {\n      grandParent = parentToClean.parentGroup;\n      wrapper.safeRemoveChild(parentToClean.div);\n      delete parentToClean.div;\n      parentToClean = grandParent;\n    }\n    // remove from alignObjects\n    if (wrapper.alignTo) {\n      erase(renderer.alignedObjects, wrapper);\n    }\n    objectEach(wrapper, function (val, key) {\n      // Destroy child elements of a group\n      if (wrapper[key] && wrapper[key].parentGroup === wrapper && wrapper[key].destroy) {\n        wrapper[key].destroy();\n      }\n      // Delete all properties\n      delete wrapper[key];\n    });\n    return;\n  }\n  /**\n   * @private\n   * @function Highcharts.SVGElement#dSettter\n   * @param {number|string|Highcharts.SVGPathArray} value\n   * @param {string} key\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  dSetter(value, key, element) {\n    if (isArray(value)) {\n      // Backwards compatibility, convert one-dimensional array into an\n      // array of segments\n      if (typeof value[0] === 'string') {\n        value = this.renderer.pathToSegments(value);\n      }\n      this.pathArray = value;\n      value = value.reduce((acc, seg, i) => {\n        if (!seg || !seg.join) {\n          return (seg || '').toString();\n        }\n        return (i ? acc + ' ' : '') + seg.join(' ');\n      }, '');\n    }\n    if (/(NaN| {2}|^$)/.test(value)) {\n      value = 'M 0 0';\n    }\n    // Check for cache before resetting. Resetting causes disturbance in the\n    // DOM, causing flickering in some cases in Edge/IE (#6747). Also\n    // possible performance gain.\n    if (this[key] !== value) {\n      element.setAttribute(key, value);\n      this[key] = value;\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.SVGElement#fillSetter\n   * @param {Highcharts.ColorType} value\n   * @param {string} key\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  fillSetter(value, key, element) {\n    if (typeof value === 'string') {\n      element.setAttribute(key, value);\n    } else if (value) {\n      this.complexColor(value, key, element);\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.SVGElement#hrefSetter\n   * @param {Highcharts.ColorType} value\n   * @param {string} key\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  hrefSetter(value, key, element) {\n    // Namespace is needed for offline export, #19106\n    element.setAttributeNS('http://www.w3.org/1999/xlink', key, value);\n  }\n  /**\n   * Get the bounding box (width, height, x and y) for the element. Generally\n   * used to get rendered text size. Since this is called a lot in charts,\n   * the results are cached based on text properties, in order to save DOM\n   * traffic. The returned bounding box includes the rotation, so for example\n   * a single text line of rotation 90 will report a greater height, and a\n   * width corresponding to the line-height.\n   *\n   * @sample highcharts/members/renderer-on-chart/\n   *         Draw a rectangle based on a text's bounding box\n   *\n   * @function Highcharts.SVGElement#getBBox\n   *\n   * @param {boolean} [reload]\n   *        Skip the cache and get the updated DOM bouding box.\n   *\n   * @param {number} [rot]\n   *        Override the element's rotation. This is internally used on axis\n   *        labels with a value of 0 to find out what the bounding box would\n   *        be have been if it were not rotated.\n   *\n   * @return {Highcharts.BBoxObject}\n   *         The bounding box with `x`, `y`, `width` and `height` properties.\n   */\n  getBBox(reload, rot) {\n    const wrapper = this,\n      {\n        alignValue,\n        element,\n        renderer,\n        styles,\n        textStr\n      } = wrapper,\n      {\n        cache,\n        cacheKeys\n      } = renderer,\n      isSVG = element.namespaceURI === wrapper.SVG_NS,\n      rotation = pick(rot, wrapper.rotation, 0),\n      fontSize = renderer.styledMode ? element && SVGElement.prototype.getStyle.call(element, 'font-size') : styles && styles.fontSize;\n    let bBox, width, height, toggleTextShadowShim, cacheKey;\n    // Avoid undefined and null (#7316)\n    if (defined(textStr)) {\n      cacheKey = textStr.toString();\n      // Since numbers are monospaced, and numerical labels appear a lot\n      // in a chart, we assume that a label of n characters has the same\n      // bounding box as others of the same length. Unless there is inner\n      // HTML in the label. In that case, leave the numbers as is (#5899).\n      if (cacheKey.indexOf('<') === -1) {\n        cacheKey = cacheKey.replace(/[0-9]/g, '0');\n      }\n      // Properties that affect bounding box\n      cacheKey += ['', renderer.rootFontSize, fontSize, rotation, wrapper.textWidth, alignValue, styles && styles.textOverflow, styles && styles.fontWeight // #12163\n      ].join(',');\n    }\n    if (cacheKey && !reload) {\n      bBox = cache[cacheKey];\n    }\n    // No cache found\n    if (!bBox) {\n      // SVG elements\n      if (isSVG || renderer.forExport) {\n        try {\n          // Fails in Firefox if the container has display: none.\n          // When the text shadow shim is used, we need to hide the\n          // fake shadows to get the correct bounding box (#3872)\n          toggleTextShadowShim = this.fakeTS && function (display) {\n            const outline = element.querySelector('.highcharts-text-outline');\n            if (outline) {\n              css(outline, {\n                display\n              });\n            }\n          };\n          // Workaround for #3842, Firefox reporting wrong bounding\n          // box for shadows\n          if (isFunction(toggleTextShadowShim)) {\n            toggleTextShadowShim('none');\n          }\n          bBox = element.getBBox ?\n          // SVG: use extend because IE9 is not allowed to change\n          // width and height in case of rotation (below)\n          extend({}, element.getBBox()) : {\n            // HTML elements with `exporting.allowHTML` and\n            // legacy IE in export mode\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n            x: 0,\n            y: 0\n          };\n          // #3842\n          if (isFunction(toggleTextShadowShim)) {\n            toggleTextShadowShim('');\n          }\n        } catch (e) {\n          '';\n        }\n        // If the bBox is not set, the try-catch block above failed. The\n        // other condition is for Opera that returns a width of\n        // -Infinity on hidden elements.\n        if (!bBox || bBox.width < 0) {\n          bBox = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n          };\n        }\n        // useHTML within SVG\n      } else {\n        bBox = wrapper.htmlGetBBox();\n      }\n      // True SVG elements as well as HTML elements in modern browsers\n      // using the .useHTML option need to compensated for rotation\n      width = bBox.width;\n      height = bBox.height;\n      // Workaround for wrong bounding box in IE, Edge and Chrome on\n      // Windows. With Highcharts' default font, IE and Edge report\n      // a box height of 16.899 and Chrome rounds it to 17. If this\n      // stands uncorrected, it results in more padding added below\n      // the text than above when adding a label border or background.\n      // Also vertical positioning is affected.\n      // https://jsfiddle.net/highcharts/em37nvuj/\n      // (#1101, #1505, #1669, #2568, #6213).\n      if (isSVG) {\n        bBox.height = height = {\n          '11px,17': 14,\n          '13px,20': 16\n        }[`${fontSize || ''},${Math.round(height)}`] || height;\n      }\n      // Adjust for rotated text\n      if (rotation) {\n        const baseline = Number(element.getAttribute('y') || 0) - bBox.y,\n          alignFactor = {\n            'right': 1,\n            'center': 0.5\n          }[alignValue || 0] || 0,\n          rad = rotation * deg2rad,\n          rad90 = (rotation - 90) * deg2rad,\n          wCosRad = width * Math.cos(rad),\n          wSinRad = width * Math.sin(rad),\n          cosRad90 = Math.cos(rad90),\n          sinRad90 = Math.sin(rad90),\n          // Find the starting point on the left side baseline of\n          // the text\n          pX = bBox.x + alignFactor * (width - wCosRad),\n          pY = bBox.y + baseline - alignFactor * wSinRad,\n          // Find all corners\n          aX = pX + baseline * cosRad90,\n          bX = aX + wCosRad,\n          cX = bX - height * cosRad90,\n          dX = cX - wCosRad,\n          aY = pY + baseline * sinRad90,\n          bY = aY + wSinRad,\n          cY = bY - height * sinRad90,\n          dY = cY - wSinRad;\n        // Deduct the bounding box from the corners\n        bBox.x = Math.min(aX, bX, cX, dX);\n        bBox.y = Math.min(aY, bY, cY, dY);\n        bBox.width = Math.max(aX, bX, cX, dX) - bBox.x;\n        bBox.height = Math.max(aY, bY, cY, dY) - bBox.y;\n      }\n    }\n    // Cache it. When loading a chart in a hidden iframe in Firefox and\n    // IE/Edge, the bounding box height is 0, so don't cache it (#5620).\n    if (cacheKey && (textStr === '' || bBox.height > 0)) {\n      // Rotate (#4681)\n      while (cacheKeys.length > 250) {\n        delete cache[cacheKeys.shift()];\n      }\n      if (!cache[cacheKey]) {\n        cacheKeys.push(cacheKey);\n      }\n      cache[cacheKey] = bBox;\n    }\n    return bBox;\n  }\n  /**\n   * Get the computed style. Only in styled mode.\n   *\n   * @example\n   * chart.series[0].points[0].graphic.getStyle('stroke-width'); // => '1px'\n   *\n   * @function Highcharts.SVGElement#getStyle\n   *\n   * @param {string} prop\n   *        The property name to check for.\n   *\n   * @return {string}\n   *         The current computed value.\n   */\n  getStyle(prop) {\n    return win.getComputedStyle(this.element || this, '').getPropertyValue(prop);\n  }\n  /**\n   * Check if an element has the given class name.\n   *\n   * @function Highcharts.SVGElement#hasClass\n   *\n   * @param {string} className\n   * The class name to check for.\n   *\n   * @return {boolean}\n   * Whether the class name is found.\n   */\n  hasClass(className) {\n    return ('' + this.attr('class')).split(' ').indexOf(className) !== -1;\n  }\n  /**\n   * Hide the element, similar to setting the `visibility` attribute to\n   * `hidden`.\n   *\n   * @function Highcharts.SVGElement#hide\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  hide() {\n    return this.attr({\n      visibility: 'hidden'\n    });\n  }\n  /**\n   * @private\n   */\n  htmlGetBBox() {\n    return {\n      height: 0,\n      width: 0,\n      x: 0,\n      y: 0\n    };\n  }\n  /**\n   * Initialize the SVG element. This function only exists to make the\n   * initialization process overridable. It should not be called directly.\n   *\n   * @function Highcharts.SVGElement#init\n   *\n   * @param {Highcharts.SVGRenderer} renderer\n   * The SVGRenderer instance to initialize to.\n   *\n   * @param {string} nodeName\n   * The SVG node name.\n   */\n  init(renderer, nodeName) {\n    /**\n     * The primary DOM node. Each `SVGElement` instance wraps a main DOM\n     * node, but may also represent more nodes.\n     *\n     * @name Highcharts.SVGElement#element\n     * @type {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement}\n     */\n    this.element = nodeName === 'span' ? createElement(nodeName) : doc.createElementNS(this.SVG_NS, nodeName);\n    /**\n     * The renderer that the SVGElement belongs to.\n     *\n     * @name Highcharts.SVGElement#renderer\n     * @type {Highcharts.SVGRenderer}\n     */\n    this.renderer = renderer;\n    fireEvent(this, 'afterInit');\n  }\n  /**\n   * Add an event listener. This is a simple setter that replaces the\n   * previous event of the same type added by this function, as opposed to\n   * the {@link Highcharts#addEvent} function.\n   *\n   * @sample highcharts/members/element-on/\n   *         A clickable rectangle\n   *\n   * @function Highcharts.SVGElement#on\n   *\n   * @param {string} eventType\n   * The event type.\n   *\n   * @param {Function} handler\n   * The handler callback.\n   *\n   * @return {Highcharts.SVGElement}\n   * The SVGElement for chaining.\n   */\n  on(eventType, handler) {\n    const {\n      onEvents\n    } = this;\n    if (onEvents[eventType]) {\n      // Unbind existing event\n      onEvents[eventType]();\n    }\n    onEvents[eventType] = addEvent(this.element, eventType, handler);\n    return this;\n  }\n  /**\n   * @private\n   * @function Highcharts.SVGElement#opacitySetter\n   * @param {string} value\n   * @param {string} key\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  opacitySetter(value, key, element) {\n    // Round off to avoid float errors, like tests where opacity lands on\n    // 9.86957e-06 instead of 0\n    const opacity = Number(Number(value).toFixed(3));\n    this.opacity = opacity;\n    element.setAttribute(key, opacity);\n  }\n  /**\n   * Remove a class name from the element.\n   *\n   * @function Highcharts.SVGElement#removeClass\n   *\n   * @param {string|RegExp} className\n   *        The class name to remove.\n   *\n   * @return {Highcharts.SVGElement} Returns the SVG element for chainability.\n   */\n  removeClass(className) {\n    return this.attr('class', ('' + this.attr('class')).replace(isString(className) ? new RegExp(`(^| )${className}( |$)`) :\n    // #12064, #13590\n    className, ' ').replace(/ +/g, ' ').trim());\n  }\n  /**\n   *\n   * @private\n   */\n  removeTextOutline() {\n    const outline = this.element.querySelector('tspan.highcharts-text-outline');\n    if (outline) {\n      this.safeRemoveChild(outline);\n    }\n  }\n  /**\n   * Removes an element from the DOM.\n   *\n   * @private\n   * @function Highcharts.SVGElement#safeRemoveChild\n   *\n   * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element\n   * The DOM node to remove.\n   */\n  safeRemoveChild(element) {\n    const parentNode = element.parentNode;\n    if (parentNode) {\n      parentNode.removeChild(element);\n    }\n  }\n  /**\n   * Set the coordinates needed to draw a consistent radial gradient across\n   * a shape regardless of positioning inside the chart. Used on pie slices\n   * to make all the slices have the same radial reference point.\n   *\n   * @function Highcharts.SVGElement#setRadialReference\n   *\n   * @param {Array<number>} coordinates\n   * The center reference. The format is `[centerX, centerY, diameter]` in\n   * pixels.\n   *\n   * @return {Highcharts.SVGElement}\n   * Returns the SVGElement for chaining.\n   */\n  setRadialReference(coordinates) {\n    const existingGradient = this.element.gradient && this.renderer.gradients[this.element.gradient];\n    this.element.radialReference = coordinates;\n    // On redrawing objects with an existing gradient, the gradient needs\n    // to be repositioned (#3801)\n    if (existingGradient && existingGradient.radAttr) {\n      existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));\n    }\n    return this;\n  }\n  /**\n   * Set a text path for a `text` or `label` element, allowing the text to\n   * flow along a path.\n   *\n   * In order to unset the path for an existing element, call `setTextPath`\n   * with `{ enabled: false }` as the second argument.\n   *\n   * @sample highcharts/members/renderer-textpath/ Text path demonstrated\n   *\n   * @function Highcharts.SVGElement#setTextPath\n   *\n   * @param {Highcharts.SVGElement|undefined} path\n   *        Path to follow. If undefined, it allows changing options for the\n   *        existing path.\n   *\n   * @param {Highcharts.DataLabelsTextPathOptionsObject} textPathOptions\n   *        Options.\n   *\n   * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.\n   */\n  setTextPath(path, textPathOptions) {\n    // Defaults\n    textPathOptions = merge(true, {\n      enabled: true,\n      attributes: {\n        dy: -5,\n        startOffset: '50%',\n        textAnchor: 'middle'\n      }\n    }, textPathOptions);\n    const url = this.renderer.url,\n      textWrapper = this.text || this,\n      textPath = textWrapper.textPath,\n      {\n        attributes,\n        enabled\n      } = textPathOptions;\n    path = path || textPath && textPath.path;\n    // Remove previously added event\n    if (textPath) {\n      textPath.undo();\n    }\n    if (path && enabled) {\n      const undo = addEvent(textWrapper, 'afterModifyTree', e => {\n        if (path && enabled) {\n          // Set ID for the path\n          let textPathId = path.attr('id');\n          if (!textPathId) {\n            path.attr('id', textPathId = uniqueKey());\n          }\n          // Set attributes for the <text>\n          const textAttribs = {\n            // dx/dy options must by set on <text> (parent), the\n            // rest should be set on <textPath>\n            x: 0,\n            y: 0\n          };\n          if (defined(attributes.dx)) {\n            textAttribs.dx = attributes.dx;\n            delete attributes.dx;\n          }\n          if (defined(attributes.dy)) {\n            textAttribs.dy = attributes.dy;\n            delete attributes.dy;\n          }\n          textWrapper.attr(textAttribs);\n          // Handle label properties\n          this.attr({\n            transform: ''\n          });\n          if (this.box) {\n            this.box = this.box.destroy();\n          }\n          // Wrap the nodes in a textPath\n          const children = e.nodes.slice(0);\n          e.nodes.length = 0;\n          e.nodes[0] = {\n            tagName: 'textPath',\n            attributes: extend(attributes, {\n              'text-anchor': attributes.textAnchor,\n              href: `${url}#${textPathId}`\n            }),\n            children\n          };\n        }\n      });\n      // Set the reference\n      textWrapper.textPath = {\n        path,\n        undo\n      };\n    } else {\n      textWrapper.attr({\n        dx: 0,\n        dy: 0\n      });\n      delete textWrapper.textPath;\n    }\n    if (this.added) {\n      // Rebuild text after added\n      textWrapper.textCache = '';\n      this.renderer.buildText(textWrapper);\n    }\n    return this;\n  }\n  /**\n   * Add a shadow to the element. In styled mode, this method is not used,\n   * instead use `defs` and filters.\n   *\n   * @example\n   * renderer.rect(10, 100, 100, 100)\n   *     .attr({ fill: 'red' })\n   *     .shadow(true);\n   *\n   * @function Highcharts.SVGElement#shadow\n   *\n   * @param {boolean|Highcharts.ShadowOptionsObject} [shadowOptions] The\n   *        shadow options. If `true`, the default options are applied. If\n   *        `false`, the current shadow will be removed.\n   *\n   * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.\n   */\n  shadow(shadowOptions) {\n    const {\n        renderer\n      } = this,\n      options = merge(this.parentGroup?.rotation === 90 ? {\n        offsetX: -1,\n        offsetY: -1\n      } : {}, isObject(shadowOptions) ? shadowOptions : {}),\n      id = renderer.shadowDefinition(options);\n    return this.attr({\n      filter: shadowOptions ? `url(${renderer.url}#${id})` : 'none'\n    });\n  }\n  /**\n   * Show the element after it has been hidden.\n   *\n   * @function Highcharts.SVGElement#show\n   *\n   * @param {boolean} [inherit=true]\n   *        Set the visibility attribute to `inherit` rather than `visible`.\n   *        The difference is that an element with `visibility=\"visible\"`\n   *        will be visible even if the parent is hidden.\n   *\n   * @return {Highcharts.SVGElement}\n   *         Returns the SVGElement for chaining.\n   */\n  show(inherit = true) {\n    return this.attr({\n      visibility: inherit ? 'inherit' : 'visible'\n    });\n  }\n  /**\n   * Set the stroke-width and record it on the SVGElement\n   *\n   * @private\n   * @function Highcharts.SVGElement#strokeSetter\n   * @param {number|string|ColorType} value\n   * @param {string} key\n   * @param {Highcharts.SVGDOMElement} element\n   */\n  'stroke-widthSetter'(value, key, element) {\n    // Record it for quick access in getter\n    this[key] = value;\n    element.setAttribute(key, value);\n  }\n  /**\n   * Get the computed stroke width in pixel values. This is used extensively\n   * when drawing shapes to ensure the shapes are rendered crisp and\n   * positioned correctly relative to each other. Using\n   * `shape-rendering: crispEdges` leaves us less control over positioning,\n   * for example when we want to stack columns next to each other, or position\n   * things pixel-perfectly within the plot box.\n   *\n   * The common pattern when placing a shape is:\n   * - Create the SVGElement and add it to the DOM. In styled mode, it will\n   *   now receive a stroke width from the style sheet. In classic mode we\n   *   will add the `stroke-width` attribute.\n   * - Read the computed `elem.strokeWidth()`.\n   * - Place it based on the stroke width.\n   *\n   * @function Highcharts.SVGElement#strokeWidth\n   *\n   * @return {number}\n   * The stroke width in pixels. Even if the given stroke widtch (in CSS or by\n   * attributes) is based on `em` or other units, the pixel size is returned.\n   */\n  strokeWidth() {\n    // In non-styled mode, read the stroke width as set by .attr\n    if (!this.renderer.styledMode) {\n      return this['stroke-width'] || 0;\n    }\n    // In styled mode, read computed stroke width\n    const val = this.getStyle('stroke-width');\n    let ret = 0,\n      dummy;\n    // Read pixel values directly\n    if (val.indexOf('px') === val.length - 2) {\n      ret = pInt(val);\n      // Other values like em, pt etc need to be measured\n    } else if (val !== '') {\n      dummy = doc.createElementNS(SVG_NS, 'rect');\n      attr(dummy, {\n        width: val,\n        'stroke-width': 0\n      });\n      this.element.parentNode.appendChild(dummy);\n      ret = dummy.getBBox().width;\n      dummy.parentNode.removeChild(dummy);\n    }\n    return ret;\n  }\n  /**\n   * If one of the symbol size affecting parameters are changed,\n   * check all the others only once for each call to an element's\n   * .attr() method\n   *\n   * @private\n   * @function Highcharts.SVGElement#symbolAttr\n   *\n   * @param {Highcharts.SVGAttributes} hash\n   * The attributes to set.\n   */\n  symbolAttr(hash) {\n    const wrapper = this;\n    SVGElement.symbolCustomAttribs.forEach(function (key) {\n      wrapper[key] = pick(hash[key], wrapper[key]);\n    });\n    wrapper.attr({\n      d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)\n    });\n  }\n  /**\n   * @private\n   * @function Highcharts.SVGElement#textSetter\n   * @param {string} value\n   */\n  textSetter(value) {\n    if (value !== this.textStr) {\n      // Delete size caches when the text changes\n      // delete this.bBox; // old code in series-label\n      delete this.textPxLength;\n      this.textStr = value;\n      if (this.added) {\n        this.renderer.buildText(this);\n      }\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.SVGElement#titleSetter\n   * @param {string} value\n   */\n  titleSetter(value) {\n    const el = this.element;\n    const titleNode = el.getElementsByTagName('title')[0] || doc.createElementNS(this.SVG_NS, 'title');\n    // Move to first child\n    if (el.insertBefore) {\n      el.insertBefore(titleNode, el.firstChild);\n    } else {\n      el.appendChild(titleNode);\n    }\n    // Replace text content and escape markup\n    titleNode.textContent =\n    // #3276, #3895\n    String(pick(value, '')).replace(/<[^>]*>/g, '').replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n  }\n  /**\n   * Bring the element to the front. Alternatively, a new zIndex can be set.\n   *\n   * @sample highcharts/members/element-tofront/\n   *         Click an element to bring it to front\n   *\n   * @function Highcharts.SVGElement#toFront\n   *\n   * @return {Highcharts.SVGElement}\n   * Returns the SVGElement for chaining.\n   */\n  toFront() {\n    const element = this.element;\n    element.parentNode.appendChild(element);\n    return this;\n  }\n  /**\n   * Move an object and its children by x and y values.\n   *\n   * @function Highcharts.SVGElement#translate\n   *\n   * @param {number} x\n   * The x value.\n   *\n   * @param {number} y\n   * The y value.\n   *\n   * @return {Highcharts.SVGElement}\n   * Translated element.\n   */\n  translate(x, y) {\n    return this.attr({\n      translateX: x,\n      translateY: y\n    });\n  }\n  /**\n   * Update the transform attribute based on internal properties. Deals with\n   * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`\n   * attributes and updates the SVG `transform` attribute.\n   *\n   * @private\n   * @function Highcharts.SVGElement#updateTransform\n   */\n  updateTransform() {\n    const {\n      element,\n      matrix,\n      rotation = 0,\n      scaleX,\n      scaleY,\n      translateX = 0,\n      translateY = 0\n    } = this;\n    // Apply translate. Nearly all transformed elements have translation,\n    // so instead of checking for translate = 0, do it always (#1767,\n    // #1846).\n    const transform = ['translate(' + translateX + ',' + translateY + ')'];\n    // apply matrix\n    if (defined(matrix)) {\n      transform.push('matrix(' + matrix.join(',') + ')');\n    }\n    // Apply rotation\n    if (rotation) {\n      // text rotation or inverted chart\n      transform.push('rotate(' + rotation + ' ' + pick(this.rotationOriginX, element.getAttribute('x'), 0) + ' ' + pick(this.rotationOriginY, element.getAttribute('y') || 0) + ')');\n    }\n    // apply scale\n    if (defined(scaleX) || defined(scaleY)) {\n      transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');\n    }\n    if (transform.length && !(this.text || this).textPath) {\n      element.setAttribute('transform', transform.join(' '));\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.SVGElement#visibilitySetter\n   *\n   * @param {string} value\n   *\n   * @param {string} key\n   *\n   * @param {Highcharts.SVGDOMElement} element\n   *\n   */\n  visibilitySetter(value, key, element) {\n    // IE9-11 doesn't handle visibilty:inherit well, so we remove the\n    // attribute instead (#2881, #3909)\n    if (value === 'inherit') {\n      element.removeAttribute(key);\n    } else if (this[key] !== value) {\n      // #6747\n      element.setAttribute(key, value);\n    }\n    this[key] = value;\n  }\n  /**\n   * @private\n   * @function Highcharts.SVGElement#xGetter\n   */\n  xGetter(key) {\n    if (this.element.nodeName === 'circle') {\n      if (key === 'x') {\n        key = 'cx';\n      } else if (key === 'y') {\n        key = 'cy';\n      }\n    }\n    return this._defaultGetter(key);\n  }\n  /**\n   * @private\n   * @function Highcharts.SVGElement#zIndexSetter\n   */\n  zIndexSetter(value, key) {\n    const renderer = this.renderer,\n      parentGroup = this.parentGroup,\n      parentWrapper = parentGroup || renderer,\n      parentNode = parentWrapper.element || renderer.box,\n      element = this.element,\n      svgParent = parentNode === renderer.box;\n    let childNodes,\n      otherElement,\n      otherZIndex,\n      inserted = false,\n      undefinedOtherZIndex,\n      run = this.added,\n      i;\n    if (defined(value)) {\n      // So we can read it for other elements in the group\n      element.setAttribute('data-z-index', value);\n      value = +value;\n      if (this[key] === value) {\n        // Only update when needed (#3865)\n        run = false;\n      }\n    } else if (defined(this[key])) {\n      element.removeAttribute('data-z-index');\n    }\n    this[key] = value;\n    // Insert according to this and other elements' zIndex. Before .add() is\n    // called, nothing is done. Then on add, or by later calls to\n    // zIndexSetter, the node is placed on the right place in the DOM.\n    if (run) {\n      value = this.zIndex;\n      if (value && parentGroup) {\n        parentGroup.handleZ = true;\n      }\n      childNodes = parentNode.childNodes;\n      for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {\n        otherElement = childNodes[i];\n        otherZIndex = otherElement.getAttribute('data-z-index');\n        undefinedOtherZIndex = !defined(otherZIndex);\n        if (otherElement !== element) {\n          if (\n          // Negative zIndex versus no zIndex:\n          // On all levels except the highest. If the parent is\n          // <svg>, then we don't want to put items before <desc>\n          // or <defs>\n          value < 0 && undefinedOtherZIndex && !svgParent && !i) {\n            parentNode.insertBefore(element, childNodes[i]);\n            inserted = true;\n          } else if (\n          // Insert after the first element with a lower zIndex\n          pInt(otherZIndex) <= value ||\n          // If negative zIndex, add this before first undefined\n          // zIndex element\n          undefinedOtherZIndex && (!defined(value) || value >= 0)) {\n            parentNode.insertBefore(element, childNodes[i + 1]);\n            inserted = true;\n          }\n        }\n      }\n      if (!inserted) {\n        parentNode.insertBefore(element, childNodes[svgParent ? 3 : 0]);\n        inserted = true;\n      }\n    }\n    return inserted;\n  }\n}\n// Custom attributes used for symbols, these should be filtered out when\n// setting SVGElement attributes (#9375).\nSVGElement.symbolCustomAttribs = ['anchorX', 'anchorY', 'clockwise', 'end', 'height', 'innerR', 'r', 'start', 'width', 'x', 'y'];\n// Some shared setters and getters\nSVGElement.prototype.strokeSetter = SVGElement.prototype.fillSetter;\nSVGElement.prototype.yGetter = SVGElement.prototype.xGetter;\nSVGElement.prototype.matrixSetter = SVGElement.prototype.rotationOriginXSetter = SVGElement.prototype.rotationOriginYSetter = SVGElement.prototype.rotationSetter = SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = SVGElement.prototype.verticalAlignSetter = function (value, key) {\n  this[key] = value;\n  this.doTransform = true;\n};\n/* *\n *\n *  Default Export\n *\n * */\nexport default SVGElement;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Reference to the global SVGElement class as a workaround for a name conflict\n * in the Highcharts namespace.\n *\n * @global\n * @typedef {global.SVGElement} GlobalSVGElement\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGElement\n */\n/**\n * The horizontal alignment of an element.\n *\n * @typedef {\"center\"|\"left\"|\"right\"} Highcharts.AlignValue\n */\n/**\n * Options to align the element relative to the chart or another box.\n *\n * @interface Highcharts.AlignObject\n */ /**\n    * Horizontal alignment. Can be one of `left`, `center` and `right`.\n    *\n    * @name Highcharts.AlignObject#align\n    * @type {Highcharts.AlignValue|undefined}\n    *\n    * @default left\n    */ /**\n       * Vertical alignment. Can be one of `top`, `middle` and `bottom`.\n       *\n       * @name Highcharts.AlignObject#verticalAlign\n       * @type {Highcharts.VerticalAlignValue|undefined}\n       *\n       * @default top\n       */ /**\n          * Horizontal pixel offset from alignment.\n          *\n          * @name Highcharts.AlignObject#x\n          * @type {number|undefined}\n          *\n          * @default 0\n          */ /**\n             * Vertical pixel offset from alignment.\n             *\n             * @name Highcharts.AlignObject#y\n             * @type {number|undefined}\n             *\n             * @default 0\n             */ /**\n                * Use the `transform` attribute with translateX and translateY custom\n                * attributes to align this elements rather than `x` and `y` attributes.\n                *\n                * @name Highcharts.AlignObject#alignByTranslate\n                * @type {boolean|undefined}\n                *\n                * @default false\n                */\n/**\n * Bounding box of an element.\n *\n * @interface Highcharts.BBoxObject\n * @extends Highcharts.PositionObject\n */ /**\n    * Height of the bounding box.\n    *\n    * @name Highcharts.BBoxObject#height\n    * @type {number}\n    */ /**\n       * Width of the bounding box.\n       *\n       * @name Highcharts.BBoxObject#width\n       * @type {number}\n       */ /**\n          * Horizontal position of the bounding box.\n          *\n          * @name Highcharts.BBoxObject#x\n          * @type {number}\n          */ /**\n             * Vertical position of the bounding box.\n             *\n             * @name Highcharts.BBoxObject#y\n             * @type {number}\n             */\n/**\n * An object of key-value pairs for SVG attributes. Attributes in Highcharts\n * elements for the most parts correspond to SVG, but some are specific to\n * Highcharts, like `zIndex`, `rotation`, `rotationOriginX`,\n * `rotationOriginY`, `translateX`, `translateY`, `scaleX` and `scaleY`. SVG\n * attributes containing a hyphen are _not_ camel-cased, they should be\n * quoted to preserve the hyphen.\n *\n * @example\n * {\n *     'stroke': '#ff0000', // basic\n *     'stroke-width': 2, // hyphenated\n *     'rotation': 45 // custom\n *     'd': ['M', 10, 10, 'L', 30, 30, 'z'] // path definition, note format\n * }\n *\n * @interface Highcharts.SVGAttributes\n */ /**\n    * @name Highcharts.SVGAttributes#[key:string]\n    * @type {*}\n    */ /**\n       * @name Highcharts.SVGAttributes#d\n       * @type {string|Highcharts.SVGPathArray|undefined}\n       */ /**\n          * @name Highcharts.SVGAttributes#dx\n          * @type {number|undefined}\n          */ /**\n             * @name Highcharts.SVGAttributes#dy\n             * @type {number|undefined}\n             */ /**\n                * @name Highcharts.SVGAttributes#fill\n                * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject|undefined}\n                */ /**\n                   * @name Highcharts.SVGAttributes#inverted\n                   * @type {boolean|undefined}\n                   */ /**\n                      * @name Highcharts.SVGAttributes#matrix\n                      * @type {Array<number>|undefined}\n                      */ /**\n                         * @name Highcharts.SVGAttributes#rotation\n                         * @type {number|undefined}\n                         */ /**\n                            * @name Highcharts.SVGAttributes#rotationOriginX\n                            * @type {number|undefined}\n                            */ /**\n                               * @name Highcharts.SVGAttributes#rotationOriginY\n                               * @type {number|undefined}\n                               */ /**\n                                  * @name Highcharts.SVGAttributes#scaleX\n                                  * @type {number|undefined}\n                                  */ /**\n                                     * @name Highcharts.SVGAttributes#scaleY\n                                     * @type {number|undefined}\n                                     */ /**\n                                        * @name Highcharts.SVGAttributes#stroke\n                                        * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject|undefined}\n                                        */ /**\n                                           * @name Highcharts.SVGAttributes#style\n                                           * @type {string|Highcharts.CSSObject|undefined}\n                                           */ /**\n                                              * @name Highcharts.SVGAttributes#translateX\n                                              * @type {number|undefined}\n                                              */ /**\n                                                 * @name Highcharts.SVGAttributes#translateY\n                                                 * @type {number|undefined}\n                                                 */ /**\n                                                    * @name Highcharts.SVGAttributes#zIndex\n                                                    * @type {number|undefined}\n                                                    */\n/**\n * An SVG DOM element. The type is a reference to the regular SVGElement in the\n * global scope.\n *\n * @typedef {globals.GlobalSVGElement} Highcharts.SVGDOMElement\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGElement\n */\n/**\n * The vertical alignment of an element.\n *\n * @typedef {\"bottom\"|\"middle\"|\"top\"} Highcharts.VerticalAlignValue\n */\n''; // keeps doclets above in JS file","map":{"version":3,"names":["A","animate","animObject","stop","Color","H","deg2rad","doc","noop","svg","SVG_NS","win","U","addEvent","attr","createElement","css","defined","erase","extend","fireEvent","isArray","isFunction","isObject","isString","merge","objectEach","pick","pInt","syncTimeout","uniqueKey","SVGElement","constructor","element","onEvents","opacity","renderer","_defaultGetter","key","ret","getAttribute","test","parseFloat","_defaultSetter","value","setAttribute","add","parent","inserted","parentGroup","textStr","nodeName","buildText","added","handleZ","zIndex","zIndexSetter","box","appendChild","onAdd","addClass","className","replace","currentClassName","split","reduce","newClassName","name","indexOf","push","join","afterSetters","doTransform","updateTransform","align","alignOptions","alignByTranslate","attribs","alignedObjects","x","y","alignTo","alignFactor","vAlignFactor","plotBox","vAlign","verticalAlign","width","Math","round","height","placed","alignAttr","alignSetter","convert","left","center","right","alignValue","params","options","complete","animOptions","globalAnimation","deferTime","defer","hidden","duration","val","prop","step","call","pos","elem","applyTextOutline","textOutline","hasContrast","styles","getContrast","style","fill","parts","color","length","strokeWidth","fakeTS","match","digit","unit","Number","removeTextOutline","outline","createElementNS","stroke","parentElem","querySelector","forEach","childNodes","childNode","clone","cloneNode","removeAttribute","totalHeight","querySelectorAll","br","textContent","dy","insertBefore","firstChild","hash","continueAnimation","symbolCustomAttribs","hasSetSymbolSize","skipAttr","setter","eachAttribute","symbolName","symbolAttr","rotation","clip","clipRect","url","id","crisp","rect","wrapper","normalizer","floor","complexColor","colorOptions","colorObject","gradName","gradAttr","radAttr","gradients","stops","stopColor","stopOpacity","radialReference","args","arguments","radialGradient","linearGradient","x1","y1","x2","y2","gradientUnits","getRadialAttr","n","gradientObject","defs","parse","get","stopObject","offset","gradient","toString","oldStyles","newStyles","textWidth","hasNew","toLowerCase","forExport","stylesToApply","namespaceURI","dashstyleSetter","i","v","NaN","destroy","ownerSVGElement","parentToClean","grandParent","onclick","onmouseout","onmouseover","onmousemove","point","clipPath","el","connector","safeRemoveChild","div","dSetter","pathToSegments","pathArray","acc","seg","fillSetter","hrefSetter","setAttributeNS","getBBox","reload","rot","cache","cacheKeys","isSVG","fontSize","styledMode","prototype","getStyle","bBox","toggleTextShadowShim","cacheKey","rootFontSize","textOverflow","fontWeight","display","offsetWidth","offsetHeight","e","htmlGetBBox","baseline","rad","rad90","wCosRad","cos","wSinRad","sin","cosRad90","sinRad90","pX","pY","aX","bX","cX","dX","aY","bY","cY","dY","min","max","shift","getComputedStyle","getPropertyValue","hasClass","hide","visibility","init","on","eventType","handler","opacitySetter","toFixed","removeClass","RegExp","trim","parentNode","removeChild","setRadialReference","coordinates","existingGradient","setTextPath","path","textPathOptions","enabled","attributes","startOffset","textAnchor","textWrapper","text","textPath","undo","textPathId","textAttribs","dx","transform","children","nodes","slice","tagName","href","textCache","shadow","shadowOptions","offsetX","offsetY","shadowDefinition","filter","show","inherit","stroke-widthSetter","dummy","d","symbols","textSetter","textPxLength","titleSetter","titleNode","getElementsByTagName","String","toFront","translate","translateX","translateY","matrix","scaleX","scaleY","rotationOriginX","rotationOriginY","visibilitySetter","xGetter","parentWrapper","svgParent","otherElement","otherZIndex","undefinedOtherZIndex","run","strokeSetter","yGetter","matrixSetter","rotationOriginXSetter","rotationOriginYSetter","rotationSetter","scaleXSetter","scaleYSetter","translateXSetter","translateYSetter","verticalAlignSetter"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Renderer/SVG/SVGElement.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport A from '../../Animation/AnimationUtilities.js';\nconst { animate, animObject, stop } = A;\nimport Color from '../../Color/Color.js';\nimport H from '../../Globals.js';\nconst { deg2rad, doc, noop, svg, SVG_NS, win } = H;\nimport U from '../../Utilities.js';\nconst { addEvent, attr, createElement, css, defined, erase, extend, fireEvent, isArray, isFunction, isObject, isString, merge, objectEach, pick, pInt, syncTimeout, uniqueKey } = U;\n/* *\n *\n *  Class\n *\n * */\n/* eslint-disable no-invalid-this, valid-jsdoc */\n/**\n * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the\n * rendering layer of Highcharts. Combined with the\n * {@link Highcharts.SVGRenderer}\n * object, these prototypes allow freeform annotation in the charts or even in\n * HTML pages without instanciating a chart. The SVGElement can also wrap HTML\n * labels, when `text` or `label` elements are created with the `useHTML`\n * parameter.\n *\n * The SVGElement instances are created through factory functions on the\n * {@link Highcharts.SVGRenderer}\n * object, like\n * {@link Highcharts.SVGRenderer#rect|rect},\n * {@link Highcharts.SVGRenderer#path|path},\n * {@link Highcharts.SVGRenderer#text|text},\n * {@link Highcharts.SVGRenderer#label|label},\n * {@link Highcharts.SVGRenderer#g|g}\n * and more.\n *\n * @class\n * @name Highcharts.SVGElement\n */\nclass SVGElement {\n    constructor() {\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        this.element = void 0;\n        this.onEvents = {};\n        this.opacity = 1; // Default base for animation\n        this.renderer = void 0;\n        this.SVG_NS = SVG_NS;\n    }\n    // @todo public zIndex?: number;\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Get the current value of an attribute or pseudo attribute,\n     * used mainly for animation. Called internally from\n     * the {@link Highcharts.SVGRenderer#attr} function.\n     *\n     * @private\n     * @function Highcharts.SVGElement#_defaultGetter\n     *\n     * @param {string} key\n     *        Property key.\n     *\n     * @return {number|string}\n     *         Property value.\n     */\n    _defaultGetter(key) {\n        let ret = pick(this[key + 'Value'], // align getter\n        this[key], this.element ? this.element.getAttribute(key) : null, 0);\n        if (/^[\\-0-9\\.]+$/.test(ret)) { // is numerical\n            ret = parseFloat(ret);\n        }\n        return ret;\n    }\n    /**\n     * @private\n     * @function Highcharts.SVGElement#_defaultSetter\n     *\n     * @param {string} value\n     *\n     * @param {string} key\n     *\n     * @param {Highcharts.SVGDOMElement} element\n     *\n     */\n    _defaultSetter(value, key, element) {\n        element.setAttribute(key, value);\n    }\n    /**\n     * Add the element to the DOM. All elements must be added this way.\n     *\n     * @sample highcharts/members/renderer-g\n     *         Elements added to a group\n     *\n     * @function Highcharts.SVGElement#add\n     *\n     * @param {Highcharts.SVGElement} [parent]\n     *        The parent item to add it to. If undefined, the element is added\n     *        to the {@link Highcharts.SVGRenderer.box}.\n     *\n     * @return {Highcharts.SVGElement}\n     *         Returns the SVGElement for chaining.\n     */\n    add(parent) {\n        const renderer = this.renderer, element = this.element;\n        let inserted;\n        if (parent) {\n            this.parentGroup = parent;\n        }\n        // Build formatted text\n        if (typeof this.textStr !== 'undefined' &&\n            this.element.nodeName === 'text' // Not for SVGLabel instances\n        ) {\n            renderer.buildText(this);\n        }\n        // Mark as added\n        this.added = true;\n        // If we're adding to renderer root, or other elements in the group\n        // have a z index, we need to handle it\n        if (!parent || parent.handleZ || this.zIndex) {\n            inserted = this.zIndexSetter();\n        }\n        // If zIndex is not handled, append at the end\n        if (!inserted) {\n            (parent ?\n                parent.element :\n                renderer.box).appendChild(element);\n        }\n        // fire an event for internal hooks\n        if (this.onAdd) {\n            this.onAdd();\n        }\n        return this;\n    }\n    /**\n     * Add a class name to an element.\n     *\n     * @function Highcharts.SVGElement#addClass\n     *\n     * @param {string} className\n     * The new class name to add.\n     *\n     * @param {boolean} [replace=false]\n     * When true, the existing class name(s) will be overwritten with the new\n     * one. When false, the new one is added.\n     *\n     * @return {Highcharts.SVGElement}\n     * Return the SVG element for chainability.\n     */\n    addClass(className, replace) {\n        const currentClassName = replace ? '' : (this.attr('class') || '');\n        // Trim the string and remove duplicates\n        className = (className || '')\n            .split(/ /g)\n            .reduce(function (newClassName, name) {\n            if (currentClassName.indexOf(name) === -1) {\n                newClassName.push(name);\n            }\n            return newClassName;\n        }, (currentClassName ?\n            [currentClassName] :\n            []))\n            .join(' ');\n        if (className !== currentClassName) {\n            this.attr('class', className);\n        }\n        return this;\n    }\n    /**\n     * This method is executed in the end of `attr()`, after setting all\n     * attributes in the hash. In can be used to efficiently consolidate\n     * multiple attributes in one SVG property -- e.g., translate, rotate and\n     * scale are merged in one \"transform\" attribute in the SVG node.\n     *\n     * @private\n     * @function Highcharts.SVGElement#afterSetters\n     */\n    afterSetters() {\n        // Update transform. Do this outside the loop to prevent redundant\n        // updating for batch setting of attributes.\n        if (this.doTransform) {\n            this.updateTransform();\n            this.doTransform = false;\n        }\n    }\n    /**\n     * Align the element relative to the chart or another box.\n     *\n     * @function Highcharts.SVGElement#align\n     *\n     * @param {Highcharts.AlignObject} [alignOptions]\n     *        The alignment options. The function can be called without this\n     *        parameter in order to re-align an element after the box has been\n     *        updated.\n     *\n     * @param {boolean} [alignByTranslate]\n     *        Align element by translation.\n     *\n     * @param {string|Highcharts.BBoxObject} [box]\n     *        The box to align to, needs a width and height. When the box is a\n     *        string, it refers to an object in the Renderer. For example, when\n     *        box is `spacingBox`, it refers to `Renderer.spacingBox` which\n     *        holds `width`, `height`, `x` and `y` properties.\n     *\n     * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.\n     */\n    align(alignOptions, alignByTranslate, box) {\n        const attribs = {}, renderer = this.renderer, alignedObjects = renderer.alignedObjects;\n        let x, y, alignTo, alignFactor, vAlignFactor;\n        // First call on instanciate\n        if (alignOptions) {\n            this.alignOptions = alignOptions;\n            this.alignByTranslate = alignByTranslate;\n            if (!box || isString(box)) {\n                this.alignTo = alignTo = box || 'renderer';\n                // prevent duplicates, like legendGroup after resize\n                erase(alignedObjects, this);\n                alignedObjects.push(this);\n                box = void 0; // reassign it below\n            }\n            // When called on resize, no arguments are supplied\n        }\n        else {\n            alignOptions = this.alignOptions;\n            alignByTranslate = this.alignByTranslate;\n            alignTo = this.alignTo;\n        }\n        box = pick(box, renderer[alignTo], alignTo === 'scrollablePlotBox' ?\n            renderer.plotBox : void 0, renderer);\n        // Assign variables\n        const align = alignOptions.align, vAlign = alignOptions.verticalAlign;\n        // default: left align\n        x = (box.x || 0) + (alignOptions.x || 0);\n        // default: top align\n        y = (box.y || 0) + (alignOptions.y || 0);\n        // Align\n        if (align === 'right') {\n            alignFactor = 1;\n        }\n        else if (align === 'center') {\n            alignFactor = 2;\n        }\n        if (alignFactor) {\n            x += (box.width - (alignOptions.width || 0)) /\n                alignFactor;\n        }\n        attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);\n        // Vertical align\n        if (vAlign === 'bottom') {\n            vAlignFactor = 1;\n        }\n        else if (vAlign === 'middle') {\n            vAlignFactor = 2;\n        }\n        if (vAlignFactor) {\n            y += (box.height - (alignOptions.height || 0)) /\n                vAlignFactor;\n        }\n        attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);\n        // Animate only if already placed\n        this[this.placed ? 'animate' : 'attr'](attribs);\n        this.placed = true;\n        this.alignAttr = attribs;\n        return this;\n    }\n    /**\n     * @private\n     * @function Highcharts.SVGElement#alignSetter\n     * @param {\"left\"|\"center\"|\"right\"} value\n     */\n    alignSetter(value) {\n        const convert = {\n            left: 'start',\n            center: 'middle',\n            right: 'end'\n        };\n        if (convert[value]) {\n            this.alignValue = value;\n            this.element.setAttribute('text-anchor', convert[value]);\n        }\n    }\n    /**\n     * Animate to given attributes or CSS properties.\n     *\n     * @sample highcharts/members/element-on/\n     *         Setting some attributes by animation\n     *\n     * @function Highcharts.SVGElement#animate\n     *\n     * @param {Highcharts.SVGAttributes} params\n     *        SVG attributes or CSS to animate.\n     *\n     * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [options]\n     *        Animation options.\n     *\n     * @param {Function} [complete]\n     *        Function to perform at the end of animation.\n     *\n     * @return {Highcharts.SVGElement}\n     *         Returns the SVGElement for chaining.\n     */\n    animate(params, options, complete) {\n        const animOptions = animObject(pick(options, this.renderer.globalAnimation, true)), deferTime = animOptions.defer;\n        // When the page is hidden save resources in the background by not\n        // running animation at all (#9749).\n        if (doc.hidden) {\n            animOptions.duration = 0;\n        }\n        if (animOptions.duration !== 0) {\n            // allows using a callback with the global animation without\n            // overwriting it\n            if (complete) {\n                animOptions.complete = complete;\n            }\n            // If defer option is defined delay the animation #12901\n            syncTimeout(() => {\n                if (this.element) {\n                    animate(this, params, animOptions);\n                }\n            }, deferTime);\n        }\n        else {\n            this.attr(params, void 0, complete || animOptions.complete);\n            // Call the end step synchronously\n            objectEach(params, function (val, prop) {\n                if (animOptions.step) {\n                    animOptions.step.call(this, val, { prop: prop, pos: 1, elem: this });\n                }\n            }, this);\n        }\n        return this;\n    }\n    /**\n     * Apply a text outline through a custom CSS property, by copying the text\n     * element and apply stroke to the copy. Used internally. Contrast checks at\n     * [example](https://jsfiddle.net/highcharts/43soe9m1/2/).\n     *\n     * @example\n     * // Specific color\n     * text.css({\n     *    textOutline: '1px black'\n     * });\n     * // Automatic contrast\n     * text.css({\n     *    color: '#000000', // black text\n     *    textOutline: '1px contrast' // => white outline\n     * });\n     *\n     * @private\n     * @function Highcharts.SVGElement#applyTextOutline\n     *\n     * @param {string} textOutline\n     *        A custom CSS `text-outline` setting, defined by `width color`.\n     */\n    applyTextOutline(textOutline) {\n        const elem = this.element, hasContrast = textOutline.indexOf('contrast') !== -1, styles = {};\n        // When the text shadow is set to contrast, use dark stroke for light\n        // text and vice versa.\n        if (hasContrast) {\n            styles.textOutline = textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));\n        }\n        // Extract the stroke width and color\n        const parts = textOutline.split(' ');\n        const color = parts[parts.length - 1];\n        let strokeWidth = parts[0];\n        if (strokeWidth && strokeWidth !== 'none' && H.svg) {\n            this.fakeTS = true; // Fake text shadow\n            // Since the stroke is applied on center of the actual outline, we\n            // need to double it to get the correct stroke-width outside the\n            // glyphs.\n            strokeWidth = strokeWidth.replace(/(^[\\d\\.]+)(.*?)$/g, function (match, digit, unit) {\n                return (2 * Number(digit)) + unit;\n            });\n            // Remove shadows from previous runs.\n            this.removeTextOutline();\n            const outline = doc.createElementNS(SVG_NS, 'tspan');\n            attr(outline, {\n                'class': 'highcharts-text-outline',\n                fill: color,\n                stroke: color,\n                'stroke-width': strokeWidth,\n                'stroke-linejoin': 'round'\n            });\n            // For each of the tspans and text nodes, create a copy in the\n            // outline.\n            const parentElem = elem.querySelector('textPath') || elem;\n            [].forEach.call(parentElem.childNodes, (childNode) => {\n                const clone = childNode.cloneNode(true);\n                if (clone.removeAttribute) {\n                    ['fill', 'stroke', 'stroke-width', 'stroke'].forEach((prop) => clone\n                        .removeAttribute(prop));\n                }\n                outline.appendChild(clone);\n            });\n            // Collect the sum of dy from all children, included nested ones\n            let totalHeight = 0;\n            [].forEach.call(parentElem.querySelectorAll('text tspan'), (element) => {\n                totalHeight += Number(element.getAttribute('dy'));\n            });\n            // Insert an absolutely positioned break before the original text\n            // to keep it in place\n            const br = doc.createElementNS(SVG_NS, 'tspan');\n            br.textContent = '\\u200B';\n            // Reset the position for the following text\n            attr(br, {\n                x: Number(elem.getAttribute('x')),\n                dy: -totalHeight\n            });\n            // Insert the outline\n            outline.appendChild(br);\n            parentElem.insertBefore(outline, parentElem.firstChild);\n        }\n    }\n    /**\n     * @function Highcharts.SVGElement#attr\n     * @param {string} key\n     * @return {number|string}\n     */ /**\n    * Apply native and custom attributes to the SVG elements.\n    *\n    * In order to set the rotation center for rotation, set x and y to 0 and\n    * use `translateX` and `translateY` attributes to position the element\n    * instead.\n    *\n    * Attributes frequently used in Highcharts are `fill`, `stroke`,\n    * `stroke-width`.\n    *\n    * @sample highcharts/members/renderer-rect/\n    *         Setting some attributes\n    *\n    * @example\n    * // Set multiple attributes\n    * element.attr({\n    *     stroke: 'red',\n    *     fill: 'blue',\n    *     x: 10,\n    *     y: 10\n    * });\n    *\n    * // Set a single attribute\n    * element.attr('stroke', 'red');\n    *\n    * // Get an attribute\n    * element.attr('stroke'); // => 'red'\n    *\n    * @function Highcharts.SVGElement#attr\n    *\n    * @param {string|Highcharts.SVGAttributes} [hash]\n    *        The native and custom SVG attributes.\n    *\n    * @param {number|string|Highcharts.SVGPathArray} [val]\n    *        If the type of the first argument is `string`, the second can be a\n    *        value, which will serve as a single attribute setter. If the first\n    *        argument is a string and the second is undefined, the function\n    *        serves as a getter and the current value of the property is\n    *        returned.\n    *\n    * @param {Function} [complete]\n    *        A callback function to execute after setting the attributes. This\n    *        makes the function compliant and interchangeable with the\n    *        {@link SVGElement#animate} function.\n    *\n    * @param {boolean} [continueAnimation=true]\n    *        Used internally when `.attr` is called as part of an animation\n    *        step. Otherwise, calling `.attr` for an attribute will stop\n    *        animation for that attribute.\n    *\n    * @return {Highcharts.SVGElement}\n    *         If used as a setter, it returns the current\n    *         {@link Highcharts.SVGElement} so the calls can be chained. If\n    *         used as a getter, the current value of the attribute is returned.\n    */\n    attr(hash, val, complete, continueAnimation) {\n        const element = this.element, symbolCustomAttribs = SVGElement.symbolCustomAttribs;\n        let key, hasSetSymbolSize, ret = this, skipAttr, setter;\n        // single key-value pair\n        if (typeof hash === 'string' && typeof val !== 'undefined') {\n            key = hash;\n            hash = {};\n            hash[key] = val;\n        }\n        // used as a getter: first argument is a string, second is undefined\n        if (typeof hash === 'string') {\n            ret = (this[hash + 'Getter'] ||\n                this._defaultGetter).call(this, hash, element);\n            // setter\n        }\n        else {\n            objectEach(hash, function eachAttribute(val, key) {\n                skipAttr = false;\n                // Unless .attr is from the animator update, stop current\n                // running animation of this property\n                if (!continueAnimation) {\n                    stop(this, key);\n                }\n                // Special handling of symbol attributes\n                if (this.symbolName &&\n                    symbolCustomAttribs.indexOf(key) !== -1) {\n                    if (!hasSetSymbolSize) {\n                        this.symbolAttr(hash);\n                        hasSetSymbolSize = true;\n                    }\n                    skipAttr = true;\n                }\n                if (this.rotation && (key === 'x' || key === 'y')) {\n                    this.doTransform = true;\n                }\n                if (!skipAttr) {\n                    setter = (this[key + 'Setter'] ||\n                        this._defaultSetter);\n                    setter.call(this, val, key, element);\n                }\n            }, this);\n            this.afterSetters();\n        }\n        // In accordance with animate, run a complete callback\n        if (complete) {\n            complete.call(this);\n        }\n        return ret;\n    }\n    /**\n     * Apply a clipping rectangle to this element.\n     *\n     * @function Highcharts.SVGElement#clip\n     *\n     * @param {Highcharts.ClipRectElement} [clipRect]\n     *        The clipping rectangle. If skipped, the current clip is removed.\n     *\n     * @return {Highcharts.SVGElement}\n     *         Returns the SVG element to allow chaining.\n     */\n    clip(clipRect) {\n        return this.attr('clip-path', clipRect ?\n            'url(' + this.renderer.url + '#' + clipRect.id + ')' :\n            'none');\n    }\n    /**\n     * Calculate the coordinates needed for drawing a rectangle crisply and\n     * return the calculated attributes.\n     *\n     * @function Highcharts.SVGElement#crisp\n     *\n     * @param {Highcharts.RectangleObject} rect\n     * Rectangle to crisp.\n     *\n     * @param {number} [strokeWidth]\n     * The stroke width to consider when computing crisp positioning. It can\n     * also be set directly on the rect parameter.\n     *\n     * @return {Highcharts.RectangleObject}\n     * The modified rectangle arguments.\n     */\n    crisp(rect, strokeWidth) {\n        const wrapper = this;\n        strokeWidth = strokeWidth || rect.strokeWidth || 0;\n        // Math.round because strokeWidth can sometimes have roundoff errors\n        const normalizer = Math.round(strokeWidth) % 2 / 2;\n        // normalize for crisp edges\n        rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;\n        rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;\n        rect.width = Math.floor((rect.width || wrapper.width || 0) - 2 * normalizer);\n        rect.height = Math.floor((rect.height || wrapper.height || 0) - 2 * normalizer);\n        if (defined(rect.strokeWidth)) {\n            rect.strokeWidth = strokeWidth;\n        }\n        return rect;\n    }\n    /**\n     * Build and apply an SVG gradient out of a common JavaScript configuration\n     * object. This function is called from the attribute setters. An event\n     * hook is added for supporting other complex color types.\n     *\n     * @private\n     * @function Highcharts.SVGElement#complexColor\n     *\n     * @param {Highcharts.GradientColorObject|Highcharts.PatternObject} colorOptions\n     * The gradient or pattern options structure.\n     *\n     * @param {string} prop\n     * The property to apply, can either be `fill` or `stroke`.\n     *\n     * @param {Highcharts.SVGDOMElement} elem\n     * SVG element to apply the gradient on.\n     */\n    complexColor(colorOptions, prop, elem) {\n        const renderer = this.renderer;\n        let colorObject, gradName, gradAttr, radAttr, gradients, stops, stopColor, stopOpacity, radialReference, id, key = [], value;\n        fireEvent(this.renderer, 'complexColor', {\n            args: arguments\n        }, function () {\n            // Apply linear or radial gradients\n            if (colorOptions.radialGradient) {\n                gradName = 'radialGradient';\n            }\n            else if (colorOptions.linearGradient) {\n                gradName = 'linearGradient';\n            }\n            if (gradName) {\n                gradAttr = colorOptions[gradName];\n                gradients = renderer.gradients;\n                stops = colorOptions.stops;\n                radialReference = elem.radialReference;\n                // Keep < 2.2 kompatibility\n                if (isArray(gradAttr)) {\n                    colorOptions[gradName] = gradAttr = {\n                        x1: gradAttr[0],\n                        y1: gradAttr[1],\n                        x2: gradAttr[2],\n                        y2: gradAttr[3],\n                        gradientUnits: 'userSpaceOnUse'\n                    };\n                }\n                // Correct the radial gradient for the radial reference system\n                if (gradName === 'radialGradient' &&\n                    radialReference &&\n                    !defined(gradAttr.gradientUnits)) {\n                    // Save the radial attributes for updating\n                    radAttr = gradAttr;\n                    gradAttr = merge(gradAttr, renderer.getRadialAttr(radialReference, radAttr), { gradientUnits: 'userSpaceOnUse' });\n                }\n                // Build the unique key to detect whether we need to create a\n                // new element (#1282)\n                objectEach(gradAttr, function (value, n) {\n                    if (n !== 'id') {\n                        key.push(n, value);\n                    }\n                });\n                objectEach(stops, function (val) {\n                    key.push(val);\n                });\n                key = key.join(',');\n                // Check if a gradient object with the same config object is\n                // created within this renderer\n                if (gradients[key]) {\n                    id = gradients[key].attr('id');\n                }\n                else {\n                    // Set the id and create the element\n                    gradAttr.id = id = uniqueKey();\n                    const gradientObject = gradients[key] =\n                        renderer.createElement(gradName)\n                            .attr(gradAttr)\n                            .add(renderer.defs);\n                    gradientObject.radAttr = radAttr;\n                    // The gradient needs to keep a list of stops to be able to\n                    // destroy them\n                    gradientObject.stops = [];\n                    stops.forEach(function (stop) {\n                        if (stop[1].indexOf('rgba') === 0) {\n                            colorObject = Color.parse(stop[1]);\n                            stopColor = colorObject.get('rgb');\n                            stopOpacity = colorObject.get('a');\n                        }\n                        else {\n                            stopColor = stop[1];\n                            stopOpacity = 1;\n                        }\n                        const stopObject = renderer.createElement('stop').attr({\n                            offset: stop[0],\n                            'stop-color': stopColor,\n                            'stop-opacity': stopOpacity\n                        }).add(gradientObject);\n                        // Add the stop element to the gradient\n                        gradientObject.stops.push(stopObject);\n                    });\n                }\n                // Set the reference to the gradient object\n                value = 'url(' + renderer.url + '#' + id + ')';\n                elem.setAttribute(prop, value);\n                elem.gradient = key;\n                // Allow the color to be concatenated into tooltips formatters\n                // etc. (#2995)\n                colorOptions.toString = function () {\n                    return value;\n                };\n            }\n        });\n    }\n    /**\n     * Set styles for the element. In addition to CSS styles supported by\n     * native SVG and HTML elements, there are also some custom made for\n     * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text\n     * elements.\n     *\n     * @sample highcharts/members/renderer-text-on-chart/\n     *         Styled text\n     *\n     * @function Highcharts.SVGElement#css\n     *\n     * @param {Highcharts.CSSObject} styles\n     *        The new CSS styles.\n     *\n     * @return {Highcharts.SVGElement}\n     *         Return the SVG element for chaining.\n     */\n    css(styles) {\n        const oldStyles = this.styles, newStyles = {}, elem = this.element;\n        let textWidth, hasNew = !oldStyles;\n        // Filter out existing styles to increase performance (#2640)\n        if (oldStyles) {\n            objectEach(styles, function (value, n) {\n                if (oldStyles && oldStyles[n] !== value) {\n                    newStyles[n] = value;\n                    hasNew = true;\n                }\n            });\n        }\n        if (hasNew) {\n            // Merge the new styles with the old ones\n            if (oldStyles) {\n                styles = extend(oldStyles, newStyles);\n            }\n            // Get the text width from style\n            // Previously set, unset it (#8234)\n            if (styles.width === null || styles.width === 'auto') {\n                delete this.textWidth;\n                // Apply new\n            }\n            else if (elem.nodeName.toLowerCase() === 'text' &&\n                styles.width) {\n                textWidth = this.textWidth = pInt(styles.width);\n            }\n            // store object\n            this.styles = styles;\n            if (textWidth && (!svg && this.renderer.forExport)) {\n                delete styles.width;\n            }\n            const stylesToApply = merge(styles);\n            if (elem.namespaceURI === this.SVG_NS) {\n                // These CSS properties are interpreted internally by the SVG\n                // renderer, but are not supported by SVG and should not be\n                // added to the DOM. In styled mode, no CSS should find its way\n                // to the DOM whatsoever (#6173, #6474).\n                ['textOutline', 'textOverflow', 'width'].forEach((key) => (stylesToApply &&\n                    delete stylesToApply[key]));\n                // SVG requires fill for text\n                if (stylesToApply.color) {\n                    stylesToApply.fill = stylesToApply.color;\n                }\n            }\n            css(elem, stylesToApply);\n        }\n        if (this.added) {\n            // Rebuild text after added. Cache mechanisms in the buildText will\n            // prevent building if there are no significant changes.\n            if (this.element.nodeName === 'text') {\n                this.renderer.buildText(this);\n            }\n            // Apply text outline after added\n            if (styles.textOutline) {\n                this.applyTextOutline(styles.textOutline);\n            }\n        }\n        return this;\n    }\n    /**\n     * @private\n     * @function Highcharts.SVGElement#dashstyleSetter\n     * @param {string} value\n     */\n    dashstyleSetter(value) {\n        let i, strokeWidth = this['stroke-width'];\n        // If \"inherit\", like maps in IE, assume 1 (#4981). With HC5 and the new\n        // strokeWidth function, we should be able to use that instead.\n        if (strokeWidth === 'inherit') {\n            strokeWidth = 1;\n        }\n        value = value && value.toLowerCase();\n        if (value) {\n            const v = value\n                .replace('shortdashdotdot', '3,1,1,1,1,1,')\n                .replace('shortdashdot', '3,1,1,1')\n                .replace('shortdot', '1,1,')\n                .replace('shortdash', '3,1,')\n                .replace('longdash', '8,3,')\n                .replace(/dot/g, '1,3,')\n                .replace('dash', '4,3,')\n                .replace(/,$/, '')\n                .split(','); // ending comma\n            i = v.length;\n            while (i--) {\n                v[i] = '' + (pInt(v[i]) * pick(strokeWidth, NaN));\n            }\n            value = v.join(',').replace(/NaN/g, 'none'); // #3226\n            this.element.setAttribute('stroke-dasharray', value);\n        }\n    }\n    /**\n     * Destroy the element and element wrapper and clear up the DOM and event\n     * hooks.\n     *\n     * @function Highcharts.SVGElement#destroy\n     */\n    destroy() {\n        const wrapper = this, element = wrapper.element || {}, renderer = wrapper.renderer, ownerSVGElement = element.ownerSVGElement;\n        let parentToClean = (element.nodeName === 'SPAN' &&\n            wrapper.parentGroup ||\n            void 0), grandParent, i;\n        // remove events\n        element.onclick = element.onmouseout = element.onmouseover =\n            element.onmousemove = element.point = null;\n        stop(wrapper); // stop running animations\n        if (wrapper.clipPath && ownerSVGElement) {\n            const clipPath = wrapper.clipPath;\n            // Look for existing references to this clipPath and remove them\n            // before destroying the element (#6196).\n            // The upper case version is for Edge\n            [].forEach.call(ownerSVGElement.querySelectorAll('[clip-path],[CLIP-PATH]'), function (el) {\n                if (el.getAttribute('clip-path').indexOf(clipPath.element.id) > -1) {\n                    el.removeAttribute('clip-path');\n                }\n            });\n            wrapper.clipPath = clipPath.destroy();\n        }\n        wrapper.connector = wrapper.connector?.destroy();\n        // Destroy stops in case this is a gradient object @todo old code?\n        if (wrapper.stops) {\n            for (i = 0; i < wrapper.stops.length; i++) {\n                wrapper.stops[i].destroy();\n            }\n            wrapper.stops.length = 0;\n            wrapper.stops = void 0;\n        }\n        // remove element\n        wrapper.safeRemoveChild(element);\n        // In case of useHTML, clean up empty containers emulating SVG groups\n        // (#1960, #2393, #2697).\n        while (parentToClean &&\n            parentToClean.div &&\n            parentToClean.div.childNodes.length === 0) {\n            grandParent = parentToClean.parentGroup;\n            wrapper.safeRemoveChild(parentToClean.div);\n            delete parentToClean.div;\n            parentToClean = grandParent;\n        }\n        // remove from alignObjects\n        if (wrapper.alignTo) {\n            erase(renderer.alignedObjects, wrapper);\n        }\n        objectEach(wrapper, function (val, key) {\n            // Destroy child elements of a group\n            if (wrapper[key] &&\n                wrapper[key].parentGroup === wrapper &&\n                wrapper[key].destroy) {\n                wrapper[key].destroy();\n            }\n            // Delete all properties\n            delete wrapper[key];\n        });\n        return;\n    }\n    /**\n     * @private\n     * @function Highcharts.SVGElement#dSettter\n     * @param {number|string|Highcharts.SVGPathArray} value\n     * @param {string} key\n     * @param {Highcharts.SVGDOMElement} element\n     */\n    dSetter(value, key, element) {\n        if (isArray(value)) {\n            // Backwards compatibility, convert one-dimensional array into an\n            // array of segments\n            if (typeof value[0] === 'string') {\n                value = this.renderer.pathToSegments(value);\n            }\n            this.pathArray = value;\n            value = value.reduce((acc, seg, i) => {\n                if (!seg || !seg.join) {\n                    return (seg || '').toString();\n                }\n                return (i ? acc + ' ' : '') + seg.join(' ');\n            }, '');\n        }\n        if (/(NaN| {2}|^$)/.test(value)) {\n            value = 'M 0 0';\n        }\n        // Check for cache before resetting. Resetting causes disturbance in the\n        // DOM, causing flickering in some cases in Edge/IE (#6747). Also\n        // possible performance gain.\n        if (this[key] !== value) {\n            element.setAttribute(key, value);\n            this[key] = value;\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.SVGElement#fillSetter\n     * @param {Highcharts.ColorType} value\n     * @param {string} key\n     * @param {Highcharts.SVGDOMElement} element\n     */\n    fillSetter(value, key, element) {\n        if (typeof value === 'string') {\n            element.setAttribute(key, value);\n        }\n        else if (value) {\n            this.complexColor(value, key, element);\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.SVGElement#hrefSetter\n     * @param {Highcharts.ColorType} value\n     * @param {string} key\n     * @param {Highcharts.SVGDOMElement} element\n     */\n    hrefSetter(value, key, element) {\n        // Namespace is needed for offline export, #19106\n        element.setAttributeNS('http://www.w3.org/1999/xlink', key, value);\n    }\n    /**\n     * Get the bounding box (width, height, x and y) for the element. Generally\n     * used to get rendered text size. Since this is called a lot in charts,\n     * the results are cached based on text properties, in order to save DOM\n     * traffic. The returned bounding box includes the rotation, so for example\n     * a single text line of rotation 90 will report a greater height, and a\n     * width corresponding to the line-height.\n     *\n     * @sample highcharts/members/renderer-on-chart/\n     *         Draw a rectangle based on a text's bounding box\n     *\n     * @function Highcharts.SVGElement#getBBox\n     *\n     * @param {boolean} [reload]\n     *        Skip the cache and get the updated DOM bouding box.\n     *\n     * @param {number} [rot]\n     *        Override the element's rotation. This is internally used on axis\n     *        labels with a value of 0 to find out what the bounding box would\n     *        be have been if it were not rotated.\n     *\n     * @return {Highcharts.BBoxObject}\n     *         The bounding box with `x`, `y`, `width` and `height` properties.\n     */\n    getBBox(reload, rot) {\n        const wrapper = this, { alignValue, element, renderer, styles, textStr } = wrapper, { cache, cacheKeys } = renderer, isSVG = element.namespaceURI === wrapper.SVG_NS, rotation = pick(rot, wrapper.rotation, 0), fontSize = renderer.styledMode ? (element &&\n            SVGElement.prototype.getStyle.call(element, 'font-size')) : (styles && styles.fontSize);\n        let bBox, width, height, toggleTextShadowShim, cacheKey;\n        // Avoid undefined and null (#7316)\n        if (defined(textStr)) {\n            cacheKey = textStr.toString();\n            // Since numbers are monospaced, and numerical labels appear a lot\n            // in a chart, we assume that a label of n characters has the same\n            // bounding box as others of the same length. Unless there is inner\n            // HTML in the label. In that case, leave the numbers as is (#5899).\n            if (cacheKey.indexOf('<') === -1) {\n                cacheKey = cacheKey.replace(/[0-9]/g, '0');\n            }\n            // Properties that affect bounding box\n            cacheKey += [\n                '',\n                renderer.rootFontSize,\n                fontSize,\n                rotation,\n                wrapper.textWidth,\n                alignValue,\n                styles && styles.textOverflow,\n                styles && styles.fontWeight // #12163\n            ].join(',');\n        }\n        if (cacheKey && !reload) {\n            bBox = cache[cacheKey];\n        }\n        // No cache found\n        if (!bBox) {\n            // SVG elements\n            if (isSVG || renderer.forExport) {\n                try { // Fails in Firefox if the container has display: none.\n                    // When the text shadow shim is used, we need to hide the\n                    // fake shadows to get the correct bounding box (#3872)\n                    toggleTextShadowShim = this.fakeTS && function (display) {\n                        const outline = element.querySelector('.highcharts-text-outline');\n                        if (outline) {\n                            css(outline, { display });\n                        }\n                    };\n                    // Workaround for #3842, Firefox reporting wrong bounding\n                    // box for shadows\n                    if (isFunction(toggleTextShadowShim)) {\n                        toggleTextShadowShim('none');\n                    }\n                    bBox = element.getBBox ?\n                        // SVG: use extend because IE9 is not allowed to change\n                        // width and height in case of rotation (below)\n                        extend({}, element.getBBox()) : {\n                        // HTML elements with `exporting.allowHTML` and\n                        // legacy IE in export mode\n                        width: element.offsetWidth,\n                        height: element.offsetHeight,\n                        x: 0,\n                        y: 0\n                    };\n                    // #3842\n                    if (isFunction(toggleTextShadowShim)) {\n                        toggleTextShadowShim('');\n                    }\n                }\n                catch (e) {\n                    '';\n                }\n                // If the bBox is not set, the try-catch block above failed. The\n                // other condition is for Opera that returns a width of\n                // -Infinity on hidden elements.\n                if (!bBox || bBox.width < 0) {\n                    bBox = { x: 0, y: 0, width: 0, height: 0 };\n                }\n                // useHTML within SVG\n            }\n            else {\n                bBox = wrapper.htmlGetBBox();\n            }\n            // True SVG elements as well as HTML elements in modern browsers\n            // using the .useHTML option need to compensated for rotation\n            width = bBox.width;\n            height = bBox.height;\n            // Workaround for wrong bounding box in IE, Edge and Chrome on\n            // Windows. With Highcharts' default font, IE and Edge report\n            // a box height of 16.899 and Chrome rounds it to 17. If this\n            // stands uncorrected, it results in more padding added below\n            // the text than above when adding a label border or background.\n            // Also vertical positioning is affected.\n            // https://jsfiddle.net/highcharts/em37nvuj/\n            // (#1101, #1505, #1669, #2568, #6213).\n            if (isSVG) {\n                bBox.height = height = ({\n                    '11px,17': 14,\n                    '13px,20': 16\n                }[`${fontSize || ''},${Math.round(height)}`] ||\n                    height);\n            }\n            // Adjust for rotated text\n            if (rotation) {\n                const baseline = Number(element.getAttribute('y') || 0) - bBox.y, alignFactor = {\n                    'right': 1,\n                    'center': 0.5\n                }[alignValue || 0] || 0, rad = rotation * deg2rad, rad90 = (rotation - 90) * deg2rad, wCosRad = width * Math.cos(rad), wSinRad = width * Math.sin(rad), cosRad90 = Math.cos(rad90), sinRad90 = Math.sin(rad90), \n                // Find the starting point on the left side baseline of\n                // the text\n                pX = bBox.x + alignFactor * (width - wCosRad), pY = bBox.y + baseline - alignFactor * wSinRad, \n                // Find all corners\n                aX = pX + baseline * cosRad90, bX = aX + wCosRad, cX = bX - height * cosRad90, dX = cX - wCosRad, aY = pY + baseline * sinRad90, bY = aY + wSinRad, cY = bY - height * sinRad90, dY = cY - wSinRad;\n                // Deduct the bounding box from the corners\n                bBox.x = Math.min(aX, bX, cX, dX);\n                bBox.y = Math.min(aY, bY, cY, dY);\n                bBox.width = Math.max(aX, bX, cX, dX) - bBox.x;\n                bBox.height = Math.max(aY, bY, cY, dY) - bBox.y;\n            }\n        }\n        // Cache it. When loading a chart in a hidden iframe in Firefox and\n        // IE/Edge, the bounding box height is 0, so don't cache it (#5620).\n        if (cacheKey && (textStr === '' || bBox.height > 0)) {\n            // Rotate (#4681)\n            while (cacheKeys.length > 250) {\n                delete cache[cacheKeys.shift()];\n            }\n            if (!cache[cacheKey]) {\n                cacheKeys.push(cacheKey);\n            }\n            cache[cacheKey] = bBox;\n        }\n        return bBox;\n    }\n    /**\n     * Get the computed style. Only in styled mode.\n     *\n     * @example\n     * chart.series[0].points[0].graphic.getStyle('stroke-width'); // => '1px'\n     *\n     * @function Highcharts.SVGElement#getStyle\n     *\n     * @param {string} prop\n     *        The property name to check for.\n     *\n     * @return {string}\n     *         The current computed value.\n     */\n    getStyle(prop) {\n        return win\n            .getComputedStyle(this.element || this, '')\n            .getPropertyValue(prop);\n    }\n    /**\n     * Check if an element has the given class name.\n     *\n     * @function Highcharts.SVGElement#hasClass\n     *\n     * @param {string} className\n     * The class name to check for.\n     *\n     * @return {boolean}\n     * Whether the class name is found.\n     */\n    hasClass(className) {\n        return ('' + this.attr('class'))\n            .split(' ')\n            .indexOf(className) !== -1;\n    }\n    /**\n     * Hide the element, similar to setting the `visibility` attribute to\n     * `hidden`.\n     *\n     * @function Highcharts.SVGElement#hide\n     *\n     * @return {Highcharts.SVGElement}\n     *         Returns the SVGElement for chaining.\n     */\n    hide() {\n        return this.attr({ visibility: 'hidden' });\n    }\n    /**\n     * @private\n     */\n    htmlGetBBox() {\n        return { height: 0, width: 0, x: 0, y: 0 };\n    }\n    /**\n     * Initialize the SVG element. This function only exists to make the\n     * initialization process overridable. It should not be called directly.\n     *\n     * @function Highcharts.SVGElement#init\n     *\n     * @param {Highcharts.SVGRenderer} renderer\n     * The SVGRenderer instance to initialize to.\n     *\n     * @param {string} nodeName\n     * The SVG node name.\n     */\n    init(renderer, nodeName) {\n        /**\n         * The primary DOM node. Each `SVGElement` instance wraps a main DOM\n         * node, but may also represent more nodes.\n         *\n         * @name Highcharts.SVGElement#element\n         * @type {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement}\n         */\n        this.element = nodeName === 'span' ?\n            createElement(nodeName) :\n            doc.createElementNS(this.SVG_NS, nodeName);\n        /**\n         * The renderer that the SVGElement belongs to.\n         *\n         * @name Highcharts.SVGElement#renderer\n         * @type {Highcharts.SVGRenderer}\n         */\n        this.renderer = renderer;\n        fireEvent(this, 'afterInit');\n    }\n    /**\n     * Add an event listener. This is a simple setter that replaces the\n     * previous event of the same type added by this function, as opposed to\n     * the {@link Highcharts#addEvent} function.\n     *\n     * @sample highcharts/members/element-on/\n     *         A clickable rectangle\n     *\n     * @function Highcharts.SVGElement#on\n     *\n     * @param {string} eventType\n     * The event type.\n     *\n     * @param {Function} handler\n     * The handler callback.\n     *\n     * @return {Highcharts.SVGElement}\n     * The SVGElement for chaining.\n     */\n    on(eventType, handler) {\n        const { onEvents } = this;\n        if (onEvents[eventType]) {\n            // Unbind existing event\n            onEvents[eventType]();\n        }\n        onEvents[eventType] = addEvent(this.element, eventType, handler);\n        return this;\n    }\n    /**\n     * @private\n     * @function Highcharts.SVGElement#opacitySetter\n     * @param {string} value\n     * @param {string} key\n     * @param {Highcharts.SVGDOMElement} element\n     */\n    opacitySetter(value, key, element) {\n        // Round off to avoid float errors, like tests where opacity lands on\n        // 9.86957e-06 instead of 0\n        const opacity = Number(Number(value).toFixed(3));\n        this.opacity = opacity;\n        element.setAttribute(key, opacity);\n    }\n    /**\n     * Remove a class name from the element.\n     *\n     * @function Highcharts.SVGElement#removeClass\n     *\n     * @param {string|RegExp} className\n     *        The class name to remove.\n     *\n     * @return {Highcharts.SVGElement} Returns the SVG element for chainability.\n     */\n    removeClass(className) {\n        return this.attr('class', ('' + this.attr('class'))\n            .replace(isString(className) ?\n            new RegExp(`(^| )${className}( |$)`) : // #12064, #13590\n            className, ' ')\n            .replace(/ +/g, ' ')\n            .trim());\n    }\n    /**\n     *\n     * @private\n     */\n    removeTextOutline() {\n        const outline = this.element\n            .querySelector('tspan.highcharts-text-outline');\n        if (outline) {\n            this.safeRemoveChild(outline);\n        }\n    }\n    /**\n     * Removes an element from the DOM.\n     *\n     * @private\n     * @function Highcharts.SVGElement#safeRemoveChild\n     *\n     * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element\n     * The DOM node to remove.\n     */\n    safeRemoveChild(element) {\n        const parentNode = element.parentNode;\n        if (parentNode) {\n            parentNode.removeChild(element);\n        }\n    }\n    /**\n     * Set the coordinates needed to draw a consistent radial gradient across\n     * a shape regardless of positioning inside the chart. Used on pie slices\n     * to make all the slices have the same radial reference point.\n     *\n     * @function Highcharts.SVGElement#setRadialReference\n     *\n     * @param {Array<number>} coordinates\n     * The center reference. The format is `[centerX, centerY, diameter]` in\n     * pixels.\n     *\n     * @return {Highcharts.SVGElement}\n     * Returns the SVGElement for chaining.\n     */\n    setRadialReference(coordinates) {\n        const existingGradient = (this.element.gradient &&\n            this.renderer.gradients[this.element.gradient]);\n        this.element.radialReference = coordinates;\n        // On redrawing objects with an existing gradient, the gradient needs\n        // to be repositioned (#3801)\n        if (existingGradient && existingGradient.radAttr) {\n            existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));\n        }\n        return this;\n    }\n    /**\n     * Set a text path for a `text` or `label` element, allowing the text to\n     * flow along a path.\n     *\n     * In order to unset the path for an existing element, call `setTextPath`\n     * with `{ enabled: false }` as the second argument.\n     *\n     * @sample highcharts/members/renderer-textpath/ Text path demonstrated\n     *\n     * @function Highcharts.SVGElement#setTextPath\n     *\n     * @param {Highcharts.SVGElement|undefined} path\n     *        Path to follow. If undefined, it allows changing options for the\n     *        existing path.\n     *\n     * @param {Highcharts.DataLabelsTextPathOptionsObject} textPathOptions\n     *        Options.\n     *\n     * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.\n     */\n    setTextPath(path, textPathOptions) {\n        // Defaults\n        textPathOptions = merge(true, {\n            enabled: true,\n            attributes: {\n                dy: -5,\n                startOffset: '50%',\n                textAnchor: 'middle'\n            }\n        }, textPathOptions);\n        const url = this.renderer.url, textWrapper = this.text || this, textPath = textWrapper.textPath, { attributes, enabled } = textPathOptions;\n        path = path || (textPath && textPath.path);\n        // Remove previously added event\n        if (textPath) {\n            textPath.undo();\n        }\n        if (path && enabled) {\n            const undo = addEvent(textWrapper, 'afterModifyTree', (e) => {\n                if (path && enabled) {\n                    // Set ID for the path\n                    let textPathId = path.attr('id');\n                    if (!textPathId) {\n                        path.attr('id', textPathId = uniqueKey());\n                    }\n                    // Set attributes for the <text>\n                    const textAttribs = {\n                        // dx/dy options must by set on <text> (parent), the\n                        // rest should be set on <textPath>\n                        x: 0,\n                        y: 0\n                    };\n                    if (defined(attributes.dx)) {\n                        textAttribs.dx = attributes.dx;\n                        delete attributes.dx;\n                    }\n                    if (defined(attributes.dy)) {\n                        textAttribs.dy = attributes.dy;\n                        delete attributes.dy;\n                    }\n                    textWrapper.attr(textAttribs);\n                    // Handle label properties\n                    this.attr({ transform: '' });\n                    if (this.box) {\n                        this.box = this.box.destroy();\n                    }\n                    // Wrap the nodes in a textPath\n                    const children = e.nodes.slice(0);\n                    e.nodes.length = 0;\n                    e.nodes[0] = {\n                        tagName: 'textPath',\n                        attributes: extend(attributes, {\n                            'text-anchor': attributes.textAnchor,\n                            href: `${url}#${textPathId}`\n                        }),\n                        children\n                    };\n                }\n            });\n            // Set the reference\n            textWrapper.textPath = { path, undo };\n        }\n        else {\n            textWrapper.attr({ dx: 0, dy: 0 });\n            delete textWrapper.textPath;\n        }\n        if (this.added) {\n            // Rebuild text after added\n            textWrapper.textCache = '';\n            this.renderer.buildText(textWrapper);\n        }\n        return this;\n    }\n    /**\n     * Add a shadow to the element. In styled mode, this method is not used,\n     * instead use `defs` and filters.\n     *\n     * @example\n     * renderer.rect(10, 100, 100, 100)\n     *     .attr({ fill: 'red' })\n     *     .shadow(true);\n     *\n     * @function Highcharts.SVGElement#shadow\n     *\n     * @param {boolean|Highcharts.ShadowOptionsObject} [shadowOptions] The\n     *        shadow options. If `true`, the default options are applied. If\n     *        `false`, the current shadow will be removed.\n     *\n     * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.\n     */\n    shadow(shadowOptions) {\n        const { renderer } = this, options = merge(this.parentGroup?.rotation === 90 ? {\n            offsetX: -1,\n            offsetY: -1\n        } : {}, isObject(shadowOptions) ? shadowOptions : {}), id = renderer.shadowDefinition(options);\n        return this.attr({\n            filter: shadowOptions ?\n                `url(${renderer.url}#${id})` :\n                'none'\n        });\n    }\n    /**\n     * Show the element after it has been hidden.\n     *\n     * @function Highcharts.SVGElement#show\n     *\n     * @param {boolean} [inherit=true]\n     *        Set the visibility attribute to `inherit` rather than `visible`.\n     *        The difference is that an element with `visibility=\"visible\"`\n     *        will be visible even if the parent is hidden.\n     *\n     * @return {Highcharts.SVGElement}\n     *         Returns the SVGElement for chaining.\n     */\n    show(inherit = true) {\n        return this.attr({ visibility: inherit ? 'inherit' : 'visible' });\n    }\n    /**\n     * Set the stroke-width and record it on the SVGElement\n     *\n     * @private\n     * @function Highcharts.SVGElement#strokeSetter\n     * @param {number|string|ColorType} value\n     * @param {string} key\n     * @param {Highcharts.SVGDOMElement} element\n     */\n    'stroke-widthSetter'(value, key, element) {\n        // Record it for quick access in getter\n        this[key] = value;\n        element.setAttribute(key, value);\n    }\n    /**\n     * Get the computed stroke width in pixel values. This is used extensively\n     * when drawing shapes to ensure the shapes are rendered crisp and\n     * positioned correctly relative to each other. Using\n     * `shape-rendering: crispEdges` leaves us less control over positioning,\n     * for example when we want to stack columns next to each other, or position\n     * things pixel-perfectly within the plot box.\n     *\n     * The common pattern when placing a shape is:\n     * - Create the SVGElement and add it to the DOM. In styled mode, it will\n     *   now receive a stroke width from the style sheet. In classic mode we\n     *   will add the `stroke-width` attribute.\n     * - Read the computed `elem.strokeWidth()`.\n     * - Place it based on the stroke width.\n     *\n     * @function Highcharts.SVGElement#strokeWidth\n     *\n     * @return {number}\n     * The stroke width in pixels. Even if the given stroke widtch (in CSS or by\n     * attributes) is based on `em` or other units, the pixel size is returned.\n     */\n    strokeWidth() {\n        // In non-styled mode, read the stroke width as set by .attr\n        if (!this.renderer.styledMode) {\n            return this['stroke-width'] || 0;\n        }\n        // In styled mode, read computed stroke width\n        const val = this.getStyle('stroke-width');\n        let ret = 0, dummy;\n        // Read pixel values directly\n        if (val.indexOf('px') === val.length - 2) {\n            ret = pInt(val);\n            // Other values like em, pt etc need to be measured\n        }\n        else if (val !== '') {\n            dummy = doc.createElementNS(SVG_NS, 'rect');\n            attr(dummy, {\n                width: val,\n                'stroke-width': 0\n            });\n            this.element.parentNode.appendChild(dummy);\n            ret = dummy.getBBox().width;\n            dummy.parentNode.removeChild(dummy);\n        }\n        return ret;\n    }\n    /**\n     * If one of the symbol size affecting parameters are changed,\n     * check all the others only once for each call to an element's\n     * .attr() method\n     *\n     * @private\n     * @function Highcharts.SVGElement#symbolAttr\n     *\n     * @param {Highcharts.SVGAttributes} hash\n     * The attributes to set.\n     */\n    symbolAttr(hash) {\n        const wrapper = this;\n        SVGElement.symbolCustomAttribs.forEach(function (key) {\n            wrapper[key] = pick(hash[key], wrapper[key]);\n        });\n        wrapper.attr({\n            d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)\n        });\n    }\n    /**\n     * @private\n     * @function Highcharts.SVGElement#textSetter\n     * @param {string} value\n     */\n    textSetter(value) {\n        if (value !== this.textStr) {\n            // Delete size caches when the text changes\n            // delete this.bBox; // old code in series-label\n            delete this.textPxLength;\n            this.textStr = value;\n            if (this.added) {\n                this.renderer.buildText(this);\n            }\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.SVGElement#titleSetter\n     * @param {string} value\n     */\n    titleSetter(value) {\n        const el = this.element;\n        const titleNode = el.getElementsByTagName('title')[0] ||\n            doc.createElementNS(this.SVG_NS, 'title');\n        // Move to first child\n        if (el.insertBefore) {\n            el.insertBefore(titleNode, el.firstChild);\n        }\n        else {\n            el.appendChild(titleNode);\n        }\n        // Replace text content and escape markup\n        titleNode.textContent =\n            // #3276, #3895\n            String(pick(value, ''))\n                .replace(/<[^>]*>/g, '')\n                .replace(/&lt;/g, '<')\n                .replace(/&gt;/g, '>');\n    }\n    /**\n     * Bring the element to the front. Alternatively, a new zIndex can be set.\n     *\n     * @sample highcharts/members/element-tofront/\n     *         Click an element to bring it to front\n     *\n     * @function Highcharts.SVGElement#toFront\n     *\n     * @return {Highcharts.SVGElement}\n     * Returns the SVGElement for chaining.\n     */\n    toFront() {\n        const element = this.element;\n        element.parentNode.appendChild(element);\n        return this;\n    }\n    /**\n     * Move an object and its children by x and y values.\n     *\n     * @function Highcharts.SVGElement#translate\n     *\n     * @param {number} x\n     * The x value.\n     *\n     * @param {number} y\n     * The y value.\n     *\n     * @return {Highcharts.SVGElement}\n     * Translated element.\n     */\n    translate(x, y) {\n        return this.attr({\n            translateX: x,\n            translateY: y\n        });\n    }\n    /**\n     * Update the transform attribute based on internal properties. Deals with\n     * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`\n     * attributes and updates the SVG `transform` attribute.\n     *\n     * @private\n     * @function Highcharts.SVGElement#updateTransform\n     */\n    updateTransform() {\n        const { element, matrix, rotation = 0, scaleX, scaleY, translateX = 0, translateY = 0 } = this;\n        // Apply translate. Nearly all transformed elements have translation,\n        // so instead of checking for translate = 0, do it always (#1767,\n        // #1846).\n        const transform = ['translate(' + translateX + ',' + translateY + ')'];\n        // apply matrix\n        if (defined(matrix)) {\n            transform.push('matrix(' + matrix.join(',') + ')');\n        }\n        // Apply rotation\n        if (rotation) { // text rotation or inverted chart\n            transform.push('rotate(' + rotation + ' ' +\n                pick(this.rotationOriginX, element.getAttribute('x'), 0) +\n                ' ' +\n                pick(this.rotationOriginY, element.getAttribute('y') || 0) + ')');\n        }\n        // apply scale\n        if (defined(scaleX) || defined(scaleY)) {\n            transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');\n        }\n        if (transform.length && !(this.text || this).textPath) {\n            element.setAttribute('transform', transform.join(' '));\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.SVGElement#visibilitySetter\n     *\n     * @param {string} value\n     *\n     * @param {string} key\n     *\n     * @param {Highcharts.SVGDOMElement} element\n     *\n     */\n    visibilitySetter(value, key, element) {\n        // IE9-11 doesn't handle visibilty:inherit well, so we remove the\n        // attribute instead (#2881, #3909)\n        if (value === 'inherit') {\n            element.removeAttribute(key);\n        }\n        else if (this[key] !== value) { // #6747\n            element.setAttribute(key, value);\n        }\n        this[key] = value;\n    }\n    /**\n     * @private\n     * @function Highcharts.SVGElement#xGetter\n     */\n    xGetter(key) {\n        if (this.element.nodeName === 'circle') {\n            if (key === 'x') {\n                key = 'cx';\n            }\n            else if (key === 'y') {\n                key = 'cy';\n            }\n        }\n        return this._defaultGetter(key);\n    }\n    /**\n     * @private\n     * @function Highcharts.SVGElement#zIndexSetter\n     */\n    zIndexSetter(value, key) {\n        const renderer = this.renderer, parentGroup = this.parentGroup, parentWrapper = parentGroup || renderer, parentNode = parentWrapper.element || renderer.box, element = this.element, svgParent = parentNode === renderer.box;\n        let childNodes, otherElement, otherZIndex, inserted = false, undefinedOtherZIndex, run = this.added, i;\n        if (defined(value)) {\n            // So we can read it for other elements in the group\n            element.setAttribute('data-z-index', value);\n            value = +value;\n            if (this[key] === value) {\n                // Only update when needed (#3865)\n                run = false;\n            }\n        }\n        else if (defined(this[key])) {\n            element.removeAttribute('data-z-index');\n        }\n        this[key] = value;\n        // Insert according to this and other elements' zIndex. Before .add() is\n        // called, nothing is done. Then on add, or by later calls to\n        // zIndexSetter, the node is placed on the right place in the DOM.\n        if (run) {\n            value = this.zIndex;\n            if (value && parentGroup) {\n                parentGroup.handleZ = true;\n            }\n            childNodes = parentNode.childNodes;\n            for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {\n                otherElement = childNodes[i];\n                otherZIndex = otherElement.getAttribute('data-z-index');\n                undefinedOtherZIndex = !defined(otherZIndex);\n                if (otherElement !== element) {\n                    if (\n                    // Negative zIndex versus no zIndex:\n                    // On all levels except the highest. If the parent is\n                    // <svg>, then we don't want to put items before <desc>\n                    // or <defs>\n                    value < 0 &&\n                        undefinedOtherZIndex &&\n                        !svgParent &&\n                        !i) {\n                        parentNode.insertBefore(element, childNodes[i]);\n                        inserted = true;\n                    }\n                    else if (\n                    // Insert after the first element with a lower zIndex\n                    pInt(otherZIndex) <= value ||\n                        // If negative zIndex, add this before first undefined\n                        // zIndex element\n                        (undefinedOtherZIndex &&\n                            (!defined(value) || value >= 0))) {\n                        parentNode.insertBefore(element, childNodes[i + 1]);\n                        inserted = true;\n                    }\n                }\n            }\n            if (!inserted) {\n                parentNode.insertBefore(element, childNodes[svgParent ? 3 : 0]);\n                inserted = true;\n            }\n        }\n        return inserted;\n    }\n}\n// Custom attributes used for symbols, these should be filtered out when\n// setting SVGElement attributes (#9375).\nSVGElement.symbolCustomAttribs = [\n    'anchorX',\n    'anchorY',\n    'clockwise',\n    'end',\n    'height',\n    'innerR',\n    'r',\n    'start',\n    'width',\n    'x',\n    'y'\n];\n// Some shared setters and getters\nSVGElement.prototype.strokeSetter = SVGElement.prototype.fillSetter;\nSVGElement.prototype.yGetter = SVGElement.prototype.xGetter;\nSVGElement.prototype.matrixSetter =\n    SVGElement.prototype.rotationOriginXSetter =\n        SVGElement.prototype.rotationOriginYSetter =\n            SVGElement.prototype.rotationSetter =\n                SVGElement.prototype.scaleXSetter =\n                    SVGElement.prototype.scaleYSetter =\n                        SVGElement.prototype.translateXSetter =\n                            SVGElement.prototype.translateYSetter =\n                                SVGElement.prototype.verticalAlignSetter = function (value, key) {\n                                    this[key] = value;\n                                    this.doTransform = true;\n                                };\n/* *\n *\n *  Default Export\n *\n * */\nexport default SVGElement;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Reference to the global SVGElement class as a workaround for a name conflict\n * in the Highcharts namespace.\n *\n * @global\n * @typedef {global.SVGElement} GlobalSVGElement\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGElement\n */\n/**\n * The horizontal alignment of an element.\n *\n * @typedef {\"center\"|\"left\"|\"right\"} Highcharts.AlignValue\n */\n/**\n * Options to align the element relative to the chart or another box.\n *\n * @interface Highcharts.AlignObject\n */ /**\n* Horizontal alignment. Can be one of `left`, `center` and `right`.\n*\n* @name Highcharts.AlignObject#align\n* @type {Highcharts.AlignValue|undefined}\n*\n* @default left\n*/ /**\n* Vertical alignment. Can be one of `top`, `middle` and `bottom`.\n*\n* @name Highcharts.AlignObject#verticalAlign\n* @type {Highcharts.VerticalAlignValue|undefined}\n*\n* @default top\n*/ /**\n* Horizontal pixel offset from alignment.\n*\n* @name Highcharts.AlignObject#x\n* @type {number|undefined}\n*\n* @default 0\n*/ /**\n* Vertical pixel offset from alignment.\n*\n* @name Highcharts.AlignObject#y\n* @type {number|undefined}\n*\n* @default 0\n*/ /**\n* Use the `transform` attribute with translateX and translateY custom\n* attributes to align this elements rather than `x` and `y` attributes.\n*\n* @name Highcharts.AlignObject#alignByTranslate\n* @type {boolean|undefined}\n*\n* @default false\n*/\n/**\n * Bounding box of an element.\n *\n * @interface Highcharts.BBoxObject\n * @extends Highcharts.PositionObject\n */ /**\n* Height of the bounding box.\n*\n* @name Highcharts.BBoxObject#height\n* @type {number}\n*/ /**\n* Width of the bounding box.\n*\n* @name Highcharts.BBoxObject#width\n* @type {number}\n*/ /**\n* Horizontal position of the bounding box.\n*\n* @name Highcharts.BBoxObject#x\n* @type {number}\n*/ /**\n* Vertical position of the bounding box.\n*\n* @name Highcharts.BBoxObject#y\n* @type {number}\n*/\n/**\n * An object of key-value pairs for SVG attributes. Attributes in Highcharts\n * elements for the most parts correspond to SVG, but some are specific to\n * Highcharts, like `zIndex`, `rotation`, `rotationOriginX`,\n * `rotationOriginY`, `translateX`, `translateY`, `scaleX` and `scaleY`. SVG\n * attributes containing a hyphen are _not_ camel-cased, they should be\n * quoted to preserve the hyphen.\n *\n * @example\n * {\n *     'stroke': '#ff0000', // basic\n *     'stroke-width': 2, // hyphenated\n *     'rotation': 45 // custom\n *     'd': ['M', 10, 10, 'L', 30, 30, 'z'] // path definition, note format\n * }\n *\n * @interface Highcharts.SVGAttributes\n */ /**\n* @name Highcharts.SVGAttributes#[key:string]\n* @type {*}\n*/ /**\n* @name Highcharts.SVGAttributes#d\n* @type {string|Highcharts.SVGPathArray|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#dx\n* @type {number|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#dy\n* @type {number|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#fill\n* @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#inverted\n* @type {boolean|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#matrix\n* @type {Array<number>|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#rotation\n* @type {number|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#rotationOriginX\n* @type {number|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#rotationOriginY\n* @type {number|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#scaleX\n* @type {number|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#scaleY\n* @type {number|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#stroke\n* @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#style\n* @type {string|Highcharts.CSSObject|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#translateX\n* @type {number|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#translateY\n* @type {number|undefined}\n*/ /**\n* @name Highcharts.SVGAttributes#zIndex\n* @type {number|undefined}\n*/\n/**\n * An SVG DOM element. The type is a reference to the regular SVGElement in the\n * global scope.\n *\n * @typedef {globals.GlobalSVGElement} Highcharts.SVGDOMElement\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGElement\n */\n/**\n * The vertical alignment of an element.\n *\n * @typedef {\"bottom\"|\"middle\"|\"top\"} Highcharts.VerticalAlignValue\n */\n''; // keeps doclets above in JS file\n"],"mappings":"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B;IACJ;IACA,OAAOA,QAAQ;EACnB;AACJ;AACA;AACA;AACAjB,UAAU,CAACwH,mBAAmB,GAAG,CAC7B,SAAS,EACT,SAAS,EACT,WAAW,EACX,KAAK,EACL,QAAQ,EACR,QAAQ,EACR,GAAG,EACH,OAAO,EACP,OAAO,EACP,GAAG,EACH,GAAG,CACN;AACD;AACAxH,UAAU,CAACiN,SAAS,CAAC8G,YAAY,GAAG/T,UAAU,CAACiN,SAAS,CAACX,UAAU;AACnEtM,UAAU,CAACiN,SAAS,CAAC+G,OAAO,GAAGhU,UAAU,CAACiN,SAAS,CAACuG,OAAO;AAC3DxT,UAAU,CAACiN,SAAS,CAACgH,YAAY,GAC7BjU,UAAU,CAACiN,SAAS,CAACiH,qBAAqB,GACtClU,UAAU,CAACiN,SAAS,CAACkH,qBAAqB,GACtCnU,UAAU,CAACiN,SAAS,CAACmH,cAAc,GAC/BpU,UAAU,CAACiN,SAAS,CAACoH,YAAY,GAC7BrU,UAAU,CAACiN,SAAS,CAACqH,YAAY,GAC7BtU,UAAU,CAACiN,SAAS,CAACsH,gBAAgB,GACjCvU,UAAU,CAACiN,SAAS,CAACuH,gBAAgB,GACjCxU,UAAU,CAACiN,SAAS,CAACwH,mBAAmB,GAAG,UAAU5T,KAAK,EAAEN,GAAG,EAAE;EAC7D,IAAI,CAACA,GAAG,CAAC,GAAGM,KAAK;EACjB,IAAI,CAAC4B,WAAW,GAAG,IAAI;AAC3B,CAAC;AACjC;AACA;AACA;AACA;AACA;AACA,eAAezC,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAPI,CAOD;AACH;AACA;AACA;AACA;AACA;AACA;AACA,SAPG,CAOA;AACH;AACA;AACA;AACA;AACA;AACA;AACA,YAPG,CAOA;AACH;AACA;AACA;AACA;AACA;AACA;AACA,eAPG,CAOA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GALA,CAKI;AACJ;AACA;AACA;AACA;AACA,MALI,CAKD;AACH;AACA;AACA;AACA;AACA,SALG,CAKA;AACH;AACA;AACA;AACA;AACA,YALG,CAKA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAjBA,CAiBI;AACJ;AACA;AACA,MAHI,CAGD;AACH;AACA;AACA,SAHG,CAGA;AACH;AACA;AACA,YAHG,CAGA;AACH;AACA;AACA,eAHG,CAGA;AACH;AACA;AACA,kBAHG,CAGA;AACH;AACA;AACA,qBAHG,CAGA;AACH;AACA;AACA,wBAHG,CAGA;AACH;AACA;AACA,2BAHG,CAGA;AACH;AACA;AACA,8BAHG,CAGA;AACH;AACA;AACA,iCAHG,CAGA;AACH;AACA;AACA,oCAHG,CAGA;AACH;AACA;AACA,uCAHG,CAGA;AACH;AACA;AACA,0CAHG,CAGA;AACH;AACA;AACA,6CAHG,CAGA;AACH;AACA;AACA,gDAHG,CAGA;AACH;AACA;AACA,mDAHG,CAGA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}