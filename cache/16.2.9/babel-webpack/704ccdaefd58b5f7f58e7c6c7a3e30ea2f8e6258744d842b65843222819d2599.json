{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport Color from '../Color/Color.js';\nconst {\n  parse: color\n} = Color;\nimport H from '../Globals.js';\nconst {\n  win\n} = H;\nimport U from '../Utilities.js';\nconst {\n  isNumber,\n  objectEach\n} = U;\n/* eslint-disable no-invalid-this, valid-jsdoc */\n/* *\n *\n *  Class\n *\n * */\n/**\n * An animator object used internally. One instance applies to one property\n * (attribute or style prop) on one element. Animation is always initiated\n * through {@link SVGElement#animate}.\n *\n * @example\n * let rect = renderer.rect(0, 0, 10, 10).add();\n * rect.animate({ width: 100 });\n *\n * @private\n * @class\n * @name Highcharts.Fx\n *\n * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} elem\n * The element to animate.\n *\n * @param {Partial<Highcharts.AnimationOptionsObject>} options\n * Animation options.\n *\n * @param {string} prop\n * The single attribute or CSS property to animate.\n */\nclass Fx {\n  /* *\n   *\n   *  Constructors\n   *\n   * */\n  constructor(elem, options, prop) {\n    this.pos = NaN;\n    this.options = options;\n    this.elem = elem;\n    this.prop = prop;\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * Set the current step of a path definition on SVGElement.\n   *\n   * @function Highcharts.Fx#dSetter\n   *\n   */\n  dSetter() {\n    const paths = this.paths,\n      start = paths && paths[0],\n      end = paths && paths[1],\n      now = this.now || 0;\n    let path = [];\n    // Land on the final path without adjustment points appended in the ends\n    if (now === 1 || !start || !end) {\n      path = this.toD || [];\n    } else if (start.length === end.length && now < 1) {\n      for (let i = 0; i < end.length; i++) {\n        // Tween between the start segment and the end segment. Start\n        // with a copy of the end segment and tween the appropriate\n        // numerics\n        const startSeg = start[i];\n        const endSeg = end[i];\n        const tweenSeg = [];\n        for (let j = 0; j < endSeg.length; j++) {\n          const startItem = startSeg[j];\n          const endItem = endSeg[j];\n          // Tween numbers\n          if (isNumber(startItem) && isNumber(endItem) &&\n          // Arc boolean flags\n          !(endSeg[0] === 'A' && (j === 4 || j === 5))) {\n            tweenSeg[j] = startItem + now * (endItem - startItem);\n            // Strings, take directly from the end segment\n          } else {\n            tweenSeg[j] = endItem;\n          }\n        }\n        path.push(tweenSeg);\n      }\n      // If animation is finished or length not matching, land on right value\n    } else {\n      path = end;\n    }\n    this.elem.attr('d', path, void 0, true);\n  }\n  /**\n   * Update the element with the current animation step.\n   *\n   * @function Highcharts.Fx#update\n   *\n   */\n  update() {\n    const elem = this.elem,\n      prop = this.prop,\n      // if destroyed, it is null\n      now = this.now,\n      step = this.options.step;\n    // Animation setter defined from outside\n    if (this[prop + 'Setter']) {\n      this[prop + 'Setter']();\n      // Other animations on SVGElement\n    } else if (elem.attr) {\n      if (elem.element) {\n        elem.attr(prop, now, null, true);\n      }\n      // HTML styles, raw HTML content like container size\n    } else {\n      elem.style[prop] = now + this.unit;\n    }\n    if (step) {\n      step.call(elem, now, this);\n    }\n  }\n  /**\n   * Run an animation.\n   *\n   * @function Highcharts.Fx#run\n   *\n   * @param {number} from\n   *        The current value, value to start from.\n   *\n   * @param {number} to\n   *        The end value, value to land on.\n   *\n   * @param {string} unit\n   *        The property unit, for example `px`.\n   *\n   */\n  run(from, to, unit) {\n    const self = this,\n      options = self.options,\n      timer = function (gotoEnd) {\n        return timer.stopped ? false : self.step(gotoEnd);\n      },\n      requestAnimationFrame = win.requestAnimationFrame || function (step) {\n        setTimeout(step, 13);\n      },\n      step = function () {\n        for (let i = 0; i < Fx.timers.length; i++) {\n          if (!Fx.timers[i]()) {\n            Fx.timers.splice(i--, 1);\n          }\n        }\n        if (Fx.timers.length) {\n          requestAnimationFrame(step);\n        }\n      };\n    if (from === to && !this.elem['forceAnimate:' + this.prop]) {\n      delete options.curAnim[this.prop];\n      if (options.complete && Object.keys(options.curAnim).length === 0) {\n        options.complete.call(this.elem);\n      }\n    } else {\n      // #7166\n      this.startTime = +new Date();\n      this.start = from;\n      this.end = to;\n      this.unit = unit;\n      this.now = this.start;\n      this.pos = 0;\n      timer.elem = this.elem;\n      timer.prop = this.prop;\n      if (timer() && Fx.timers.push(timer) === 1) {\n        requestAnimationFrame(step);\n      }\n    }\n  }\n  /**\n   * Run a single step in the animation.\n   *\n   * @function Highcharts.Fx#step\n   *\n   * @param {boolean} [gotoEnd]\n   *        Whether to go to the endpoint of the animation after abort.\n   *\n   * @return {boolean}\n   *         Returns `true` if animation continues.\n   */\n  step(gotoEnd) {\n    const t = +new Date(),\n      options = this.options,\n      elem = this.elem,\n      complete = options.complete,\n      duration = options.duration,\n      curAnim = options.curAnim;\n    let ret, done;\n    if (!!elem.attr && !elem.element) {\n      // #2616, element is destroyed\n      ret = false;\n    } else if (gotoEnd || t >= duration + this.startTime) {\n      this.now = this.end;\n      this.pos = 1;\n      this.update();\n      curAnim[this.prop] = true;\n      done = true;\n      objectEach(curAnim, function (val) {\n        if (val !== true) {\n          done = false;\n        }\n      });\n      if (done && complete) {\n        complete.call(elem);\n      }\n      ret = false;\n    } else {\n      this.pos = options.easing((t - this.startTime) / duration);\n      this.now = this.start + (this.end - this.start) * this.pos;\n      this.update();\n      ret = true;\n    }\n    return ret;\n  }\n  /**\n   * Prepare start and end values so that the path can be animated one to one.\n   *\n   * @function Highcharts.Fx#initPath\n   *\n   * @param {Highcharts.SVGElement} elem\n   *        The SVGElement item.\n   *\n   * @param {Highcharts.SVGPathArray|undefined} fromD\n   *        Starting path definition.\n   *\n   * @param {Highcharts.SVGPathArray} toD\n   *        Ending path definition.\n   *\n   * @return {Array<Highcharts.SVGPathArray,Highcharts.SVGPathArray>}\n   *         An array containing start and end paths in array form so that\n   *         they can be animated in parallel.\n   */\n  initPath(elem, fromD, toD) {\n    const startX = elem.startX,\n      endX = elem.endX,\n      end = toD.slice(),\n      // copy\n      isArea = elem.isArea,\n      positionFactor = isArea ? 2 : 1;\n    let shift,\n      fullLength,\n      i,\n      reverse,\n      start = fromD && fromD.slice(); // copy\n    if (!start) {\n      return [end, end];\n    }\n    /**\n     * If shifting points, prepend a dummy point to the end path.\n     * @private\n     */\n    function prepend(arr, other) {\n      while (arr.length < fullLength) {\n        // Move to, line to or curve to?\n        const moveSegment = arr[0],\n          otherSegment = other[fullLength - arr.length];\n        if (otherSegment && moveSegment[0] === 'M') {\n          if (otherSegment[0] === 'C') {\n            arr[0] = ['C', moveSegment[1], moveSegment[2], moveSegment[1], moveSegment[2], moveSegment[1], moveSegment[2]];\n          } else {\n            arr[0] = ['L', moveSegment[1], moveSegment[2]];\n          }\n        }\n        // Prepend a copy of the first point\n        arr.unshift(moveSegment);\n        // For areas, the bottom path goes back again to the left, so we\n        // need to append a copy of the last point.\n        if (isArea) {\n          const z = arr.pop();\n          arr.push(arr[arr.length - 1], z); // append point and the Z\n        }\n      }\n    }\n    /**\n     * Copy and append last point until the length matches the end length.\n     * @private\n     */\n    function append(arr, other) {\n      while (arr.length < fullLength) {\n        // Pull out the slice that is going to be appended or inserted.\n        // In a line graph, the positionFactor is 1, and the last point\n        // is sliced out. In an area graph, the positionFactor is 2,\n        // causing the middle two points to be sliced out, since an area\n        // path starts at left, follows the upper path then turns and\n        // follows the bottom back.\n        const segmentToAdd = arr[Math.floor(arr.length / positionFactor) - 1].slice();\n        // Disable the first control point of curve segments\n        if (segmentToAdd[0] === 'C') {\n          segmentToAdd[1] = segmentToAdd[5];\n          segmentToAdd[2] = segmentToAdd[6];\n        }\n        if (!isArea) {\n          arr.push(segmentToAdd);\n        } else {\n          const lowerSegmentToAdd = arr[Math.floor(arr.length / positionFactor)].slice();\n          arr.splice(arr.length / 2, 0, segmentToAdd, lowerSegmentToAdd);\n        }\n      }\n    }\n    // For sideways animation, find out how much we need to shift to get the\n    // start path Xs to match the end path Xs.\n    if (startX && endX && endX.length) {\n      for (i = 0; i < startX.length; i++) {\n        // Moving left, new points coming in on right\n        if (startX[i] === endX[0]) {\n          shift = i;\n          break;\n          // Moving right\n        } else if (startX[0] === endX[endX.length - startX.length + i]) {\n          shift = i;\n          reverse = true;\n          break;\n          // Fixed from the right side, \"scaling\" left\n        } else if (startX[startX.length - 1] === endX[endX.length - startX.length + i]) {\n          shift = startX.length - i;\n          break;\n        }\n      }\n      if (typeof shift === 'undefined') {\n        start = [];\n      }\n    }\n    if (start.length && isNumber(shift)) {\n      // The common target length for the start and end array, where both\n      // arrays are padded in opposite ends\n      fullLength = end.length + shift * positionFactor;\n      if (!reverse) {\n        prepend(end, start);\n        append(start, end);\n      } else {\n        prepend(start, end);\n        append(end, start);\n      }\n    }\n    return [start, end];\n  }\n  /**\n   * Handle animation of the color attributes directly.\n   *\n   * @function Highcharts.Fx#fillSetter\n   *\n   */\n  fillSetter() {\n    Fx.prototype.strokeSetter.apply(this, arguments);\n  }\n  /**\n   * Handle animation of the color attributes directly.\n   *\n   * @function Highcharts.Fx#strokeSetter\n   *\n   */\n  strokeSetter() {\n    this.elem.attr(this.prop, color(this.start).tweenTo(color(this.end), this.pos), void 0, true);\n  }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nFx.timers = [];\n/* *\n *\n *  Default Export\n *\n * */\nexport default Fx;","map":{"version":3,"names":["Color","parse","color","H","win","U","isNumber","objectEach","Fx","constructor","elem","options","prop","pos","NaN","dSetter","paths","start","end","now","path","toD","length","i","startSeg","endSeg","tweenSeg","j","startItem","endItem","push","attr","update","step","element","style","unit","call","run","from","to","self","timer","gotoEnd","stopped","requestAnimationFrame","setTimeout","timers","splice","curAnim","complete","Object","keys","startTime","Date","t","duration","ret","done","val","easing","initPath","fromD","startX","endX","slice","isArea","positionFactor","shift","fullLength","reverse","prepend","arr","other","moveSegment","otherSegment","unshift","z","pop","append","segmentToAdd","Math","floor","lowerSegmentToAdd","fillSetter","prototype","strokeSetter","apply","arguments","tweenTo"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Animation/Fx.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport Color from '../Color/Color.js';\nconst { parse: color } = Color;\nimport H from '../Globals.js';\nconst { win } = H;\nimport U from '../Utilities.js';\nconst { isNumber, objectEach } = U;\n/* eslint-disable no-invalid-this, valid-jsdoc */\n/* *\n *\n *  Class\n *\n * */\n/**\n * An animator object used internally. One instance applies to one property\n * (attribute or style prop) on one element. Animation is always initiated\n * through {@link SVGElement#animate}.\n *\n * @example\n * let rect = renderer.rect(0, 0, 10, 10).add();\n * rect.animate({ width: 100 });\n *\n * @private\n * @class\n * @name Highcharts.Fx\n *\n * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} elem\n * The element to animate.\n *\n * @param {Partial<Highcharts.AnimationOptionsObject>} options\n * Animation options.\n *\n * @param {string} prop\n * The single attribute or CSS property to animate.\n */\nclass Fx {\n    /* *\n     *\n     *  Constructors\n     *\n     * */\n    constructor(elem, options, prop) {\n        this.pos = NaN;\n        this.options = options;\n        this.elem = elem;\n        this.prop = prop;\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Set the current step of a path definition on SVGElement.\n     *\n     * @function Highcharts.Fx#dSetter\n     *\n     */\n    dSetter() {\n        const paths = this.paths, start = paths && paths[0], end = paths && paths[1], now = this.now || 0;\n        let path = [];\n        // Land on the final path without adjustment points appended in the ends\n        if (now === 1 || !start || !end) {\n            path = this.toD || [];\n        }\n        else if (start.length === end.length && now < 1) {\n            for (let i = 0; i < end.length; i++) {\n                // Tween between the start segment and the end segment. Start\n                // with a copy of the end segment and tween the appropriate\n                // numerics\n                const startSeg = start[i];\n                const endSeg = end[i];\n                const tweenSeg = [];\n                for (let j = 0; j < endSeg.length; j++) {\n                    const startItem = startSeg[j];\n                    const endItem = endSeg[j];\n                    // Tween numbers\n                    if (isNumber(startItem) &&\n                        isNumber(endItem) &&\n                        // Arc boolean flags\n                        !(endSeg[0] === 'A' && (j === 4 || j === 5))) {\n                        tweenSeg[j] = startItem + now * (endItem - startItem);\n                        // Strings, take directly from the end segment\n                    }\n                    else {\n                        tweenSeg[j] = endItem;\n                    }\n                }\n                path.push(tweenSeg);\n            }\n            // If animation is finished or length not matching, land on right value\n        }\n        else {\n            path = end;\n        }\n        this.elem.attr('d', path, void 0, true);\n    }\n    /**\n     * Update the element with the current animation step.\n     *\n     * @function Highcharts.Fx#update\n     *\n     */\n    update() {\n        const elem = this.elem, prop = this.prop, // if destroyed, it is null\n        now = this.now, step = this.options.step;\n        // Animation setter defined from outside\n        if (this[prop + 'Setter']) {\n            this[prop + 'Setter']();\n            // Other animations on SVGElement\n        }\n        else if (elem.attr) {\n            if (elem.element) {\n                elem.attr(prop, now, null, true);\n            }\n            // HTML styles, raw HTML content like container size\n        }\n        else {\n            elem.style[prop] = now + this.unit;\n        }\n        if (step) {\n            step.call(elem, now, this);\n        }\n    }\n    /**\n     * Run an animation.\n     *\n     * @function Highcharts.Fx#run\n     *\n     * @param {number} from\n     *        The current value, value to start from.\n     *\n     * @param {number} to\n     *        The end value, value to land on.\n     *\n     * @param {string} unit\n     *        The property unit, for example `px`.\n     *\n     */\n    run(from, to, unit) {\n        const self = this, options = self.options, timer = function (gotoEnd) {\n            return timer.stopped ? false : self.step(gotoEnd);\n        }, requestAnimationFrame = win.requestAnimationFrame ||\n            function (step) {\n                setTimeout(step, 13);\n            }, step = function () {\n            for (let i = 0; i < Fx.timers.length; i++) {\n                if (!Fx.timers[i]()) {\n                    Fx.timers.splice(i--, 1);\n                }\n            }\n            if (Fx.timers.length) {\n                requestAnimationFrame(step);\n            }\n        };\n        if (from === to && !this.elem['forceAnimate:' + this.prop]) {\n            delete options.curAnim[this.prop];\n            if (options.complete &&\n                Object.keys(options.curAnim).length === 0) {\n                options.complete.call(this.elem);\n            }\n        }\n        else { // #7166\n            this.startTime = +new Date();\n            this.start = from;\n            this.end = to;\n            this.unit = unit;\n            this.now = this.start;\n            this.pos = 0;\n            timer.elem = this.elem;\n            timer.prop = this.prop;\n            if (timer() && Fx.timers.push(timer) === 1) {\n                requestAnimationFrame(step);\n            }\n        }\n    }\n    /**\n     * Run a single step in the animation.\n     *\n     * @function Highcharts.Fx#step\n     *\n     * @param {boolean} [gotoEnd]\n     *        Whether to go to the endpoint of the animation after abort.\n     *\n     * @return {boolean}\n     *         Returns `true` if animation continues.\n     */\n    step(gotoEnd) {\n        const t = +new Date(), options = this.options, elem = this.elem, complete = options.complete, duration = options.duration, curAnim = options.curAnim;\n        let ret, done;\n        if (!!elem.attr && !elem.element) { // #2616, element is destroyed\n            ret = false;\n        }\n        else if (gotoEnd || t >= duration + this.startTime) {\n            this.now = this.end;\n            this.pos = 1;\n            this.update();\n            curAnim[this.prop] = true;\n            done = true;\n            objectEach(curAnim, function (val) {\n                if (val !== true) {\n                    done = false;\n                }\n            });\n            if (done && complete) {\n                complete.call(elem);\n            }\n            ret = false;\n        }\n        else {\n            this.pos = options.easing((t - this.startTime) / duration);\n            this.now = this.start + ((this.end -\n                this.start) * this.pos);\n            this.update();\n            ret = true;\n        }\n        return ret;\n    }\n    /**\n     * Prepare start and end values so that the path can be animated one to one.\n     *\n     * @function Highcharts.Fx#initPath\n     *\n     * @param {Highcharts.SVGElement} elem\n     *        The SVGElement item.\n     *\n     * @param {Highcharts.SVGPathArray|undefined} fromD\n     *        Starting path definition.\n     *\n     * @param {Highcharts.SVGPathArray} toD\n     *        Ending path definition.\n     *\n     * @return {Array<Highcharts.SVGPathArray,Highcharts.SVGPathArray>}\n     *         An array containing start and end paths in array form so that\n     *         they can be animated in parallel.\n     */\n    initPath(elem, fromD, toD) {\n        const startX = elem.startX, endX = elem.endX, end = toD.slice(), // copy\n        isArea = elem.isArea, positionFactor = isArea ? 2 : 1;\n        let shift, fullLength, i, reverse, start = fromD && fromD.slice(); // copy\n        if (!start) {\n            return [end, end];\n        }\n        /**\n         * If shifting points, prepend a dummy point to the end path.\n         * @private\n         */\n        function prepend(arr, other) {\n            while (arr.length < fullLength) {\n                // Move to, line to or curve to?\n                const moveSegment = arr[0], otherSegment = other[fullLength - arr.length];\n                if (otherSegment && moveSegment[0] === 'M') {\n                    if (otherSegment[0] === 'C') {\n                        arr[0] = [\n                            'C',\n                            moveSegment[1],\n                            moveSegment[2],\n                            moveSegment[1],\n                            moveSegment[2],\n                            moveSegment[1],\n                            moveSegment[2]\n                        ];\n                    }\n                    else {\n                        arr[0] = ['L', moveSegment[1], moveSegment[2]];\n                    }\n                }\n                // Prepend a copy of the first point\n                arr.unshift(moveSegment);\n                // For areas, the bottom path goes back again to the left, so we\n                // need to append a copy of the last point.\n                if (isArea) {\n                    const z = arr.pop();\n                    arr.push(arr[arr.length - 1], z); // append point and the Z\n                }\n            }\n        }\n        /**\n         * Copy and append last point until the length matches the end length.\n         * @private\n         */\n        function append(arr, other) {\n            while (arr.length < fullLength) {\n                // Pull out the slice that is going to be appended or inserted.\n                // In a line graph, the positionFactor is 1, and the last point\n                // is sliced out. In an area graph, the positionFactor is 2,\n                // causing the middle two points to be sliced out, since an area\n                // path starts at left, follows the upper path then turns and\n                // follows the bottom back.\n                const segmentToAdd = arr[Math.floor(arr.length / positionFactor) - 1].slice();\n                // Disable the first control point of curve segments\n                if (segmentToAdd[0] === 'C') {\n                    segmentToAdd[1] = segmentToAdd[5];\n                    segmentToAdd[2] = segmentToAdd[6];\n                }\n                if (!isArea) {\n                    arr.push(segmentToAdd);\n                }\n                else {\n                    const lowerSegmentToAdd = arr[Math.floor(arr.length / positionFactor)].slice();\n                    arr.splice(arr.length / 2, 0, segmentToAdd, lowerSegmentToAdd);\n                }\n            }\n        }\n        // For sideways animation, find out how much we need to shift to get the\n        // start path Xs to match the end path Xs.\n        if (startX && endX && endX.length) {\n            for (i = 0; i < startX.length; i++) {\n                // Moving left, new points coming in on right\n                if (startX[i] === endX[0]) {\n                    shift = i;\n                    break;\n                    // Moving right\n                }\n                else if (startX[0] ===\n                    endX[endX.length - startX.length + i]) {\n                    shift = i;\n                    reverse = true;\n                    break;\n                    // Fixed from the right side, \"scaling\" left\n                }\n                else if (startX[startX.length - 1] ===\n                    endX[endX.length - startX.length + i]) {\n                    shift = startX.length - i;\n                    break;\n                }\n            }\n            if (typeof shift === 'undefined') {\n                start = [];\n            }\n        }\n        if (start.length && isNumber(shift)) {\n            // The common target length for the start and end array, where both\n            // arrays are padded in opposite ends\n            fullLength = end.length + shift * positionFactor;\n            if (!reverse) {\n                prepend(end, start);\n                append(start, end);\n            }\n            else {\n                prepend(start, end);\n                append(end, start);\n            }\n        }\n        return [start, end];\n    }\n    /**\n     * Handle animation of the color attributes directly.\n     *\n     * @function Highcharts.Fx#fillSetter\n     *\n     */\n    fillSetter() {\n        Fx.prototype.strokeSetter.apply(this, arguments);\n    }\n    /**\n     * Handle animation of the color attributes directly.\n     *\n     * @function Highcharts.Fx#strokeSetter\n     *\n     */\n    strokeSetter() {\n        this.elem.attr(this.prop, color(this.start).tweenTo(color(this.end), this.pos), void 0, true);\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\nFx.timers = [];\n/* *\n *\n *  Default Export\n *\n * */\nexport default Fx;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}