{"ast":null,"code":"/* *\n *\n *  Highcharts module to hide overlapping data labels.\n *  This module is included in Highcharts.\n *\n *  (c) 2009-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport U from '../Core/Utilities.js';\nconst {\n  addEvent,\n  fireEvent,\n  isNumber,\n  objectEach,\n  pick,\n  pushUnique\n} = U;\n/* *\n *\n *  Constants\n *\n * */\nconst composedMembers = [];\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Hide overlapping labels. Labels are moved and faded in and out on zoom to\n * provide a smooth visual imression.\n *\n * @requires modules/overlapping-datalabels\n *\n * @private\n * @function Highcharts.Chart#hideOverlappingLabels\n * @param {Array<Highcharts.SVGElement>} labels\n *        Rendered data labels\n */\nfunction chartHideOverlappingLabels(labels) {\n  const chart = this,\n    len = labels.length,\n    ren = chart.renderer,\n    isIntersectRect = (box1, box2) => !(box2.x >= box1.x + box1.width || box2.x + box2.width <= box1.x || box2.y >= box1.y + box1.height || box2.y + box2.height <= box1.y),\n    // Get the box with its position inside the chart, as opposed to getBBox\n    // that only reports the position relative to the parent.\n    getAbsoluteBox = label => {\n      const padding = label.box ? 0 : label.padding || 0;\n      let pos,\n        parent,\n        bBox,\n        // Substract the padding if no background or border (#4333)\n        lineHeightCorrection = 0,\n        xOffset = 0,\n        boxWidth,\n        alignValue;\n      if (label && (!label.alignAttr || label.placed)) {\n        pos = label.alignAttr || {\n          x: label.attr('x'),\n          y: label.attr('y')\n        };\n        parent = label.parentGroup;\n        // Get width and height if pure text nodes (stack labels)\n        if (!label.width) {\n          bBox = label.getBBox();\n          label.width = bBox.width;\n          label.height = bBox.height;\n          // Labels positions are computed from top left corner, so we\n          // need to substract the text height from text nodes too.\n          lineHeightCorrection = ren.fontMetrics(label.element).h;\n        }\n        boxWidth = label.width - 2 * padding;\n        alignValue = {\n          left: '0',\n          center: '0.5',\n          right: '1'\n        }[label.alignValue];\n        if (alignValue) {\n          xOffset = +alignValue * boxWidth;\n        } else if (isNumber(label.x) && Math.round(label.x) !== label.translateX) {\n          xOffset = label.x - (label.translateX || 0);\n        }\n        return {\n          x: pos.x + (parent.translateX || 0) + padding - (xOffset || 0),\n          y: pos.y + (parent.translateY || 0) + padding - lineHeightCorrection,\n          width: label.width - 2 * padding,\n          height: (label.height || 0) - 2 * padding\n        };\n      }\n    };\n  let label,\n    label1,\n    label2,\n    box1,\n    box2,\n    isLabelAffected = false;\n  for (let i = 0; i < len; i++) {\n    label = labels[i];\n    if (label) {\n      // Mark with initial opacity\n      label.oldOpacity = label.opacity;\n      label.newOpacity = 1;\n      label.absoluteBox = getAbsoluteBox(label);\n    }\n  }\n  // Prevent a situation in a gradually rising slope, that each label will\n  // hide the previous one because the previous one always has lower rank.\n  labels.sort((a, b) => (b.labelrank || 0) - (a.labelrank || 0));\n  // Detect overlapping labels\n  for (let i = 0; i < len; ++i) {\n    label1 = labels[i];\n    box1 = label1 && label1.absoluteBox;\n    for (let j = i + 1; j < len; ++j) {\n      label2 = labels[j];\n      box2 = label2 && label2.absoluteBox;\n      if (box1 && box2 && label1 !== label2 &&\n      // #6465, polar chart with connectEnds\n      label1.newOpacity !== 0 && label2.newOpacity !== 0 &&\n      // #15863 dataLabels are no longer hidden by translation\n      label1.visibility !== 'hidden' && label2.visibility !== 'hidden') {\n        if (isIntersectRect(box1, box2)) {\n          (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;\n        }\n      }\n    }\n  }\n  // Hide or show\n  for (const label of labels) {\n    if (hideOrShow(label, chart)) {\n      isLabelAffected = true;\n    }\n  }\n  if (isLabelAffected) {\n    fireEvent(chart, 'afterHideAllOverlappingLabels');\n  }\n}\n/** @private */\nfunction compose(ChartClass) {\n  if (pushUnique(composedMembers, ChartClass)) {\n    const chartProto = ChartClass.prototype;\n    chartProto.hideOverlappingLabels = chartHideOverlappingLabels;\n    addEvent(ChartClass, 'render', onChartRender);\n  }\n}\n/**\n * Hide or show labels based on opacity.\n *\n * @private\n * @function hideOrShow\n * @param {Highcharts.SVGElement} label\n * The label.\n * @param {Highcharts.Chart} chart\n * The chart that contains the label.\n * @return {boolean}\n * Whether label is affected\n */\nfunction hideOrShow(label, chart) {\n  let complete,\n    newOpacity,\n    isLabelAffected = false;\n  if (label) {\n    newOpacity = label.newOpacity;\n    if (label.oldOpacity !== newOpacity) {\n      // Make sure the label is completely hidden to avoid catching clicks\n      // (#4362)\n      if (label.alignAttr && label.placed) {\n        // data labels\n        label[newOpacity ? 'removeClass' : 'addClass']('highcharts-data-label-hidden');\n        complete = function () {\n          if (!chart.styledMode) {\n            label.css({\n              pointerEvents: newOpacity ? 'auto' : 'none'\n            });\n          }\n        };\n        isLabelAffected = true;\n        // Animate or set the opacity\n        label.alignAttr.opacity = newOpacity;\n        label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);\n        fireEvent(chart, 'afterHideOverlappingLabel');\n      } else {\n        // other labels, tick labels\n        label.attr({\n          opacity: newOpacity\n        });\n      }\n    }\n    label.isOld = true;\n  }\n  return isLabelAffected;\n}\n/**\n * Collect potensial overlapping data labels. Stack labels probably don't need\n * to be considered because they are usually accompanied by data labels that lie\n * inside the columns.\n * @private\n */\nfunction onChartRender() {\n  const chart = this;\n  let labels = [];\n  // Consider external label collectors\n  for (const collector of chart.labelCollectors || []) {\n    labels = labels.concat(collector());\n  }\n  for (const yAxis of chart.yAxis || []) {\n    if (yAxis.stacking && yAxis.options.stackLabels && !yAxis.options.stackLabels.allowOverlap) {\n      objectEach(yAxis.stacking.stacks, stack => {\n        objectEach(stack, stackItem => {\n          if (stackItem.label) {\n            labels.push(stackItem.label);\n          }\n        });\n      });\n    }\n  }\n  for (const series of chart.series || []) {\n    if (series.visible && series.hasDataLabels?.()) {\n      // #3866\n      const push = points => {\n        for (const point of points) {\n          if (point.visible) {\n            (point.dataLabels || []).forEach(label => {\n              const options = label.options || {};\n              label.labelrank = pick(options.labelrank, point.labelrank, point.shapeArgs?.height); // #4118\n              // Allow overlap if the option is explicitly true\n              if (\n              // #13449\n              options.allowOverlap ??\n              // Pie labels outside have a separate placement\n              // logic, skip the overlap logic\n              Number(options.distance) > 0) {\n                label.oldOpacity = label.opacity;\n                label.newOpacity = 1;\n                hideOrShow(label, chart);\n                // Do not allow overlap\n              } else {\n                labels.push(label);\n              }\n            });\n          }\n        }\n      };\n      push(series.nodes || []);\n      push(series.points);\n    }\n  }\n  this.hideOverlappingLabels(labels);\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst OverlappingDataLabels = {\n  compose\n};\nexport default OverlappingDataLabels;","map":{"version":3,"names":["U","addEvent","fireEvent","isNumber","objectEach","pick","pushUnique","composedMembers","chartHideOverlappingLabels","labels","chart","len","length","ren","renderer","isIntersectRect","box1","box2","x","width","y","height","getAbsoluteBox","label","padding","box","pos","parent","bBox","lineHeightCorrection","xOffset","boxWidth","alignValue","alignAttr","placed","attr","parentGroup","getBBox","fontMetrics","element","h","left","center","right","Math","round","translateX","translateY","label1","label2","isLabelAffected","i","oldOpacity","opacity","newOpacity","absoluteBox","sort","a","b","labelrank","j","visibility","hideOrShow","compose","ChartClass","chartProto","prototype","hideOverlappingLabels","onChartRender","complete","styledMode","css","pointerEvents","isOld","collector","labelCollectors","concat","yAxis","stacking","options","stackLabels","allowOverlap","stacks","stack","stackItem","push","series","visible","hasDataLabels","points","point","dataLabels","forEach","shapeArgs","Number","distance","nodes","OverlappingDataLabels"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Extensions/OverlappingDataLabels.js"],"sourcesContent":["/* *\n *\n *  Highcharts module to hide overlapping data labels.\n *  This module is included in Highcharts.\n *\n *  (c) 2009-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport U from '../Core/Utilities.js';\nconst { addEvent, fireEvent, isNumber, objectEach, pick, pushUnique } = U;\n/* *\n *\n *  Constants\n *\n * */\nconst composedMembers = [];\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Hide overlapping labels. Labels are moved and faded in and out on zoom to\n * provide a smooth visual imression.\n *\n * @requires modules/overlapping-datalabels\n *\n * @private\n * @function Highcharts.Chart#hideOverlappingLabels\n * @param {Array<Highcharts.SVGElement>} labels\n *        Rendered data labels\n */\nfunction chartHideOverlappingLabels(labels) {\n    const chart = this, len = labels.length, ren = chart.renderer, isIntersectRect = (box1, box2) => !(box2.x >= box1.x + box1.width ||\n        box2.x + box2.width <= box1.x ||\n        box2.y >= box1.y + box1.height ||\n        box2.y + box2.height <= box1.y), \n    // Get the box with its position inside the chart, as opposed to getBBox\n    // that only reports the position relative to the parent.\n    getAbsoluteBox = (label) => {\n        const padding = label.box ? 0 : (label.padding || 0);\n        let pos, parent, bBox, \n        // Substract the padding if no background or border (#4333)\n        lineHeightCorrection = 0, xOffset = 0, boxWidth, alignValue;\n        if (label &&\n            (!label.alignAttr || label.placed)) {\n            pos = label.alignAttr || {\n                x: label.attr('x'),\n                y: label.attr('y')\n            };\n            parent = label.parentGroup;\n            // Get width and height if pure text nodes (stack labels)\n            if (!label.width) {\n                bBox = label.getBBox();\n                label.width = bBox.width;\n                label.height = bBox.height;\n                // Labels positions are computed from top left corner, so we\n                // need to substract the text height from text nodes too.\n                lineHeightCorrection = ren.fontMetrics(label.element).h;\n            }\n            boxWidth = label.width - 2 * padding;\n            alignValue = {\n                left: '0',\n                center: '0.5',\n                right: '1'\n            }[label.alignValue];\n            if (alignValue) {\n                xOffset = +alignValue * boxWidth;\n            }\n            else if (isNumber(label.x) &&\n                Math.round(label.x) !== label.translateX) {\n                xOffset = label.x - (label.translateX || 0);\n            }\n            return {\n                x: pos.x + (parent.translateX || 0) + padding -\n                    (xOffset || 0),\n                y: pos.y + (parent.translateY || 0) + padding -\n                    lineHeightCorrection,\n                width: label.width - 2 * padding,\n                height: (label.height || 0) - 2 * padding\n            };\n        }\n    };\n    let label, label1, label2, box1, box2, isLabelAffected = false;\n    for (let i = 0; i < len; i++) {\n        label = labels[i];\n        if (label) {\n            // Mark with initial opacity\n            label.oldOpacity = label.opacity;\n            label.newOpacity = 1;\n            label.absoluteBox = getAbsoluteBox(label);\n        }\n    }\n    // Prevent a situation in a gradually rising slope, that each label will\n    // hide the previous one because the previous one always has lower rank.\n    labels.sort((a, b) => (b.labelrank || 0) - (a.labelrank || 0));\n    // Detect overlapping labels\n    for (let i = 0; i < len; ++i) {\n        label1 = labels[i];\n        box1 = label1 && label1.absoluteBox;\n        for (let j = i + 1; j < len; ++j) {\n            label2 = labels[j];\n            box2 = label2 && label2.absoluteBox;\n            if (box1 &&\n                box2 &&\n                label1 !== label2 && // #6465, polar chart with connectEnds\n                label1.newOpacity !== 0 &&\n                label2.newOpacity !== 0 &&\n                // #15863 dataLabels are no longer hidden by translation\n                label1.visibility !== 'hidden' &&\n                label2.visibility !== 'hidden') {\n                if (isIntersectRect(box1, box2)) {\n                    (label1.labelrank < label2.labelrank ? label1 : label2)\n                        .newOpacity = 0;\n                }\n            }\n        }\n    }\n    // Hide or show\n    for (const label of labels) {\n        if (hideOrShow(label, chart)) {\n            isLabelAffected = true;\n        }\n    }\n    if (isLabelAffected) {\n        fireEvent(chart, 'afterHideAllOverlappingLabels');\n    }\n}\n/** @private */\nfunction compose(ChartClass) {\n    if (pushUnique(composedMembers, ChartClass)) {\n        const chartProto = ChartClass.prototype;\n        chartProto.hideOverlappingLabels = chartHideOverlappingLabels;\n        addEvent(ChartClass, 'render', onChartRender);\n    }\n}\n/**\n * Hide or show labels based on opacity.\n *\n * @private\n * @function hideOrShow\n * @param {Highcharts.SVGElement} label\n * The label.\n * @param {Highcharts.Chart} chart\n * The chart that contains the label.\n * @return {boolean}\n * Whether label is affected\n */\nfunction hideOrShow(label, chart) {\n    let complete, newOpacity, isLabelAffected = false;\n    if (label) {\n        newOpacity = label.newOpacity;\n        if (label.oldOpacity !== newOpacity) {\n            // Make sure the label is completely hidden to avoid catching clicks\n            // (#4362)\n            if (label.alignAttr && label.placed) { // data labels\n                label[newOpacity ? 'removeClass' : 'addClass']('highcharts-data-label-hidden');\n                complete = function () {\n                    if (!chart.styledMode) {\n                        label.css({\n                            pointerEvents: newOpacity ? 'auto' : 'none'\n                        });\n                    }\n                };\n                isLabelAffected = true;\n                // Animate or set the opacity\n                label.alignAttr.opacity = newOpacity;\n                label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);\n                fireEvent(chart, 'afterHideOverlappingLabel');\n            }\n            else { // other labels, tick labels\n                label.attr({\n                    opacity: newOpacity\n                });\n            }\n        }\n        label.isOld = true;\n    }\n    return isLabelAffected;\n}\n/**\n * Collect potensial overlapping data labels. Stack labels probably don't need\n * to be considered because they are usually accompanied by data labels that lie\n * inside the columns.\n * @private\n */\nfunction onChartRender() {\n    const chart = this;\n    let labels = [];\n    // Consider external label collectors\n    for (const collector of (chart.labelCollectors || [])) {\n        labels = labels.concat(collector());\n    }\n    for (const yAxis of (chart.yAxis || [])) {\n        if (yAxis.stacking &&\n            yAxis.options.stackLabels &&\n            !yAxis.options.stackLabels.allowOverlap) {\n            objectEach(yAxis.stacking.stacks, (stack) => {\n                objectEach(stack, (stackItem) => {\n                    if (stackItem.label) {\n                        labels.push(stackItem.label);\n                    }\n                });\n            });\n        }\n    }\n    for (const series of (chart.series || [])) {\n        if (series.visible && series.hasDataLabels?.()) { // #3866\n            const push = (points) => {\n                for (const point of points) {\n                    if (point.visible) {\n                        (point.dataLabels || []).forEach((label) => {\n                            const options = label.options || {};\n                            label.labelrank = pick(options.labelrank, point.labelrank, point.shapeArgs?.height); // #4118\n                            // Allow overlap if the option is explicitly true\n                            if (\n                            // #13449\n                            options.allowOverlap ??\n                                // Pie labels outside have a separate placement\n                                // logic, skip the overlap logic\n                                Number(options.distance) > 0) {\n                                label.oldOpacity = label.opacity;\n                                label.newOpacity = 1;\n                                hideOrShow(label, chart);\n                                // Do not allow overlap\n                            }\n                            else {\n                                labels.push(label);\n                            }\n                        });\n                    }\n                }\n            };\n            push(series.nodes || []);\n            push(series.points);\n        }\n    }\n    this.hideOverlappingLabels(labels);\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst OverlappingDataLabels = {\n    compose\n};\nexport default OverlappingDataLabels;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}