{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport A from '../Animation/AnimationUtilities.js';\nconst {\n  animObject,\n  setAnimation\n} = A;\nimport D from '../Defaults.js';\nconst {\n  defaultOptions\n} = D;\nimport F from '../Foundation.js';\nconst {\n  registerEventOptions\n} = F;\nimport H from '../Globals.js';\nconst {\n  hasTouch,\n  svg,\n  win\n} = H;\nimport LegendSymbol from '../Legend/LegendSymbol.js';\nimport Point from './Point.js';\nimport SeriesDefaults from './SeriesDefaults.js';\nimport SeriesRegistry from './SeriesRegistry.js';\nconst {\n  seriesTypes\n} = SeriesRegistry;\nimport SVGElement from '../Renderer/SVG/SVGElement.js';\nimport U from '../Utilities.js';\nconst {\n  addEvent,\n  arrayMax,\n  arrayMin,\n  clamp,\n  correctFloat,\n  defined,\n  diffObjects,\n  erase,\n  error,\n  extend,\n  find,\n  fireEvent,\n  getClosestDistance,\n  getNestedProperty,\n  insertItem,\n  isArray,\n  isNumber,\n  isString,\n  merge,\n  objectEach,\n  pick,\n  removeEvent,\n  splat,\n  syncTimeout\n} = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * This is the base series prototype that all other series types inherit from.\n * A new series is initialized either through the\n * [series](https://api.highcharts.com/highcharts/series)\n * option structure, or after the chart is initialized, through\n * {@link Highcharts.Chart#addSeries}.\n *\n * The object can be accessed in a number of ways. All series and point event\n * handlers give a reference to the `series` object. The chart object has a\n * {@link Highcharts.Chart#series|series} property that is a collection of all\n * the chart's series. The point objects and axis objects also have the same\n * reference.\n *\n * Another way to reference the series programmatically is by `id`. Add an id\n * in the series configuration options, and get the series object by\n * {@link Highcharts.Chart#get}.\n *\n * Configuration options for the series are given in three levels. Options for\n * all series in a chart are given in the\n * [plotOptions.series](https://api.highcharts.com/highcharts/plotOptions.series)\n * object. Then options for all series of a specific type\n * are given in the plotOptions of that type, for example `plotOptions.line`.\n * Next, options for one single series are given in the series array, or as\n * arguments to `chart.addSeries`.\n *\n * The data in the series is stored in various arrays.\n *\n * - First, `series.options.data` contains all the original config options for\n *   each point whether added by options or methods like `series.addPoint`.\n *\n * - Next, `series.data` contains those values converted to points, but in case\n *   the series data length exceeds the `cropThreshold`, or if the data is\n *   grouped, `series.data` doesn't contain all the points. It only contains the\n *   points that have been created on demand.\n *\n * - Then there's `series.points` that contains all currently visible point\n *   objects. In case of cropping, the cropped-away points are not part of this\n *   array. The `series.points` array starts at `series.cropStart` compared to\n *   `series.data` and `series.options.data`. If however the series data is\n *   grouped, these can't be correlated one to one.\n *\n * - `series.xData` and `series.processedXData` contain clean x values,\n *   equivalent to `series.data` and `series.points`.\n *\n * - `series.yData` and `series.processedYData` contain clean y values,\n *   equivalent to `series.data` and `series.points`.\n *\n * @class\n * @name Highcharts.Series\n *\n * @param {Highcharts.Chart} chart\n * The chart instance.\n *\n * @param {Highcharts.SeriesOptionsType|object} options\n * The series options.\n */\nclass Series {\n  constructor() {\n    /* *\n     *\n     *  Static Properties\n     *\n     * */\n    this._i = void 0;\n    this.chart = void 0;\n    this.data = void 0;\n    this.eventOptions = void 0;\n    this.eventsToUnbind = void 0;\n    this.index = void 0;\n    this.linkedSeries = void 0;\n    this.options = void 0;\n    this.points = void 0;\n    this.processedXData = void 0;\n    this.processedYData = void 0;\n    this.tooltipOptions = void 0;\n    this.userOptions = void 0;\n    this.xAxis = void 0;\n    this.yAxis = void 0;\n    this.zones = void 0;\n    /** eslint-enable valid-jsdoc */\n  }\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /* eslint-disable valid-jsdoc */\n  init(chart, userOptions) {\n    fireEvent(this, 'init', {\n      options: userOptions\n    });\n    const series = this,\n      chartSeries = chart.series;\n    // The 'eventsToUnbind' property moved from prototype into the\n    // Series init to avoid reference to the same array between\n    // the different series and charts. #12959, #13937\n    this.eventsToUnbind = [];\n    /**\n     * Read only. The chart that the series belongs to.\n     *\n     * @name Highcharts.Series#chart\n     * @type {Highcharts.Chart}\n     */\n    series.chart = chart;\n    /**\n     * Read only. The series' type, like \"line\", \"area\", \"column\" etc.\n     * The type in the series options anc can be altered using\n     * {@link Series#update}.\n     *\n     * @name Highcharts.Series#type\n     * @type {string}\n     */\n    /**\n     * Read only. The series' current options. To update, use\n     * {@link Series#update}.\n     *\n     * @name Highcharts.Series#options\n     * @type {Highcharts.SeriesOptionsType}\n     */\n    series.options = series.setOptions(userOptions);\n    const options = series.options,\n      visible = options.visible !== false;\n    series.linkedSeries = [];\n    // bind the axes\n    series.bindAxes();\n    extend(series, {\n      /**\n       * The series name as given in the options. Defaults to\n       * \"Series {n}\".\n       *\n       * @name Highcharts.Series#name\n       * @type {string}\n       */\n      name: options.name,\n      state: '',\n      /**\n       * Read only. The series' visibility state as set by {@link\n       * Series#show}, {@link Series#hide}, or in the initial\n       * configuration.\n       *\n       * @name Highcharts.Series#visible\n       * @type {boolean}\n       */\n      visible,\n      /**\n       * Read only. The series' selected state as set by {@link\n       * Highcharts.Series#select}.\n       *\n       * @name Highcharts.Series#selected\n       * @type {boolean}\n       */\n      selected: options.selected === true // false by default\n    });\n\n    registerEventOptions(this, options);\n    const events = options.events;\n    if (events && events.click || options.point && options.point.events && options.point.events.click || options.allowPointSelect) {\n      chart.runTrackerClick = true;\n    }\n    series.getColor();\n    series.getSymbol();\n    // Initialize the parallel data arrays\n    series.parallelArrays.forEach(function (key) {\n      if (!series[key + 'Data']) {\n        series[key + 'Data'] = [];\n      }\n    });\n    // Mark cartesian\n    if (series.isCartesian) {\n      chart.hasCartesianSeries = true;\n    }\n    // Get the index and register the series in the chart. The index is\n    // one more than the current latest series index (#5960).\n    let lastSeries;\n    if (chartSeries.length) {\n      lastSeries = chartSeries[chartSeries.length - 1];\n    }\n    series._i = pick(lastSeries && lastSeries._i, -1) + 1;\n    series.opacity = series.options.opacity;\n    // Insert the series and re-order all series above the insertion\n    // point.\n    chart.orderItems('series', insertItem(this, chartSeries));\n    // Set options for series with sorting and set data later.\n    if (options.dataSorting && options.dataSorting.enabled) {\n      series.setDataSortingOptions();\n    } else if (!series.points && !series.data) {\n      series.setData(options.data, false);\n    }\n    fireEvent(this, 'afterInit');\n  }\n  /**\n   * Check whether the series item is itself or inherits from a certain\n   * series type.\n   *\n   * @function Highcharts.Series#is\n   * @param {string} type The type of series to check for, can be either\n   *        featured or custom series types. For example `column`, `pie`,\n   *        `ohlc` etc.\n   *\n   * @return {boolean}\n   *        True if this item is or inherits from the given type.\n   */\n  is(type) {\n    return seriesTypes[type] && this instanceof seriesTypes[type];\n  }\n  /**\n   * Set the xAxis and yAxis properties of cartesian series, and register\n   * the series in the `axis.series` array.\n   *\n   * @private\n   * @function Highcharts.Series#bindAxes\n   */\n  bindAxes() {\n    const series = this,\n      seriesOptions = series.options,\n      chart = series.chart;\n    let axisOptions;\n    fireEvent(this, 'bindAxes', null, function () {\n      // repeat for xAxis and yAxis\n      (series.axisTypes || []).forEach(function (coll) {\n        // loop through the chart's axis objects\n        chart[coll].forEach(function (axis) {\n          axisOptions = axis.options;\n          // apply if the series xAxis or yAxis option mathches\n          // the number of the axis, or if undefined, use the\n          // first axis\n          if (pick(seriesOptions[coll], 0) === axis.index || typeof seriesOptions[coll] !== 'undefined' && seriesOptions[coll] === axisOptions.id) {\n            // register this series in the axis.series lookup\n            insertItem(series, axis.series);\n            // set this series.xAxis or series.yAxis reference\n            /**\n             * Read only. The unique xAxis object associated\n             * with the series.\n             *\n             * @name Highcharts.Series#xAxis\n             * @type {Highcharts.Axis}\n             */\n            /**\n             * Read only. The unique yAxis object associated\n             * with the series.\n             *\n             * @name Highcharts.Series#yAxis\n             * @type {Highcharts.Axis}\n             */\n            series[coll] = axis;\n            // mark dirty for redraw\n            axis.isDirty = true;\n          }\n        });\n        // The series needs an X and an Y axis\n        if (!series[coll] && series.optionalAxis !== coll) {\n          error(18, true, chart);\n        }\n      });\n    });\n    fireEvent(this, 'afterBindAxes');\n  }\n  /**\n   * For simple series types like line and column, the data values are\n   * held in arrays like xData and yData for quick lookup to find extremes\n   * and more. For multidimensional series like bubble and map, this can\n   * be extended with arrays like zData and valueData by adding to the\n   * `series.parallelArrays` array.\n   *\n   * @private\n   * @function Highcharts.Series#updateParallelArrays\n   */\n  updateParallelArrays(point, i, iArgs) {\n    const series = point.series,\n      fn = isNumber(i) ?\n      // Insert the value in the given position\n      function (key) {\n        const val = key === 'y' && series.toYData ? series.toYData(point) : point[key];\n        series[key + 'Data'][i] = val;\n      } :\n      // Apply the method specified in i with the following\n      // arguments as arguments\n      function (key) {\n        Array.prototype[i].apply(series[key + 'Data'], iArgs);\n      };\n    series.parallelArrays.forEach(fn);\n  }\n  /**\n   * Define hasData functions for series. These return true if there\n   * are data points on this series within the plot area.\n   *\n   * @private\n   * @function Highcharts.Series#hasData\n   */\n  hasData() {\n    return this.visible && typeof this.dataMax !== 'undefined' && typeof this.dataMin !== 'undefined' ||\n    // #3703\n    this.visible && this.yData && this.yData.length > 0 // #9758\n    ;\n  }\n  /**\n   * Determine whether the marker in a series has changed.\n   *\n   * @private\n   * @function Highcharts.Series#hasMarkerChanged\n   */\n  hasMarkerChanged(options, oldOptions) {\n    const series = this,\n      marker = options.marker,\n      oldMarker = oldOptions.marker || {};\n    return marker && (oldMarker.enabled && !marker.enabled || oldMarker.symbol !== marker.symbol ||\n    // #10870, #15946\n    oldMarker.height !== marker.height ||\n    // #16274\n    oldMarker.width !== marker.width // #16274\n    );\n  }\n  /**\n   * Return an auto incremented x value based on the pointStart and\n   * pointInterval options. This is only used if an x value is not given\n   * for the point that calls autoIncrement.\n   *\n   * @private\n   * @function Highcharts.Series#autoIncrement\n   */\n  autoIncrement(x) {\n    const options = this.options,\n      pointIntervalUnit = options.pointIntervalUnit,\n      relativeXValue = options.relativeXValue,\n      time = this.chart.time;\n    let xIncrement = this.xIncrement,\n      date,\n      pointInterval;\n    xIncrement = pick(xIncrement, options.pointStart, 0);\n    this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);\n    if (relativeXValue && isNumber(x)) {\n      pointInterval *= x;\n    }\n    // Added code for pointInterval strings\n    if (pointIntervalUnit) {\n      date = new time.Date(xIncrement);\n      if (pointIntervalUnit === 'day') {\n        time.set('Date', date, time.get('Date', date) + pointInterval);\n      } else if (pointIntervalUnit === 'month') {\n        time.set('Month', date, time.get('Month', date) + pointInterval);\n      } else if (pointIntervalUnit === 'year') {\n        time.set('FullYear', date, time.get('FullYear', date) + pointInterval);\n      }\n      pointInterval = date.getTime() - xIncrement;\n    }\n    if (relativeXValue && isNumber(x)) {\n      return xIncrement + pointInterval;\n    }\n    this.xIncrement = xIncrement + pointInterval;\n    return xIncrement;\n  }\n  /**\n   * Internal function to set properties for series if data sorting is\n   * enabled.\n   *\n   * @private\n   * @function Highcharts.Series#setDataSortingOptions\n   */\n  setDataSortingOptions() {\n    const options = this.options;\n    extend(this, {\n      requireSorting: false,\n      sorted: false,\n      enabledDataSorting: true,\n      allowDG: false\n    });\n    // To allow unsorted data for column series.\n    if (!defined(options.pointRange)) {\n      options.pointRange = 1;\n    }\n  }\n  /**\n   * Set the series options by merging from the options tree. Called\n   * internally on initializing and updating series. This function will\n   * not redraw the series. For API usage, use {@link Series#update}.\n   * @private\n   * @function Highcharts.Series#setOptions\n   * @param {Highcharts.SeriesOptionsType} itemOptions\n   * The series options.\n   * @emits Highcharts.Series#event:afterSetOptions\n   */\n  setOptions(itemOptions) {\n    const chart = this.chart,\n      chartOptions = chart.options,\n      plotOptions = chartOptions.plotOptions,\n      userOptions = chart.userOptions || {},\n      seriesUserOptions = merge(itemOptions),\n      styledMode = chart.styledMode,\n      e = {\n        plotOptions: plotOptions,\n        userOptions: seriesUserOptions\n      };\n    let zone;\n    fireEvent(this, 'setOptions', e);\n    // These may be modified by the event\n    const typeOptions = e.plotOptions[this.type],\n      userPlotOptions = userOptions.plotOptions || {},\n      userPlotOptionsSeries = userPlotOptions.series || {},\n      defaultPlotOptionsType = defaultOptions.plotOptions[this.type] || {},\n      userPlotOptionsType = userPlotOptions[this.type] || {};\n    // use copy to prevent undetected changes (#9762)\n    /**\n     * Contains series options by the user without defaults.\n     * @name Highcharts.Series#userOptions\n     * @type {Highcharts.SeriesOptionsType}\n     */\n    this.userOptions = e.userOptions;\n    const options = merge(typeOptions, plotOptions.series,\n    // #3881, chart instance plotOptions[type] should trump\n    // plotOptions.series\n    userPlotOptionsType, seriesUserOptions);\n    // The tooltip options are merged between global and series specific\n    // options. Importance order asscendingly:\n    // globals: (1)tooltip, (2)plotOptions.series,\n    // (3)plotOptions[this.type]\n    // init userOptions with possible later updates: 4-6 like 1-3 and\n    // (7)this series options\n    this.tooltipOptions = merge(defaultOptions.tooltip,\n    // 1\n    defaultOptions.plotOptions.series?.tooltip,\n    // 2\n    defaultPlotOptionsType?.tooltip,\n    // 3\n    chart.userOptions.tooltip,\n    // 4\n    userPlotOptions.series?.tooltip,\n    // 5\n    userPlotOptionsType.tooltip,\n    // 6\n    seriesUserOptions.tooltip // 7\n    );\n    // When shared tooltip, stickyTracking is true by default,\n    // unless user says otherwise.\n    this.stickyTracking = pick(seriesUserOptions.stickyTracking, userPlotOptionsType.stickyTracking, userPlotOptionsSeries.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : options.stickyTracking);\n    // Delete marker object if not allowed (#1125)\n    if (typeOptions.marker === null) {\n      delete options.marker;\n    }\n    // Handle color zones\n    this.zoneAxis = options.zoneAxis;\n    const zones = this.zones = (options.zones || []).slice();\n    if ((options.negativeColor || options.negativeFillColor) && !options.zones) {\n      zone = {\n        value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,\n        className: 'highcharts-negative'\n      };\n      if (!styledMode) {\n        zone.color = options.negativeColor;\n        zone.fillColor = options.negativeFillColor;\n      }\n      zones.push(zone);\n    }\n    if (zones.length) {\n      // Push one extra zone for the rest\n      if (defined(zones[zones.length - 1].value)) {\n        zones.push(styledMode ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n      }\n    }\n    fireEvent(this, 'afterSetOptions', {\n      options: options\n    });\n    return options;\n  }\n  /**\n   * Return series name in \"Series {Number}\" format or the one defined by\n   * a user. This method can be simply overridden as series name format\n   * can vary (e.g. technical indicators).\n   *\n   * @function Highcharts.Series#getName\n   *\n   * @return {string}\n   * The series name.\n   */\n  getName() {\n    // #4119\n    return pick(this.options.name, 'Series ' + (this.index + 1));\n  }\n  /**\n   * @private\n   * @function Highcharts.Series#getCyclic\n   */\n  getCyclic(prop, value, defaults) {\n    const chart = this.chart,\n      indexName = `${prop}Index`,\n      counterName = `${prop}Counter`,\n      len =\n      // Symbol count\n      defaults?.length ||\n      // Color count\n      chart.options.chart.colorCount;\n    let i, setting;\n    if (!value) {\n      // Pick up either the colorIndex option, or the series.colorIndex\n      // after Series.update()\n      setting = pick(prop === 'color' ? this.options.colorIndex : void 0, this[indexName]);\n      if (defined(setting)) {\n        // after Series.update()\n        i = setting;\n      } else {\n        // #6138\n        if (!chart.series.length) {\n          chart[counterName] = 0;\n        }\n        i = chart[counterName] % len;\n        chart[counterName] += 1;\n      }\n      if (defaults) {\n        value = defaults[i];\n      }\n    }\n    // Set the colorIndex\n    if (typeof i !== 'undefined') {\n      this[indexName] = i;\n    }\n    this[prop] = value;\n  }\n  /**\n   * Get the series' color based on either the options or pulled from\n   * global options.\n   *\n   * @private\n   * @function Highcharts.Series#getColor\n   */\n  getColor() {\n    if (this.chart.styledMode) {\n      this.getCyclic('color');\n    } else if (this.options.colorByPoint) {\n      this.color = \"#cccccc\" /* Palette.neutralColor20 */;\n    } else {\n      this.getCyclic('color', this.options.color || defaultOptions.plotOptions[this.type].color, this.chart.options.colors);\n    }\n  }\n  /**\n   * Get all points' instances created for this series.\n   *\n   * @private\n   * @function Highcharts.Series#getPointsCollection\n   */\n  getPointsCollection() {\n    return (this.hasGroupedData ? this.points : this.data) || [];\n  }\n  /**\n   * Get the series' symbol based on either the options or pulled from\n   * global options.\n   *\n   * @private\n   * @function Highcharts.Series#getSymbol\n   */\n  getSymbol() {\n    const seriesMarkerOption = this.options.marker;\n    this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);\n  }\n  /**\n   * Finds the index of an existing point that matches the given point\n   * options.\n   *\n   * @private\n   * @function Highcharts.Series#findPointIndex\n   * @param {Highcharts.PointOptionsObject} optionsObject\n   * The options of the point.\n   * @param {number} fromIndex\n   * The index to start searching from, used for optimizing series with\n   * required sorting.\n   * @return {number|undefined}\n   * Returns the index of a matching point, or undefined if no match is found.\n   */\n  findPointIndex(optionsObject, fromIndex) {\n    const id = optionsObject.id,\n      x = optionsObject.x,\n      oldData = this.points,\n      dataSorting = this.options.dataSorting;\n    let matchingPoint, matchedById, pointIndex;\n    if (id) {\n      const item = this.chart.get(id);\n      if (item instanceof Point) {\n        matchingPoint = item;\n      }\n    } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {\n      let matcher = oldPoint => !oldPoint.touched && oldPoint.index === optionsObject.index;\n      if (dataSorting && dataSorting.matchByName) {\n        matcher = oldPoint => !oldPoint.touched && oldPoint.name === optionsObject.name;\n      } else if (this.options.relativeXValue) {\n        matcher = oldPoint => !oldPoint.touched && oldPoint.options.x === optionsObject.x;\n      }\n      matchingPoint = find(oldData, matcher);\n      // Add unmatched point as a new point\n      if (!matchingPoint) {\n        return void 0;\n      }\n    }\n    if (matchingPoint) {\n      pointIndex = matchingPoint && matchingPoint.index;\n      if (typeof pointIndex !== 'undefined') {\n        matchedById = true;\n      }\n    }\n    // Search for the same X in the existing data set\n    if (typeof pointIndex === 'undefined' && isNumber(x)) {\n      pointIndex = this.xData.indexOf(x, fromIndex);\n    }\n    // Reduce pointIndex if data is cropped\n    if (pointIndex !== -1 && typeof pointIndex !== 'undefined' && this.cropped) {\n      pointIndex = pointIndex >= this.cropStart ? pointIndex - this.cropStart : pointIndex;\n    }\n    if (!matchedById && isNumber(pointIndex) && oldData[pointIndex] && oldData[pointIndex].touched) {\n      pointIndex = void 0;\n    }\n    return pointIndex;\n  }\n  /**\n   * Internal function called from setData. If the point count is the same\n   * as it was, or if there are overlapping X values, just run\n   * Point.update which is cheaper, allows animation, and keeps references\n   * to points. This also allows adding or removing points if the X-es\n   * don't match.\n   *\n   * @private\n   * @function Highcharts.Series#updateData\n   */\n  updateData(data, animation) {\n    const options = this.options,\n      dataSorting = options.dataSorting,\n      oldData = this.points,\n      pointsToAdd = [],\n      requireSorting = this.requireSorting,\n      equalLength = data.length === oldData.length;\n    let hasUpdatedByKey,\n      i,\n      point,\n      lastIndex,\n      succeeded = true;\n    this.xIncrement = null;\n    // Iterate the new data\n    data.forEach(function (pointOptions, i) {\n      const optionsObject = defined(pointOptions) && this.pointClass.prototype.optionsToObject.call({\n        series: this\n      }, pointOptions) || {};\n      let pointIndex;\n      // Get the x of the new data point\n      const x = optionsObject.x,\n        id = optionsObject.id;\n      if (id || isNumber(x)) {\n        pointIndex = this.findPointIndex(optionsObject, lastIndex);\n        // Matching X not found\n        // or used already due to ununique x values (#8995),\n        // add point (but later)\n        if (pointIndex === -1 || typeof pointIndex === 'undefined') {\n          pointsToAdd.push(pointOptions);\n          // Matching X found, update\n        } else if (oldData[pointIndex] && pointOptions !== options.data[pointIndex]) {\n          oldData[pointIndex].update(pointOptions, false, null, false);\n          // Mark it touched, below we will remove all points that\n          // are not touched.\n          oldData[pointIndex].touched = true;\n          // Speed optimize by only searching after last known\n          // index. Performs ~20% bettor on large data sets.\n          if (requireSorting) {\n            lastIndex = pointIndex + 1;\n          }\n          // Point exists, no changes, don't remove it\n        } else if (oldData[pointIndex]) {\n          oldData[pointIndex].touched = true;\n        }\n        // If the length is equal and some of the nodes had a\n        // match in the same position, we don't want to remove\n        // non-matches.\n        if (!equalLength || i !== pointIndex || dataSorting && dataSorting.enabled || this.hasDerivedData) {\n          hasUpdatedByKey = true;\n        }\n      } else {\n        // Gather all points that are not matched\n        pointsToAdd.push(pointOptions);\n      }\n    }, this);\n    // Remove points that don't exist in the updated data set\n    if (hasUpdatedByKey) {\n      i = oldData.length;\n      while (i--) {\n        point = oldData[i];\n        if (point && !point.touched && point.remove) {\n          point.remove(false, animation);\n        }\n      }\n      // If we did not find keys (ids or x-values), and the length is the\n      // same, update one-to-one\n    } else if (equalLength && (!dataSorting || !dataSorting.enabled)) {\n      data.forEach(function (point, i) {\n        // .update doesn't exist on a linked, hidden series (#3709)\n        // (#10187)\n        if (point !== oldData[i].y && !oldData[i].destroyed) {\n          oldData[i].update(point, false, null, false);\n        }\n      });\n      // Don't add new points since those configs are used above\n      pointsToAdd.length = 0;\n      // Did not succeed in updating data\n    } else {\n      succeeded = false;\n    }\n    oldData.forEach(function (point) {\n      if (point) {\n        point.touched = false;\n      }\n    });\n    if (!succeeded) {\n      return false;\n    }\n    // Add new points\n    pointsToAdd.forEach(function (point) {\n      this.addPoint(point, false, null, null, false);\n    }, this);\n    if (this.xIncrement === null && this.xData && this.xData.length) {\n      this.xIncrement = arrayMax(this.xData);\n      this.autoIncrement();\n    }\n    return true;\n  }\n  /**\n   * Apply a new set of data to the series and optionally redraw it. The\n   * new data array is passed by reference (except in case of\n   * `updatePoints`), and may later be mutated when updating the chart\n   * data.\n   *\n   * Note the difference in behaviour when setting the same amount of\n   * points, or a different amount of points, as handled by the\n   * `updatePoints` parameter.\n   *\n   * @sample highcharts/members/series-setdata/\n   *         Set new data from a button\n   * @sample highcharts/members/series-setdata-pie/\n   *         Set data in a pie\n   * @sample stock/members/series-setdata/\n   *         Set new data in Highcharts Stock\n   * @sample maps/members/series-setdata/\n   *         Set new data in Highmaps\n   *\n   * @function Highcharts.Series#setData\n   *\n   * @param {Array<Highcharts.PointOptionsType>} data\n   *        Takes an array of data in the same format as described under\n   *        `series.{type}.data` for the given series type, for example a\n   *        line series would take data in the form described under\n   *        [series.line.data](https://api.highcharts.com/highcharts/series.line.data).\n   *\n   * @param {boolean} [redraw=true]\n   *        Whether to redraw the chart after the series is altered. If\n   *        doing more operations on the chart, it is a good idea to set\n   *        redraw to false and call {@link Chart#redraw} after.\n   *\n   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]\n   *        When the updated data is the same length as the existing data,\n   *        points will be updated by default, and animation visualizes\n   *        how the points are changed. Set false to disable animation, or\n   *        a configuration object to set duration or easing.\n   *\n   * @param {boolean} [updatePoints=true]\n   *        When this is true, points will be updated instead of replaced\n   *        whenever possible. This occurs a) when the updated data is the\n   *        same length as the existing data, b) when points are matched\n   *        by their id's, or c) when points can be matched by X values.\n   *        This allows updating with animation and performs better. In\n   *        this case, the original array is not passed by reference. Set\n   *        `false` to prevent.\n   */\n  setData(data, redraw = true, animation, updatePoints) {\n    const series = this,\n      oldData = series.points,\n      oldDataLength = oldData && oldData.length || 0,\n      options = series.options,\n      chart = series.chart,\n      dataSorting = options.dataSorting,\n      xAxis = series.xAxis,\n      turboThreshold = options.turboThreshold,\n      xData = this.xData,\n      yData = this.yData,\n      pointArrayMap = series.pointArrayMap,\n      valueCount = pointArrayMap && pointArrayMap.length,\n      keys = options.keys;\n    let i,\n      pt,\n      updatedData,\n      indexOfX = 0,\n      indexOfY = 1,\n      firstPoint = null,\n      copiedData;\n    if (!chart.options.chart.allowMutatingData) {\n      // #4259\n      // Remove old reference\n      if (options.data) {\n        delete series.options.data;\n      }\n      if (series.userOptions.data) {\n        delete series.userOptions.data;\n      }\n      copiedData = merge(true, data);\n    }\n    data = copiedData || data || [];\n    const dataLength = data.length;\n    if (dataSorting && dataSorting.enabled) {\n      data = this.sortData(data);\n    }\n    // First try to run Point.update which is cheaper, allows animation,\n    // and keeps references to points.\n    if (chart.options.chart.allowMutatingData && updatePoints !== false && dataLength && oldDataLength && !series.cropped && !series.hasGroupedData && series.visible &&\n    // Soft updating has no benefit in boost, and causes JS error\n    // (#8355)\n    !series.boosted) {\n      updatedData = this.updateData(data, animation);\n    }\n    if (!updatedData) {\n      // Reset properties\n      series.xIncrement = null;\n      series.colorCounter = 0; // for series with colorByPoint (#1547)\n      // Update parallel arrays\n      this.parallelArrays.forEach(function (key) {\n        series[key + 'Data'].length = 0;\n      });\n      // In turbo mode, only one- or twodimensional arrays of numbers\n      // are allowed. The first value is tested, and we assume that\n      // all the rest are defined the same way. Although the 'for'\n      // loops are similar, they are repeated inside each if-else\n      // conditional for max performance.\n      if (turboThreshold && dataLength > turboThreshold) {\n        firstPoint = series.getFirstValidPoint(data);\n        if (isNumber(firstPoint)) {\n          // assume all points are numbers\n          for (i = 0; i < dataLength; i++) {\n            xData[i] = this.autoIncrement();\n            yData[i] = data[i];\n          }\n          // Assume all points are arrays when first point is\n        } else if (isArray(firstPoint)) {\n          if (valueCount) {\n            // [x, low, high] or [x, o, h, l, c]\n            if (firstPoint.length === valueCount) {\n              for (i = 0; i < dataLength; i++) {\n                xData[i] = this.autoIncrement();\n                yData[i] = data[i];\n              }\n            } else {\n              for (i = 0; i < dataLength; i++) {\n                pt = data[i];\n                xData[i] = pt[0];\n                yData[i] = pt.slice(1, valueCount + 1);\n              }\n            }\n          } else {\n            // [x, y]\n            if (keys) {\n              indexOfX = keys.indexOf('x');\n              indexOfY = keys.indexOf('y');\n              indexOfX = indexOfX >= 0 ? indexOfX : 0;\n              indexOfY = indexOfY >= 0 ? indexOfY : 1;\n            }\n            if (firstPoint.length === 1) {\n              indexOfY = 0;\n            }\n            if (indexOfX === indexOfY) {\n              for (i = 0; i < dataLength; i++) {\n                xData[i] = this.autoIncrement();\n                yData[i] = data[i][indexOfY];\n              }\n            } else {\n              for (i = 0; i < dataLength; i++) {\n                pt = data[i];\n                xData[i] = pt[indexOfX];\n                yData[i] = pt[indexOfY];\n              }\n            }\n          }\n        } else {\n          // Highcharts expects configs to be numbers or arrays in\n          // turbo mode\n          error(12, false, chart);\n        }\n      } else {\n        for (i = 0; i < dataLength; i++) {\n          pt = {\n            series: series\n          };\n          series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);\n          series.updateParallelArrays(pt, i);\n        }\n      }\n      // Forgetting to cast strings to numbers is a common caveat when\n      // handling CSV or JSON\n      if (yData && isString(yData[0])) {\n        error(14, true, chart);\n      }\n      series.data = [];\n      series.options.data = series.userOptions.data = data;\n      // destroy old points\n      i = oldDataLength;\n      while (i--) {\n        oldData[i]?.destroy();\n      }\n      // reset minRange (#878)\n      if (xAxis) {\n        xAxis.minRange = xAxis.userMinRange;\n      }\n      // redraw\n      series.isDirty = chart.isDirtyBox = true;\n      series.isDirtyData = !!oldData;\n      animation = false;\n    }\n    // Typically for pie series, points need to be processed and\n    // generated prior to rendering the legend\n    if (options.legendType === 'point') {\n      this.processData();\n      this.generatePoints();\n    }\n    if (redraw) {\n      chart.redraw(animation);\n    }\n  }\n  /**\n   * Internal function to sort series data\n   *\n   * @private\n   * @function Highcharts.Series#sortData\n   * @param {Array<Highcharts.PointOptionsType>} data\n   * Force data grouping.\n   */\n  sortData(data) {\n    const series = this,\n      options = series.options,\n      dataSorting = options.dataSorting,\n      sortKey = dataSorting.sortKey || 'y',\n      getPointOptionsObject = function (series, pointOptions) {\n        return defined(pointOptions) && series.pointClass.prototype.optionsToObject.call({\n          series: series\n        }, pointOptions) || {};\n      };\n    data.forEach(function (pointOptions, i) {\n      data[i] = getPointOptionsObject(series, pointOptions);\n      data[i].index = i;\n    }, this);\n    // Sorting\n    const sortedData = data.concat().sort((a, b) => {\n      const aValue = getNestedProperty(sortKey, a);\n      const bValue = getNestedProperty(sortKey, b);\n      return bValue < aValue ? -1 : bValue > aValue ? 1 : 0;\n    });\n    // Set x value depending on the position in the array\n    sortedData.forEach(function (point, i) {\n      point.x = i;\n    }, this);\n    // Set the same x for linked series points if they don't have their\n    // own sorting\n    if (series.linkedSeries) {\n      series.linkedSeries.forEach(function (linkedSeries) {\n        const options = linkedSeries.options,\n          seriesData = options.data;\n        if ((!options.dataSorting || !options.dataSorting.enabled) && seriesData) {\n          seriesData.forEach(function (pointOptions, i) {\n            seriesData[i] = getPointOptionsObject(linkedSeries, pointOptions);\n            if (data[i]) {\n              seriesData[i].x = data[i].x;\n              seriesData[i].index = i;\n            }\n          });\n          linkedSeries.setData(seriesData, false);\n        }\n      });\n    }\n    return data;\n  }\n  /**\n   * Internal function to process the data by cropping away unused data\n   * points if the series is longer than the crop threshold. This saves\n   * computing time for large series.\n   *\n   * @private\n   * @function Highcharts.Series#getProcessedData\n   * @param {boolean} [forceExtremesFromAll]\n   * Force getting extremes of a total series data range.\n   */\n  getProcessedData(forceExtremesFromAll) {\n    const series = this,\n      xAxis = series.xAxis,\n      options = series.options,\n      cropThreshold = options.cropThreshold,\n      getExtremesFromAll = forceExtremesFromAll || series.getExtremesFromAll || options.getExtremesFromAll,\n      // #4599\n      logarithmic = xAxis?.logarithmic,\n      isCartesian = series.isCartesian;\n    let croppedData,\n      cropped,\n      cropStart = 0,\n      xExtremes,\n      min,\n      max,\n      // copied during slice operation:\n      processedXData = series.xData,\n      processedYData = series.yData,\n      updatingNames = false;\n    const dataLength = processedXData.length;\n    if (xAxis) {\n      // corrected for log axis (#3053)\n      xExtremes = xAxis.getExtremes();\n      min = xExtremes.min;\n      max = xExtremes.max;\n      updatingNames = !!(xAxis.categories && !xAxis.names.length);\n    }\n    // optionally filter out points outside the plot area\n    if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {\n      // it's outside current extremes\n      if (processedXData[dataLength - 1] < min || processedXData[0] > max) {\n        processedXData = [];\n        processedYData = [];\n        // only crop if it's actually spilling out\n      } else if (series.yData && (processedXData[0] < min || processedXData[dataLength - 1] > max)) {\n        croppedData = this.cropData(series.xData, series.yData, min, max);\n        processedXData = croppedData.xData;\n        processedYData = croppedData.yData;\n        cropStart = croppedData.start;\n        cropped = true;\n      }\n    }\n    // Find the closest distance between processed points\n    const closestPointRange = getClosestDistance([logarithmic ? processedXData.map(logarithmic.log2lin) : processedXData],\n    // Unsorted data is not supported by the line tooltip, as well as\n    // data grouping and navigation in Stock charts (#725) and width\n    // calculation of columns (#1900). Avoid warning during the\n    // premature processing pass in updateNames (#16104).\n    () => series.requireSorting && !updatingNames && error(15, false, series.chart));\n    return {\n      xData: processedXData,\n      yData: processedYData,\n      cropped: cropped,\n      cropStart: cropStart,\n      closestPointRange: closestPointRange\n    };\n  }\n  /**\n   * Internal function to apply processed data.\n   * In Highcharts Stock, this function is extended to provide data grouping.\n   *\n   * @private\n   * @function Highcharts.Series#processData\n   * @param {boolean} [force]\n   * Force data grouping.\n   */\n  processData(force) {\n    const series = this,\n      xAxis = series.xAxis;\n    // If the series data or axes haven't changed, don't go through\n    // this. Return false to pass the message on to override methods\n    // like in data grouping.\n    if (series.isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {\n      return false;\n    }\n    const processedData = series.getProcessedData();\n    // Record the properties\n    series.cropped = processedData.cropped; // undefined or true\n    series.cropStart = processedData.cropStart;\n    series.processedXData = processedData.xData;\n    series.processedYData = processedData.yData;\n    series.closestPointRange = series.basePointRange = processedData.closestPointRange;\n    fireEvent(series, 'afterProcessData');\n  }\n  /**\n   * Iterate over xData and crop values between min and max. Returns\n   * object containing crop start/end cropped xData with corresponding\n   * part of yData, dataMin and dataMax within the cropped range.\n   *\n   * @private\n   * @function Highcharts.Series#cropData\n   */\n  cropData(xData, yData, min, max) {\n    const dataLength = xData.length;\n    let i,\n      j,\n      start = 0,\n      end = dataLength;\n    // Iterate up to find slice start\n    for (i = 0; i < dataLength; i++) {\n      if (xData[i] >= min) {\n        start = Math.max(0, i - 1);\n        break;\n      }\n    }\n    // Proceed to find slice end\n    for (j = i; j < dataLength; j++) {\n      if (xData[j] > max) {\n        end = j + 1;\n        break;\n      }\n    }\n    return {\n      xData: xData.slice(start, end),\n      yData: yData.slice(start, end),\n      start,\n      end\n    };\n  }\n  /**\n   * Generate the data point after the data has been processed by cropping\n   * away unused points and optionally grouped in Highcharts Stock.\n   *\n   * @private\n   * @function Highcharts.Series#generatePoints\n   */\n  generatePoints() {\n    const series = this,\n      options = series.options,\n      dataOptions = series.processedData || options.data,\n      processedXData = series.processedXData,\n      processedYData = series.processedYData,\n      PointClass = series.pointClass,\n      processedDataLength = processedXData.length,\n      cropStart = series.cropStart || 0,\n      hasGroupedData = series.hasGroupedData,\n      keys = options.keys,\n      points = [],\n      groupCropStartIndex = options.dataGrouping && options.dataGrouping.groupAll ? cropStart : 0;\n    let dataLength,\n      cursor,\n      point,\n      i,\n      data = series.data;\n    if (!data && !hasGroupedData) {\n      const arr = [];\n      arr.length = dataOptions.length;\n      data = series.data = arr;\n    }\n    if (keys && hasGroupedData) {\n      // grouped data has already applied keys (#6590)\n      series.options.keys = false;\n    }\n    for (i = 0; i < processedDataLength; i++) {\n      cursor = cropStart + i;\n      if (!hasGroupedData) {\n        point = data[cursor];\n        // #970:\n        if (!point && typeof dataOptions[cursor] !== 'undefined') {\n          data[cursor] = point = new PointClass().init(series, dataOptions[cursor], processedXData[i]);\n        }\n      } else {\n        // splat the y data in case of ohlc data array\n        point = new PointClass().init(series, [processedXData[i]].concat(splat(processedYData[i])));\n        point.dataGroup = series.groupMap[groupCropStartIndex + i];\n        if (point.dataGroup.options) {\n          point.options = point.dataGroup.options;\n          extend(point, point.dataGroup.options);\n          // Collision of props and options (#9770)\n          delete point.dataLabels;\n        }\n      }\n      if (point) {\n        // #6279\n        /**\n         * Contains the point's index in the `Series.points` array.\n         *\n         * @name Highcharts.Point#index\n         * @type {number}\n         * @readonly\n         */\n        // For faster access in Point.update\n        point.index = hasGroupedData ? groupCropStartIndex + i : cursor;\n        points[i] = point;\n      }\n    }\n    // restore keys options (#6590)\n    series.options.keys = keys;\n    // Hide cropped-away points - this only runs when the number of\n    // points is above cropThreshold, or when swithching view from\n    // non-grouped data to grouped data (#637)\n    if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {\n      for (i = 0; i < dataLength; i++) {\n        // when has grouped data, clear all points\n        if (i === cropStart && !hasGroupedData) {\n          i += processedDataLength;\n        }\n        if (data[i]) {\n          data[i].destroyElements();\n          data[i].plotX = void 0; // #1003\n        }\n      }\n    }\n    /**\n     * Read only. An array containing those values converted to points.\n     * In case the series data length exceeds the `cropThreshold`, or if\n     * the data is grouped, `series.data` doesn't contain all the\n     * points. Also, in case a series is hidden, the `data` array may be\n     * empty. To access raw values, `series.options.data` will always be\n     * up to date. `Series.data` only contains the points that have been\n     * created on demand. To modify the data, use\n     * {@link Highcharts.Series#setData} or\n     * {@link Highcharts.Point#update}.\n     *\n     * @see Series.points\n     *\n     * @name Highcharts.Series#data\n     * @type {Array<Highcharts.Point>}\n     */\n    series.data = data;\n    /**\n     * An array containing all currently visible point objects. In case\n     * of cropping, the cropped-away points are not part of this array.\n     * The `series.points` array starts at `series.cropStart` compared\n     * to `series.data` and `series.options.data`. If however the series\n     * data is grouped, these can't be correlated one to one. To modify\n     * the data, use {@link Highcharts.Series#setData} or\n     * {@link Highcharts.Point#update}.\n     *\n     * @name Highcharts.Series#points\n     * @type {Array<Highcharts.Point>}\n     */\n    series.points = points;\n    fireEvent(this, 'afterGeneratePoints');\n  }\n  /**\n   * Get current X extremes for the visible data.\n   *\n   * @private\n   * @function Highcharts.Series#getXExtremes\n   * @param {Array<number>} xData\n   * The data to inspect. Defaults to the current data within the visible\n   * range.\n   */\n  getXExtremes(xData) {\n    return {\n      min: arrayMin(xData),\n      max: arrayMax(xData)\n    };\n  }\n  /**\n   * Calculate Y extremes for the visible data. The result is returned\n   * as an object with `dataMin` and `dataMax` properties.\n   *\n   * @private\n   * @function Highcharts.Series#getExtremes\n   * @param {Array<number>} [yData]\n   * The data to inspect. Defaults to the current data within the visible\n   * range.\n   * @param {boolean} [forceExtremesFromAll]\n   * Force getting extremes of a total series data range.\n   */\n  getExtremes(yData, forceExtremesFromAll) {\n    const xAxis = this.xAxis,\n      yAxis = this.yAxis,\n      xData = this.processedXData || this.xData,\n      activeYData = [],\n      // Handle X outside the viewed area. This does not work with\n      // non-sorted data like scatter (#7639).\n      shoulder = this.requireSorting && !this.is('column') ? 1 : 0,\n      // #2117, need to compensate for log X axis\n      positiveValuesOnly = yAxis ? yAxis.positiveValuesOnly : false;\n    let xExtremes,\n      validValue,\n      withinRange,\n      x,\n      y,\n      i,\n      j,\n      xMin = 0,\n      xMax = 0,\n      activeCounter = 0;\n    yData = yData || this.stackedYData || this.processedYData || [];\n    const yDataLength = yData.length;\n    if (xAxis) {\n      xExtremes = xAxis.getExtremes();\n      xMin = xExtremes.min;\n      xMax = xExtremes.max;\n    }\n    for (i = 0; i < yDataLength; i++) {\n      x = xData[i];\n      y = yData[i];\n      // For points within the visible range, including the first\n      // point outside the visible range (#7061), consider y extremes.\n      validValue = (isNumber(y) || isArray(y)) && ((isNumber(y) ? y > 0 : y.length) || !positiveValuesOnly);\n      withinRange = forceExtremesFromAll || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !xAxis ||\n      // for colorAxis support\n      (xData[i + shoulder] || x) >= xMin && (xData[i - shoulder] || x) <= xMax;\n      if (validValue && withinRange) {\n        j = y.length;\n        if (j) {\n          // array, like ohlc or range data\n          while (j--) {\n            if (isNumber(y[j])) {\n              // #7380, #11513\n              activeYData[activeCounter++] = y[j];\n            }\n          }\n        } else {\n          activeYData[activeCounter++] = y;\n        }\n      }\n    }\n    const dataExtremes = {\n      activeYData,\n      dataMin: arrayMin(activeYData),\n      dataMax: arrayMax(activeYData)\n    };\n    fireEvent(this, 'afterGetExtremes', {\n      dataExtremes\n    });\n    return dataExtremes;\n  }\n  /**\n   * Set the current data extremes as `dataMin` and `dataMax` on the\n   * Series item. Use this only when the series properties should be\n   * updated.\n   *\n   * @private\n   * @function Highcharts.Series#applyExtremes\n   */\n  applyExtremes() {\n    const dataExtremes = this.getExtremes();\n    /**\n     * Contains the minimum value of the series' data point. Some series\n     * types like `networkgraph` do not support this property as they\n     * lack a `y`-value.\n     * @name Highcharts.Series#dataMin\n     * @type {number|undefined}\n     * @readonly\n     */\n    this.dataMin = dataExtremes.dataMin;\n    /**\n     * Contains the maximum value of the series' data point. Some series\n     * types like `networkgraph` do not support this property as they\n     * lack a `y`-value.\n     * @name Highcharts.Series#dataMax\n     * @type {number|undefined}\n     * @readonly\n     */\n    this.dataMax = dataExtremes.dataMax;\n    return dataExtremes;\n  }\n  /**\n   * Find and return the first non null point in the data\n   *\n   * @private\n   * @function Highcharts.Series.getFirstValidPoint\n   * @param {Array<Highcharts.PointOptionsType>} data\n   * Array of options for points\n   */\n  getFirstValidPoint(data) {\n    const dataLength = data.length;\n    let i = 0,\n      firstPoint = null;\n    while (firstPoint === null && i < dataLength) {\n      firstPoint = data[i];\n      i++;\n    }\n    return firstPoint;\n  }\n  /**\n   * Translate data points from raw data values to chart specific\n   * positioning data needed later in the `drawPoints` and `drawGraph`\n   * functions. This function can be overridden in plugins and custom\n   * series type implementations.\n   *\n   * @function Highcharts.Series#translate\n   *\n   * @emits Highcharts.Series#events:translate\n   */\n  translate() {\n    if (!this.processedXData) {\n      // hidden series\n      this.processData();\n    }\n    this.generatePoints();\n    const series = this,\n      options = series.options,\n      stacking = options.stacking,\n      xAxis = series.xAxis,\n      categories = xAxis.categories,\n      enabledDataSorting = series.enabledDataSorting,\n      yAxis = series.yAxis,\n      points = series.points,\n      dataLength = points.length,\n      pointPlacement = series.pointPlacementToXValue(),\n      // #7860\n      dynamicallyPlaced = Boolean(pointPlacement),\n      threshold = options.threshold,\n      stackThreshold = options.startFromThreshold ? threshold : 0;\n    let i,\n      plotX,\n      lastPlotX,\n      stackIndicator,\n      closestPointRangePx = Number.MAX_VALUE;\n    /**\n     * Plotted coordinates need to be within a limited range. Drawing\n     * too far outside the viewport causes various rendering issues\n     * (#3201, #3923, #7555).\n     * @private\n     */\n    function limitedRange(val) {\n      return clamp(val, -1e5, 1e5);\n    }\n    // Translate each point\n    for (i = 0; i < dataLength; i++) {\n      const point = points[i],\n        xValue = point.x;\n      let stackItem,\n        stackValues,\n        yValue = point.y,\n        lowValue = point.low;\n      const stacks = stacking && yAxis.stacking?.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey];\n      plotX = xAxis.translate(\n      // #3923\n      xValue, false, false, false, true, pointPlacement);\n      /**\n       * The translated X value for the point in terms of pixels. Relative\n       * to the X axis position if the series has one, otherwise relative\n       * to the plot area. Depending on the series type this value might\n       * not be defined.\n       *\n       * In an inverted chart the x-axis is going from the bottom to the\n       * top so the `plotX` value is the number of pixels from the bottom\n       * of the axis.\n       *\n       * @see Highcharts.Point#pos\n       * @name Highcharts.Point#plotX\n       * @type {number|undefined}\n       */\n      point.plotX = isNumber(plotX) ? correctFloat(\n      // #5236\n      limitedRange(plotX) // #3923\n      ) : void 0;\n      // Calculate the bottom y value for stacked series\n      if (stacking && series.visible && stacks && stacks[xValue]) {\n        stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);\n        if (!point.isNull && stackIndicator.key) {\n          stackItem = stacks[xValue];\n          stackValues = stackItem.points[stackIndicator.key];\n        }\n        if (stackItem && isArray(stackValues)) {\n          lowValue = stackValues[0];\n          yValue = stackValues[1];\n          if (lowValue === stackThreshold && stackIndicator.key === stacks[xValue].base) {\n            lowValue = pick(isNumber(threshold) ? threshold : yAxis.min);\n          }\n          // #1200, #1232\n          if (yAxis.positiveValuesOnly && defined(lowValue) && lowValue <= 0) {\n            lowValue = void 0;\n          }\n          point.total = point.stackTotal = pick(stackItem.total);\n          point.percentage = defined(point.y) && stackItem.total ? point.y / stackItem.total * 100 : void 0;\n          point.stackY = yValue;\n          // in case of variwide series (where widths of points are\n          // different in most cases), stack labels are positioned\n          // wrongly, so the call of the setOffset is omited here and\n          // labels are correctly positioned later, at the end of the\n          // variwide's translate function (#10962)\n          if (!series.irregularWidths) {\n            stackItem.setOffset(series.pointXOffset || 0, series.barW || 0, void 0, void 0, void 0, series.xAxis);\n          }\n        }\n      }\n      // Set translated yBottom or remove it\n      point.yBottom = defined(lowValue) ? limitedRange(yAxis.translate(lowValue, false, true, false, true)) : void 0;\n      // General hook, used for Highcharts Stock compare and cumulative\n      if (series.dataModify) {\n        yValue = series.dataModify.modifyValue(yValue, i);\n      }\n      // Set the the plotY value, reset it for redraws #3201, #18422\n      let plotY;\n      if (isNumber(yValue) && point.plotX !== void 0) {\n        plotY = yAxis.translate(yValue, false, true, false, true);\n        plotY = isNumber(plotY) ? limitedRange(plotY) : void 0;\n      }\n      /**\n       * The translated Y value for the point in terms of pixels. Relative\n       * to the Y axis position if the series has one, otherwise relative\n       * to the plot area. Depending on the series type this value might\n       * not be defined.\n       *\n       * In an inverted chart the y-axis is going from right to left\n       * so the `plotY` value is the number of pixels from the right\n       * of the `yAxis`.\n       *\n       * @see Highcharts.Point#pos\n       * @name Highcharts.Point#plotY\n       * @type {number|undefined}\n       */\n      point.plotY = plotY;\n      point.isInside = this.isPointInside(point);\n      // Set client related positions for mouse tracking\n      point.clientX = dynamicallyPlaced ? correctFloat(xAxis.translate(xValue, false, false, false, true, pointPlacement)) : plotX; // #1514, #5383, #5518\n      // Negative points #19028\n      point.negative = (point.y || 0) < (threshold || 0);\n      // some API data\n      point.category = pick(categories && categories[point.x], point.x);\n      // Determine auto enabling of markers (#3635, #5099)\n      if (!point.isNull && point.visible !== false) {\n        if (typeof lastPlotX !== 'undefined') {\n          closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));\n        }\n        lastPlotX = plotX;\n      }\n      // Find point zone\n      point.zone = this.zones.length ? point.getZone() : void 0;\n      // Animate new points with data sorting\n      if (!point.graphic && series.group && enabledDataSorting) {\n        point.isNew = true;\n      }\n    }\n    series.closestPointRangePx = closestPointRangePx;\n    fireEvent(this, 'afterTranslate');\n  }\n  /**\n   * Return the series points with null points filtered out.\n   *\n   * @function Highcharts.Series#getValidPoints\n   *\n   * @param {Array<Highcharts.Point>} [points]\n   * The points to inspect, defaults to {@link Series.points}.\n   *\n   * @param {boolean} [insideOnly=false]\n   * Whether to inspect only the points that are inside the visible view.\n   *\n   * @param {boolean} [allowNull=false]\n   * Whether to allow null points to pass as valid points.\n   *\n   * @return {Array<Highcharts.Point>}\n   * The valid points.\n   */\n  getValidPoints(points, insideOnly, allowNull) {\n    const chart = this.chart;\n    // #3916, #5029, #5085\n    return (points || this.points || []).filter(function (point) {\n      const {\n          plotX,\n          plotY\n        } = point,\n        // Undefined plotY is treated as null when negative values\n        // in log axis (#18422)\n        asNull = !allowNull && (point.isNull || !isNumber(plotY));\n      if (asNull || insideOnly && !chart.isInsidePlot(plotX, plotY, {\n        inverted: chart.inverted\n      })) {\n        return false;\n      }\n      return point.visible !== false;\n    });\n  }\n  /**\n   * Get the clipping for the series. Could be called for a series to\n   * initiate animating the clip or to set the final clip (only width\n   * and x).\n   *\n   * @private\n   * @function Highcharts.Series#getClip\n   */\n  getClipBox() {\n    const {\n      chart,\n      xAxis,\n      yAxis\n    } = this;\n    // If no axes on the series, use global clipBox\n    const seriesBox = merge(chart.clipBox);\n    // Otherwise, use clipBox.width which is corrected for plotBorderWidth\n    // and clipOffset\n    if (xAxis && xAxis.len !== chart.plotSizeX) {\n      seriesBox.width = xAxis.len;\n    }\n    if (yAxis && yAxis.len !== chart.plotSizeY) {\n      seriesBox.height = yAxis.len;\n    }\n    return seriesBox;\n  }\n  /**\n   * Get the shared clip key, creating it if it doesn't exist.\n   *\n   * @private\n   * @function Highcharts.Series#getSharedClipKey\n   */\n  getSharedClipKey() {\n    this.sharedClipKey = (this.options.xAxis || 0) + ',' + (this.options.yAxis || 0);\n    return this.sharedClipKey;\n  }\n  /**\n   * Set the clipping for the series. For animated series the clip is later\n   * modified.\n   *\n   * @private\n   * @function Highcharts.Series#setClip\n   */\n  setClip() {\n    const {\n        chart,\n        group,\n        markerGroup\n      } = this,\n      sharedClips = chart.sharedClips,\n      renderer = chart.renderer,\n      clipBox = this.getClipBox(),\n      sharedClipKey = this.getSharedClipKey(); // #4526\n    let clipRect = sharedClips[sharedClipKey];\n    // If a clipping rectangle for the same set of axes does not exist,\n    // create it\n    if (!clipRect) {\n      sharedClips[sharedClipKey] = clipRect = renderer.clipRect(clipBox);\n      // When setting chart size, or when the series is rendered again before\n      // starting animating, in compliance to a responsive rule\n    } else {\n      clipRect.animate(clipBox);\n    }\n    if (group) {\n      // When clip is false, reset to no clip after animation\n      group.clip(this.options.clip === false ? void 0 : clipRect);\n    }\n    // Unclip temporary animation clip\n    if (markerGroup) {\n      markerGroup.clip();\n    }\n  }\n  /**\n   * Animate in the series. Called internally twice. First with the `init`\n   * parameter set to true, which sets up the initial state of the\n   * animation. Then when ready, it is called with the `init` parameter\n   * undefined, in order to perform the actual animation.\n   *\n   * @function Highcharts.Series#animate\n   *\n   * @param {boolean} [init]\n   * Initialize the animation.\n   */\n  animate(init) {\n    const {\n        chart,\n        group,\n        markerGroup\n      } = this,\n      inverted = chart.inverted,\n      animation = animObject(this.options.animation),\n      // The key for temporary animation clips\n      animationClipKey = [this.getSharedClipKey(), animation.duration, animation.easing, animation.defer].join(',');\n    let animationClipRect = chart.sharedClips[animationClipKey],\n      markerAnimationClipRect = chart.sharedClips[animationClipKey + 'm'];\n    // Initialize the animation. Set up the clipping rectangle.\n    if (init && group) {\n      const clipBox = this.getClipBox();\n      // Create temporary animation clips\n      if (!animationClipRect) {\n        clipBox.width = 0;\n        if (inverted) {\n          clipBox.x = chart.plotHeight;\n        }\n        animationClipRect = chart.renderer.clipRect(clipBox);\n        chart.sharedClips[animationClipKey] = animationClipRect;\n        // The marker clip box. The number 99 is a safe margin to avoid\n        // markers being clipped during animation.\n        const markerClipBox = {\n          x: inverted ? -99 : -99,\n          y: inverted ? -99 : -99,\n          width: inverted ? chart.plotWidth + 199 : 99,\n          height: inverted ? 99 : chart.plotHeight + 199\n        };\n        markerAnimationClipRect = chart.renderer.clipRect(markerClipBox);\n        chart.sharedClips[animationClipKey + 'm'] = markerAnimationClipRect;\n      } else {\n        // When height changes during animation, typically due to\n        // responsive settings\n        animationClipRect.attr('height', clipBox.height);\n      }\n      group.clip(animationClipRect);\n      if (markerGroup) {\n        markerGroup.clip(markerAnimationClipRect);\n      }\n      // Run the animation\n    } else if (animationClipRect &&\n    // Only first series in this pane\n    !animationClipRect.hasClass('highcharts-animating')) {\n      const finalBox = this.getClipBox(),\n        step = animation.step;\n      // Only do this when there are actually markers\n      if (markerGroup && markerGroup.element.childNodes.length) {\n        // To provide as smooth animation as possible, update the marker\n        // group clipping in steps of the main group animation\n        animation.step = function (val, fx) {\n          if (step) {\n            step.apply(fx, arguments);\n          }\n          if (fx.prop === 'width' && markerAnimationClipRect && markerAnimationClipRect.element) {\n            markerAnimationClipRect.attr(inverted ? 'height' : 'width', val + 99);\n          }\n        };\n      }\n      animationClipRect.addClass('highcharts-animating').animate(finalBox, animation);\n    }\n  }\n  /**\n   * This runs after animation to land on the final plot clipping.\n   *\n   * @private\n   * @function Highcharts.Series#afterAnimate\n   *\n   * @emits Highcharts.Series#event:afterAnimate\n   */\n  afterAnimate() {\n    this.setClip();\n    // Destroy temporary clip rectangles that are no longer in use\n    objectEach(this.chart.sharedClips, (clip, key, sharedClips) => {\n      if (clip && !this.chart.container.querySelector(`[clip-path=\"url(#${clip.id})\"]`)) {\n        clip.destroy();\n        delete sharedClips[key];\n      }\n    });\n    this.finishedAnimating = true;\n    fireEvent(this, 'afterAnimate');\n  }\n  /**\n   * Draw the markers for line-like series types, and columns or other\n   * graphical representation for {@link Point} objects for other series\n   * types. The resulting element is typically stored as\n   * {@link Point.graphic}, and is created on the first call and updated\n   * and moved on subsequent calls.\n   *\n   * @function Highcharts.Series#drawPoints\n   */\n  drawPoints(points = this.points) {\n    const series = this,\n      chart = series.chart,\n      styledMode = chart.styledMode,\n      {\n        colorAxis,\n        options\n      } = series,\n      seriesMarkerOptions = options.marker,\n      markerGroup = series[series.specialGroup || 'markerGroup'],\n      xAxis = series.xAxis,\n      globallyEnabled = pick(seriesMarkerOptions.enabled, !xAxis || xAxis.isRadial ? true : null,\n      // Use larger or equal as radius is null in bubbles (#6321)\n      series.closestPointRangePx >= seriesMarkerOptions.enabledThreshold * seriesMarkerOptions.radius);\n    let i, point, graphic, verb, pointMarkerOptions, hasPointMarker, markerAttribs;\n    if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {\n      for (i = 0; i < points.length; i++) {\n        point = points[i];\n        graphic = point.graphic;\n        verb = graphic ? 'animate' : 'attr';\n        pointMarkerOptions = point.marker || {};\n        hasPointMarker = !!point.marker;\n        const shouldDrawMarker = (globallyEnabled && typeof pointMarkerOptions.enabled === 'undefined' || pointMarkerOptions.enabled) && !point.isNull && point.visible !== false;\n        // only draw the point if y is defined\n        if (shouldDrawMarker) {\n          // Shortcuts\n          const symbol = pick(pointMarkerOptions.symbol, series.symbol, 'rect');\n          markerAttribs = series.markerAttribs(point, point.selected && 'select');\n          // Set starting position for point sliding animation.\n          if (series.enabledDataSorting) {\n            point.startXPos = xAxis.reversed ? -(markerAttribs.width || 0) : xAxis.width;\n          }\n          const isInside = point.isInside !== false;\n          if (!graphic && isInside && ((markerAttribs.width || 0) > 0 || point.hasImage)) {\n            /**\n             * SVG graphic representing the point in the chart. In\n             * some cases it may be a hidden graphic to improve\n             * accessibility.\n             *\n             * Typically this is a simple shape, like a `rect`\n             * for column charts or `path` for line markers, but\n             * for some complex series types like boxplot or 3D\n             * charts, the graphic may be a `g` element\n             * containing other shapes. The graphic is generated\n             * the first time {@link Series#drawPoints} runs,\n             * and updated and moved on subsequent runs.\n             *\n             * @see Highcharts.Point#graphics\n             *\n             * @name Highcharts.Point#graphic\n             * @type {Highcharts.SVGElement|undefined}\n             */\n            point.graphic = graphic = chart.renderer.symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ? pointMarkerOptions : seriesMarkerOptions).add(markerGroup);\n            // Sliding animation for new points\n            if (series.enabledDataSorting && chart.hasRendered) {\n              graphic.attr({\n                x: point.startXPos\n              });\n              verb = 'animate';\n            }\n          }\n          if (graphic && verb === 'animate') {\n            // update\n            // Since the marker group isn't clipped, each\n            // individual marker must be toggled\n            graphic[isInside ? 'show' : 'hide'](isInside).animate(markerAttribs);\n          }\n          // Presentational attributes\n          if (graphic) {\n            const pointAttr = series.pointAttribs(point, styledMode || !point.selected ? void 0 : 'select');\n            if (!styledMode) {\n              graphic[verb](pointAttr);\n            } else if (colorAxis) {\n              // #14114\n              graphic['css']({\n                fill: pointAttr.fill\n              });\n            }\n          }\n          if (graphic) {\n            graphic.addClass(point.getClassName(), true);\n          }\n        } else if (graphic) {\n          point.graphic = graphic.destroy(); // #1269\n        }\n      }\n    }\n  }\n  /**\n   * Get non-presentational attributes for a point. Used internally for\n   * both styled mode and classic. Can be overridden for different series\n   * types.\n   *\n   * @see Series#pointAttribs\n   *\n   * @function Highcharts.Series#markerAttribs\n   *\n   * @param {Highcharts.Point} point\n   * The Point to inspect.\n   *\n   * @param {string} [state]\n   * The state, can be either `hover`, `select` or undefined.\n   *\n   * @return {Highcharts.SVGAttributes}\n   * A hash containing those attributes that are not settable from CSS.\n   */\n  markerAttribs(point, state) {\n    const seriesOptions = this.options,\n      seriesMarkerOptions = seriesOptions.marker,\n      pointMarkerOptions = point.marker || {},\n      symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol,\n      attribs = {};\n    let seriesStateOptions,\n      pointStateOptions,\n      radius = pick(pointMarkerOptions.radius, seriesMarkerOptions && seriesMarkerOptions.radius);\n    // Handle hover and select states\n    if (state) {\n      seriesStateOptions = seriesMarkerOptions.states[state];\n      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state];\n      radius = pick(pointStateOptions && pointStateOptions.radius, seriesStateOptions && seriesStateOptions.radius, radius && radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0));\n    }\n    point.hasImage = symbol && symbol.indexOf('url') === 0;\n    if (point.hasImage) {\n      radius = 0; // and subsequently width and height is not set\n    }\n\n    const pos = point.pos();\n    if (isNumber(radius) && pos) {\n      attribs.x = pos[0] - radius;\n      attribs.y = pos[1] - radius;\n      if (seriesOptions.crisp) {\n        // Math.floor for #1843:\n        attribs.x = Math.floor(attribs.x);\n      }\n    }\n    if (radius) {\n      attribs.width = attribs.height = 2 * radius;\n    }\n    return attribs;\n  }\n  /**\n   * Internal function to get presentational attributes for each point.\n   * Unlike {@link Series#markerAttribs}, this function should return\n   * those attributes that can also be set in CSS. In styled mode,\n   * `pointAttribs` won't be called.\n   *\n   * @private\n   * @function Highcharts.Series#pointAttribs\n   *\n   * @param {Highcharts.Point} [point]\n   * The point instance to inspect.\n   *\n   * @param {string} [state]\n   * The point state, can be either `hover`, `select` or 'normal'. If\n   * undefined, normal state is assumed.\n   *\n   * @return {Highcharts.SVGAttributes}\n   * The presentational attributes to be set on the point.\n   */\n  pointAttribs(point, state) {\n    const seriesMarkerOptions = this.options.marker,\n      pointOptions = point && point.options,\n      pointMarkerOptions = pointOptions && pointOptions.marker || {},\n      pointColorOption = pointOptions && pointOptions.color,\n      pointColor = point && point.color,\n      zoneColor = point && point.zone && point.zone.color;\n    let seriesStateOptions,\n      pointStateOptions,\n      color = this.color,\n      fill,\n      stroke,\n      strokeWidth = pick(pointMarkerOptions.lineWidth, seriesMarkerOptions.lineWidth),\n      opacity = 1;\n    color = pointColorOption || zoneColor || pointColor || color;\n    fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color;\n    stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color;\n    // Handle hover and select states\n    state = state || 'normal';\n    if (state) {\n      seriesStateOptions = seriesMarkerOptions.states[state] || {};\n      pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};\n      strokeWidth = pick(pointStateOptions.lineWidth, seriesStateOptions.lineWidth, strokeWidth + pick(pointStateOptions.lineWidthPlus, seriesStateOptions.lineWidthPlus, 0));\n      fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;\n      stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;\n      opacity = pick(pointStateOptions.opacity, seriesStateOptions.opacity, opacity);\n    }\n    return {\n      'stroke': stroke,\n      'stroke-width': strokeWidth,\n      'fill': fill,\n      'opacity': opacity\n    };\n  }\n  /**\n   * Clear DOM objects and free up memory.\n   *\n   * @private\n   * @function Highcharts.Series#destroy\n   *\n   * @emits Highcharts.Series#event:destroy\n   */\n  destroy(keepEventsForUpdate) {\n    const series = this,\n      chart = series.chart,\n      issue134 = /AppleWebKit\\/533/.test(win.navigator.userAgent),\n      data = series.data || [];\n    let destroy, i, point, axis;\n    // add event hook\n    fireEvent(series, 'destroy', {\n      keepEventsForUpdate\n    });\n    // remove events\n    this.removeEvents(keepEventsForUpdate);\n    // erase from axes\n    (series.axisTypes || []).forEach(function (AXIS) {\n      axis = series[AXIS];\n      if (axis && axis.series) {\n        erase(axis.series, series);\n        axis.isDirty = axis.forceRedraw = true;\n      }\n    });\n    // remove legend items\n    if (series.legendItem) {\n      series.chart.legend.destroyItem(series);\n    }\n    // destroy all points with their elements\n    i = data.length;\n    while (i--) {\n      point = data[i];\n      if (point && point.destroy) {\n        point.destroy();\n      }\n    }\n    if (series.clips) {\n      series.clips.forEach(clip => clip.destroy());\n    }\n    // Clear the animation timeout if we are destroying the series\n    // during initial animation\n    U.clearTimeout(series.animationTimeout);\n    // Destroy all SVGElements associated to the series\n    objectEach(series, function (val, prop) {\n      // Survive provides a hook for not destroying\n      if (val instanceof SVGElement && !val.survive) {\n        // issue 134 workaround\n        destroy = issue134 && prop === 'group' ? 'hide' : 'destroy';\n        val[destroy]();\n      }\n    });\n    // remove from hoverSeries\n    if (chart.hoverSeries === series) {\n      chart.hoverSeries = void 0;\n    }\n    erase(chart.series, series);\n    chart.orderItems('series');\n    // clear all members\n    objectEach(series, function (val, prop) {\n      if (!keepEventsForUpdate || prop !== 'hcEvents') {\n        delete series[prop];\n      }\n    });\n  }\n  /**\n   * Clip the graphs into zones for colors and styling.\n   *\n   * @private\n   * @function Highcharts.Series#applyZones\n   */\n  applyZones() {\n    const series = this,\n      chart = this.chart,\n      renderer = chart.renderer,\n      zones = this.zones,\n      clips = this.clips || [],\n      graph = this.graph,\n      area = this.area,\n      plotSizeMax = Math.max(chart.plotWidth, chart.plotHeight),\n      axis = this[(this.zoneAxis || 'y') + 'Axis'],\n      inverted = chart.inverted;\n    let translatedFrom,\n      translatedTo,\n      clipAttr,\n      extremes,\n      reversed,\n      horiz,\n      pxRange,\n      pxPosMin,\n      pxPosMax,\n      zoneArea,\n      zoneGraph,\n      ignoreZones = false;\n    if (zones.length && (graph || area) && axis && typeof axis.min !== 'undefined') {\n      reversed = axis.reversed;\n      horiz = axis.horiz;\n      // The use of the Color Threshold assumes there are no gaps\n      // so it is safe to hide the original graph and area\n      // unless it is not waterfall series, then use showLine property\n      // to set lines between columns to be visible (#7862)\n      if (graph && !this.showLine) {\n        graph.hide();\n      }\n      if (area) {\n        area.hide();\n      }\n      // Create the clips\n      extremes = axis.getExtremes();\n      zones.forEach(function (threshold, i) {\n        translatedFrom = reversed ? horiz ? chart.plotWidth : 0 : horiz ? 0 : axis.toPixels(extremes.min) || 0;\n        translatedFrom = clamp(pick(translatedTo, translatedFrom), 0, plotSizeMax);\n        translatedTo = clamp(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true) || 0), 0, plotSizeMax);\n        if (ignoreZones) {\n          translatedFrom = translatedTo = axis.toPixels(extremes.max);\n        }\n        pxRange = Math.abs(translatedFrom - translatedTo);\n        pxPosMin = Math.min(translatedFrom, translatedTo);\n        pxPosMax = Math.max(translatedFrom, translatedTo);\n        if (axis.isXAxis) {\n          clipAttr = {\n            x: inverted ? pxPosMax : pxPosMin,\n            y: 0,\n            width: pxRange,\n            height: plotSizeMax\n          };\n          if (!horiz) {\n            clipAttr.x = chart.plotHeight - clipAttr.x;\n          }\n        } else {\n          clipAttr = {\n            x: 0,\n            y: inverted ? pxPosMax : pxPosMin,\n            width: plotSizeMax,\n            height: pxRange\n          };\n          if (horiz) {\n            clipAttr.y = chart.plotWidth - clipAttr.y;\n          }\n        }\n        if (clips[i]) {\n          clips[i].animate(clipAttr);\n        } else {\n          clips[i] = renderer.clipRect(clipAttr);\n        }\n        // when no data, graph zone is not applied and after setData\n        // clip was ignored. As a result, it should be applied each\n        // time.\n        zoneArea = series['zone-area-' + i];\n        zoneGraph = series['zone-graph-' + i];\n        if (graph && zoneGraph) {\n          zoneGraph.clip(clips[i]);\n        }\n        if (area && zoneArea) {\n          zoneArea.clip(clips[i]);\n        }\n        // if this zone extends out of the axis, ignore the others\n        ignoreZones = threshold.value > extremes.max;\n        // Clear translatedTo for indicators\n        if (series.resetZones && translatedTo === 0) {\n          translatedTo = void 0;\n        }\n      });\n      this.clips = clips;\n    } else if (series.visible) {\n      // If zones were removed, restore graph and area\n      if (graph) {\n        graph.show();\n      }\n      if (area) {\n        area.show();\n      }\n    }\n  }\n  /**\n   * General abstraction for creating plot groups like series.group,\n   * series.dataLabelsGroup and series.markerGroup. On subsequent calls,\n   * the group will only be adjusted to the updated plot size.\n   *\n   * @private\n   * @function Highcharts.Series#plotGroup\n   */\n  plotGroup(prop, name, visibility, zIndex, parent) {\n    let group = this[prop];\n    const isNew = !group,\n      attrs = {\n        visibility,\n        zIndex: zIndex || 0.1 // Pointer logic uses this\n      };\n    // Avoid setting undefined opacity, or in styled mode\n    if (typeof this.opacity !== 'undefined' && !this.chart.styledMode && this.state !== 'inactive' // #13719\n    ) {\n      attrs.opacity = this.opacity;\n    }\n    // Generate it on first call\n    if (isNew) {\n      this[prop] = group = this.chart.renderer.g().add(parent);\n    }\n    // Add the class names, and replace existing ones as response to\n    // Series.update (#6660)\n    group.addClass('highcharts-' + name + ' highcharts-series-' + this.index + ' highcharts-' + this.type + '-series ' + (defined(this.colorIndex) ? 'highcharts-color-' + this.colorIndex + ' ' : '') + (this.options.className || '') + (group.hasClass('highcharts-tracker') ? ' highcharts-tracker' : ''), true);\n    // Place it on first and subsequent (redraw) calls\n    group.attr(attrs)[isNew ? 'attr' : 'animate'](this.getPlotBox(name));\n    return group;\n  }\n  /**\n   * Get the translation and scale for the plot area of this series.\n   *\n   * @function Highcharts.Series#getPlotBox\n   */\n  getPlotBox(name) {\n    let horAxis = this.xAxis,\n      vertAxis = this.yAxis;\n    const chart = this.chart,\n      inverted = chart.inverted && !chart.polar && horAxis && this.invertible !== false && name === 'series';\n    // Swap axes for inverted (#2339)\n    if (chart.inverted) {\n      horAxis = vertAxis;\n      vertAxis = this.xAxis;\n    }\n    return {\n      translateX: horAxis ? horAxis.left : chart.plotLeft,\n      translateY: vertAxis ? vertAxis.top : chart.plotTop,\n      rotation: inverted ? 90 : 0,\n      rotationOriginX: inverted ? (horAxis.len - vertAxis.len) / 2 : 0,\n      rotationOriginY: inverted ? (horAxis.len + vertAxis.len) / 2 : 0,\n      scaleX: inverted ? -1 : 1,\n      scaleY: 1\n    };\n  }\n  /**\n   * Removes the event handlers attached previously with addEvents.\n   * @private\n   * @function Highcharts.Series#removeEvents\n   */\n  removeEvents(keepEventsForUpdate) {\n    const series = this;\n    if (!keepEventsForUpdate) {\n      // remove all events\n      removeEvent(series);\n    }\n    if (series.eventsToUnbind.length) {\n      // remove only internal events for proper update\n      // #12355 - solves problem with multiple destroy events\n      series.eventsToUnbind.forEach(function (unbind) {\n        unbind();\n      });\n      series.eventsToUnbind.length = 0;\n    }\n  }\n  /**\n   * Render the graph and markers. Called internally when first rendering\n   * and later when redrawing the chart. This function can be extended in\n   * plugins, but normally shouldn't be called directly.\n   *\n   * @function Highcharts.Series#render\n   *\n   * @emits Highcharts.Series#event:afterRender\n   */\n  render() {\n    const series = this,\n      chart = series.chart,\n      options = series.options,\n      animOptions = animObject(options.animation),\n      visibility = series.visible ? 'inherit' : 'hidden',\n      // #2597\n      zIndex = options.zIndex,\n      hasRendered = series.hasRendered,\n      chartSeriesGroup = chart.seriesGroup,\n      inverted = chart.inverted;\n    let animDuration = !series.finishedAnimating ? animOptions.duration : 0;\n    fireEvent(this, 'render');\n    // the group\n    const group = series.plotGroup('group', 'series', visibility, zIndex, chartSeriesGroup);\n    series.markerGroup = series.plotGroup('markerGroup', 'markers', visibility, zIndex, chartSeriesGroup);\n    // Initial clipping, applies to columns etc. (#3839).\n    if (options.clip !== false) {\n      series.setClip();\n    }\n    // Initialize the animation\n    if (series.animate && animDuration) {\n      series.animate(true);\n    }\n    // Draw the graph if any\n    if (series.drawGraph) {\n      series.drawGraph();\n      series.applyZones();\n    }\n    // Draw the points\n    if (series.visible) {\n      series.drawPoints();\n    }\n    // Draw the data labels\n    if (series.drawDataLabels) {\n      series.drawDataLabels();\n    }\n    // In pie charts, slices are added to the DOM, but actual rendering\n    // is postponed until labels reserved their space\n    if (series.redrawPoints) {\n      series.redrawPoints();\n    }\n    // Draw the mouse tracking area\n    if (series.drawTracker && options.enableMouseTracking) {\n      series.drawTracker();\n    }\n    // Run the animation\n    if (series.animate && animDuration) {\n      series.animate();\n    }\n    // Call the afterAnimate function on animation complete (but don't\n    // overwrite the animation.complete option which should be available\n    // to the user).\n    if (!hasRendered) {\n      // Additional time if defer is defined before afterAnimate\n      // will be triggered\n      if (animDuration && animOptions.defer) {\n        animDuration += animOptions.defer;\n      }\n      series.animationTimeout = syncTimeout(function () {\n        series.afterAnimate();\n      }, animDuration || 0);\n    }\n    // Means data is in accordance with what you see\n    series.isDirty = false;\n    // (See #322) series.isDirty = series.isDirtyData = false; // means\n    // data is in accordance with what you see\n    series.hasRendered = true;\n    fireEvent(series, 'afterRender');\n  }\n  /**\n   * Redraw the series. This function is called internally from\n   * `chart.redraw` and normally shouldn't be called directly.\n   * @private\n   * @function Highcharts.Series#redraw\n   */\n  redraw() {\n    // Cache it here as it is set to false in render, but used after\n    const wasDirty = this.isDirty || this.isDirtyData;\n    this.translate();\n    this.render();\n    if (wasDirty) {\n      // #3868, #3945\n      delete this.kdTree;\n    }\n  }\n  /**\n   * Whether to reserve space for the series, either because it is visible or\n   * because the `chart.ignoreHiddenSeries` option is false.\n   *\n   * @private\n   */\n  reserveSpace() {\n    return this.visible || !this.chart.options.chart.ignoreHiddenSeries;\n  }\n  /**\n   * Find the nearest point from a pointer event. This applies to series that\n   * use k-d-trees to get the nearest point. Native pointer events must be\n   * normalized using `Pointer.normalize`, that adds `chartX` and `chartY`\n   * properties.\n   *\n   * @sample highcharts/demo/synchronized-charts\n   *         Synchronized charts with tooltips\n   *\n   * @function Highcharts.Series#searchPoint\n   *\n   * @param {Highcharts.PointerEvent} e\n   *        The normalized pointer event\n   * @param {boolean} [compareX=false]\n   *        Search only by the X value, not Y\n   *\n   * @return {Point|undefined}\n   *        The closest point to the pointer event\n   */\n  searchPoint(e, compareX) {\n    const series = this,\n      xAxis = series.xAxis,\n      yAxis = series.yAxis,\n      inverted = series.chart.inverted;\n    return this.searchKDTree({\n      clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,\n      plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos\n    }, compareX, e);\n  }\n  /**\n   * Build the k-d-tree that is used by mouse and touch interaction to get\n   * the closest point. Line-like series typically have a one-dimensional\n   * tree where points are searched along the X axis, while scatter-like\n   * series typically search in two dimensions, X and Y.\n   *\n   * @private\n   * @function Highcharts.Series#buildKDTree\n   */\n  buildKDTree(e) {\n    // Prevent multiple k-d-trees from being built simultaneously\n    // (#6235)\n    this.buildingKdTree = true;\n    const series = this,\n      dimensions = series.options.findNearestPointBy.indexOf('y') > -1 ? 2 : 1;\n    /**\n     * Internal function\n     * @private\n     */\n    function _kdtree(points, depth, dimensions) {\n      const length = points && points.length;\n      let axis, median;\n      if (length) {\n        // alternate between the axis\n        axis = series.kdAxisArray[depth % dimensions];\n        // sort point array\n        points.sort(function (a, b) {\n          return a[axis] - b[axis];\n        });\n        median = Math.floor(length / 2);\n        // build and return nod\n        return {\n          point: points[median],\n          left: _kdtree(points.slice(0, median), depth + 1, dimensions),\n          right: _kdtree(points.slice(median + 1), depth + 1, dimensions)\n        };\n      }\n    }\n    /**\n     * Start the recursive build process with a clone of the points\n     * array and null points filtered out. (#3873)\n     * @private\n     */\n    function startRecursive() {\n      series.kdTree = _kdtree(series.getValidPoints(null,\n      // For line-type series restrict to plot area, but\n      // column-type series not (#3916, #4511)\n      !series.directTouch), dimensions, dimensions);\n      series.buildingKdTree = false;\n    }\n    delete series.kdTree;\n    // For testing tooltips, don't build async. Also if touchstart, we\n    // may be dealing with click events on mobile, so don't delay\n    // (#6817).\n    syncTimeout(startRecursive, series.options.kdNow || e && e.type === 'touchstart' ? 0 : 1);\n  }\n  /**\n   * @private\n   * @function Highcharts.Series#searchKDTree\n   */\n  searchKDTree(point, compareX, e) {\n    const series = this,\n      [kdX, kdY] = this.kdAxisArray,\n      kdComparer = compareX ? 'distX' : 'dist',\n      kdDimensions = (series.options.findNearestPointBy || '').indexOf('y') > -1 ? 2 : 1,\n      useRadius = !!series.isBubble;\n    /**\n     * Set the one and two dimensional distance on the point object.\n     * @private\n     */\n    function setDistance(p1, p2) {\n      const p1kdX = p1[kdX],\n        p2kdX = p2[kdX],\n        x = defined(p1kdX) && defined(p2kdX) ? p1kdX - p2kdX : null,\n        p1kdY = p1[kdY],\n        p2kdY = p2[kdY],\n        y = defined(p1kdY) && defined(p2kdY) ? p1kdY - p2kdY : 0,\n        radius = useRadius ? p2.marker?.radius || 0 : 0;\n      p2.dist = Math.sqrt((x && x * x || 0) + y * y) - radius;\n      p2.distX = defined(x) ? Math.abs(x) - radius : Number.MAX_VALUE;\n    }\n    /**\n     * @private\n     */\n    function _search(search, tree, depth, dimensions) {\n      const point = tree.point,\n        axis = series.kdAxisArray[depth % dimensions];\n      let nPoint1,\n        nPoint2,\n        ret = point;\n      setDistance(search, point);\n      // Pick side based on distance to splitting point\n      const tdist = (search[axis] || 0) - (point[axis] || 0) + (useRadius ? point.marker?.radius || 0 : 0),\n        sideA = tdist < 0 ? 'left' : 'right',\n        sideB = tdist < 0 ? 'right' : 'left';\n      // End of tree\n      if (tree[sideA]) {\n        nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);\n        ret = nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point;\n      }\n      if (tree[sideB]) {\n        // compare distance to current best to splitting point to\n        // decide whether to check side B or not\n        if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {\n          nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);\n          ret = nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret;\n        }\n      }\n      return ret;\n    }\n    if (!this.kdTree && !this.buildingKdTree) {\n      this.buildKDTree(e);\n    }\n    if (this.kdTree) {\n      return _search(point, this.kdTree, kdDimensions, kdDimensions);\n    }\n  }\n  /**\n   * @private\n   * @function Highcharts.Series#pointPlacementToXValue\n   */\n  pointPlacementToXValue() {\n    const {\n      options: {\n        pointPlacement,\n        pointRange\n      },\n      xAxis: axis\n    } = this;\n    let factor = pointPlacement;\n    // Point placement is relative to each series pointRange (#5889)\n    if (factor === 'between') {\n      factor = axis.reversed ? -0.5 : 0.5; // #11955\n    }\n\n    return isNumber(factor) ? factor * (pointRange || axis.pointRange) : 0;\n  }\n  /**\n   * @private\n   * @function Highcharts.Series#isPointInside\n   */\n  isPointInside(point) {\n    const {\n        chart,\n        xAxis,\n        yAxis\n      } = this,\n      isInside = typeof point.plotY !== 'undefined' && typeof point.plotX !== 'undefined' && point.plotY >= 0 && point.plotY <= (yAxis ? yAxis.len : chart.plotHeight) && point.plotX >= 0 && point.plotX <= (xAxis ? xAxis.len : chart.plotWidth);\n    return isInside;\n  }\n  /**\n   * Draw the tracker object that sits above all data labels and markers to\n   * track mouse events on the graph or points. For the line type charts\n   * the tracker uses the same graphPath, but with a greater stroke width\n   * for better control.\n   * @private\n   */\n  drawTracker() {\n    const series = this,\n      options = series.options,\n      trackByArea = options.trackByArea,\n      trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n      // trackerPathLength = trackerPath.length,\n      chart = series.chart,\n      pointer = chart.pointer,\n      renderer = chart.renderer,\n      snap = chart.options.tooltip.snap,\n      tracker = series.tracker,\n      onMouseOver = function (e) {\n        if (options.enableMouseTracking && chart.hoverSeries !== series) {\n          series.onMouseOver();\n        }\n      },\n      /*\n       * Empirical lowest possible opacities for TRACKER_FILL for an\n       * element to stay invisible but clickable\n       * IE9: 0.00000000001 (unlimited)\n       * IE10: 0.0001 (exporting only)\n       * FF: 0.00000000001 (unlimited)\n       * Chrome: 0.000001\n       * Safari: 0.000001\n       * Opera: 0.00000000001 (unlimited)\n       */\n      TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')';\n    let i;\n    // Draw the tracker\n    if (tracker) {\n      tracker.attr({\n        d: trackerPath\n      });\n    } else if (series.graph) {\n      // create\n      series.tracker = renderer.path(trackerPath).attr({\n        visibility: series.visible ? 'inherit' : 'hidden',\n        zIndex: 2\n      }).addClass(trackByArea ? 'highcharts-tracker-area' : 'highcharts-tracker-line').add(series.group);\n      if (!chart.styledMode) {\n        series.tracker.attr({\n          'stroke-linecap': 'round',\n          'stroke-linejoin': 'round',\n          stroke: TRACKER_FILL,\n          fill: trackByArea ? TRACKER_FILL : 'none',\n          'stroke-width': series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap)\n        });\n      }\n      // The tracker is added to the series group, which is clipped, but\n      // is covered by the marker group. So the marker group also needs to\n      // capture events.\n      [series.tracker, series.markerGroup, series.dataLabelsGroup].forEach(function (tracker) {\n        if (tracker) {\n          tracker.addClass('highcharts-tracker').on('mouseover', onMouseOver).on('mouseout', function (e) {\n            pointer.onTrackerMouseOut(e);\n          });\n          if (options.cursor && !chart.styledMode) {\n            tracker.css({\n              cursor: options.cursor\n            });\n          }\n          if (hasTouch) {\n            tracker.on('touchstart', onMouseOver);\n          }\n        }\n      });\n    }\n    fireEvent(this, 'afterDrawTracker');\n  }\n  /**\n   * Add a point to the series after render time. The point can be added at\n   * the end, or by giving it an X value, to the start or in the middle of the\n   * series.\n   *\n   * @sample highcharts/members/series-addpoint-append/\n   *         Append point\n   * @sample highcharts/members/series-addpoint-append-and-shift/\n   *         Append and shift\n   * @sample highcharts/members/series-addpoint-x-and-y/\n   *         Both X and Y values given\n   * @sample highcharts/members/series-addpoint-pie/\n   *         Append pie slice\n   * @sample stock/members/series-addpoint/\n   *         Append 100 points in Highcharts Stock\n   * @sample stock/members/series-addpoint-shift/\n   *         Append and shift in Highcharts Stock\n   * @sample maps/members/series-addpoint/\n   *         Add a point in Highmaps\n   *\n   * @function Highcharts.Series#addPoint\n   *\n   * @param {Highcharts.PointOptionsType} options\n   *        The point options. If options is a single number, a point with\n   *        that y value is appended to the series. If it is an array, it will\n   *        be interpreted as x and y values respectively. If it is an\n   *        object, advanced options as outlined under `series.data` are\n   *        applied.\n   *\n   * @param {boolean} [redraw=true]\n   *        Whether to redraw the chart after the point is added. When adding\n   *        more than one point, it is highly recommended that the redraw\n   *        option be set to false, and instead {@link Chart#redraw} is\n   *        explicitly called after the adding of points is finished.\n   *        Otherwise, the chart will redraw after adding each point.\n   *\n   * @param {boolean} [shift=false]\n   *        If true, a point is shifted off the start of the series as one is\n   *        appended to the end.\n   *\n   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]\n   *        Whether to apply animation, and optionally animation\n   *        configuration.\n   *\n   * @param {boolean} [withEvent=true]\n   *        Used internally, whether to fire the series `addPoint` event.\n   *\n   * @emits Highcharts.Series#event:addPoint\n   */\n  addPoint(options, redraw, shift, animation, withEvent) {\n    const series = this,\n      seriesOptions = series.options,\n      data = series.data,\n      chart = series.chart,\n      xAxis = series.xAxis,\n      names = xAxis && xAxis.hasNames && xAxis.names,\n      dataOptions = seriesOptions.data,\n      xData = series.xData;\n    let isInTheMiddle, i;\n    // Optional redraw, defaults to true\n    redraw = pick(redraw, true);\n    // Get options and push the point to xData, yData and series.options. In\n    // series.generatePoints the Point instance will be created on demand\n    // and pushed to the series.data array.\n    const point = {\n      series: series\n    };\n    series.pointClass.prototype.applyOptions.apply(point, [options]);\n    const x = point.x;\n    // Get the insertion point\n    i = xData.length;\n    if (series.requireSorting && x < xData[i - 1]) {\n      isInTheMiddle = true;\n      while (i && xData[i - 1] > x) {\n        i--;\n      }\n    }\n    // Insert undefined item\n    series.updateParallelArrays(point, 'splice', [i, 0, 0]);\n    // Update it\n    series.updateParallelArrays(point, i);\n    if (names && point.name) {\n      names[x] = point.name;\n    }\n    dataOptions.splice(i, 0, options);\n    if (isInTheMiddle ||\n    // When processedData is present we need to splice an empty slot\n    // into series.data, otherwise generatePoints won't pick it up.\n    series.processedData) {\n      series.data.splice(i, 0, null);\n      series.processData();\n    }\n    // Generate points to be added to the legend (#1329)\n    if (seriesOptions.legendType === 'point') {\n      series.generatePoints();\n    }\n    // Shift the first point off the parallel arrays\n    if (shift) {\n      if (data[0] && !!data[0].remove) {\n        data[0].remove(false);\n      } else {\n        data.shift();\n        series.updateParallelArrays(point, 'shift');\n        dataOptions.shift();\n      }\n    }\n    // Fire event\n    if (withEvent !== false) {\n      fireEvent(series, 'addPoint', {\n        point: point\n      });\n    }\n    // redraw\n    series.isDirty = true;\n    series.isDirtyData = true;\n    if (redraw) {\n      chart.redraw(animation); // Animation is set anyway on redraw, #5665\n    }\n  }\n  /**\n   * Remove a point from the series. Unlike the\n   * {@link Highcharts.Point#remove} method, this can also be done on a point\n   * that is not instanciated because it is outside the view or subject to\n   * Highcharts Stock data grouping.\n   *\n   * @sample highcharts/members/series-removepoint/\n   *         Remove cropped point\n   *\n   * @function Highcharts.Series#removePoint\n   *\n   * @param {number} i\n   *        The index of the point in the {@link Highcharts.Series.data|data}\n   *        array.\n   *\n   * @param {boolean} [redraw=true]\n   *        Whether to redraw the chart after the point is added. When\n   *        removing more than one point, it is highly recommended that the\n   *        `redraw` option be set to `false`, and instead {@link\n   *        Highcharts.Chart#redraw} is explicitly called after the adding of\n   *        points is finished.\n   *\n   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]\n   *        Whether and optionally how the series should be animated.\n   *\n   * @emits Highcharts.Point#event:remove\n   */\n  removePoint(i, redraw, animation) {\n    const series = this,\n      data = series.data,\n      point = data[i],\n      points = series.points,\n      chart = series.chart,\n      remove = function () {\n        if (points && points.length === data.length) {\n          // #4935\n          points.splice(i, 1);\n        }\n        data.splice(i, 1);\n        series.options.data.splice(i, 1);\n        series.updateParallelArrays(point || {\n          series: series\n        }, 'splice', [i, 1]);\n        if (point) {\n          point.destroy();\n        }\n        // redraw\n        series.isDirty = true;\n        series.isDirtyData = true;\n        if (redraw) {\n          chart.redraw();\n        }\n      };\n    setAnimation(animation, chart);\n    redraw = pick(redraw, true);\n    // Fire the event with a default handler of removing the point\n    if (point) {\n      point.firePointEvent('remove', null, remove);\n    } else {\n      remove();\n    }\n  }\n  /**\n   * Remove a series and optionally redraw the chart.\n   *\n   * @sample highcharts/members/series-remove/\n   *         Remove first series from a button\n   *\n   * @function Highcharts.Series#remove\n   *\n   * @param {boolean} [redraw=true]\n   *        Whether to redraw the chart or wait for an explicit call to\n   *        {@link Highcharts.Chart#redraw}.\n   *\n   * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]\n   *        Whether to apply animation, and optionally animation\n   *        configuration.\n   *\n   * @param {boolean} [withEvent=true]\n   *        Used internally, whether to fire the series `remove` event.\n   *\n   * @emits Highcharts.Series#event:remove\n   */\n  remove(redraw, animation, withEvent, keepEvents) {\n    const series = this,\n      chart = series.chart;\n    /**\n     * @private\n     */\n    function remove() {\n      // Destroy elements\n      series.destroy(keepEvents);\n      // Redraw\n      chart.isDirtyLegend = chart.isDirtyBox = true;\n      chart.linkSeries(keepEvents);\n      if (pick(redraw, true)) {\n        chart.redraw(animation);\n      }\n    }\n    // Fire the event with a default handler of removing the point\n    if (withEvent !== false) {\n      fireEvent(series, 'remove', null, remove);\n    } else {\n      remove();\n    }\n  }\n  /**\n   * Update the series with a new set of options. For a clean and precise\n   * handling of new options, all methods and elements from the series are\n   * removed, and it is initialized from scratch. Therefore, this method is\n   * more performance expensive than some other utility methods like {@link\n   * Series#setData} or {@link Series#setVisible}.\n   *\n   * Note that `Series.update` may mutate the passed `data` options.\n   *\n   * @sample highcharts/members/series-update/\n   *         Updating series options\n   * @sample maps/members/series-update/\n   *         Update series options in Highmaps\n   *\n   * @function Highcharts.Series#update\n   *\n   * @param {Highcharts.SeriesOptionsType} options\n   *        New options that will be merged with the series' existing options.\n   *\n   * @param {boolean} [redraw=true]\n   *        Whether to redraw the chart after the series is altered. If doing\n   *        more operations on the chart, it is a good idea to set redraw to\n   *        false and call {@link Chart#redraw} after.\n   *\n   * @emits Highcharts.Series#event:update\n   * @emits Highcharts.Series#event:afterUpdate\n   */\n  update(options, redraw) {\n    options = diffObjects(options, this.userOptions);\n    fireEvent(this, 'update', {\n      options: options\n    });\n    const series = this,\n      chart = series.chart,\n      // must use user options when changing type because series.options\n      // is merged in with type specific plotOptions\n      oldOptions = series.userOptions,\n      initialType = series.initialType || series.type,\n      plotOptions = chart.options.plotOptions,\n      initialSeriesProto = seriesTypes[initialType].prototype,\n      groups = ['group', 'markerGroup', 'dataLabelsGroup', 'transformGroup'],\n      optionsToCheck = ['dataGrouping', 'pointStart', 'pointInterval', 'pointIntervalUnit', 'keys'],\n      // Animation must be enabled when calling update before the initial\n      // animation has first run. This happens when calling update\n      // directly after chart initialization, or when applying responsive\n      // rules (#6912).\n      animation = series.finishedAnimating && {\n        animation: false\n      },\n      kinds = {};\n    let seriesOptions,\n      n,\n      preserve = ['colorIndex', 'eventOptions', 'navigatorSeries', 'symbolIndex', 'baseSeries'],\n      newType = options.type || oldOptions.type || chart.options.chart.type;\n    const keepPoints = !(\n    // Indicators, histograms etc recalculate the data. It should be\n    // possible to omit this.\n    this.hasDerivedData ||\n    // New type requires new point classes\n    newType && newType !== this.type ||\n    // New options affecting how the data points are built\n    typeof options.pointStart !== 'undefined' || typeof options.pointInterval !== 'undefined' || typeof options.relativeXValue !== 'undefined' || options.joinBy || options.mapData ||\n    // #11636\n    // Changes to data grouping requires new points in new group\n    optionsToCheck.some(option => series.hasOptionChanged(option)));\n    newType = newType || initialType;\n    if (keepPoints) {\n      preserve.push('data', 'isDirtyData',\n      // GeoHeatMap interpolation\n      'isDirtyCanvas', 'points', 'processedData',\n      // #17057\n      'processedXData', 'processedYData', 'xIncrement', 'cropped', '_hasPointMarkers', 'hasDataLabels', 'clips',\n      // #15420\n      // Networkgraph (#14397)\n      'nodes', 'layout',\n      // Treemap\n      'level',\n      // Map specific, consider moving it to series-specific preserve-\n      // properties (#10617)\n      'mapMap', 'mapData', 'minY', 'maxY', 'minX', 'maxX');\n      if (options.visible !== false) {\n        preserve.push('area', 'graph');\n      }\n      series.parallelArrays.forEach(function (key) {\n        preserve.push(key + 'Data');\n      });\n      if (options.data) {\n        // setData uses dataSorting options so we need to update them\n        // earlier\n        if (options.dataSorting) {\n          extend(series.options.dataSorting, options.dataSorting);\n        }\n        this.setData(options.data, false);\n      }\n    }\n    // Do the merge, with some forced options\n    options = merge(oldOptions, animation, {\n      // When oldOptions.index is null it should't be cleared.\n      // Otherwise navigator series will have wrong indexes (#10193).\n      index: typeof oldOptions.index === 'undefined' ? series.index : oldOptions.index,\n      pointStart: pick(\n      // When updating from blank (#7933)\n      plotOptions?.series?.pointStart, oldOptions.pointStart,\n      // When updating after addPoint\n      series.xData[0])\n    }, !keepPoints && {\n      data: series.options.data\n    }, options);\n    // Merge does not merge arrays, but replaces them. Since points were\n    // updated, `series.options.data` has correct merged options, use it:\n    if (keepPoints && options.data) {\n      options.data = series.options.data;\n    }\n    // Make sure preserved properties are not destroyed (#3094)\n    preserve = groups.concat(preserve);\n    preserve.forEach(function (prop) {\n      preserve[prop] = series[prop];\n      delete series[prop];\n    });\n    let casting = false;\n    if (seriesTypes[newType]) {\n      casting = newType !== series.type;\n      // Destroy the series and delete all properties, it will be\n      // reinserted within the `init` call below\n      series.remove(false, false, false, true);\n      if (casting) {\n        // Modern browsers including IE11\n        if (Object.setPrototypeOf) {\n          Object.setPrototypeOf(series, seriesTypes[newType].prototype);\n          // Legacy (IE < 11)\n        } else {\n          const ownEvents = Object.hasOwnProperty.call(series, 'hcEvents') && series.hcEvents;\n          for (n in initialSeriesProto) {\n            // eslint-disable-line guard-for-in\n            series[n] = void 0;\n          }\n          // Reinsert all methods and properties from the new type\n          // prototype (#2270, #3719).\n          extend(series, seriesTypes[newType].prototype);\n          // The events are tied to the prototype chain, don't copy if\n          // they're not the series' own\n          if (ownEvents) {\n            series.hcEvents = ownEvents;\n          } else {\n            delete series.hcEvents;\n          }\n        }\n      }\n    } else {\n      error(17, true, chart, {\n        missingModuleFor: newType\n      });\n    }\n    // Re-register groups (#3094) and other preserved properties\n    preserve.forEach(function (prop) {\n      series[prop] = preserve[prop];\n    });\n    series.init(chart, options);\n    // Remove particular elements of the points. Check `series.options`\n    // because we need to consider the options being set on plotOptions as\n    // well.\n    if (keepPoints && this.points) {\n      seriesOptions = series.options;\n      // What kind of elements to destroy\n      if (seriesOptions.visible === false) {\n        kinds.graphic = 1;\n        kinds.dataLabel = 1;\n      } else {\n        // If the  marker got disabled or changed its symbol, width or\n        // height - destroy\n        if (this.hasMarkerChanged(seriesOptions, oldOptions)) {\n          kinds.graphic = 1;\n        }\n        if (!series.hasDataLabels?.()) {\n          kinds.dataLabel = 1;\n        }\n      }\n      for (const point of this.points) {\n        if (point && point.series) {\n          point.resolveColor();\n          // Destroy elements in order to recreate based on updated\n          // series options.\n          if (Object.keys(kinds).length) {\n            point.destroyElements(kinds);\n          }\n          if (seriesOptions.showInLegend === false && point.legendItem) {\n            chart.legend.destroyItem(point);\n          }\n        }\n      }\n    }\n    series.initialType = initialType;\n    chart.linkSeries(); // Links are lost in series.remove (#3028)\n    // #15383: Fire updatedData if the type has changed to keep linked\n    // series such as indicators updated\n    if (casting && series.linkedSeries.length) {\n      series.isDirtyData = true;\n    }\n    fireEvent(this, 'afterUpdate');\n    if (pick(redraw, true)) {\n      chart.redraw(keepPoints ? void 0 : false);\n    }\n  }\n  /**\n   * Used from within series.update\n   * @private\n   */\n  setName(name) {\n    this.name = this.options.name = this.userOptions.name = name;\n    this.chart.isDirtyLegend = true;\n  }\n  /**\n   * Check if the option has changed.\n   * @private\n   */\n  hasOptionChanged(optionName) {\n    const chart = this.chart,\n      option = this.options[optionName],\n      plotOptions = chart.options.plotOptions,\n      oldOption = this.userOptions[optionName],\n      plotOptionsOption = pick(plotOptions?.[this.type]?.[optionName], plotOptions?.series?.[optionName]);\n    // Check if `plotOptions` are defined already, #19203\n    if (oldOption && !defined(plotOptionsOption)) {\n      return option !== oldOption;\n    }\n    return option !== pick(plotOptionsOption, option);\n  }\n  /**\n   * Runs on mouse over the series graphical items.\n   *\n   * @function Highcharts.Series#onMouseOver\n   * @emits Highcharts.Series#event:mouseOver\n   */\n  onMouseOver() {\n    const series = this,\n      chart = series.chart,\n      hoverSeries = chart.hoverSeries,\n      pointer = chart.pointer;\n    pointer.setHoverChartIndex();\n    // set normal state to previous series\n    if (hoverSeries && hoverSeries !== series) {\n      hoverSeries.onMouseOut();\n    }\n    // trigger the event, but to save processing time,\n    // only if defined\n    if (series.options.events.mouseOver) {\n      fireEvent(series, 'mouseOver');\n    }\n    // hover this\n    series.setState('hover');\n    /**\n     * Contains the original hovered series.\n     *\n     * @name Highcharts.Chart#hoverSeries\n     * @type {Highcharts.Series|null}\n     */\n    chart.hoverSeries = series;\n  }\n  /**\n   * Runs on mouse out of the series graphical items.\n   *\n   * @function Highcharts.Series#onMouseOut\n   *\n   * @emits Highcharts.Series#event:mouseOut\n   */\n  onMouseOut() {\n    // trigger the event only if listeners exist\n    const series = this,\n      options = series.options,\n      chart = series.chart,\n      tooltip = chart.tooltip,\n      hoverPoint = chart.hoverPoint;\n    // #182, set to null before the mouseOut event fires\n    chart.hoverSeries = null;\n    // trigger mouse out on the point, which must be in this series\n    if (hoverPoint) {\n      hoverPoint.onMouseOut();\n    }\n    // fire the mouse out event\n    if (series && options.events.mouseOut) {\n      fireEvent(series, 'mouseOut');\n    }\n    // hide the tooltip\n    if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {\n      tooltip.hide();\n    }\n    // Reset all inactive states\n    chart.series.forEach(function (s) {\n      s.setState('', true);\n    });\n  }\n  /**\n   * Set the state of the series. Called internally on mouse interaction\n   * operations, but it can also be called directly to visually\n   * highlight a series.\n   *\n   * @function Highcharts.Series#setState\n   *\n   * @param {Highcharts.SeriesStateValue|\"\"} [state]\n   *        The new state, can be either `'hover'`, `'inactive'`, `'select'`,\n   *        or `''` (an empty string), `'normal'` or `undefined` to set to\n   *        normal state.\n   * @param {boolean} [inherit]\n   *        Determines if state should be inherited by points too.\n   */\n  setState(state, inherit) {\n    const series = this,\n      options = series.options,\n      graph = series.graph,\n      inactiveOtherPoints = options.inactiveOtherPoints,\n      stateOptions = options.states,\n      // By default a quick animation to hover/inactive,\n      // slower to un-hover\n      stateAnimation = pick(stateOptions[state || 'normal'] && stateOptions[state || 'normal'].animation, series.chart.options.chart.animation);\n    let attribs,\n      lineWidth = options.lineWidth,\n      i = 0,\n      opacity = options.opacity;\n    state = state || '';\n    if (series.state !== state) {\n      // Toggle class names\n      [series.group, series.markerGroup, series.dataLabelsGroup].forEach(function (group) {\n        if (group) {\n          // Old state\n          if (series.state) {\n            group.removeClass('highcharts-series-' + series.state);\n          }\n          // New state\n          if (state) {\n            group.addClass('highcharts-series-' + state);\n          }\n        }\n      });\n      series.state = state;\n      if (!series.chart.styledMode) {\n        if (stateOptions[state] && stateOptions[state].enabled === false) {\n          return;\n        }\n        if (state) {\n          lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035\n          opacity = pick(stateOptions[state].opacity, opacity);\n        }\n        if (graph && !graph.dashstyle && isNumber(lineWidth)) {\n          attribs = {\n            'stroke-width': lineWidth\n          };\n          // Animate the graph stroke-width.\n          graph.animate(attribs, stateAnimation);\n          while (series['zone-graph-' + i]) {\n            series['zone-graph-' + i].animate(attribs, stateAnimation);\n            i = i + 1;\n          }\n        }\n        // For some types (pie, networkgraph, sankey) opacity is\n        // resolved on a point level\n        if (!inactiveOtherPoints) {\n          [series.group, series.markerGroup, series.dataLabelsGroup, series.labelBySeries].forEach(function (group) {\n            if (group) {\n              group.animate({\n                opacity: opacity\n              }, stateAnimation);\n            }\n          });\n        }\n      }\n    }\n    // Don't loop over points on a series that doesn't apply inactive state\n    // to siblings markers (e.g. line, column)\n    if (inherit && inactiveOtherPoints && series.points) {\n      series.setAllPointsToState(state || void 0);\n    }\n  }\n  /**\n   * Set the state for all points in the series.\n   *\n   * @function Highcharts.Series#setAllPointsToState\n   *\n   * @private\n   *\n   * @param {string} [state]\n   *        Can be either `hover` or undefined to set to normal state.\n   */\n  setAllPointsToState(state) {\n    this.points.forEach(function (point) {\n      if (point.setState) {\n        point.setState(state);\n      }\n    });\n  }\n  /**\n   * Show or hide the series.\n   *\n   * @function Highcharts.Series#setVisible\n   *\n   * @param {boolean} [visible]\n   * True to show the series, false to hide. If undefined, the visibility is\n   * toggled.\n   *\n   * @param {boolean} [redraw=true]\n   * Whether to redraw the chart after the series is altered. If doing more\n   * operations on the chart, it is a good idea to set redraw to false and\n   * call {@link Chart#redraw|chart.redraw()} after.\n   *\n   * @emits Highcharts.Series#event:hide\n   * @emits Highcharts.Series#event:show\n   */\n  setVisible(vis, redraw) {\n    const series = this,\n      chart = series.chart,\n      ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n      oldVisibility = series.visible;\n    // If called without an argument, toggle visibility\n    series.visible = vis = series.options.visible = series.userOptions.visible = typeof vis === 'undefined' ? !oldVisibility : vis; // #5618\n    const showOrHide = vis ? 'show' : 'hide';\n    // Show or hide elements\n    ['group', 'dataLabelsGroup', 'markerGroup', 'tracker', 'tt'].forEach(key => {\n      series[key]?.[showOrHide]();\n    });\n    // Hide tooltip (#1361)\n    if (chart.hoverSeries === series || chart.hoverPoint?.series === series) {\n      series.onMouseOut();\n    }\n    if (series.legendItem) {\n      chart.legend.colorizeItem(series, vis);\n    }\n    // Rescale or adapt to resized chart\n    series.isDirty = true;\n    // In a stack, all other series are affected\n    if (series.options.stacking) {\n      chart.series.forEach(otherSeries => {\n        if (otherSeries.options.stacking && otherSeries.visible) {\n          otherSeries.isDirty = true;\n        }\n      });\n    }\n    // Show or hide linked series\n    series.linkedSeries.forEach(otherSeries => {\n      otherSeries.setVisible(vis, false);\n    });\n    if (ignoreHiddenSeries) {\n      chart.isDirtyBox = true;\n    }\n    fireEvent(series, showOrHide);\n    if (redraw !== false) {\n      chart.redraw();\n    }\n  }\n  /**\n   * Show the series if hidden.\n   *\n   * @sample highcharts/members/series-hide/\n   *         Toggle visibility from a button\n   *\n   * @function Highcharts.Series#show\n   * @emits Highcharts.Series#event:show\n   */\n  show() {\n    this.setVisible(true);\n  }\n  /**\n   * Hide the series if visible. If the\n   * [chart.ignoreHiddenSeries](https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries)\n   * option is true, the chart is redrawn without this series.\n   *\n   * @sample highcharts/members/series-hide/\n   *         Toggle visibility from a button\n   *\n   * @function Highcharts.Series#hide\n   * @emits Highcharts.Series#event:hide\n   */\n  hide() {\n    this.setVisible(false);\n  }\n  /**\n   * Select or unselect the series. This means its\n   * {@link Highcharts.Series.selected|selected}\n   * property is set, the checkbox in the legend is toggled and when selected,\n   * the series is returned by the {@link Highcharts.Chart#getSelectedSeries}\n   * function.\n   *\n   * @sample highcharts/members/series-select/\n   *         Select a series from a button\n   *\n   * @function Highcharts.Series#select\n   *\n   * @param {boolean} [selected]\n   * True to select the series, false to unselect. If undefined, the selection\n   * state is toggled.\n   *\n   * @emits Highcharts.Series#event:select\n   * @emits Highcharts.Series#event:unselect\n   */\n  select(selected) {\n    const series = this;\n    series.selected = selected = this.options.selected = typeof selected === 'undefined' ? !series.selected : selected;\n    if (series.checkbox) {\n      series.checkbox.checked = selected;\n    }\n    fireEvent(series, selected ? 'select' : 'unselect');\n  }\n  /**\n   * Checks if a tooltip should be shown for a given point.\n   *\n   * @private\n   */\n  shouldShowTooltip(plotX, plotY, options = {}) {\n    options.series = this;\n    options.visiblePlotOnly = true;\n    return this.chart.isInsidePlot(plotX, plotY, options);\n  }\n  /**\n   * Draws the legend symbol based on the legendSymbol user option.\n   *\n   * @private\n   */\n  drawLegendSymbol(legend, item) {\n    LegendSymbol[this.options.legendSymbol || 'rectangle']?.call(this, legend, item);\n  }\n}\nSeries.defaultOptions = SeriesDefaults;\n/**\n * Registry of all available series types.\n *\n * @name Highcharts.Series.types\n * @type {Highcharts.Dictionary<typeof_Highcharts.Series>}\n */\nSeries.types = SeriesRegistry.seriesTypes;\n/* *\n *\n *  Static Functions\n *\n * */\n/**\n * Registers a series class to be accessible via `Series.types`.\n *\n * @function Highcharts.Series.registerType\n *\n * @param {string} seriesType\n * The series type as an identifier string in lower case.\n *\n * @param {Function} SeriesClass\n * The series class as a class pattern or a constructor function with\n * prototype.\n */\nSeries.registerType = SeriesRegistry.registerSeriesType;\nextend(Series.prototype, {\n  axisTypes: ['xAxis', 'yAxis'],\n  coll: 'series',\n  colorCounter: 0,\n  directTouch: false,\n  isCartesian: true,\n  kdAxisArray: ['clientX', 'plotY'],\n  // Each point's x and y values are stored in this.xData and this.yData:\n  parallelArrays: ['x', 'y'],\n  pointClass: Point,\n  requireSorting: true,\n  // Requires the data to be sorted:\n  sorted: true\n});\n/* *\n *\n *  Registry\n *\n * */\nSeriesRegistry.series = Series;\n/* *\n *\n *  Default Export\n *\n * */\nexport default Series;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * This is a placeholder type of the possible series options for\n * [Highcharts](../highcharts/series), [Highcharts Stock](../highstock/series),\n * [Highmaps](../highmaps/series), and [Gantt](../gantt/series).\n *\n * In TypeScript is this dynamically generated to reference all possible types\n * of series options.\n *\n * @ignore-declaration\n * @typedef {Highcharts.SeriesOptions|Highcharts.Dictionary<*>} Highcharts.SeriesOptionsType\n */\n/**\n * Options for `dataSorting`.\n *\n * @interface Highcharts.DataSortingOptionsObject\n * @since 8.0.0\n */ /**\n    * Enable or disable data sorting for the series.\n    * @name Highcharts.DataSortingOptionsObject#enabled\n    * @type {boolean|undefined}\n    */ /**\n       * Whether to allow matching points by name in an update.\n       * @name Highcharts.DataSortingOptionsObject#matchByName\n       * @type {boolean|undefined}\n       */ /**\n          * Determines what data value should be used to sort by.\n          * @name Highcharts.DataSortingOptionsObject#sortKey\n          * @type {string|undefined}\n          */\n/**\n * Function callback when a series has been animated.\n *\n * @callback Highcharts.SeriesAfterAnimateCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        The series where the event occured.\n *\n * @param {Highcharts.SeriesAfterAnimateEventObject} event\n *        Event arguments.\n */\n/**\n * Event information regarding completed animation of a series.\n *\n * @interface Highcharts.SeriesAfterAnimateEventObject\n */ /**\n    * Animated series.\n    * @name Highcharts.SeriesAfterAnimateEventObject#target\n    * @type {Highcharts.Series}\n    */ /**\n       * Event type.\n       * @name Highcharts.SeriesAfterAnimateEventObject#type\n       * @type {\"afterAnimate\"}\n       */\n/**\n * Function callback when the checkbox next to the series' name in the legend is\n * clicked.\n *\n * @callback Highcharts.SeriesCheckboxClickCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        The series where the event occured.\n *\n * @param {Highcharts.SeriesCheckboxClickEventObject} event\n *        Event arguments.\n */\n/**\n * Event information regarding check of a series box.\n *\n * @interface Highcharts.SeriesCheckboxClickEventObject\n */ /**\n    * Whether the box has been checked.\n    * @name Highcharts.SeriesCheckboxClickEventObject#checked\n    * @type {boolean}\n    */ /**\n       * Related series.\n       * @name Highcharts.SeriesCheckboxClickEventObject#item\n       * @type {Highcharts.Series}\n       */ /**\n          * Related series.\n          * @name Highcharts.SeriesCheckboxClickEventObject#target\n          * @type {Highcharts.Series}\n          */ /**\n             * Event type.\n             * @name Highcharts.SeriesCheckboxClickEventObject#type\n             * @type {\"checkboxClick\"}\n             */\n/**\n * Function callback when a series is clicked. Return false to cancel toogle\n * actions.\n *\n * @callback Highcharts.SeriesClickCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        The series where the event occured.\n *\n * @param {Highcharts.SeriesClickEventObject} event\n *        Event arguments.\n */\n/**\n * Common information for a click event on a series.\n *\n * @interface Highcharts.SeriesClickEventObject\n * @extends global.Event\n */ /**\n    * Nearest point on the graph.\n    * @name Highcharts.SeriesClickEventObject#point\n    * @type {Highcharts.Point}\n    */\n/**\n * Gets fired when the series is hidden after chart generation time, either by\n * clicking the legend item or by calling `.hide()`.\n *\n * @callback Highcharts.SeriesHideCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        The series where the event occured.\n *\n * @param {global.Event} event\n *        The event that occured.\n */\n/**\n * The SVG value used for the `stroke-linecap` and `stroke-linejoin` of a line\n * graph.\n *\n * @typedef {\"butt\"|\"round\"|\"square\"|string} Highcharts.SeriesLinecapValue\n */\n/**\n * Gets fired when the legend item belonging to the series is clicked. The\n * default action is to toggle the visibility of the series. This can be\n * prevented by returning `false` or calling `event.preventDefault()`.\n *\n * @callback Highcharts.SeriesLegendItemClickCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        The series where the event occured.\n *\n * @param {Highcharts.SeriesLegendItemClickEventObject} event\n *        The event that occured.\n */\n/**\n * Information about the event.\n *\n * @interface Highcharts.SeriesLegendItemClickEventObject\n */ /**\n    * Related browser event.\n    * @name Highcharts.SeriesLegendItemClickEventObject#browserEvent\n    * @type {global.PointerEvent}\n    */ /**\n       * Prevent the default action of toggle the visibility of the series.\n       * @name Highcharts.SeriesLegendItemClickEventObject#preventDefault\n       * @type {Function}\n       */ /**\n          * Related series.\n          * @name Highcharts.SeriesCheckboxClickEventObject#target\n          * @type {Highcharts.Series}\n          */ /**\n             * Event type.\n             * @name Highcharts.SeriesCheckboxClickEventObject#type\n             * @type {\"checkboxClick\"}\n             */\n/**\n * Gets fired when the mouse leaves the graph.\n *\n * @callback Highcharts.SeriesMouseOutCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        Series where the event occured.\n *\n * @param {global.PointerEvent} event\n *        Event that occured.\n */\n/**\n * Gets fired when the mouse enters the graph.\n *\n * @callback Highcharts.SeriesMouseOverCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        Series where the event occured.\n *\n * @param {global.PointerEvent} event\n *        Event that occured.\n */\n/**\n * Translation and scale for the plot area of a series.\n *\n * @interface Highcharts.SeriesPlotBoxObject\n */ /**\n    * @name Highcharts.SeriesPlotBoxObject#scaleX\n    * @type {number}\n    */ /**\n       * @name Highcharts.SeriesPlotBoxObject#scaleY\n       * @type {number}\n       */ /**\n          * @name Highcharts.SeriesPlotBoxObject#translateX\n          * @type {number}\n          */ /**\n             * @name Highcharts.SeriesPlotBoxObject#translateY\n             * @type {number}\n             */\n/**\n * Gets fired when the series is shown after chart generation time, either by\n * clicking the legend item or by calling `.show()`.\n *\n * @callback Highcharts.SeriesShowCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        Series where the event occured.\n *\n * @param {global.Event} event\n *        Event that occured.\n */\n/**\n * Possible key values for the series state options.\n *\n * @typedef {\"hover\"|\"inactive\"|\"normal\"|\"select\"} Highcharts.SeriesStateValue\n */\n''; // detach doclets above\n/* *\n *\n *  API Options\n *\n * */\n/**\n * Series options for specific data and the data itself. In TypeScript you\n * have to cast the series options to specific series types, to get all\n * possible options for a series.\n *\n * @example\n * // TypeScript example\n * Highcharts.chart('container', {\n *     series: [{\n *         color: '#06C',\n *         data: [[0, 1], [2, 3]]\n *     } as Highcharts.SeriesLineOptions ]\n * });\n *\n * @type      {Array<*>}\n * @apioption series\n */\n/**\n * An id for the series. This can be used after render time to get a pointer\n * to the series object through `chart.get()`.\n *\n * @sample {highcharts} highcharts/plotoptions/series-id/\n *         Get series by id\n *\n * @type      {string}\n * @since     1.2.0\n * @apioption series.id\n */\n/**\n * The index of the series in the chart, affecting the internal index in the\n * `chart.series` array, the visible Z index as well as the order in the\n * legend.\n *\n * @type      {number}\n * @since     2.3.0\n * @apioption series.index\n */\n/**\n * The sequential index of the series in the legend.\n *\n * @see [legend.reversed](#legend.reversed),\n *      [yAxis.reversedStacks](#yAxis.reversedStacks)\n *\n * @sample {highcharts|highstock} highcharts/series/legendindex/\n *         Legend in opposite order\n *\n * @type      {number}\n * @apioption series.legendIndex\n */\n/**\n * The name of the series as shown in the legend, tooltip etc.\n *\n * @sample {highcharts} highcharts/series/name/\n *         Series name\n * @sample {highmaps} maps/demo/category-map/\n *         Series name\n *\n * @type      {string}\n * @apioption series.name\n */\n/**\n * This option allows grouping series in a stacked chart. The stack option\n * can be a string or anything else, as long as the grouped series' stack\n * options match each other after conversion into a string.\n *\n * @sample {highcharts} highcharts/series/stack/\n *         Stacked and grouped columns\n *\n * @type      {number|string}\n * @since     2.1\n * @product   highcharts highstock\n * @apioption series.stack\n */\n/**\n * The type of series, for example `line` or `column`. By default, the\n * series type is inherited from [chart.type](#chart.type), so unless the\n * chart is a combination of series types, there is no need to set it on the\n * series level.\n *\n * @sample {highcharts} highcharts/series/type/\n *         Line and column in the same chart\n * @sample highcharts/series/type-dynamic/\n *         Dynamic types with button selector\n * @sample {highmaps} maps/demo/mapline-mappoint/\n *         Multiple types in the same map\n *\n * @type      {string}\n * @apioption series.type\n */\n/**\n * When using dual or multiple x axes, this number defines which xAxis the\n * particular series is connected to. It refers to either the\n * {@link #xAxis.id|axis id}\n * or the index of the axis in the xAxis array, with 0 being the first.\n *\n * @type      {number|string}\n * @default   0\n * @product   highcharts highstock\n * @apioption series.xAxis\n */\n/**\n * When using dual or multiple y axes, this number defines which yAxis the\n * particular series is connected to. It refers to either the\n * {@link #yAxis.id|axis id}\n * or the index of the axis in the yAxis array, with 0 being the first.\n *\n * @sample {highcharts} highcharts/series/yaxis/\n *         Apply the column series to the secondary Y axis\n *\n * @type      {number|string}\n * @default   0\n * @product   highcharts highstock\n * @apioption series.yAxis\n */\n/**\n * Define the visual z index of the series.\n *\n * @sample {highcharts} highcharts/plotoptions/series-zindex-default/\n *         With no z index, the series defined last are on top\n * @sample {highcharts} highcharts/plotoptions/series-zindex/\n *         With a z index, the series with the highest z index is on top\n * @sample {highstock} highcharts/plotoptions/series-zindex-default/\n *         With no z index, the series defined last are on top\n * @sample {highstock} highcharts/plotoptions/series-zindex/\n *         With a z index, the series with the highest z index is on top\n *\n * @type      {number}\n * @product   highcharts highstock\n * @apioption series.zIndex\n */\n''; // include precedent doclets in transpilat","map":{"version":3,"names":["A","animObject","setAnimation","D","defaultOptions","F","registerEventOptions","H","hasTouch","svg","win","LegendSymbol","Point","SeriesDefaults","SeriesRegistry","seriesTypes","SVGElement","U","addEvent","arrayMax","arrayMin","clamp","correctFloat","defined","diffObjects","erase","error","extend","find","fireEvent","getClosestDistance","getNestedProperty","insertItem","isArray","isNumber","isString","merge","objectEach","pick","removeEvent","splat","syncTimeout","Series","constructor","_i","chart","data","eventOptions","eventsToUnbind","index","linkedSeries","options","points","processedXData","processedYData","tooltipOptions","userOptions","xAxis","yAxis","zones","init","series","chartSeries","setOptions","visible","bindAxes","name","state","selected","events","click","point","allowPointSelect","runTrackerClick","getColor","getSymbol","parallelArrays","forEach","key","isCartesian","hasCartesianSeries","lastSeries","length","opacity","orderItems","dataSorting","enabled","setDataSortingOptions","setData","is","type","seriesOptions","axisOptions","axisTypes","coll","axis","id","isDirty","optionalAxis","updateParallelArrays","i","iArgs","fn","val","toYData","Array","prototype","apply","hasData","dataMax","dataMin","yData","hasMarkerChanged","oldOptions","marker","oldMarker","symbol","height","width","autoIncrement","x","pointIntervalUnit","relativeXValue","time","xIncrement","date","pointInterval","pointStart","Date","set","get","getTime","requireSorting","sorted","enabledDataSorting","allowDG","pointRange","itemOptions","chartOptions","plotOptions","seriesUserOptions","styledMode","e","zone","typeOptions","userPlotOptions","userPlotOptionsSeries","defaultPlotOptionsType","userPlotOptionsType","tooltip","stickyTracking","shared","noSharedTooltip","zoneAxis","slice","negativeColor","negativeFillColor","value","threshold","className","color","fillColor","push","getName","getCyclic","prop","defaults","indexName","counterName","len","colorCount","setting","colorIndex","colorByPoint","colors","getPointsCollection","hasGroupedData","seriesMarkerOption","symbols","findPointIndex","optionsObject","fromIndex","oldData","matchingPoint","matchedById","pointIndex","item","linkedParent","matcher","oldPoint","touched","matchByName","xData","indexOf","cropped","cropStart","updateData","animation","pointsToAdd","equalLength","hasUpdatedByKey","lastIndex","succeeded","pointOptions","pointClass","optionsToObject","call","update","hasDerivedData","remove","y","destroyed","addPoint","redraw","updatePoints","oldDataLength","turboThreshold","pointArrayMap","valueCount","keys","pt","updatedData","indexOfX","indexOfY","firstPoint","copiedData","allowMutatingData","dataLength","sortData","boosted","colorCounter","getFirstValidPoint","applyOptions","destroy","minRange","userMinRange","isDirtyBox","isDirtyData","legendType","processData","generatePoints","sortKey","getPointOptionsObject","sortedData","concat","sort","a","b","aValue","bValue","seriesData","getProcessedData","forceExtremesFromAll","cropThreshold","getExtremesFromAll","logarithmic","croppedData","xExtremes","min","max","updatingNames","getExtremes","categories","names","forceCrop","cropData","start","closestPointRange","map","log2lin","force","processedData","basePointRange","j","end","Math","dataOptions","PointClass","processedDataLength","groupCropStartIndex","dataGrouping","groupAll","cursor","arr","dataGroup","groupMap","dataLabels","destroyElements","plotX","getXExtremes","activeYData","shoulder","positiveValuesOnly","validValue","withinRange","xMin","xMax","activeCounter","stackedYData","yDataLength","dataExtremes","applyExtremes","translate","stacking","pointPlacement","pointPlacementToXValue","dynamicallyPlaced","Boolean","stackThreshold","startFromThreshold","lastPlotX","stackIndicator","closestPointRangePx","Number","MAX_VALUE","limitedRange","xValue","stackItem","stackValues","yValue","lowValue","low","stacks","negStacks","stackKey","getStackIndicator","isNull","base","total","stackTotal","percentage","stackY","irregularWidths","setOffset","pointXOffset","barW","yBottom","dataModify","modifyValue","plotY","isInside","isPointInside","clientX","negative","category","abs","getZone","graphic","group","isNew","getValidPoints","insideOnly","allowNull","filter","asNull","isInsidePlot","inverted","getClipBox","seriesBox","clipBox","plotSizeX","plotSizeY","getSharedClipKey","sharedClipKey","setClip","markerGroup","sharedClips","renderer","clipRect","animate","clip","animationClipKey","duration","easing","defer","join","animationClipRect","markerAnimationClipRect","plotHeight","markerClipBox","plotWidth","attr","hasClass","finalBox","step","element","childNodes","fx","arguments","addClass","afterAnimate","container","querySelector","finishedAnimating","drawPoints","colorAxis","seriesMarkerOptions","specialGroup","globallyEnabled","isRadial","enabledThreshold","radius","verb","pointMarkerOptions","hasPointMarker","markerAttribs","_hasPointMarkers","shouldDrawMarker","startXPos","reversed","hasImage","add","hasRendered","pointAttr","pointAttribs","fill","getClassName","attribs","seriesStateOptions","pointStateOptions","states","radiusPlus","pos","crisp","floor","pointColorOption","pointColor","zoneColor","stroke","strokeWidth","lineWidth","lineColor","lineWidthPlus","keepEventsForUpdate","issue134","test","navigator","userAgent","removeEvents","AXIS","forceRedraw","legendItem","legend","destroyItem","clips","clearTimeout","animationTimeout","survive","hoverSeries","applyZones","graph","area","plotSizeMax","translatedFrom","translatedTo","clipAttr","extremes","horiz","pxRange","pxPosMin","pxPosMax","zoneArea","zoneGraph","ignoreZones","showLine","hide","toPixels","round","isXAxis","resetZones","show","plotGroup","visibility","zIndex","parent","attrs","g","getPlotBox","horAxis","vertAxis","polar","invertible","translateX","left","plotLeft","translateY","top","plotTop","rotation","rotationOriginX","rotationOriginY","scaleX","scaleY","unbind","render","animOptions","chartSeriesGroup","seriesGroup","animDuration","drawGraph","drawDataLabels","redrawPoints","drawTracker","enableMouseTracking","wasDirty","kdTree","reserveSpace","ignoreHiddenSeries","searchPoint","compareX","searchKDTree","chartY","chartX","buildKDTree","buildingKdTree","dimensions","findNearestPointBy","_kdtree","depth","median","kdAxisArray","right","startRecursive","directTouch","kdNow","kdX","kdY","kdComparer","kdDimensions","useRadius","isBubble","setDistance","p1","p2","p1kdX","p2kdX","p1kdY","p2kdY","dist","sqrt","distX","_search","search","tree","nPoint1","nPoint2","ret","tdist","sideA","sideB","factor","trackByArea","trackerPath","areaPath","graphPath","pointer","snap","tracker","onMouseOver","TRACKER_FILL","d","path","dataLabelsGroup","on","onTrackerMouseOut","css","shift","withEvent","hasNames","isInTheMiddle","splice","removePoint","firePointEvent","keepEvents","isDirtyLegend","linkSeries","initialType","initialSeriesProto","groups","optionsToCheck","kinds","n","preserve","newType","keepPoints","joinBy","mapData","some","option","hasOptionChanged","casting","Object","setPrototypeOf","ownEvents","hasOwnProperty","hcEvents","missingModuleFor","dataLabel","hasDataLabels","resolveColor","showInLegend","setName","optionName","oldOption","plotOptionsOption","setHoverChartIndex","onMouseOut","mouseOver","setState","hoverPoint","mouseOut","s","inherit","inactiveOtherPoints","stateOptions","stateAnimation","removeClass","dashstyle","labelBySeries","setAllPointsToState","setVisible","vis","oldVisibility","showOrHide","colorizeItem","otherSeries","select","checkbox","checked","shouldShowTooltip","visiblePlotOnly","drawLegendSymbol","legendSymbol","types","registerType","registerSeriesType"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Series/Series.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport A from '../Animation/AnimationUtilities.js';\nconst { animObject, setAnimation } = A;\nimport D from '../Defaults.js';\nconst { defaultOptions } = D;\nimport F from '../Foundation.js';\nconst { registerEventOptions } = F;\nimport H from '../Globals.js';\nconst { hasTouch, svg, win } = H;\nimport LegendSymbol from '../Legend/LegendSymbol.js';\nimport Point from './Point.js';\nimport SeriesDefaults from './SeriesDefaults.js';\nimport SeriesRegistry from './SeriesRegistry.js';\nconst { seriesTypes } = SeriesRegistry;\nimport SVGElement from '../Renderer/SVG/SVGElement.js';\nimport U from '../Utilities.js';\nconst { addEvent, arrayMax, arrayMin, clamp, correctFloat, defined, diffObjects, erase, error, extend, find, fireEvent, getClosestDistance, getNestedProperty, insertItem, isArray, isNumber, isString, merge, objectEach, pick, removeEvent, splat, syncTimeout } = U;\n/* *\n *\n *  Class\n *\n * */\n/**\n * This is the base series prototype that all other series types inherit from.\n * A new series is initialized either through the\n * [series](https://api.highcharts.com/highcharts/series)\n * option structure, or after the chart is initialized, through\n * {@link Highcharts.Chart#addSeries}.\n *\n * The object can be accessed in a number of ways. All series and point event\n * handlers give a reference to the `series` object. The chart object has a\n * {@link Highcharts.Chart#series|series} property that is a collection of all\n * the chart's series. The point objects and axis objects also have the same\n * reference.\n *\n * Another way to reference the series programmatically is by `id`. Add an id\n * in the series configuration options, and get the series object by\n * {@link Highcharts.Chart#get}.\n *\n * Configuration options for the series are given in three levels. Options for\n * all series in a chart are given in the\n * [plotOptions.series](https://api.highcharts.com/highcharts/plotOptions.series)\n * object. Then options for all series of a specific type\n * are given in the plotOptions of that type, for example `plotOptions.line`.\n * Next, options for one single series are given in the series array, or as\n * arguments to `chart.addSeries`.\n *\n * The data in the series is stored in various arrays.\n *\n * - First, `series.options.data` contains all the original config options for\n *   each point whether added by options or methods like `series.addPoint`.\n *\n * - Next, `series.data` contains those values converted to points, but in case\n *   the series data length exceeds the `cropThreshold`, or if the data is\n *   grouped, `series.data` doesn't contain all the points. It only contains the\n *   points that have been created on demand.\n *\n * - Then there's `series.points` that contains all currently visible point\n *   objects. In case of cropping, the cropped-away points are not part of this\n *   array. The `series.points` array starts at `series.cropStart` compared to\n *   `series.data` and `series.options.data`. If however the series data is\n *   grouped, these can't be correlated one to one.\n *\n * - `series.xData` and `series.processedXData` contain clean x values,\n *   equivalent to `series.data` and `series.points`.\n *\n * - `series.yData` and `series.processedYData` contain clean y values,\n *   equivalent to `series.data` and `series.points`.\n *\n * @class\n * @name Highcharts.Series\n *\n * @param {Highcharts.Chart} chart\n * The chart instance.\n *\n * @param {Highcharts.SeriesOptionsType|object} options\n * The series options.\n */\nclass Series {\n    constructor() {\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        this._i = void 0;\n        this.chart = void 0;\n        this.data = void 0;\n        this.eventOptions = void 0;\n        this.eventsToUnbind = void 0;\n        this.index = void 0;\n        this.linkedSeries = void 0;\n        this.options = void 0;\n        this.points = void 0;\n        this.processedXData = void 0;\n        this.processedYData = void 0;\n        this.tooltipOptions = void 0;\n        this.userOptions = void 0;\n        this.xAxis = void 0;\n        this.yAxis = void 0;\n        this.zones = void 0;\n        /** eslint-enable valid-jsdoc */\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /* eslint-disable valid-jsdoc */\n    init(chart, userOptions) {\n        fireEvent(this, 'init', { options: userOptions });\n        const series = this, chartSeries = chart.series;\n        // The 'eventsToUnbind' property moved from prototype into the\n        // Series init to avoid reference to the same array between\n        // the different series and charts. #12959, #13937\n        this.eventsToUnbind = [];\n        /**\n         * Read only. The chart that the series belongs to.\n         *\n         * @name Highcharts.Series#chart\n         * @type {Highcharts.Chart}\n         */\n        series.chart = chart;\n        /**\n         * Read only. The series' type, like \"line\", \"area\", \"column\" etc.\n         * The type in the series options anc can be altered using\n         * {@link Series#update}.\n         *\n         * @name Highcharts.Series#type\n         * @type {string}\n         */\n        /**\n         * Read only. The series' current options. To update, use\n         * {@link Series#update}.\n         *\n         * @name Highcharts.Series#options\n         * @type {Highcharts.SeriesOptionsType}\n         */\n        series.options = series.setOptions(userOptions);\n        const options = series.options, visible = options.visible !== false;\n        series.linkedSeries = [];\n        // bind the axes\n        series.bindAxes();\n        extend(series, {\n            /**\n             * The series name as given in the options. Defaults to\n             * \"Series {n}\".\n             *\n             * @name Highcharts.Series#name\n             * @type {string}\n             */\n            name: options.name,\n            state: '',\n            /**\n             * Read only. The series' visibility state as set by {@link\n             * Series#show}, {@link Series#hide}, or in the initial\n             * configuration.\n             *\n             * @name Highcharts.Series#visible\n             * @type {boolean}\n             */\n            visible,\n            /**\n             * Read only. The series' selected state as set by {@link\n             * Highcharts.Series#select}.\n             *\n             * @name Highcharts.Series#selected\n             * @type {boolean}\n             */\n            selected: options.selected === true // false by default\n        });\n        registerEventOptions(this, options);\n        const events = options.events;\n        if ((events && events.click) ||\n            (options.point &&\n                options.point.events &&\n                options.point.events.click) ||\n            options.allowPointSelect) {\n            chart.runTrackerClick = true;\n        }\n        series.getColor();\n        series.getSymbol();\n        // Initialize the parallel data arrays\n        series.parallelArrays.forEach(function (key) {\n            if (!series[key + 'Data']) {\n                series[key + 'Data'] = [];\n            }\n        });\n        // Mark cartesian\n        if (series.isCartesian) {\n            chart.hasCartesianSeries = true;\n        }\n        // Get the index and register the series in the chart. The index is\n        // one more than the current latest series index (#5960).\n        let lastSeries;\n        if (chartSeries.length) {\n            lastSeries = chartSeries[chartSeries.length - 1];\n        }\n        series._i = pick(lastSeries && lastSeries._i, -1) + 1;\n        series.opacity = series.options.opacity;\n        // Insert the series and re-order all series above the insertion\n        // point.\n        chart.orderItems('series', insertItem(this, chartSeries));\n        // Set options for series with sorting and set data later.\n        if (options.dataSorting && options.dataSorting.enabled) {\n            series.setDataSortingOptions();\n        }\n        else if (!series.points && !series.data) {\n            series.setData(options.data, false);\n        }\n        fireEvent(this, 'afterInit');\n    }\n    /**\n     * Check whether the series item is itself or inherits from a certain\n     * series type.\n     *\n     * @function Highcharts.Series#is\n     * @param {string} type The type of series to check for, can be either\n     *        featured or custom series types. For example `column`, `pie`,\n     *        `ohlc` etc.\n     *\n     * @return {boolean}\n     *        True if this item is or inherits from the given type.\n     */\n    is(type) {\n        return seriesTypes[type] && this instanceof seriesTypes[type];\n    }\n    /**\n     * Set the xAxis and yAxis properties of cartesian series, and register\n     * the series in the `axis.series` array.\n     *\n     * @private\n     * @function Highcharts.Series#bindAxes\n     */\n    bindAxes() {\n        const series = this, seriesOptions = series.options, chart = series.chart;\n        let axisOptions;\n        fireEvent(this, 'bindAxes', null, function () {\n            // repeat for xAxis and yAxis\n            (series.axisTypes || []).forEach(function (coll) {\n                // loop through the chart's axis objects\n                chart[coll].forEach(function (axis) {\n                    axisOptions = axis.options;\n                    // apply if the series xAxis or yAxis option mathches\n                    // the number of the axis, or if undefined, use the\n                    // first axis\n                    if (pick(seriesOptions[coll], 0) === axis.index ||\n                        (typeof seriesOptions[coll] !==\n                            'undefined' &&\n                            seriesOptions[coll] === axisOptions.id)) {\n                        // register this series in the axis.series lookup\n                        insertItem(series, axis.series);\n                        // set this series.xAxis or series.yAxis reference\n                        /**\n                         * Read only. The unique xAxis object associated\n                         * with the series.\n                         *\n                         * @name Highcharts.Series#xAxis\n                         * @type {Highcharts.Axis}\n                         */\n                        /**\n                         * Read only. The unique yAxis object associated\n                         * with the series.\n                         *\n                         * @name Highcharts.Series#yAxis\n                         * @type {Highcharts.Axis}\n                         */\n                        series[coll] = axis;\n                        // mark dirty for redraw\n                        axis.isDirty = true;\n                    }\n                });\n                // The series needs an X and an Y axis\n                if (!series[coll] &&\n                    series.optionalAxis !== coll) {\n                    error(18, true, chart);\n                }\n            });\n        });\n        fireEvent(this, 'afterBindAxes');\n    }\n    /**\n     * For simple series types like line and column, the data values are\n     * held in arrays like xData and yData for quick lookup to find extremes\n     * and more. For multidimensional series like bubble and map, this can\n     * be extended with arrays like zData and valueData by adding to the\n     * `series.parallelArrays` array.\n     *\n     * @private\n     * @function Highcharts.Series#updateParallelArrays\n     */\n    updateParallelArrays(point, i, iArgs) {\n        const series = point.series, fn = isNumber(i) ?\n            // Insert the value in the given position\n            function (key) {\n                const val = key === 'y' && series.toYData ?\n                    series.toYData(point) :\n                    point[key];\n                series[key + 'Data'][i] = val;\n            } :\n            // Apply the method specified in i with the following\n            // arguments as arguments\n            function (key) {\n                Array.prototype[i].apply(series[key + 'Data'], iArgs);\n            };\n        series.parallelArrays.forEach(fn);\n    }\n    /**\n     * Define hasData functions for series. These return true if there\n     * are data points on this series within the plot area.\n     *\n     * @private\n     * @function Highcharts.Series#hasData\n     */\n    hasData() {\n        return ((this.visible &&\n            typeof this.dataMax !== 'undefined' &&\n            typeof this.dataMin !== 'undefined') || ( // #3703\n        this.visible &&\n            this.yData &&\n            this.yData.length > 0) // #9758\n        );\n    }\n    /**\n     * Determine whether the marker in a series has changed.\n     *\n     * @private\n     * @function Highcharts.Series#hasMarkerChanged\n     */\n    hasMarkerChanged(options, oldOptions) {\n        const series = this, marker = options.marker, oldMarker = oldOptions.marker || {};\n        return marker && ((oldMarker.enabled && !marker.enabled) ||\n            oldMarker.symbol !== marker.symbol || // #10870, #15946\n            oldMarker.height !== marker.height || // #16274\n            oldMarker.width !== marker.width // #16274\n        );\n    }\n    /**\n     * Return an auto incremented x value based on the pointStart and\n     * pointInterval options. This is only used if an x value is not given\n     * for the point that calls autoIncrement.\n     *\n     * @private\n     * @function Highcharts.Series#autoIncrement\n     */\n    autoIncrement(x) {\n        const options = this.options, pointIntervalUnit = options.pointIntervalUnit, relativeXValue = options.relativeXValue, time = this.chart.time;\n        let xIncrement = this.xIncrement, date, pointInterval;\n        xIncrement = pick(xIncrement, options.pointStart, 0);\n        this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);\n        if (relativeXValue && isNumber(x)) {\n            pointInterval *= x;\n        }\n        // Added code for pointInterval strings\n        if (pointIntervalUnit) {\n            date = new time.Date(xIncrement);\n            if (pointIntervalUnit === 'day') {\n                time.set('Date', date, time.get('Date', date) + pointInterval);\n            }\n            else if (pointIntervalUnit === 'month') {\n                time.set('Month', date, time.get('Month', date) + pointInterval);\n            }\n            else if (pointIntervalUnit === 'year') {\n                time.set('FullYear', date, time.get('FullYear', date) + pointInterval);\n            }\n            pointInterval = date.getTime() - xIncrement;\n        }\n        if (relativeXValue && isNumber(x)) {\n            return xIncrement + pointInterval;\n        }\n        this.xIncrement = xIncrement + pointInterval;\n        return xIncrement;\n    }\n    /**\n     * Internal function to set properties for series if data sorting is\n     * enabled.\n     *\n     * @private\n     * @function Highcharts.Series#setDataSortingOptions\n     */\n    setDataSortingOptions() {\n        const options = this.options;\n        extend(this, {\n            requireSorting: false,\n            sorted: false,\n            enabledDataSorting: true,\n            allowDG: false\n        });\n        // To allow unsorted data for column series.\n        if (!defined(options.pointRange)) {\n            options.pointRange = 1;\n        }\n    }\n    /**\n     * Set the series options by merging from the options tree. Called\n     * internally on initializing and updating series. This function will\n     * not redraw the series. For API usage, use {@link Series#update}.\n     * @private\n     * @function Highcharts.Series#setOptions\n     * @param {Highcharts.SeriesOptionsType} itemOptions\n     * The series options.\n     * @emits Highcharts.Series#event:afterSetOptions\n     */\n    setOptions(itemOptions) {\n        const chart = this.chart, chartOptions = chart.options, plotOptions = chartOptions.plotOptions, userOptions = chart.userOptions || {}, seriesUserOptions = merge(itemOptions), styledMode = chart.styledMode, e = {\n            plotOptions: plotOptions,\n            userOptions: seriesUserOptions\n        };\n        let zone;\n        fireEvent(this, 'setOptions', e);\n        // These may be modified by the event\n        const typeOptions = e.plotOptions[this.type], userPlotOptions = (userOptions.plotOptions || {}), userPlotOptionsSeries = userPlotOptions.series || {}, defaultPlotOptionsType = (defaultOptions.plotOptions[this.type] || {}), userPlotOptionsType = userPlotOptions[this.type] || {};\n        // use copy to prevent undetected changes (#9762)\n        /**\n         * Contains series options by the user without defaults.\n         * @name Highcharts.Series#userOptions\n         * @type {Highcharts.SeriesOptionsType}\n         */\n        this.userOptions = e.userOptions;\n        const options = merge(typeOptions, plotOptions.series, \n        // #3881, chart instance plotOptions[type] should trump\n        // plotOptions.series\n        userPlotOptionsType, seriesUserOptions);\n        // The tooltip options are merged between global and series specific\n        // options. Importance order asscendingly:\n        // globals: (1)tooltip, (2)plotOptions.series,\n        // (3)plotOptions[this.type]\n        // init userOptions with possible later updates: 4-6 like 1-3 and\n        // (7)this series options\n        this.tooltipOptions = merge(defaultOptions.tooltip, // 1\n        defaultOptions.plotOptions.series?.tooltip, // 2\n        defaultPlotOptionsType?.tooltip, // 3\n        chart.userOptions.tooltip, // 4\n        userPlotOptions.series?.tooltip, // 5\n        userPlotOptionsType.tooltip, // 6\n        seriesUserOptions.tooltip // 7\n        );\n        // When shared tooltip, stickyTracking is true by default,\n        // unless user says otherwise.\n        this.stickyTracking = pick(seriesUserOptions.stickyTracking, userPlotOptionsType.stickyTracking, userPlotOptionsSeries.stickyTracking, (this.tooltipOptions.shared && !this.noSharedTooltip ?\n            true :\n            options.stickyTracking));\n        // Delete marker object if not allowed (#1125)\n        if (typeOptions.marker === null) {\n            delete options.marker;\n        }\n        // Handle color zones\n        this.zoneAxis = options.zoneAxis;\n        const zones = this.zones = (options.zones || []).slice();\n        if ((options.negativeColor || options.negativeFillColor) &&\n            !options.zones) {\n            zone = {\n                value: options[this.zoneAxis + 'Threshold'] ||\n                    options.threshold ||\n                    0,\n                className: 'highcharts-negative'\n            };\n            if (!styledMode) {\n                zone.color = options.negativeColor;\n                zone.fillColor = options.negativeFillColor;\n            }\n            zones.push(zone);\n        }\n        if (zones.length) { // Push one extra zone for the rest\n            if (defined(zones[zones.length - 1].value)) {\n                zones.push(styledMode ? {} : {\n                    color: this.color,\n                    fillColor: this.fillColor\n                });\n            }\n        }\n        fireEvent(this, 'afterSetOptions', { options: options });\n        return options;\n    }\n    /**\n     * Return series name in \"Series {Number}\" format or the one defined by\n     * a user. This method can be simply overridden as series name format\n     * can vary (e.g. technical indicators).\n     *\n     * @function Highcharts.Series#getName\n     *\n     * @return {string}\n     * The series name.\n     */\n    getName() {\n        // #4119\n        return pick(this.options.name, 'Series ' + (this.index + 1));\n    }\n    /**\n     * @private\n     * @function Highcharts.Series#getCyclic\n     */\n    getCyclic(prop, value, defaults) {\n        const chart = this.chart, indexName = `${prop}Index`, counterName = `${prop}Counter`, len = (\n        // Symbol count\n        defaults?.length ||\n            // Color count\n            chart.options.chart.colorCount);\n        let i, setting;\n        if (!value) {\n            // Pick up either the colorIndex option, or the series.colorIndex\n            // after Series.update()\n            setting = pick(prop === 'color' ? this.options.colorIndex : void 0, this[indexName]);\n            if (defined(setting)) { // after Series.update()\n                i = setting;\n            }\n            else {\n                // #6138\n                if (!chart.series.length) {\n                    chart[counterName] = 0;\n                }\n                i = chart[counterName] % len;\n                chart[counterName] += 1;\n            }\n            if (defaults) {\n                value = defaults[i];\n            }\n        }\n        // Set the colorIndex\n        if (typeof i !== 'undefined') {\n            this[indexName] = i;\n        }\n        this[prop] = value;\n    }\n    /**\n     * Get the series' color based on either the options or pulled from\n     * global options.\n     *\n     * @private\n     * @function Highcharts.Series#getColor\n     */\n    getColor() {\n        if (this.chart.styledMode) {\n            this.getCyclic('color');\n        }\n        else if (this.options.colorByPoint) {\n            this.color = \"#cccccc\" /* Palette.neutralColor20 */;\n        }\n        else {\n            this.getCyclic('color', this.options.color ||\n                defaultOptions.plotOptions[this.type].color, this.chart.options.colors);\n        }\n    }\n    /**\n     * Get all points' instances created for this series.\n     *\n     * @private\n     * @function Highcharts.Series#getPointsCollection\n     */\n    getPointsCollection() {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n    }\n    /**\n     * Get the series' symbol based on either the options or pulled from\n     * global options.\n     *\n     * @private\n     * @function Highcharts.Series#getSymbol\n     */\n    getSymbol() {\n        const seriesMarkerOption = this.options.marker;\n        this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);\n    }\n    /**\n     * Finds the index of an existing point that matches the given point\n     * options.\n     *\n     * @private\n     * @function Highcharts.Series#findPointIndex\n     * @param {Highcharts.PointOptionsObject} optionsObject\n     * The options of the point.\n     * @param {number} fromIndex\n     * The index to start searching from, used for optimizing series with\n     * required sorting.\n     * @return {number|undefined}\n     * Returns the index of a matching point, or undefined if no match is found.\n     */\n    findPointIndex(optionsObject, fromIndex) {\n        const id = optionsObject.id, x = optionsObject.x, oldData = this.points, dataSorting = this.options.dataSorting;\n        let matchingPoint, matchedById, pointIndex;\n        if (id) {\n            const item = this.chart.get(id);\n            if (item instanceof Point) {\n                matchingPoint = item;\n            }\n        }\n        else if (this.linkedParent ||\n            this.enabledDataSorting ||\n            this.options.relativeXValue) {\n            let matcher = (oldPoint) => !oldPoint.touched &&\n                oldPoint.index === optionsObject.index;\n            if (dataSorting && dataSorting.matchByName) {\n                matcher = (oldPoint) => !oldPoint.touched &&\n                    oldPoint.name === optionsObject.name;\n            }\n            else if (this.options.relativeXValue) {\n                matcher = (oldPoint) => !oldPoint.touched &&\n                    oldPoint.options.x === optionsObject.x;\n            }\n            matchingPoint = find(oldData, matcher);\n            // Add unmatched point as a new point\n            if (!matchingPoint) {\n                return void 0;\n            }\n        }\n        if (matchingPoint) {\n            pointIndex = matchingPoint && matchingPoint.index;\n            if (typeof pointIndex !== 'undefined') {\n                matchedById = true;\n            }\n        }\n        // Search for the same X in the existing data set\n        if (typeof pointIndex === 'undefined' && isNumber(x)) {\n            pointIndex = this.xData.indexOf(x, fromIndex);\n        }\n        // Reduce pointIndex if data is cropped\n        if (pointIndex !== -1 &&\n            typeof pointIndex !== 'undefined' &&\n            this.cropped) {\n            pointIndex = (pointIndex >= this.cropStart) ?\n                pointIndex - this.cropStart : pointIndex;\n        }\n        if (!matchedById &&\n            isNumber(pointIndex) &&\n            oldData[pointIndex] && oldData[pointIndex].touched) {\n            pointIndex = void 0;\n        }\n        return pointIndex;\n    }\n    /**\n     * Internal function called from setData. If the point count is the same\n     * as it was, or if there are overlapping X values, just run\n     * Point.update which is cheaper, allows animation, and keeps references\n     * to points. This also allows adding or removing points if the X-es\n     * don't match.\n     *\n     * @private\n     * @function Highcharts.Series#updateData\n     */\n    updateData(data, animation) {\n        const options = this.options, dataSorting = options.dataSorting, oldData = this.points, pointsToAdd = [], requireSorting = this.requireSorting, equalLength = data.length === oldData.length;\n        let hasUpdatedByKey, i, point, lastIndex, succeeded = true;\n        this.xIncrement = null;\n        // Iterate the new data\n        data.forEach(function (pointOptions, i) {\n            const optionsObject = (defined(pointOptions) &&\n                this.pointClass.prototype.optionsToObject.call({ series: this }, pointOptions)) || {};\n            let pointIndex;\n            // Get the x of the new data point\n            const x = optionsObject.x, id = optionsObject.id;\n            if (id || isNumber(x)) {\n                pointIndex = this.findPointIndex(optionsObject, lastIndex);\n                // Matching X not found\n                // or used already due to ununique x values (#8995),\n                // add point (but later)\n                if (pointIndex === -1 ||\n                    typeof pointIndex === 'undefined') {\n                    pointsToAdd.push(pointOptions);\n                    // Matching X found, update\n                }\n                else if (oldData[pointIndex] &&\n                    pointOptions !== options.data[pointIndex]) {\n                    oldData[pointIndex].update(pointOptions, false, null, false);\n                    // Mark it touched, below we will remove all points that\n                    // are not touched.\n                    oldData[pointIndex].touched = true;\n                    // Speed optimize by only searching after last known\n                    // index. Performs ~20% bettor on large data sets.\n                    if (requireSorting) {\n                        lastIndex = pointIndex + 1;\n                    }\n                    // Point exists, no changes, don't remove it\n                }\n                else if (oldData[pointIndex]) {\n                    oldData[pointIndex].touched = true;\n                }\n                // If the length is equal and some of the nodes had a\n                // match in the same position, we don't want to remove\n                // non-matches.\n                if (!equalLength ||\n                    i !== pointIndex ||\n                    (dataSorting && dataSorting.enabled) ||\n                    this.hasDerivedData) {\n                    hasUpdatedByKey = true;\n                }\n            }\n            else {\n                // Gather all points that are not matched\n                pointsToAdd.push(pointOptions);\n            }\n        }, this);\n        // Remove points that don't exist in the updated data set\n        if (hasUpdatedByKey) {\n            i = oldData.length;\n            while (i--) {\n                point = oldData[i];\n                if (point && !point.touched && point.remove) {\n                    point.remove(false, animation);\n                }\n            }\n            // If we did not find keys (ids or x-values), and the length is the\n            // same, update one-to-one\n        }\n        else if (equalLength && (!dataSorting || !dataSorting.enabled)) {\n            data.forEach(function (point, i) {\n                // .update doesn't exist on a linked, hidden series (#3709)\n                // (#10187)\n                if (point !== oldData[i].y && !oldData[i].destroyed) {\n                    oldData[i].update(point, false, null, false);\n                }\n            });\n            // Don't add new points since those configs are used above\n            pointsToAdd.length = 0;\n            // Did not succeed in updating data\n        }\n        else {\n            succeeded = false;\n        }\n        oldData.forEach(function (point) {\n            if (point) {\n                point.touched = false;\n            }\n        });\n        if (!succeeded) {\n            return false;\n        }\n        // Add new points\n        pointsToAdd.forEach(function (point) {\n            this.addPoint(point, false, null, null, false);\n        }, this);\n        if (this.xIncrement === null &&\n            this.xData &&\n            this.xData.length) {\n            this.xIncrement = arrayMax(this.xData);\n            this.autoIncrement();\n        }\n        return true;\n    }\n    /**\n     * Apply a new set of data to the series and optionally redraw it. The\n     * new data array is passed by reference (except in case of\n     * `updatePoints`), and may later be mutated when updating the chart\n     * data.\n     *\n     * Note the difference in behaviour when setting the same amount of\n     * points, or a different amount of points, as handled by the\n     * `updatePoints` parameter.\n     *\n     * @sample highcharts/members/series-setdata/\n     *         Set new data from a button\n     * @sample highcharts/members/series-setdata-pie/\n     *         Set data in a pie\n     * @sample stock/members/series-setdata/\n     *         Set new data in Highcharts Stock\n     * @sample maps/members/series-setdata/\n     *         Set new data in Highmaps\n     *\n     * @function Highcharts.Series#setData\n     *\n     * @param {Array<Highcharts.PointOptionsType>} data\n     *        Takes an array of data in the same format as described under\n     *        `series.{type}.data` for the given series type, for example a\n     *        line series would take data in the form described under\n     *        [series.line.data](https://api.highcharts.com/highcharts/series.line.data).\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart after the series is altered. If\n     *        doing more operations on the chart, it is a good idea to set\n     *        redraw to false and call {@link Chart#redraw} after.\n     *\n     * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]\n     *        When the updated data is the same length as the existing data,\n     *        points will be updated by default, and animation visualizes\n     *        how the points are changed. Set false to disable animation, or\n     *        a configuration object to set duration or easing.\n     *\n     * @param {boolean} [updatePoints=true]\n     *        When this is true, points will be updated instead of replaced\n     *        whenever possible. This occurs a) when the updated data is the\n     *        same length as the existing data, b) when points are matched\n     *        by their id's, or c) when points can be matched by X values.\n     *        This allows updating with animation and performs better. In\n     *        this case, the original array is not passed by reference. Set\n     *        `false` to prevent.\n     */\n    setData(data, redraw = true, animation, updatePoints) {\n        const series = this, oldData = series.points, oldDataLength = (oldData && oldData.length) || 0, options = series.options, chart = series.chart, dataSorting = options.dataSorting, xAxis = series.xAxis, turboThreshold = options.turboThreshold, xData = this.xData, yData = this.yData, pointArrayMap = series.pointArrayMap, valueCount = pointArrayMap && pointArrayMap.length, keys = options.keys;\n        let i, pt, updatedData, indexOfX = 0, indexOfY = 1, firstPoint = null, copiedData;\n        if (!chart.options.chart.allowMutatingData) { // #4259\n            // Remove old reference\n            if (options.data) {\n                delete series.options.data;\n            }\n            if (series.userOptions.data) {\n                delete series.userOptions.data;\n            }\n            copiedData = merge(true, data);\n        }\n        data = copiedData || data || [];\n        const dataLength = data.length;\n        if (dataSorting && dataSorting.enabled) {\n            data = this.sortData(data);\n        }\n        // First try to run Point.update which is cheaper, allows animation,\n        // and keeps references to points.\n        if (chart.options.chart.allowMutatingData &&\n            updatePoints !== false &&\n            dataLength &&\n            oldDataLength &&\n            !series.cropped &&\n            !series.hasGroupedData &&\n            series.visible &&\n            // Soft updating has no benefit in boost, and causes JS error\n            // (#8355)\n            !series.boosted) {\n            updatedData = this.updateData(data, animation);\n        }\n        if (!updatedData) {\n            // Reset properties\n            series.xIncrement = null;\n            series.colorCounter = 0; // for series with colorByPoint (#1547)\n            // Update parallel arrays\n            this.parallelArrays.forEach(function (key) {\n                series[key + 'Data'].length = 0;\n            });\n            // In turbo mode, only one- or twodimensional arrays of numbers\n            // are allowed. The first value is tested, and we assume that\n            // all the rest are defined the same way. Although the 'for'\n            // loops are similar, they are repeated inside each if-else\n            // conditional for max performance.\n            if (turboThreshold && dataLength > turboThreshold) {\n                firstPoint = series.getFirstValidPoint(data);\n                if (isNumber(firstPoint)) { // assume all points are numbers\n                    for (i = 0; i < dataLength; i++) {\n                        xData[i] = this.autoIncrement();\n                        yData[i] = data[i];\n                    }\n                    // Assume all points are arrays when first point is\n                }\n                else if (isArray(firstPoint)) {\n                    if (valueCount) { // [x, low, high] or [x, o, h, l, c]\n                        if (firstPoint.length === valueCount) {\n                            for (i = 0; i < dataLength; i++) {\n                                xData[i] = this.autoIncrement();\n                                yData[i] = data[i];\n                            }\n                        }\n                        else {\n                            for (i = 0; i < dataLength; i++) {\n                                pt = data[i];\n                                xData[i] = pt[0];\n                                yData[i] =\n                                    pt.slice(1, valueCount + 1);\n                            }\n                        }\n                    }\n                    else { // [x, y]\n                        if (keys) {\n                            indexOfX = keys.indexOf('x');\n                            indexOfY = keys.indexOf('y');\n                            indexOfX = indexOfX >= 0 ? indexOfX : 0;\n                            indexOfY = indexOfY >= 0 ? indexOfY : 1;\n                        }\n                        if (firstPoint.length === 1) {\n                            indexOfY = 0;\n                        }\n                        if (indexOfX === indexOfY) {\n                            for (i = 0; i < dataLength; i++) {\n                                xData[i] = this.autoIncrement();\n                                yData[i] = data[i][indexOfY];\n                            }\n                        }\n                        else {\n                            for (i = 0; i < dataLength; i++) {\n                                pt = data[i];\n                                xData[i] = pt[indexOfX];\n                                yData[i] = pt[indexOfY];\n                            }\n                        }\n                    }\n                }\n                else {\n                    // Highcharts expects configs to be numbers or arrays in\n                    // turbo mode\n                    error(12, false, chart);\n                }\n            }\n            else {\n                for (i = 0; i < dataLength; i++) {\n                    pt = { series: series };\n                    series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);\n                    series.updateParallelArrays(pt, i);\n                }\n            }\n            // Forgetting to cast strings to numbers is a common caveat when\n            // handling CSV or JSON\n            if (yData && isString(yData[0])) {\n                error(14, true, chart);\n            }\n            series.data = [];\n            series.options.data = series.userOptions.data = data;\n            // destroy old points\n            i = oldDataLength;\n            while (i--) {\n                oldData[i]?.destroy();\n            }\n            // reset minRange (#878)\n            if (xAxis) {\n                xAxis.minRange = xAxis.userMinRange;\n            }\n            // redraw\n            series.isDirty = chart.isDirtyBox = true;\n            series.isDirtyData = !!oldData;\n            animation = false;\n        }\n        // Typically for pie series, points need to be processed and\n        // generated prior to rendering the legend\n        if (options.legendType === 'point') {\n            this.processData();\n            this.generatePoints();\n        }\n        if (redraw) {\n            chart.redraw(animation);\n        }\n    }\n    /**\n     * Internal function to sort series data\n     *\n     * @private\n     * @function Highcharts.Series#sortData\n     * @param {Array<Highcharts.PointOptionsType>} data\n     * Force data grouping.\n     */\n    sortData(data) {\n        const series = this, options = series.options, dataSorting = options.dataSorting, sortKey = dataSorting.sortKey || 'y', getPointOptionsObject = function (series, pointOptions) {\n            return (defined(pointOptions) &&\n                series.pointClass.prototype.optionsToObject.call({\n                    series: series\n                }, pointOptions)) || {};\n        };\n        data.forEach(function (pointOptions, i) {\n            data[i] = getPointOptionsObject(series, pointOptions);\n            data[i].index = i;\n        }, this);\n        // Sorting\n        const sortedData = data.concat().sort((a, b) => {\n            const aValue = getNestedProperty(sortKey, a);\n            const bValue = getNestedProperty(sortKey, b);\n            return bValue < aValue ? -1 : bValue > aValue ? 1 : 0;\n        });\n        // Set x value depending on the position in the array\n        sortedData.forEach(function (point, i) {\n            point.x = i;\n        }, this);\n        // Set the same x for linked series points if they don't have their\n        // own sorting\n        if (series.linkedSeries) {\n            series.linkedSeries.forEach(function (linkedSeries) {\n                const options = linkedSeries.options, seriesData = options.data;\n                if ((!options.dataSorting ||\n                    !options.dataSorting.enabled) &&\n                    seriesData) {\n                    seriesData.forEach(function (pointOptions, i) {\n                        seriesData[i] = getPointOptionsObject(linkedSeries, pointOptions);\n                        if (data[i]) {\n                            seriesData[i].x = data[i].x;\n                            seriesData[i].index = i;\n                        }\n                    });\n                    linkedSeries.setData(seriesData, false);\n                }\n            });\n        }\n        return data;\n    }\n    /**\n     * Internal function to process the data by cropping away unused data\n     * points if the series is longer than the crop threshold. This saves\n     * computing time for large series.\n     *\n     * @private\n     * @function Highcharts.Series#getProcessedData\n     * @param {boolean} [forceExtremesFromAll]\n     * Force getting extremes of a total series data range.\n     */\n    getProcessedData(forceExtremesFromAll) {\n        const series = this, xAxis = series.xAxis, options = series.options, cropThreshold = options.cropThreshold, getExtremesFromAll = forceExtremesFromAll ||\n            series.getExtremesFromAll ||\n            options.getExtremesFromAll, // #4599\n        logarithmic = xAxis?.logarithmic, isCartesian = series.isCartesian;\n        let croppedData, cropped, cropStart = 0, xExtremes, min, max, \n        // copied during slice operation:\n        processedXData = series.xData, processedYData = series.yData, updatingNames = false;\n        const dataLength = processedXData.length;\n        if (xAxis) {\n            // corrected for log axis (#3053)\n            xExtremes = xAxis.getExtremes();\n            min = xExtremes.min;\n            max = xExtremes.max;\n            updatingNames = !!(xAxis.categories && !xAxis.names.length);\n        }\n        // optionally filter out points outside the plot area\n        if (isCartesian &&\n            series.sorted &&\n            !getExtremesFromAll &&\n            (!cropThreshold ||\n                dataLength > cropThreshold ||\n                series.forceCrop)) {\n            // it's outside current extremes\n            if (processedXData[dataLength - 1] < min ||\n                processedXData[0] > max) {\n                processedXData = [];\n                processedYData = [];\n                // only crop if it's actually spilling out\n            }\n            else if (series.yData && (processedXData[0] < min ||\n                processedXData[dataLength - 1] > max)) {\n                croppedData = this.cropData(series.xData, series.yData, min, max);\n                processedXData = croppedData.xData;\n                processedYData = croppedData.yData;\n                cropStart = croppedData.start;\n                cropped = true;\n            }\n        }\n        // Find the closest distance between processed points\n        const closestPointRange = getClosestDistance([\n            logarithmic ?\n                processedXData.map(logarithmic.log2lin) :\n                processedXData\n        ], \n        // Unsorted data is not supported by the line tooltip, as well as\n        // data grouping and navigation in Stock charts (#725) and width\n        // calculation of columns (#1900). Avoid warning during the\n        // premature processing pass in updateNames (#16104).\n        () => (series.requireSorting &&\n            !updatingNames &&\n            error(15, false, series.chart)));\n        return {\n            xData: processedXData,\n            yData: processedYData,\n            cropped: cropped,\n            cropStart: cropStart,\n            closestPointRange: closestPointRange\n        };\n    }\n    /**\n     * Internal function to apply processed data.\n     * In Highcharts Stock, this function is extended to provide data grouping.\n     *\n     * @private\n     * @function Highcharts.Series#processData\n     * @param {boolean} [force]\n     * Force data grouping.\n     */\n    processData(force) {\n        const series = this, xAxis = series.xAxis;\n        // If the series data or axes haven't changed, don't go through\n        // this. Return false to pass the message on to override methods\n        // like in data grouping.\n        if (series.isCartesian &&\n            !series.isDirty &&\n            !xAxis.isDirty &&\n            !series.yAxis.isDirty &&\n            !force) {\n            return false;\n        }\n        const processedData = series.getProcessedData();\n        // Record the properties\n        series.cropped = processedData.cropped; // undefined or true\n        series.cropStart = processedData.cropStart;\n        series.processedXData = processedData.xData;\n        series.processedYData = processedData.yData;\n        series.closestPointRange = (series.basePointRange = processedData.closestPointRange);\n        fireEvent(series, 'afterProcessData');\n    }\n    /**\n     * Iterate over xData and crop values between min and max. Returns\n     * object containing crop start/end cropped xData with corresponding\n     * part of yData, dataMin and dataMax within the cropped range.\n     *\n     * @private\n     * @function Highcharts.Series#cropData\n     */\n    cropData(xData, yData, min, max) {\n        const dataLength = xData.length;\n        let i, j, start = 0, end = dataLength;\n        // Iterate up to find slice start\n        for (i = 0; i < dataLength; i++) {\n            if (xData[i] >= min) {\n                start = Math.max(0, i - 1);\n                break;\n            }\n        }\n        // Proceed to find slice end\n        for (j = i; j < dataLength; j++) {\n            if (xData[j] > max) {\n                end = j + 1;\n                break;\n            }\n        }\n        return {\n            xData: xData.slice(start, end),\n            yData: yData.slice(start, end),\n            start,\n            end\n        };\n    }\n    /**\n     * Generate the data point after the data has been processed by cropping\n     * away unused points and optionally grouped in Highcharts Stock.\n     *\n     * @private\n     * @function Highcharts.Series#generatePoints\n     */\n    generatePoints() {\n        const series = this, options = series.options, dataOptions = (series.processedData || options.data), processedXData = series.processedXData, processedYData = series.processedYData, PointClass = series.pointClass, processedDataLength = processedXData.length, cropStart = series.cropStart || 0, hasGroupedData = series.hasGroupedData, keys = options.keys, points = [], groupCropStartIndex = (options.dataGrouping &&\n            options.dataGrouping.groupAll ?\n            cropStart :\n            0);\n        let dataLength, cursor, point, i, data = series.data;\n        if (!data && !hasGroupedData) {\n            const arr = [];\n            arr.length = dataOptions.length;\n            data = series.data = arr;\n        }\n        if (keys && hasGroupedData) {\n            // grouped data has already applied keys (#6590)\n            series.options.keys = false;\n        }\n        for (i = 0; i < processedDataLength; i++) {\n            cursor = cropStart + i;\n            if (!hasGroupedData) {\n                point = data[cursor];\n                // #970:\n                if (!point &&\n                    typeof dataOptions[cursor] !== 'undefined') {\n                    data[cursor] = point = (new PointClass()).init(series, dataOptions[cursor], processedXData[i]);\n                }\n            }\n            else {\n                // splat the y data in case of ohlc data array\n                point = (new PointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));\n                point.dataGroup = series.groupMap[groupCropStartIndex + i];\n                if (point.dataGroup.options) {\n                    point.options = point.dataGroup.options;\n                    extend(point, point.dataGroup.options);\n                    // Collision of props and options (#9770)\n                    delete point.dataLabels;\n                }\n            }\n            if (point) { // #6279\n                /**\n                 * Contains the point's index in the `Series.points` array.\n                 *\n                 * @name Highcharts.Point#index\n                 * @type {number}\n                 * @readonly\n                 */\n                // For faster access in Point.update\n                point.index = hasGroupedData ?\n                    (groupCropStartIndex + i) : cursor;\n                points[i] = point;\n            }\n        }\n        // restore keys options (#6590)\n        series.options.keys = keys;\n        // Hide cropped-away points - this only runs when the number of\n        // points is above cropThreshold, or when swithching view from\n        // non-grouped data to grouped data (#637)\n        if (data &&\n            (processedDataLength !== (dataLength = data.length) ||\n                hasGroupedData)) {\n            for (i = 0; i < dataLength; i++) {\n                // when has grouped data, clear all points\n                if (i === cropStart && !hasGroupedData) {\n                    i += processedDataLength;\n                }\n                if (data[i]) {\n                    data[i].destroyElements();\n                    data[i].plotX = void 0; // #1003\n                }\n            }\n        }\n        /**\n         * Read only. An array containing those values converted to points.\n         * In case the series data length exceeds the `cropThreshold`, or if\n         * the data is grouped, `series.data` doesn't contain all the\n         * points. Also, in case a series is hidden, the `data` array may be\n         * empty. To access raw values, `series.options.data` will always be\n         * up to date. `Series.data` only contains the points that have been\n         * created on demand. To modify the data, use\n         * {@link Highcharts.Series#setData} or\n         * {@link Highcharts.Point#update}.\n         *\n         * @see Series.points\n         *\n         * @name Highcharts.Series#data\n         * @type {Array<Highcharts.Point>}\n         */\n        series.data = data;\n        /**\n         * An array containing all currently visible point objects. In case\n         * of cropping, the cropped-away points are not part of this array.\n         * The `series.points` array starts at `series.cropStart` compared\n         * to `series.data` and `series.options.data`. If however the series\n         * data is grouped, these can't be correlated one to one. To modify\n         * the data, use {@link Highcharts.Series#setData} or\n         * {@link Highcharts.Point#update}.\n         *\n         * @name Highcharts.Series#points\n         * @type {Array<Highcharts.Point>}\n         */\n        series.points = points;\n        fireEvent(this, 'afterGeneratePoints');\n    }\n    /**\n     * Get current X extremes for the visible data.\n     *\n     * @private\n     * @function Highcharts.Series#getXExtremes\n     * @param {Array<number>} xData\n     * The data to inspect. Defaults to the current data within the visible\n     * range.\n     */\n    getXExtremes(xData) {\n        return {\n            min: arrayMin(xData),\n            max: arrayMax(xData)\n        };\n    }\n    /**\n     * Calculate Y extremes for the visible data. The result is returned\n     * as an object with `dataMin` and `dataMax` properties.\n     *\n     * @private\n     * @function Highcharts.Series#getExtremes\n     * @param {Array<number>} [yData]\n     * The data to inspect. Defaults to the current data within the visible\n     * range.\n     * @param {boolean} [forceExtremesFromAll]\n     * Force getting extremes of a total series data range.\n     */\n    getExtremes(yData, forceExtremesFromAll) {\n        const xAxis = this.xAxis, yAxis = this.yAxis, xData = this.processedXData || this.xData, activeYData = [], \n        // Handle X outside the viewed area. This does not work with\n        // non-sorted data like scatter (#7639).\n        shoulder = this.requireSorting && !this.is('column') ?\n            1 : 0, \n        // #2117, need to compensate for log X axis\n        positiveValuesOnly = yAxis ? yAxis.positiveValuesOnly : false;\n        let xExtremes, validValue, withinRange, x, y, i, j, xMin = 0, xMax = 0, activeCounter = 0;\n        yData = yData || this.stackedYData || this.processedYData || [];\n        const yDataLength = yData.length;\n        if (xAxis) {\n            xExtremes = xAxis.getExtremes();\n            xMin = xExtremes.min;\n            xMax = xExtremes.max;\n        }\n        for (i = 0; i < yDataLength; i++) {\n            x = xData[i];\n            y = yData[i];\n            // For points within the visible range, including the first\n            // point outside the visible range (#7061), consider y extremes.\n            validValue = ((isNumber(y) ||\n                isArray(y)) && ((isNumber(y) ? y > 0 : y.length) ||\n                !positiveValuesOnly));\n            withinRange = (forceExtremesFromAll ||\n                this.getExtremesFromAll ||\n                this.options.getExtremesFromAll ||\n                this.cropped ||\n                !xAxis || // for colorAxis support\n                ((xData[i + shoulder] || x) >= xMin &&\n                    (xData[i - shoulder] || x) <= xMax));\n            if (validValue && withinRange) {\n                j = y.length;\n                if (j) { // array, like ohlc or range data\n                    while (j--) {\n                        if (isNumber(y[j])) { // #7380, #11513\n                            activeYData[activeCounter++] = y[j];\n                        }\n                    }\n                }\n                else {\n                    activeYData[activeCounter++] = y;\n                }\n            }\n        }\n        const dataExtremes = {\n            activeYData,\n            dataMin: arrayMin(activeYData),\n            dataMax: arrayMax(activeYData)\n        };\n        fireEvent(this, 'afterGetExtremes', { dataExtremes });\n        return dataExtremes;\n    }\n    /**\n     * Set the current data extremes as `dataMin` and `dataMax` on the\n     * Series item. Use this only when the series properties should be\n     * updated.\n     *\n     * @private\n     * @function Highcharts.Series#applyExtremes\n     */\n    applyExtremes() {\n        const dataExtremes = this.getExtremes();\n        /**\n         * Contains the minimum value of the series' data point. Some series\n         * types like `networkgraph` do not support this property as they\n         * lack a `y`-value.\n         * @name Highcharts.Series#dataMin\n         * @type {number|undefined}\n         * @readonly\n         */\n        this.dataMin = dataExtremes.dataMin;\n        /**\n         * Contains the maximum value of the series' data point. Some series\n         * types like `networkgraph` do not support this property as they\n         * lack a `y`-value.\n         * @name Highcharts.Series#dataMax\n         * @type {number|undefined}\n         * @readonly\n         */\n        this.dataMax = dataExtremes.dataMax;\n        return dataExtremes;\n    }\n    /**\n     * Find and return the first non null point in the data\n     *\n     * @private\n     * @function Highcharts.Series.getFirstValidPoint\n     * @param {Array<Highcharts.PointOptionsType>} data\n     * Array of options for points\n     */\n    getFirstValidPoint(data) {\n        const dataLength = data.length;\n        let i = 0, firstPoint = null;\n        while (firstPoint === null && i < dataLength) {\n            firstPoint = data[i];\n            i++;\n        }\n        return firstPoint;\n    }\n    /**\n     * Translate data points from raw data values to chart specific\n     * positioning data needed later in the `drawPoints` and `drawGraph`\n     * functions. This function can be overridden in plugins and custom\n     * series type implementations.\n     *\n     * @function Highcharts.Series#translate\n     *\n     * @emits Highcharts.Series#events:translate\n     */\n    translate() {\n        if (!this.processedXData) { // hidden series\n            this.processData();\n        }\n        this.generatePoints();\n        const series = this, options = series.options, stacking = options.stacking, xAxis = series.xAxis, categories = xAxis.categories, enabledDataSorting = series.enabledDataSorting, yAxis = series.yAxis, points = series.points, dataLength = points.length, pointPlacement = series.pointPlacementToXValue(), // #7860\n        dynamicallyPlaced = Boolean(pointPlacement), threshold = options.threshold, stackThreshold = options.startFromThreshold ? threshold : 0;\n        let i, plotX, lastPlotX, stackIndicator, closestPointRangePx = Number.MAX_VALUE;\n        /**\n         * Plotted coordinates need to be within a limited range. Drawing\n         * too far outside the viewport causes various rendering issues\n         * (#3201, #3923, #7555).\n         * @private\n         */\n        function limitedRange(val) {\n            return clamp(val, -1e5, 1e5);\n        }\n        // Translate each point\n        for (i = 0; i < dataLength; i++) {\n            const point = points[i], xValue = point.x;\n            let stackItem, stackValues, yValue = point.y, lowValue = point.low;\n            const stacks = stacking && yAxis.stacking?.stacks[(series.negStacks &&\n                yValue <\n                    (stackThreshold ? 0 : threshold) ?\n                '-' :\n                '') + series.stackKey];\n            plotX = xAxis.translate(// #3923\n            xValue, false, false, false, true, pointPlacement);\n            /**\n             * The translated X value for the point in terms of pixels. Relative\n             * to the X axis position if the series has one, otherwise relative\n             * to the plot area. Depending on the series type this value might\n             * not be defined.\n             *\n             * In an inverted chart the x-axis is going from the bottom to the\n             * top so the `plotX` value is the number of pixels from the bottom\n             * of the axis.\n             *\n             * @see Highcharts.Point#pos\n             * @name Highcharts.Point#plotX\n             * @type {number|undefined}\n             */\n            point.plotX = isNumber(plotX) ? correctFloat(// #5236\n            limitedRange(plotX) // #3923\n            ) : void 0;\n            // Calculate the bottom y value for stacked series\n            if (stacking &&\n                series.visible &&\n                stacks &&\n                stacks[xValue]) {\n                stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);\n                if (!point.isNull && stackIndicator.key) {\n                    stackItem = stacks[xValue];\n                    stackValues = stackItem.points[stackIndicator.key];\n                }\n                if (stackItem && isArray(stackValues)) {\n                    lowValue = stackValues[0];\n                    yValue = stackValues[1];\n                    if (lowValue === stackThreshold &&\n                        stackIndicator.key === stacks[xValue].base) {\n                        lowValue = pick(isNumber(threshold) ? threshold : yAxis.min);\n                    }\n                    // #1200, #1232\n                    if (yAxis.positiveValuesOnly &&\n                        defined(lowValue) &&\n                        lowValue <= 0) {\n                        lowValue = void 0;\n                    }\n                    point.total = point.stackTotal = pick(stackItem.total);\n                    point.percentage = defined(point.y) && stackItem.total ?\n                        (point.y / stackItem.total * 100) : void 0;\n                    point.stackY = yValue;\n                    // in case of variwide series (where widths of points are\n                    // different in most cases), stack labels are positioned\n                    // wrongly, so the call of the setOffset is omited here and\n                    // labels are correctly positioned later, at the end of the\n                    // variwide's translate function (#10962)\n                    if (!series.irregularWidths) {\n                        stackItem.setOffset(series.pointXOffset || 0, series.barW || 0, void 0, void 0, void 0, series.xAxis);\n                    }\n                }\n            }\n            // Set translated yBottom or remove it\n            point.yBottom = defined(lowValue) ?\n                limitedRange(yAxis.translate(lowValue, false, true, false, true)) :\n                void 0;\n            // General hook, used for Highcharts Stock compare and cumulative\n            if (series.dataModify) {\n                yValue = series.dataModify.modifyValue(yValue, i);\n            }\n            // Set the the plotY value, reset it for redraws #3201, #18422\n            let plotY;\n            if (isNumber(yValue) && point.plotX !== void 0) {\n                plotY = yAxis.translate(yValue, false, true, false, true);\n                plotY = isNumber(plotY) ? limitedRange(plotY) : void 0;\n            }\n            /**\n             * The translated Y value for the point in terms of pixels. Relative\n             * to the Y axis position if the series has one, otherwise relative\n             * to the plot area. Depending on the series type this value might\n             * not be defined.\n             *\n             * In an inverted chart the y-axis is going from right to left\n             * so the `plotY` value is the number of pixels from the right\n             * of the `yAxis`.\n             *\n             * @see Highcharts.Point#pos\n             * @name Highcharts.Point#plotY\n             * @type {number|undefined}\n             */\n            point.plotY = plotY;\n            point.isInside = this.isPointInside(point);\n            // Set client related positions for mouse tracking\n            point.clientX = dynamicallyPlaced ?\n                correctFloat(xAxis.translate(xValue, false, false, false, true, pointPlacement)) :\n                plotX; // #1514, #5383, #5518\n            // Negative points #19028\n            point.negative = (point.y || 0) < (threshold || 0);\n            // some API data\n            point.category = pick(categories && categories[point.x], point.x);\n            // Determine auto enabling of markers (#3635, #5099)\n            if (!point.isNull && point.visible !== false) {\n                if (typeof lastPlotX !== 'undefined') {\n                    closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));\n                }\n                lastPlotX = plotX;\n            }\n            // Find point zone\n            point.zone = this.zones.length ? point.getZone() : void 0;\n            // Animate new points with data sorting\n            if (!point.graphic && series.group && enabledDataSorting) {\n                point.isNew = true;\n            }\n        }\n        series.closestPointRangePx = closestPointRangePx;\n        fireEvent(this, 'afterTranslate');\n    }\n    /**\n     * Return the series points with null points filtered out.\n     *\n     * @function Highcharts.Series#getValidPoints\n     *\n     * @param {Array<Highcharts.Point>} [points]\n     * The points to inspect, defaults to {@link Series.points}.\n     *\n     * @param {boolean} [insideOnly=false]\n     * Whether to inspect only the points that are inside the visible view.\n     *\n     * @param {boolean} [allowNull=false]\n     * Whether to allow null points to pass as valid points.\n     *\n     * @return {Array<Highcharts.Point>}\n     * The valid points.\n     */\n    getValidPoints(points, insideOnly, allowNull) {\n        const chart = this.chart;\n        // #3916, #5029, #5085\n        return (points || this.points || []).filter(function (point) {\n            const { plotX, plotY } = point, \n            // Undefined plotY is treated as null when negative values\n            // in log axis (#18422)\n            asNull = !allowNull && (point.isNull || !isNumber(plotY));\n            if (asNull || (insideOnly && !chart.isInsidePlot(plotX, plotY, { inverted: chart.inverted }))) {\n                return false;\n            }\n            return point.visible !== false;\n        });\n    }\n    /**\n     * Get the clipping for the series. Could be called for a series to\n     * initiate animating the clip or to set the final clip (only width\n     * and x).\n     *\n     * @private\n     * @function Highcharts.Series#getClip\n     */\n    getClipBox() {\n        const { chart, xAxis, yAxis } = this;\n        // If no axes on the series, use global clipBox\n        const seriesBox = merge(chart.clipBox);\n        // Otherwise, use clipBox.width which is corrected for plotBorderWidth\n        // and clipOffset\n        if (xAxis && xAxis.len !== chart.plotSizeX) {\n            seriesBox.width = xAxis.len;\n        }\n        if (yAxis && yAxis.len !== chart.plotSizeY) {\n            seriesBox.height = yAxis.len;\n        }\n        return seriesBox;\n    }\n    /**\n     * Get the shared clip key, creating it if it doesn't exist.\n     *\n     * @private\n     * @function Highcharts.Series#getSharedClipKey\n     */\n    getSharedClipKey() {\n        this.sharedClipKey = (this.options.xAxis || 0) + ',' +\n            (this.options.yAxis || 0);\n        return this.sharedClipKey;\n    }\n    /**\n     * Set the clipping for the series. For animated series the clip is later\n     * modified.\n     *\n     * @private\n     * @function Highcharts.Series#setClip\n     */\n    setClip() {\n        const { chart, group, markerGroup } = this, sharedClips = chart.sharedClips, renderer = chart.renderer, clipBox = this.getClipBox(), sharedClipKey = this.getSharedClipKey(); // #4526\n        let clipRect = sharedClips[sharedClipKey];\n        // If a clipping rectangle for the same set of axes does not exist,\n        // create it\n        if (!clipRect) {\n            sharedClips[sharedClipKey] = clipRect = renderer.clipRect(clipBox);\n            // When setting chart size, or when the series is rendered again before\n            // starting animating, in compliance to a responsive rule\n        }\n        else {\n            clipRect.animate(clipBox);\n        }\n        if (group) {\n            // When clip is false, reset to no clip after animation\n            group.clip(this.options.clip === false ? void 0 : clipRect);\n        }\n        // Unclip temporary animation clip\n        if (markerGroup) {\n            markerGroup.clip();\n        }\n    }\n    /**\n     * Animate in the series. Called internally twice. First with the `init`\n     * parameter set to true, which sets up the initial state of the\n     * animation. Then when ready, it is called with the `init` parameter\n     * undefined, in order to perform the actual animation.\n     *\n     * @function Highcharts.Series#animate\n     *\n     * @param {boolean} [init]\n     * Initialize the animation.\n     */\n    animate(init) {\n        const { chart, group, markerGroup } = this, inverted = chart.inverted, animation = animObject(this.options.animation), \n        // The key for temporary animation clips\n        animationClipKey = [\n            this.getSharedClipKey(),\n            animation.duration,\n            animation.easing,\n            animation.defer\n        ].join(',');\n        let animationClipRect = chart.sharedClips[animationClipKey], markerAnimationClipRect = chart.sharedClips[animationClipKey + 'm'];\n        // Initialize the animation. Set up the clipping rectangle.\n        if (init && group) {\n            const clipBox = this.getClipBox();\n            // Create temporary animation clips\n            if (!animationClipRect) {\n                clipBox.width = 0;\n                if (inverted) {\n                    clipBox.x = chart.plotHeight;\n                }\n                animationClipRect = chart.renderer.clipRect(clipBox);\n                chart.sharedClips[animationClipKey] = animationClipRect;\n                // The marker clip box. The number 99 is a safe margin to avoid\n                // markers being clipped during animation.\n                const markerClipBox = {\n                    x: inverted ? -99 : -99,\n                    y: inverted ? -99 : -99,\n                    width: inverted ? chart.plotWidth + 199 : 99,\n                    height: inverted ? 99 : chart.plotHeight + 199\n                };\n                markerAnimationClipRect = chart.renderer.clipRect(markerClipBox);\n                chart.sharedClips[animationClipKey + 'm'] = markerAnimationClipRect;\n            }\n            else {\n                // When height changes during animation, typically due to\n                // responsive settings\n                animationClipRect.attr('height', clipBox.height);\n            }\n            group.clip(animationClipRect);\n            if (markerGroup) {\n                markerGroup.clip(markerAnimationClipRect);\n            }\n            // Run the animation\n        }\n        else if (animationClipRect &&\n            // Only first series in this pane\n            !animationClipRect.hasClass('highcharts-animating')) {\n            const finalBox = this.getClipBox(), step = animation.step;\n            // Only do this when there are actually markers\n            if (markerGroup && markerGroup.element.childNodes.length) {\n                // To provide as smooth animation as possible, update the marker\n                // group clipping in steps of the main group animation\n                animation.step = function (val, fx) {\n                    if (step) {\n                        step.apply(fx, arguments);\n                    }\n                    if (fx.prop === 'width' &&\n                        markerAnimationClipRect &&\n                        markerAnimationClipRect.element) {\n                        markerAnimationClipRect.attr(inverted ? 'height' : 'width', val + 99);\n                    }\n                };\n            }\n            animationClipRect\n                .addClass('highcharts-animating')\n                .animate(finalBox, animation);\n        }\n    }\n    /**\n     * This runs after animation to land on the final plot clipping.\n     *\n     * @private\n     * @function Highcharts.Series#afterAnimate\n     *\n     * @emits Highcharts.Series#event:afterAnimate\n     */\n    afterAnimate() {\n        this.setClip();\n        // Destroy temporary clip rectangles that are no longer in use\n        objectEach(this.chart.sharedClips, (clip, key, sharedClips) => {\n            if (clip && !this.chart.container.querySelector(`[clip-path=\"url(#${clip.id})\"]`)) {\n                clip.destroy();\n                delete sharedClips[key];\n            }\n        });\n        this.finishedAnimating = true;\n        fireEvent(this, 'afterAnimate');\n    }\n    /**\n     * Draw the markers for line-like series types, and columns or other\n     * graphical representation for {@link Point} objects for other series\n     * types. The resulting element is typically stored as\n     * {@link Point.graphic}, and is created on the first call and updated\n     * and moved on subsequent calls.\n     *\n     * @function Highcharts.Series#drawPoints\n     */\n    drawPoints(points = this.points) {\n        const series = this, chart = series.chart, styledMode = chart.styledMode, { colorAxis, options } = series, seriesMarkerOptions = options.marker, markerGroup = series[series.specialGroup || 'markerGroup'], xAxis = series.xAxis, globallyEnabled = pick(seriesMarkerOptions.enabled, !xAxis || xAxis.isRadial ? true : null, \n        // Use larger or equal as radius is null in bubbles (#6321)\n        series.closestPointRangePx >= (seriesMarkerOptions.enabledThreshold *\n            seriesMarkerOptions.radius));\n        let i, point, graphic, verb, pointMarkerOptions, hasPointMarker, markerAttribs;\n        if (seriesMarkerOptions.enabled !== false ||\n            series._hasPointMarkers) {\n            for (i = 0; i < points.length; i++) {\n                point = points[i];\n                graphic = point.graphic;\n                verb = graphic ? 'animate' : 'attr';\n                pointMarkerOptions = point.marker || {};\n                hasPointMarker = !!point.marker;\n                const shouldDrawMarker = ((globallyEnabled &&\n                    typeof pointMarkerOptions.enabled === 'undefined') || pointMarkerOptions.enabled) && !point.isNull && point.visible !== false;\n                // only draw the point if y is defined\n                if (shouldDrawMarker) {\n                    // Shortcuts\n                    const symbol = pick(pointMarkerOptions.symbol, series.symbol, 'rect');\n                    markerAttribs = series.markerAttribs(point, (point.selected && 'select'));\n                    // Set starting position for point sliding animation.\n                    if (series.enabledDataSorting) {\n                        point.startXPos = xAxis.reversed ?\n                            -(markerAttribs.width || 0) :\n                            xAxis.width;\n                    }\n                    const isInside = point.isInside !== false;\n                    if (!graphic &&\n                        isInside &&\n                        ((markerAttribs.width || 0) > 0 || point.hasImage)) {\n                        /**\n                         * SVG graphic representing the point in the chart. In\n                         * some cases it may be a hidden graphic to improve\n                         * accessibility.\n                         *\n                         * Typically this is a simple shape, like a `rect`\n                         * for column charts or `path` for line markers, but\n                         * for some complex series types like boxplot or 3D\n                         * charts, the graphic may be a `g` element\n                         * containing other shapes. The graphic is generated\n                         * the first time {@link Series#drawPoints} runs,\n                         * and updated and moved on subsequent runs.\n                         *\n                         * @see Highcharts.Point#graphics\n                         *\n                         * @name Highcharts.Point#graphic\n                         * @type {Highcharts.SVGElement|undefined}\n                         */\n                        point.graphic = graphic = chart.renderer\n                            .symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ?\n                            pointMarkerOptions :\n                            seriesMarkerOptions)\n                            .add(markerGroup);\n                        // Sliding animation for new points\n                        if (series.enabledDataSorting &&\n                            chart.hasRendered) {\n                            graphic.attr({\n                                x: point.startXPos\n                            });\n                            verb = 'animate';\n                        }\n                    }\n                    if (graphic && verb === 'animate') { // update\n                        // Since the marker group isn't clipped, each\n                        // individual marker must be toggled\n                        graphic[isInside ? 'show' : 'hide'](isInside)\n                            .animate(markerAttribs);\n                    }\n                    // Presentational attributes\n                    if (graphic) {\n                        const pointAttr = series.pointAttribs(point, ((styledMode || !point.selected) ?\n                            void 0 :\n                            'select'));\n                        if (!styledMode) {\n                            graphic[verb](pointAttr);\n                        }\n                        else if (colorAxis) { // #14114\n                            graphic['css']({\n                                fill: pointAttr.fill\n                            });\n                        }\n                    }\n                    if (graphic) {\n                        graphic.addClass(point.getClassName(), true);\n                    }\n                }\n                else if (graphic) {\n                    point.graphic = graphic.destroy(); // #1269\n                }\n            }\n        }\n    }\n    /**\n     * Get non-presentational attributes for a point. Used internally for\n     * both styled mode and classic. Can be overridden for different series\n     * types.\n     *\n     * @see Series#pointAttribs\n     *\n     * @function Highcharts.Series#markerAttribs\n     *\n     * @param {Highcharts.Point} point\n     * The Point to inspect.\n     *\n     * @param {string} [state]\n     * The state, can be either `hover`, `select` or undefined.\n     *\n     * @return {Highcharts.SVGAttributes}\n     * A hash containing those attributes that are not settable from CSS.\n     */\n    markerAttribs(point, state) {\n        const seriesOptions = this.options, seriesMarkerOptions = seriesOptions.marker, pointMarkerOptions = point.marker || {}, symbol = (pointMarkerOptions.symbol ||\n            seriesMarkerOptions.symbol), attribs = {};\n        let seriesStateOptions, pointStateOptions, radius = pick(pointMarkerOptions.radius, seriesMarkerOptions && seriesMarkerOptions.radius);\n        // Handle hover and select states\n        if (state) {\n            seriesStateOptions = seriesMarkerOptions.states[state];\n            pointStateOptions = pointMarkerOptions.states &&\n                pointMarkerOptions.states[state];\n            radius = pick(pointStateOptions && pointStateOptions.radius, seriesStateOptions && seriesStateOptions.radius, radius && radius + (seriesStateOptions && seriesStateOptions.radiusPlus ||\n                0));\n        }\n        point.hasImage = symbol && symbol.indexOf('url') === 0;\n        if (point.hasImage) {\n            radius = 0; // and subsequently width and height is not set\n        }\n        const pos = point.pos();\n        if (isNumber(radius) && pos) {\n            attribs.x = pos[0] - radius;\n            attribs.y = pos[1] - radius;\n            if (seriesOptions.crisp) {\n                // Math.floor for #1843:\n                attribs.x = Math.floor(attribs.x);\n            }\n        }\n        if (radius) {\n            attribs.width = attribs.height = 2 * radius;\n        }\n        return attribs;\n    }\n    /**\n     * Internal function to get presentational attributes for each point.\n     * Unlike {@link Series#markerAttribs}, this function should return\n     * those attributes that can also be set in CSS. In styled mode,\n     * `pointAttribs` won't be called.\n     *\n     * @private\n     * @function Highcharts.Series#pointAttribs\n     *\n     * @param {Highcharts.Point} [point]\n     * The point instance to inspect.\n     *\n     * @param {string} [state]\n     * The point state, can be either `hover`, `select` or 'normal'. If\n     * undefined, normal state is assumed.\n     *\n     * @return {Highcharts.SVGAttributes}\n     * The presentational attributes to be set on the point.\n     */\n    pointAttribs(point, state) {\n        const seriesMarkerOptions = this.options.marker, pointOptions = point && point.options, pointMarkerOptions = ((pointOptions && pointOptions.marker) || {}), pointColorOption = pointOptions && pointOptions.color, pointColor = point && point.color, zoneColor = point && point.zone && point.zone.color;\n        let seriesStateOptions, pointStateOptions, color = this.color, fill, stroke, strokeWidth = pick(pointMarkerOptions.lineWidth, seriesMarkerOptions.lineWidth), opacity = 1;\n        color = (pointColorOption ||\n            zoneColor ||\n            pointColor ||\n            color);\n        fill = (pointMarkerOptions.fillColor ||\n            seriesMarkerOptions.fillColor ||\n            color);\n        stroke = (pointMarkerOptions.lineColor ||\n            seriesMarkerOptions.lineColor ||\n            color);\n        // Handle hover and select states\n        state = state || 'normal';\n        if (state) {\n            seriesStateOptions = (seriesMarkerOptions.states[state] || {});\n            pointStateOptions = (pointMarkerOptions.states &&\n                pointMarkerOptions.states[state]) || {};\n            strokeWidth = pick(pointStateOptions.lineWidth, seriesStateOptions.lineWidth, strokeWidth + pick(pointStateOptions.lineWidthPlus, seriesStateOptions.lineWidthPlus, 0));\n            fill = (pointStateOptions.fillColor ||\n                seriesStateOptions.fillColor ||\n                fill);\n            stroke = (pointStateOptions.lineColor ||\n                seriesStateOptions.lineColor ||\n                stroke);\n            opacity = pick(pointStateOptions.opacity, seriesStateOptions.opacity, opacity);\n        }\n        return {\n            'stroke': stroke,\n            'stroke-width': strokeWidth,\n            'fill': fill,\n            'opacity': opacity\n        };\n    }\n    /**\n     * Clear DOM objects and free up memory.\n     *\n     * @private\n     * @function Highcharts.Series#destroy\n     *\n     * @emits Highcharts.Series#event:destroy\n     */\n    destroy(keepEventsForUpdate) {\n        const series = this, chart = series.chart, issue134 = /AppleWebKit\\/533/.test(win.navigator.userAgent), data = series.data || [];\n        let destroy, i, point, axis;\n        // add event hook\n        fireEvent(series, 'destroy', { keepEventsForUpdate });\n        // remove events\n        this.removeEvents(keepEventsForUpdate);\n        // erase from axes\n        (series.axisTypes || []).forEach(function (AXIS) {\n            axis = series[AXIS];\n            if (axis && axis.series) {\n                erase(axis.series, series);\n                axis.isDirty = axis.forceRedraw = true;\n            }\n        });\n        // remove legend items\n        if (series.legendItem) {\n            series.chart.legend.destroyItem(series);\n        }\n        // destroy all points with their elements\n        i = data.length;\n        while (i--) {\n            point = data[i];\n            if (point && point.destroy) {\n                point.destroy();\n            }\n        }\n        if (series.clips) {\n            series.clips.forEach((clip) => clip.destroy());\n        }\n        // Clear the animation timeout if we are destroying the series\n        // during initial animation\n        U.clearTimeout(series.animationTimeout);\n        // Destroy all SVGElements associated to the series\n        objectEach(series, function (val, prop) {\n            // Survive provides a hook for not destroying\n            if (val instanceof SVGElement && !val.survive) {\n                // issue 134 workaround\n                destroy = issue134 && prop === 'group' ?\n                    'hide' :\n                    'destroy';\n                val[destroy]();\n            }\n        });\n        // remove from hoverSeries\n        if (chart.hoverSeries === series) {\n            chart.hoverSeries = void 0;\n        }\n        erase(chart.series, series);\n        chart.orderItems('series');\n        // clear all members\n        objectEach(series, function (val, prop) {\n            if (!keepEventsForUpdate || prop !== 'hcEvents') {\n                delete series[prop];\n            }\n        });\n    }\n    /**\n     * Clip the graphs into zones for colors and styling.\n     *\n     * @private\n     * @function Highcharts.Series#applyZones\n     */\n    applyZones() {\n        const series = this, chart = this.chart, renderer = chart.renderer, zones = this.zones, clips = (this.clips || []), graph = this.graph, area = this.area, plotSizeMax = Math.max(chart.plotWidth, chart.plotHeight), axis = this[(this.zoneAxis || 'y') + 'Axis'], inverted = chart.inverted;\n        let translatedFrom, translatedTo, clipAttr, extremes, reversed, horiz, pxRange, pxPosMin, pxPosMax, zoneArea, zoneGraph, ignoreZones = false;\n        if (zones.length &&\n            (graph || area) &&\n            axis &&\n            typeof axis.min !== 'undefined') {\n            reversed = axis.reversed;\n            horiz = axis.horiz;\n            // The use of the Color Threshold assumes there are no gaps\n            // so it is safe to hide the original graph and area\n            // unless it is not waterfall series, then use showLine property\n            // to set lines between columns to be visible (#7862)\n            if (graph && !this.showLine) {\n                graph.hide();\n            }\n            if (area) {\n                area.hide();\n            }\n            // Create the clips\n            extremes = axis.getExtremes();\n            zones.forEach(function (threshold, i) {\n                translatedFrom = reversed ?\n                    (horiz ? chart.plotWidth : 0) :\n                    (horiz ? 0 : (axis.toPixels(extremes.min) || 0));\n                translatedFrom = clamp(pick(translatedTo, translatedFrom), 0, plotSizeMax);\n                translatedTo = clamp(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true) || 0), 0, plotSizeMax);\n                if (ignoreZones) {\n                    translatedFrom = translatedTo =\n                        axis.toPixels(extremes.max);\n                }\n                pxRange = Math.abs(translatedFrom - translatedTo);\n                pxPosMin = Math.min(translatedFrom, translatedTo);\n                pxPosMax = Math.max(translatedFrom, translatedTo);\n                if (axis.isXAxis) {\n                    clipAttr = {\n                        x: inverted ? pxPosMax : pxPosMin,\n                        y: 0,\n                        width: pxRange,\n                        height: plotSizeMax\n                    };\n                    if (!horiz) {\n                        clipAttr.x = chart.plotHeight - clipAttr.x;\n                    }\n                }\n                else {\n                    clipAttr = {\n                        x: 0,\n                        y: inverted ? pxPosMax : pxPosMin,\n                        width: plotSizeMax,\n                        height: pxRange\n                    };\n                    if (horiz) {\n                        clipAttr.y = chart.plotWidth - clipAttr.y;\n                    }\n                }\n                if (clips[i]) {\n                    clips[i].animate(clipAttr);\n                }\n                else {\n                    clips[i] = renderer.clipRect(clipAttr);\n                }\n                // when no data, graph zone is not applied and after setData\n                // clip was ignored. As a result, it should be applied each\n                // time.\n                zoneArea = series['zone-area-' + i];\n                zoneGraph = series['zone-graph-' + i];\n                if (graph && zoneGraph) {\n                    zoneGraph.clip(clips[i]);\n                }\n                if (area && zoneArea) {\n                    zoneArea.clip(clips[i]);\n                }\n                // if this zone extends out of the axis, ignore the others\n                ignoreZones = threshold.value > extremes.max;\n                // Clear translatedTo for indicators\n                if (series.resetZones && translatedTo === 0) {\n                    translatedTo = void 0;\n                }\n            });\n            this.clips = clips;\n        }\n        else if (series.visible) {\n            // If zones were removed, restore graph and area\n            if (graph) {\n                graph.show();\n            }\n            if (area) {\n                area.show();\n            }\n        }\n    }\n    /**\n     * General abstraction for creating plot groups like series.group,\n     * series.dataLabelsGroup and series.markerGroup. On subsequent calls,\n     * the group will only be adjusted to the updated plot size.\n     *\n     * @private\n     * @function Highcharts.Series#plotGroup\n     */\n    plotGroup(prop, name, visibility, zIndex, parent) {\n        let group = this[prop];\n        const isNew = !group, attrs = {\n            visibility,\n            zIndex: zIndex || 0.1 // Pointer logic uses this\n        };\n        // Avoid setting undefined opacity, or in styled mode\n        if (typeof this.opacity !== 'undefined' &&\n            !this.chart.styledMode && this.state !== 'inactive' // #13719\n        ) {\n            attrs.opacity = this.opacity;\n        }\n        // Generate it on first call\n        if (isNew) {\n            this[prop] = group = this.chart.renderer\n                .g()\n                .add(parent);\n        }\n        // Add the class names, and replace existing ones as response to\n        // Series.update (#6660)\n        group.addClass(('highcharts-' + name +\n            ' highcharts-series-' + this.index +\n            ' highcharts-' + this.type + '-series ' +\n            (defined(this.colorIndex) ?\n                'highcharts-color-' + this.colorIndex + ' ' :\n                '') +\n            (this.options.className || '') +\n            (group.hasClass('highcharts-tracker') ?\n                ' highcharts-tracker' :\n                '')), true);\n        // Place it on first and subsequent (redraw) calls\n        group.attr(attrs)[isNew ? 'attr' : 'animate'](this.getPlotBox(name));\n        return group;\n    }\n    /**\n     * Get the translation and scale for the plot area of this series.\n     *\n     * @function Highcharts.Series#getPlotBox\n     */\n    getPlotBox(name) {\n        let horAxis = this.xAxis, vertAxis = this.yAxis;\n        const chart = this.chart, inverted = (chart.inverted &&\n            !chart.polar &&\n            horAxis &&\n            this.invertible !== false &&\n            name === 'series');\n        // Swap axes for inverted (#2339)\n        if (chart.inverted) {\n            horAxis = vertAxis;\n            vertAxis = this.xAxis;\n        }\n        return {\n            translateX: horAxis ? horAxis.left : chart.plotLeft,\n            translateY: vertAxis ? vertAxis.top : chart.plotTop,\n            rotation: inverted ? 90 : 0,\n            rotationOriginX: inverted ?\n                (horAxis.len - vertAxis.len) / 2 :\n                0,\n            rotationOriginY: inverted ?\n                (horAxis.len + vertAxis.len) / 2 :\n                0,\n            scaleX: inverted ? -1 : 1,\n            scaleY: 1\n        };\n    }\n    /**\n     * Removes the event handlers attached previously with addEvents.\n     * @private\n     * @function Highcharts.Series#removeEvents\n     */\n    removeEvents(keepEventsForUpdate) {\n        const series = this;\n        if (!keepEventsForUpdate) {\n            // remove all events\n            removeEvent(series);\n        }\n        if (series.eventsToUnbind.length) {\n            // remove only internal events for proper update\n            // #12355 - solves problem with multiple destroy events\n            series.eventsToUnbind.forEach(function (unbind) {\n                unbind();\n            });\n            series.eventsToUnbind.length = 0;\n        }\n    }\n    /**\n     * Render the graph and markers. Called internally when first rendering\n     * and later when redrawing the chart. This function can be extended in\n     * plugins, but normally shouldn't be called directly.\n     *\n     * @function Highcharts.Series#render\n     *\n     * @emits Highcharts.Series#event:afterRender\n     */\n    render() {\n        const series = this, chart = series.chart, options = series.options, animOptions = animObject(options.animation), visibility = series.visible ?\n            'inherit' : 'hidden', // #2597\n        zIndex = options.zIndex, hasRendered = series.hasRendered, chartSeriesGroup = chart.seriesGroup, inverted = chart.inverted;\n        let animDuration = (!series.finishedAnimating) ?\n            animOptions.duration : 0;\n        fireEvent(this, 'render');\n        // the group\n        const group = series.plotGroup('group', 'series', visibility, zIndex, chartSeriesGroup);\n        series.markerGroup = series.plotGroup('markerGroup', 'markers', visibility, zIndex, chartSeriesGroup);\n        // Initial clipping, applies to columns etc. (#3839).\n        if (options.clip !== false) {\n            series.setClip();\n        }\n        // Initialize the animation\n        if (series.animate && animDuration) {\n            series.animate(true);\n        }\n        // Draw the graph if any\n        if (series.drawGraph) {\n            series.drawGraph();\n            series.applyZones();\n        }\n        // Draw the points\n        if (series.visible) {\n            series.drawPoints();\n        }\n        // Draw the data labels\n        if (series.drawDataLabels) {\n            series.drawDataLabels();\n        }\n        // In pie charts, slices are added to the DOM, but actual rendering\n        // is postponed until labels reserved their space\n        if (series.redrawPoints) {\n            series.redrawPoints();\n        }\n        // Draw the mouse tracking area\n        if (series.drawTracker &&\n            options.enableMouseTracking) {\n            series.drawTracker();\n        }\n        // Run the animation\n        if (series.animate && animDuration) {\n            series.animate();\n        }\n        // Call the afterAnimate function on animation complete (but don't\n        // overwrite the animation.complete option which should be available\n        // to the user).\n        if (!hasRendered) {\n            // Additional time if defer is defined before afterAnimate\n            // will be triggered\n            if (animDuration && animOptions.defer) {\n                animDuration += animOptions.defer;\n            }\n            series.animationTimeout = syncTimeout(function () {\n                series.afterAnimate();\n            }, animDuration || 0);\n        }\n        // Means data is in accordance with what you see\n        series.isDirty = false;\n        // (See #322) series.isDirty = series.isDirtyData = false; // means\n        // data is in accordance with what you see\n        series.hasRendered = true;\n        fireEvent(series, 'afterRender');\n    }\n    /**\n     * Redraw the series. This function is called internally from\n     * `chart.redraw` and normally shouldn't be called directly.\n     * @private\n     * @function Highcharts.Series#redraw\n     */\n    redraw() {\n        // Cache it here as it is set to false in render, but used after\n        const wasDirty = this.isDirty || this.isDirtyData;\n        this.translate();\n        this.render();\n        if (wasDirty) { // #3868, #3945\n            delete this.kdTree;\n        }\n    }\n    /**\n     * Whether to reserve space for the series, either because it is visible or\n     * because the `chart.ignoreHiddenSeries` option is false.\n     *\n     * @private\n     */\n    reserveSpace() {\n        return this.visible || !this.chart.options.chart.ignoreHiddenSeries;\n    }\n    /**\n     * Find the nearest point from a pointer event. This applies to series that\n     * use k-d-trees to get the nearest point. Native pointer events must be\n     * normalized using `Pointer.normalize`, that adds `chartX` and `chartY`\n     * properties.\n     *\n     * @sample highcharts/demo/synchronized-charts\n     *         Synchronized charts with tooltips\n     *\n     * @function Highcharts.Series#searchPoint\n     *\n     * @param {Highcharts.PointerEvent} e\n     *        The normalized pointer event\n     * @param {boolean} [compareX=false]\n     *        Search only by the X value, not Y\n     *\n     * @return {Point|undefined}\n     *        The closest point to the pointer event\n     */\n    searchPoint(e, compareX) {\n        const series = this, xAxis = series.xAxis, yAxis = series.yAxis, inverted = series.chart.inverted;\n        return this.searchKDTree({\n            clientX: inverted ?\n                xAxis.len - e.chartY + xAxis.pos :\n                e.chartX - xAxis.pos,\n            plotY: inverted ?\n                yAxis.len - e.chartX + yAxis.pos :\n                e.chartY - yAxis.pos\n        }, compareX, e);\n    }\n    /**\n     * Build the k-d-tree that is used by mouse and touch interaction to get\n     * the closest point. Line-like series typically have a one-dimensional\n     * tree where points are searched along the X axis, while scatter-like\n     * series typically search in two dimensions, X and Y.\n     *\n     * @private\n     * @function Highcharts.Series#buildKDTree\n     */\n    buildKDTree(e) {\n        // Prevent multiple k-d-trees from being built simultaneously\n        // (#6235)\n        this.buildingKdTree = true;\n        const series = this, dimensions = series.options.findNearestPointBy\n            .indexOf('y') > -1 ? 2 : 1;\n        /**\n         * Internal function\n         * @private\n         */\n        function _kdtree(points, depth, dimensions) {\n            const length = points && points.length;\n            let axis, median;\n            if (length) {\n                // alternate between the axis\n                axis = series.kdAxisArray[depth % dimensions];\n                // sort point array\n                points.sort(function (a, b) {\n                    return a[axis] - b[axis];\n                });\n                median = Math.floor(length / 2);\n                // build and return nod\n                return {\n                    point: points[median],\n                    left: _kdtree(points.slice(0, median), depth + 1, dimensions),\n                    right: _kdtree(points.slice(median + 1), depth + 1, dimensions)\n                };\n            }\n        }\n        /**\n         * Start the recursive build process with a clone of the points\n         * array and null points filtered out. (#3873)\n         * @private\n         */\n        function startRecursive() {\n            series.kdTree = _kdtree(series.getValidPoints(null, \n            // For line-type series restrict to plot area, but\n            // column-type series not (#3916, #4511)\n            !series.directTouch), dimensions, dimensions);\n            series.buildingKdTree = false;\n        }\n        delete series.kdTree;\n        // For testing tooltips, don't build async. Also if touchstart, we\n        // may be dealing with click events on mobile, so don't delay\n        // (#6817).\n        syncTimeout(startRecursive, series.options.kdNow || (e && e.type === 'touchstart') ? 0 : 1);\n    }\n    /**\n     * @private\n     * @function Highcharts.Series#searchKDTree\n     */\n    searchKDTree(point, compareX, e) {\n        const series = this, [kdX, kdY] = this.kdAxisArray, kdComparer = compareX ? 'distX' : 'dist', kdDimensions = (series.options.findNearestPointBy || '')\n            .indexOf('y') > -1 ? 2 : 1, useRadius = !!series.isBubble;\n        /**\n         * Set the one and two dimensional distance on the point object.\n         * @private\n         */\n        function setDistance(p1, p2) {\n            const p1kdX = p1[kdX], p2kdX = p2[kdX], x = (defined(p1kdX) && defined(p2kdX)) ? p1kdX - p2kdX : null, p1kdY = p1[kdY], p2kdY = p2[kdY], y = (defined(p1kdY) && defined(p2kdY)) ? p1kdY - p2kdY : 0, radius = useRadius ? (p2.marker?.radius || 0) : 0;\n            p2.dist = Math.sqrt(((x && x * x) || 0) + y * y) - radius;\n            p2.distX = defined(x) ? (Math.abs(x) - radius) : Number.MAX_VALUE;\n        }\n        /**\n         * @private\n         */\n        function _search(search, tree, depth, dimensions) {\n            const point = tree.point, axis = series.kdAxisArray[depth % dimensions];\n            let nPoint1, nPoint2, ret = point;\n            setDistance(search, point);\n            // Pick side based on distance to splitting point\n            const tdist = (search[axis] || 0) - (point[axis] || 0) +\n                (useRadius ? (point.marker?.radius || 0) : 0), sideA = tdist < 0 ? 'left' : 'right', sideB = tdist < 0 ? 'right' : 'left';\n            // End of tree\n            if (tree[sideA]) {\n                nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);\n                ret = (nPoint1[kdComparer] <\n                    ret[kdComparer] ?\n                    nPoint1 :\n                    point);\n            }\n            if (tree[sideB]) {\n                // compare distance to current best to splitting point to\n                // decide whether to check side B or not\n                if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {\n                    nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);\n                    ret = (nPoint2[kdComparer] <\n                        ret[kdComparer] ?\n                        nPoint2 :\n                        ret);\n                }\n            }\n            return ret;\n        }\n        if (!this.kdTree && !this.buildingKdTree) {\n            this.buildKDTree(e);\n        }\n        if (this.kdTree) {\n            return _search(point, this.kdTree, kdDimensions, kdDimensions);\n        }\n    }\n    /**\n     * @private\n     * @function Highcharts.Series#pointPlacementToXValue\n     */\n    pointPlacementToXValue() {\n        const { options: { pointPlacement, pointRange }, xAxis: axis } = this;\n        let factor = pointPlacement;\n        // Point placement is relative to each series pointRange (#5889)\n        if (factor === 'between') {\n            factor = axis.reversed ? -0.5 : 0.5; // #11955\n        }\n        return isNumber(factor) ?\n            factor * (pointRange || axis.pointRange) :\n            0;\n    }\n    /**\n     * @private\n     * @function Highcharts.Series#isPointInside\n     */\n    isPointInside(point) {\n        const { chart, xAxis, yAxis } = this, isInside = (typeof point.plotY !== 'undefined' &&\n            typeof point.plotX !== 'undefined' &&\n            point.plotY >= 0 &&\n            point.plotY <= (yAxis ? yAxis.len : chart.plotHeight) &&\n            point.plotX >= 0 &&\n            point.plotX <= (xAxis ? xAxis.len : chart.plotWidth));\n        return isInside;\n    }\n    /**\n     * Draw the tracker object that sits above all data labels and markers to\n     * track mouse events on the graph or points. For the line type charts\n     * the tracker uses the same graphPath, but with a greater stroke width\n     * for better control.\n     * @private\n     */\n    drawTracker() {\n        const series = this, options = series.options, trackByArea = options.trackByArea, trackerPath = [].concat(trackByArea ?\n            series.areaPath :\n            series.graphPath), \n        // trackerPathLength = trackerPath.length,\n        chart = series.chart, pointer = chart.pointer, renderer = chart.renderer, snap = chart.options.tooltip.snap, tracker = series.tracker, onMouseOver = function (e) {\n            if (options.enableMouseTracking &&\n                chart.hoverSeries !== series) {\n                series.onMouseOver();\n            }\n        }, \n        /*\n         * Empirical lowest possible opacities for TRACKER_FILL for an\n         * element to stay invisible but clickable\n         * IE9: 0.00000000001 (unlimited)\n         * IE10: 0.0001 (exporting only)\n         * FF: 0.00000000001 (unlimited)\n         * Chrome: 0.000001\n         * Safari: 0.000001\n         * Opera: 0.00000000001 (unlimited)\n         */\n        TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')';\n        let i;\n        // Draw the tracker\n        if (tracker) {\n            tracker.attr({ d: trackerPath });\n        }\n        else if (series.graph) { // create\n            series.tracker = renderer.path(trackerPath)\n                .attr({\n                visibility: series.visible ? 'inherit' : 'hidden',\n                zIndex: 2\n            })\n                .addClass(trackByArea ?\n                'highcharts-tracker-area' :\n                'highcharts-tracker-line')\n                .add(series.group);\n            if (!chart.styledMode) {\n                series.tracker.attr({\n                    'stroke-linecap': 'round',\n                    'stroke-linejoin': 'round',\n                    stroke: TRACKER_FILL,\n                    fill: trackByArea ? TRACKER_FILL : 'none',\n                    'stroke-width': series.graph.strokeWidth() +\n                        (trackByArea ? 0 : 2 * snap)\n                });\n            }\n            // The tracker is added to the series group, which is clipped, but\n            // is covered by the marker group. So the marker group also needs to\n            // capture events.\n            [\n                series.tracker,\n                series.markerGroup,\n                series.dataLabelsGroup\n            ].forEach(function (tracker) {\n                if (tracker) {\n                    tracker.addClass('highcharts-tracker')\n                        .on('mouseover', onMouseOver)\n                        .on('mouseout', function (e) {\n                        pointer.onTrackerMouseOut(e);\n                    });\n                    if (options.cursor && !chart.styledMode) {\n                        tracker.css({ cursor: options.cursor });\n                    }\n                    if (hasTouch) {\n                        tracker.on('touchstart', onMouseOver);\n                    }\n                }\n            });\n        }\n        fireEvent(this, 'afterDrawTracker');\n    }\n    /**\n     * Add a point to the series after render time. The point can be added at\n     * the end, or by giving it an X value, to the start or in the middle of the\n     * series.\n     *\n     * @sample highcharts/members/series-addpoint-append/\n     *         Append point\n     * @sample highcharts/members/series-addpoint-append-and-shift/\n     *         Append and shift\n     * @sample highcharts/members/series-addpoint-x-and-y/\n     *         Both X and Y values given\n     * @sample highcharts/members/series-addpoint-pie/\n     *         Append pie slice\n     * @sample stock/members/series-addpoint/\n     *         Append 100 points in Highcharts Stock\n     * @sample stock/members/series-addpoint-shift/\n     *         Append and shift in Highcharts Stock\n     * @sample maps/members/series-addpoint/\n     *         Add a point in Highmaps\n     *\n     * @function Highcharts.Series#addPoint\n     *\n     * @param {Highcharts.PointOptionsType} options\n     *        The point options. If options is a single number, a point with\n     *        that y value is appended to the series. If it is an array, it will\n     *        be interpreted as x and y values respectively. If it is an\n     *        object, advanced options as outlined under `series.data` are\n     *        applied.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart after the point is added. When adding\n     *        more than one point, it is highly recommended that the redraw\n     *        option be set to false, and instead {@link Chart#redraw} is\n     *        explicitly called after the adding of points is finished.\n     *        Otherwise, the chart will redraw after adding each point.\n     *\n     * @param {boolean} [shift=false]\n     *        If true, a point is shifted off the start of the series as one is\n     *        appended to the end.\n     *\n     * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]\n     *        Whether to apply animation, and optionally animation\n     *        configuration.\n     *\n     * @param {boolean} [withEvent=true]\n     *        Used internally, whether to fire the series `addPoint` event.\n     *\n     * @emits Highcharts.Series#event:addPoint\n     */\n    addPoint(options, redraw, shift, animation, withEvent) {\n        const series = this, seriesOptions = series.options, data = series.data, chart = series.chart, xAxis = series.xAxis, names = xAxis && xAxis.hasNames && xAxis.names, dataOptions = seriesOptions.data, xData = series.xData;\n        let isInTheMiddle, i;\n        // Optional redraw, defaults to true\n        redraw = pick(redraw, true);\n        // Get options and push the point to xData, yData and series.options. In\n        // series.generatePoints the Point instance will be created on demand\n        // and pushed to the series.data array.\n        const point = { series: series };\n        series.pointClass.prototype.applyOptions.apply(point, [options]);\n        const x = point.x;\n        // Get the insertion point\n        i = xData.length;\n        if (series.requireSorting && x < xData[i - 1]) {\n            isInTheMiddle = true;\n            while (i && xData[i - 1] > x) {\n                i--;\n            }\n        }\n        // Insert undefined item\n        series.updateParallelArrays(point, 'splice', [i, 0, 0]);\n        // Update it\n        series.updateParallelArrays(point, i);\n        if (names && point.name) {\n            names[x] = point.name;\n        }\n        dataOptions.splice(i, 0, options);\n        if (isInTheMiddle ||\n            // When processedData is present we need to splice an empty slot\n            // into series.data, otherwise generatePoints won't pick it up.\n            series.processedData) {\n            series.data.splice(i, 0, null);\n            series.processData();\n        }\n        // Generate points to be added to the legend (#1329)\n        if (seriesOptions.legendType === 'point') {\n            series.generatePoints();\n        }\n        // Shift the first point off the parallel arrays\n        if (shift) {\n            if (data[0] && !!data[0].remove) {\n                data[0].remove(false);\n            }\n            else {\n                data.shift();\n                series.updateParallelArrays(point, 'shift');\n                dataOptions.shift();\n            }\n        }\n        // Fire event\n        if (withEvent !== false) {\n            fireEvent(series, 'addPoint', { point: point });\n        }\n        // redraw\n        series.isDirty = true;\n        series.isDirtyData = true;\n        if (redraw) {\n            chart.redraw(animation); // Animation is set anyway on redraw, #5665\n        }\n    }\n    /**\n     * Remove a point from the series. Unlike the\n     * {@link Highcharts.Point#remove} method, this can also be done on a point\n     * that is not instanciated because it is outside the view or subject to\n     * Highcharts Stock data grouping.\n     *\n     * @sample highcharts/members/series-removepoint/\n     *         Remove cropped point\n     *\n     * @function Highcharts.Series#removePoint\n     *\n     * @param {number} i\n     *        The index of the point in the {@link Highcharts.Series.data|data}\n     *        array.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart after the point is added. When\n     *        removing more than one point, it is highly recommended that the\n     *        `redraw` option be set to `false`, and instead {@link\n     *        Highcharts.Chart#redraw} is explicitly called after the adding of\n     *        points is finished.\n     *\n     * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]\n     *        Whether and optionally how the series should be animated.\n     *\n     * @emits Highcharts.Point#event:remove\n     */\n    removePoint(i, redraw, animation) {\n        const series = this, data = series.data, point = data[i], points = series.points, chart = series.chart, remove = function () {\n            if (points && points.length === data.length) { // #4935\n                points.splice(i, 1);\n            }\n            data.splice(i, 1);\n            series.options.data.splice(i, 1);\n            series.updateParallelArrays(point || { series: series }, 'splice', [i, 1]);\n            if (point) {\n                point.destroy();\n            }\n            // redraw\n            series.isDirty = true;\n            series.isDirtyData = true;\n            if (redraw) {\n                chart.redraw();\n            }\n        };\n        setAnimation(animation, chart);\n        redraw = pick(redraw, true);\n        // Fire the event with a default handler of removing the point\n        if (point) {\n            point.firePointEvent('remove', null, remove);\n        }\n        else {\n            remove();\n        }\n    }\n    /**\n     * Remove a series and optionally redraw the chart.\n     *\n     * @sample highcharts/members/series-remove/\n     *         Remove first series from a button\n     *\n     * @function Highcharts.Series#remove\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart or wait for an explicit call to\n     *        {@link Highcharts.Chart#redraw}.\n     *\n     * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]\n     *        Whether to apply animation, and optionally animation\n     *        configuration.\n     *\n     * @param {boolean} [withEvent=true]\n     *        Used internally, whether to fire the series `remove` event.\n     *\n     * @emits Highcharts.Series#event:remove\n     */\n    remove(redraw, animation, withEvent, keepEvents) {\n        const series = this, chart = series.chart;\n        /**\n         * @private\n         */\n        function remove() {\n            // Destroy elements\n            series.destroy(keepEvents);\n            // Redraw\n            chart.isDirtyLegend = chart.isDirtyBox = true;\n            chart.linkSeries(keepEvents);\n            if (pick(redraw, true)) {\n                chart.redraw(animation);\n            }\n        }\n        // Fire the event with a default handler of removing the point\n        if (withEvent !== false) {\n            fireEvent(series, 'remove', null, remove);\n        }\n        else {\n            remove();\n        }\n    }\n    /**\n     * Update the series with a new set of options. For a clean and precise\n     * handling of new options, all methods and elements from the series are\n     * removed, and it is initialized from scratch. Therefore, this method is\n     * more performance expensive than some other utility methods like {@link\n     * Series#setData} or {@link Series#setVisible}.\n     *\n     * Note that `Series.update` may mutate the passed `data` options.\n     *\n     * @sample highcharts/members/series-update/\n     *         Updating series options\n     * @sample maps/members/series-update/\n     *         Update series options in Highmaps\n     *\n     * @function Highcharts.Series#update\n     *\n     * @param {Highcharts.SeriesOptionsType} options\n     *        New options that will be merged with the series' existing options.\n     *\n     * @param {boolean} [redraw=true]\n     *        Whether to redraw the chart after the series is altered. If doing\n     *        more operations on the chart, it is a good idea to set redraw to\n     *        false and call {@link Chart#redraw} after.\n     *\n     * @emits Highcharts.Series#event:update\n     * @emits Highcharts.Series#event:afterUpdate\n     */\n    update(options, redraw) {\n        options = diffObjects(options, this.userOptions);\n        fireEvent(this, 'update', { options: options });\n        const series = this, chart = series.chart, \n        // must use user options when changing type because series.options\n        // is merged in with type specific plotOptions\n        oldOptions = series.userOptions, initialType = series.initialType || series.type, plotOptions = chart.options.plotOptions, initialSeriesProto = seriesTypes[initialType].prototype, groups = [\n            'group',\n            'markerGroup',\n            'dataLabelsGroup',\n            'transformGroup'\n        ], optionsToCheck = [\n            'dataGrouping',\n            'pointStart',\n            'pointInterval',\n            'pointIntervalUnit',\n            'keys'\n        ], \n        // Animation must be enabled when calling update before the initial\n        // animation has first run. This happens when calling update\n        // directly after chart initialization, or when applying responsive\n        // rules (#6912).\n        animation = series.finishedAnimating && { animation: false }, kinds = {};\n        let seriesOptions, n, preserve = [\n            'colorIndex',\n            'eventOptions',\n            'navigatorSeries',\n            'symbolIndex',\n            'baseSeries'\n        ], newType = (options.type ||\n            oldOptions.type ||\n            chart.options.chart.type);\n        const keepPoints = !(\n        // Indicators, histograms etc recalculate the data. It should be\n        // possible to omit this.\n        this.hasDerivedData ||\n            // New type requires new point classes\n            (newType && newType !== this.type) ||\n            // New options affecting how the data points are built\n            typeof options.pointStart !== 'undefined' ||\n            typeof options.pointInterval !== 'undefined' ||\n            typeof options.relativeXValue !== 'undefined' ||\n            options.joinBy ||\n            options.mapData || // #11636\n            // Changes to data grouping requires new points in new group\n            optionsToCheck.some((option) => series.hasOptionChanged(option)));\n        newType = newType || initialType;\n        if (keepPoints) {\n            preserve.push('data', 'isDirtyData', \n            // GeoHeatMap interpolation\n            'isDirtyCanvas', 'points', 'processedData', // #17057\n            'processedXData', 'processedYData', 'xIncrement', 'cropped', '_hasPointMarkers', 'hasDataLabels', 'clips', // #15420\n            // Networkgraph (#14397)\n            'nodes', 'layout', \n            // Treemap\n            'level', \n            // Map specific, consider moving it to series-specific preserve-\n            // properties (#10617)\n            'mapMap', 'mapData', 'minY', 'maxY', 'minX', 'maxX');\n            if (options.visible !== false) {\n                preserve.push('area', 'graph');\n            }\n            series.parallelArrays.forEach(function (key) {\n                preserve.push(key + 'Data');\n            });\n            if (options.data) {\n                // setData uses dataSorting options so we need to update them\n                // earlier\n                if (options.dataSorting) {\n                    extend(series.options.dataSorting, options.dataSorting);\n                }\n                this.setData(options.data, false);\n            }\n        }\n        // Do the merge, with some forced options\n        options = merge(oldOptions, animation, {\n            // When oldOptions.index is null it should't be cleared.\n            // Otherwise navigator series will have wrong indexes (#10193).\n            index: typeof oldOptions.index === 'undefined' ?\n                series.index : oldOptions.index,\n            pointStart: pick(\n            // When updating from blank (#7933)\n            plotOptions?.series?.pointStart, oldOptions.pointStart, \n            // When updating after addPoint\n            series.xData[0])\n        }, (!keepPoints && { data: series.options.data }), options);\n        // Merge does not merge arrays, but replaces them. Since points were\n        // updated, `series.options.data` has correct merged options, use it:\n        if (keepPoints && options.data) {\n            options.data = series.options.data;\n        }\n        // Make sure preserved properties are not destroyed (#3094)\n        preserve = groups.concat(preserve);\n        preserve.forEach(function (prop) {\n            preserve[prop] = series[prop];\n            delete series[prop];\n        });\n        let casting = false;\n        if (seriesTypes[newType]) {\n            casting = newType !== series.type;\n            // Destroy the series and delete all properties, it will be\n            // reinserted within the `init` call below\n            series.remove(false, false, false, true);\n            if (casting) {\n                // Modern browsers including IE11\n                if (Object.setPrototypeOf) {\n                    Object.setPrototypeOf(series, seriesTypes[newType].prototype);\n                    // Legacy (IE < 11)\n                }\n                else {\n                    const ownEvents = Object.hasOwnProperty.call(series, 'hcEvents') && series.hcEvents;\n                    for (n in initialSeriesProto) { // eslint-disable-line guard-for-in\n                        series[n] = void 0;\n                    }\n                    // Reinsert all methods and properties from the new type\n                    // prototype (#2270, #3719).\n                    extend(series, seriesTypes[newType].prototype);\n                    // The events are tied to the prototype chain, don't copy if\n                    // they're not the series' own\n                    if (ownEvents) {\n                        series.hcEvents = ownEvents;\n                    }\n                    else {\n                        delete series.hcEvents;\n                    }\n                }\n            }\n        }\n        else {\n            error(17, true, chart, { missingModuleFor: newType });\n        }\n        // Re-register groups (#3094) and other preserved properties\n        preserve.forEach(function (prop) {\n            series[prop] = preserve[prop];\n        });\n        series.init(chart, options);\n        // Remove particular elements of the points. Check `series.options`\n        // because we need to consider the options being set on plotOptions as\n        // well.\n        if (keepPoints && this.points) {\n            seriesOptions = series.options;\n            // What kind of elements to destroy\n            if (seriesOptions.visible === false) {\n                kinds.graphic = 1;\n                kinds.dataLabel = 1;\n            }\n            else {\n                // If the  marker got disabled or changed its symbol, width or\n                // height - destroy\n                if (this.hasMarkerChanged(seriesOptions, oldOptions)) {\n                    kinds.graphic = 1;\n                }\n                if (!series.hasDataLabels?.()) {\n                    kinds.dataLabel = 1;\n                }\n            }\n            for (const point of this.points) {\n                if (point && point.series) {\n                    point.resolveColor();\n                    // Destroy elements in order to recreate based on updated\n                    // series options.\n                    if (Object.keys(kinds).length) {\n                        point.destroyElements(kinds);\n                    }\n                    if (seriesOptions.showInLegend === false &&\n                        point.legendItem) {\n                        chart.legend.destroyItem(point);\n                    }\n                }\n            }\n        }\n        series.initialType = initialType;\n        chart.linkSeries(); // Links are lost in series.remove (#3028)\n        // #15383: Fire updatedData if the type has changed to keep linked\n        // series such as indicators updated\n        if (casting && series.linkedSeries.length) {\n            series.isDirtyData = true;\n        }\n        fireEvent(this, 'afterUpdate');\n        if (pick(redraw, true)) {\n            chart.redraw(keepPoints ? void 0 : false);\n        }\n    }\n    /**\n     * Used from within series.update\n     * @private\n     */\n    setName(name) {\n        this.name = this.options.name = this.userOptions.name = name;\n        this.chart.isDirtyLegend = true;\n    }\n    /**\n     * Check if the option has changed.\n     * @private\n     */\n    hasOptionChanged(optionName) {\n        const chart = this.chart, option = this.options[optionName], plotOptions = chart.options.plotOptions, oldOption = this.userOptions[optionName], plotOptionsOption = pick(plotOptions?.[this.type]?.[optionName], plotOptions?.series?.[optionName]);\n        // Check if `plotOptions` are defined already, #19203\n        if (oldOption && !defined(plotOptionsOption)) {\n            return option !== oldOption;\n        }\n        return option !== pick(plotOptionsOption, option);\n    }\n    /**\n     * Runs on mouse over the series graphical items.\n     *\n     * @function Highcharts.Series#onMouseOver\n     * @emits Highcharts.Series#event:mouseOver\n     */\n    onMouseOver() {\n        const series = this, chart = series.chart, hoverSeries = chart.hoverSeries, pointer = chart.pointer;\n        pointer.setHoverChartIndex();\n        // set normal state to previous series\n        if (hoverSeries && hoverSeries !== series) {\n            hoverSeries.onMouseOut();\n        }\n        // trigger the event, but to save processing time,\n        // only if defined\n        if (series.options.events.mouseOver) {\n            fireEvent(series, 'mouseOver');\n        }\n        // hover this\n        series.setState('hover');\n        /**\n         * Contains the original hovered series.\n         *\n         * @name Highcharts.Chart#hoverSeries\n         * @type {Highcharts.Series|null}\n         */\n        chart.hoverSeries = series;\n    }\n    /**\n     * Runs on mouse out of the series graphical items.\n     *\n     * @function Highcharts.Series#onMouseOut\n     *\n     * @emits Highcharts.Series#event:mouseOut\n     */\n    onMouseOut() {\n        // trigger the event only if listeners exist\n        const series = this, options = series.options, chart = series.chart, tooltip = chart.tooltip, hoverPoint = chart.hoverPoint;\n        // #182, set to null before the mouseOut event fires\n        chart.hoverSeries = null;\n        // trigger mouse out on the point, which must be in this series\n        if (hoverPoint) {\n            hoverPoint.onMouseOut();\n        }\n        // fire the mouse out event\n        if (series && options.events.mouseOut) {\n            fireEvent(series, 'mouseOut');\n        }\n        // hide the tooltip\n        if (tooltip &&\n            !series.stickyTracking &&\n            (!tooltip.shared || series.noSharedTooltip)) {\n            tooltip.hide();\n        }\n        // Reset all inactive states\n        chart.series.forEach(function (s) {\n            s.setState('', true);\n        });\n    }\n    /**\n     * Set the state of the series. Called internally on mouse interaction\n     * operations, but it can also be called directly to visually\n     * highlight a series.\n     *\n     * @function Highcharts.Series#setState\n     *\n     * @param {Highcharts.SeriesStateValue|\"\"} [state]\n     *        The new state, can be either `'hover'`, `'inactive'`, `'select'`,\n     *        or `''` (an empty string), `'normal'` or `undefined` to set to\n     *        normal state.\n     * @param {boolean} [inherit]\n     *        Determines if state should be inherited by points too.\n     */\n    setState(state, inherit) {\n        const series = this, options = series.options, graph = series.graph, inactiveOtherPoints = options.inactiveOtherPoints, stateOptions = options.states, \n        // By default a quick animation to hover/inactive,\n        // slower to un-hover\n        stateAnimation = pick((stateOptions[state || 'normal'] &&\n            stateOptions[state || 'normal'].animation), series.chart.options.chart.animation);\n        let attribs, lineWidth = options.lineWidth, i = 0, opacity = options.opacity;\n        state = state || '';\n        if (series.state !== state) {\n            // Toggle class names\n            [\n                series.group,\n                series.markerGroup,\n                series.dataLabelsGroup\n            ].forEach(function (group) {\n                if (group) {\n                    // Old state\n                    if (series.state) {\n                        group.removeClass('highcharts-series-' + series.state);\n                    }\n                    // New state\n                    if (state) {\n                        group.addClass('highcharts-series-' + state);\n                    }\n                }\n            });\n            series.state = state;\n            if (!series.chart.styledMode) {\n                if (stateOptions[state] &&\n                    stateOptions[state].enabled === false) {\n                    return;\n                }\n                if (state) {\n                    lineWidth = (stateOptions[state].lineWidth ||\n                        lineWidth + (stateOptions[state].lineWidthPlus || 0)); // #4035\n                    opacity = pick(stateOptions[state].opacity, opacity);\n                }\n                if (graph && !graph.dashstyle && isNumber(lineWidth)) {\n                    attribs = {\n                        'stroke-width': lineWidth\n                    };\n                    // Animate the graph stroke-width.\n                    graph.animate(attribs, stateAnimation);\n                    while (series['zone-graph-' + i]) {\n                        series['zone-graph-' + i].animate(attribs, stateAnimation);\n                        i = i + 1;\n                    }\n                }\n                // For some types (pie, networkgraph, sankey) opacity is\n                // resolved on a point level\n                if (!inactiveOtherPoints) {\n                    [\n                        series.group,\n                        series.markerGroup,\n                        series.dataLabelsGroup,\n                        series.labelBySeries\n                    ].forEach(function (group) {\n                        if (group) {\n                            group.animate({\n                                opacity: opacity\n                            }, stateAnimation);\n                        }\n                    });\n                }\n            }\n        }\n        // Don't loop over points on a series that doesn't apply inactive state\n        // to siblings markers (e.g. line, column)\n        if (inherit && inactiveOtherPoints && series.points) {\n            series.setAllPointsToState(state || void 0);\n        }\n    }\n    /**\n     * Set the state for all points in the series.\n     *\n     * @function Highcharts.Series#setAllPointsToState\n     *\n     * @private\n     *\n     * @param {string} [state]\n     *        Can be either `hover` or undefined to set to normal state.\n     */\n    setAllPointsToState(state) {\n        this.points.forEach(function (point) {\n            if (point.setState) {\n                point.setState(state);\n            }\n        });\n    }\n    /**\n     * Show or hide the series.\n     *\n     * @function Highcharts.Series#setVisible\n     *\n     * @param {boolean} [visible]\n     * True to show the series, false to hide. If undefined, the visibility is\n     * toggled.\n     *\n     * @param {boolean} [redraw=true]\n     * Whether to redraw the chart after the series is altered. If doing more\n     * operations on the chart, it is a good idea to set redraw to false and\n     * call {@link Chart#redraw|chart.redraw()} after.\n     *\n     * @emits Highcharts.Series#event:hide\n     * @emits Highcharts.Series#event:show\n     */\n    setVisible(vis, redraw) {\n        const series = this, chart = series.chart, ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries, oldVisibility = series.visible;\n        // If called without an argument, toggle visibility\n        series.visible =\n            vis =\n                series.options.visible =\n                    series.userOptions.visible =\n                        typeof vis === 'undefined' ? !oldVisibility : vis; // #5618\n        const showOrHide = vis ? 'show' : 'hide';\n        // Show or hide elements\n        [\n            'group',\n            'dataLabelsGroup',\n            'markerGroup',\n            'tracker',\n            'tt'\n        ].forEach((key) => {\n            series[key]?.[showOrHide]();\n        });\n        // Hide tooltip (#1361)\n        if (chart.hoverSeries === series ||\n            chart.hoverPoint?.series === series) {\n            series.onMouseOut();\n        }\n        if (series.legendItem) {\n            chart.legend.colorizeItem(series, vis);\n        }\n        // Rescale or adapt to resized chart\n        series.isDirty = true;\n        // In a stack, all other series are affected\n        if (series.options.stacking) {\n            chart.series.forEach((otherSeries) => {\n                if (otherSeries.options.stacking && otherSeries.visible) {\n                    otherSeries.isDirty = true;\n                }\n            });\n        }\n        // Show or hide linked series\n        series.linkedSeries.forEach((otherSeries) => {\n            otherSeries.setVisible(vis, false);\n        });\n        if (ignoreHiddenSeries) {\n            chart.isDirtyBox = true;\n        }\n        fireEvent(series, showOrHide);\n        if (redraw !== false) {\n            chart.redraw();\n        }\n    }\n    /**\n     * Show the series if hidden.\n     *\n     * @sample highcharts/members/series-hide/\n     *         Toggle visibility from a button\n     *\n     * @function Highcharts.Series#show\n     * @emits Highcharts.Series#event:show\n     */\n    show() {\n        this.setVisible(true);\n    }\n    /**\n     * Hide the series if visible. If the\n     * [chart.ignoreHiddenSeries](https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries)\n     * option is true, the chart is redrawn without this series.\n     *\n     * @sample highcharts/members/series-hide/\n     *         Toggle visibility from a button\n     *\n     * @function Highcharts.Series#hide\n     * @emits Highcharts.Series#event:hide\n     */\n    hide() {\n        this.setVisible(false);\n    }\n    /**\n     * Select or unselect the series. This means its\n     * {@link Highcharts.Series.selected|selected}\n     * property is set, the checkbox in the legend is toggled and when selected,\n     * the series is returned by the {@link Highcharts.Chart#getSelectedSeries}\n     * function.\n     *\n     * @sample highcharts/members/series-select/\n     *         Select a series from a button\n     *\n     * @function Highcharts.Series#select\n     *\n     * @param {boolean} [selected]\n     * True to select the series, false to unselect. If undefined, the selection\n     * state is toggled.\n     *\n     * @emits Highcharts.Series#event:select\n     * @emits Highcharts.Series#event:unselect\n     */\n    select(selected) {\n        const series = this;\n        series.selected =\n            selected =\n                this.options.selected = (typeof selected === 'undefined' ?\n                    !series.selected :\n                    selected);\n        if (series.checkbox) {\n            series.checkbox.checked = selected;\n        }\n        fireEvent(series, selected ? 'select' : 'unselect');\n    }\n    /**\n     * Checks if a tooltip should be shown for a given point.\n     *\n     * @private\n     */\n    shouldShowTooltip(plotX, plotY, options = {}) {\n        options.series = this;\n        options.visiblePlotOnly = true;\n        return this.chart.isInsidePlot(plotX, plotY, options);\n    }\n    /**\n     * Draws the legend symbol based on the legendSymbol user option.\n     *\n     * @private\n     */\n    drawLegendSymbol(legend, item) {\n        LegendSymbol[this.options.legendSymbol || 'rectangle']\n            ?.call(this, legend, item);\n    }\n}\nSeries.defaultOptions = SeriesDefaults;\n/**\n * Registry of all available series types.\n *\n * @name Highcharts.Series.types\n * @type {Highcharts.Dictionary<typeof_Highcharts.Series>}\n */\nSeries.types = SeriesRegistry.seriesTypes;\n/* *\n *\n *  Static Functions\n *\n * */\n/**\n * Registers a series class to be accessible via `Series.types`.\n *\n * @function Highcharts.Series.registerType\n *\n * @param {string} seriesType\n * The series type as an identifier string in lower case.\n *\n * @param {Function} SeriesClass\n * The series class as a class pattern or a constructor function with\n * prototype.\n */\nSeries.registerType = SeriesRegistry.registerSeriesType;\nextend(Series.prototype, {\n    axisTypes: ['xAxis', 'yAxis'],\n    coll: 'series',\n    colorCounter: 0,\n    directTouch: false,\n    isCartesian: true,\n    kdAxisArray: ['clientX', 'plotY'],\n    // Each point's x and y values are stored in this.xData and this.yData:\n    parallelArrays: ['x', 'y'],\n    pointClass: Point,\n    requireSorting: true,\n    // Requires the data to be sorted:\n    sorted: true\n});\n/* *\n *\n *  Registry\n *\n * */\nSeriesRegistry.series = Series;\n/* *\n *\n *  Default Export\n *\n * */\nexport default Series;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * This is a placeholder type of the possible series options for\n * [Highcharts](../highcharts/series), [Highcharts Stock](../highstock/series),\n * [Highmaps](../highmaps/series), and [Gantt](../gantt/series).\n *\n * In TypeScript is this dynamically generated to reference all possible types\n * of series options.\n *\n * @ignore-declaration\n * @typedef {Highcharts.SeriesOptions|Highcharts.Dictionary<*>} Highcharts.SeriesOptionsType\n */\n/**\n * Options for `dataSorting`.\n *\n * @interface Highcharts.DataSortingOptionsObject\n * @since 8.0.0\n */ /**\n* Enable or disable data sorting for the series.\n* @name Highcharts.DataSortingOptionsObject#enabled\n* @type {boolean|undefined}\n*/ /**\n* Whether to allow matching points by name in an update.\n* @name Highcharts.DataSortingOptionsObject#matchByName\n* @type {boolean|undefined}\n*/ /**\n* Determines what data value should be used to sort by.\n* @name Highcharts.DataSortingOptionsObject#sortKey\n* @type {string|undefined}\n*/\n/**\n * Function callback when a series has been animated.\n *\n * @callback Highcharts.SeriesAfterAnimateCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        The series where the event occured.\n *\n * @param {Highcharts.SeriesAfterAnimateEventObject} event\n *        Event arguments.\n */\n/**\n * Event information regarding completed animation of a series.\n *\n * @interface Highcharts.SeriesAfterAnimateEventObject\n */ /**\n* Animated series.\n* @name Highcharts.SeriesAfterAnimateEventObject#target\n* @type {Highcharts.Series}\n*/ /**\n* Event type.\n* @name Highcharts.SeriesAfterAnimateEventObject#type\n* @type {\"afterAnimate\"}\n*/\n/**\n * Function callback when the checkbox next to the series' name in the legend is\n * clicked.\n *\n * @callback Highcharts.SeriesCheckboxClickCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        The series where the event occured.\n *\n * @param {Highcharts.SeriesCheckboxClickEventObject} event\n *        Event arguments.\n */\n/**\n * Event information regarding check of a series box.\n *\n * @interface Highcharts.SeriesCheckboxClickEventObject\n */ /**\n* Whether the box has been checked.\n* @name Highcharts.SeriesCheckboxClickEventObject#checked\n* @type {boolean}\n*/ /**\n* Related series.\n* @name Highcharts.SeriesCheckboxClickEventObject#item\n* @type {Highcharts.Series}\n*/ /**\n* Related series.\n* @name Highcharts.SeriesCheckboxClickEventObject#target\n* @type {Highcharts.Series}\n*/ /**\n* Event type.\n* @name Highcharts.SeriesCheckboxClickEventObject#type\n* @type {\"checkboxClick\"}\n*/\n/**\n * Function callback when a series is clicked. Return false to cancel toogle\n * actions.\n *\n * @callback Highcharts.SeriesClickCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        The series where the event occured.\n *\n * @param {Highcharts.SeriesClickEventObject} event\n *        Event arguments.\n */\n/**\n * Common information for a click event on a series.\n *\n * @interface Highcharts.SeriesClickEventObject\n * @extends global.Event\n */ /**\n* Nearest point on the graph.\n* @name Highcharts.SeriesClickEventObject#point\n* @type {Highcharts.Point}\n*/\n/**\n * Gets fired when the series is hidden after chart generation time, either by\n * clicking the legend item or by calling `.hide()`.\n *\n * @callback Highcharts.SeriesHideCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        The series where the event occured.\n *\n * @param {global.Event} event\n *        The event that occured.\n */\n/**\n * The SVG value used for the `stroke-linecap` and `stroke-linejoin` of a line\n * graph.\n *\n * @typedef {\"butt\"|\"round\"|\"square\"|string} Highcharts.SeriesLinecapValue\n */\n/**\n * Gets fired when the legend item belonging to the series is clicked. The\n * default action is to toggle the visibility of the series. This can be\n * prevented by returning `false` or calling `event.preventDefault()`.\n *\n * @callback Highcharts.SeriesLegendItemClickCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        The series where the event occured.\n *\n * @param {Highcharts.SeriesLegendItemClickEventObject} event\n *        The event that occured.\n */\n/**\n * Information about the event.\n *\n * @interface Highcharts.SeriesLegendItemClickEventObject\n */ /**\n* Related browser event.\n* @name Highcharts.SeriesLegendItemClickEventObject#browserEvent\n* @type {global.PointerEvent}\n*/ /**\n* Prevent the default action of toggle the visibility of the series.\n* @name Highcharts.SeriesLegendItemClickEventObject#preventDefault\n* @type {Function}\n*/ /**\n* Related series.\n* @name Highcharts.SeriesCheckboxClickEventObject#target\n* @type {Highcharts.Series}\n*/ /**\n* Event type.\n* @name Highcharts.SeriesCheckboxClickEventObject#type\n* @type {\"checkboxClick\"}\n*/\n/**\n * Gets fired when the mouse leaves the graph.\n *\n * @callback Highcharts.SeriesMouseOutCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        Series where the event occured.\n *\n * @param {global.PointerEvent} event\n *        Event that occured.\n */\n/**\n * Gets fired when the mouse enters the graph.\n *\n * @callback Highcharts.SeriesMouseOverCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        Series where the event occured.\n *\n * @param {global.PointerEvent} event\n *        Event that occured.\n */\n/**\n * Translation and scale for the plot area of a series.\n *\n * @interface Highcharts.SeriesPlotBoxObject\n */ /**\n* @name Highcharts.SeriesPlotBoxObject#scaleX\n* @type {number}\n*/ /**\n* @name Highcharts.SeriesPlotBoxObject#scaleY\n* @type {number}\n*/ /**\n* @name Highcharts.SeriesPlotBoxObject#translateX\n* @type {number}\n*/ /**\n* @name Highcharts.SeriesPlotBoxObject#translateY\n* @type {number}\n*/\n/**\n * Gets fired when the series is shown after chart generation time, either by\n * clicking the legend item or by calling `.show()`.\n *\n * @callback Highcharts.SeriesShowCallbackFunction\n *\n * @param {Highcharts.Series} this\n *        Series where the event occured.\n *\n * @param {global.Event} event\n *        Event that occured.\n */\n/**\n * Possible key values for the series state options.\n *\n * @typedef {\"hover\"|\"inactive\"|\"normal\"|\"select\"} Highcharts.SeriesStateValue\n */\n''; // detach doclets above\n/* *\n *\n *  API Options\n *\n * */\n/**\n * Series options for specific data and the data itself. In TypeScript you\n * have to cast the series options to specific series types, to get all\n * possible options for a series.\n *\n * @example\n * // TypeScript example\n * Highcharts.chart('container', {\n *     series: [{\n *         color: '#06C',\n *         data: [[0, 1], [2, 3]]\n *     } as Highcharts.SeriesLineOptions ]\n * });\n *\n * @type      {Array<*>}\n * @apioption series\n */\n/**\n * An id for the series. This can be used after render time to get a pointer\n * to the series object through `chart.get()`.\n *\n * @sample {highcharts} highcharts/plotoptions/series-id/\n *         Get series by id\n *\n * @type      {string}\n * @since     1.2.0\n * @apioption series.id\n */\n/**\n * The index of the series in the chart, affecting the internal index in the\n * `chart.series` array, the visible Z index as well as the order in the\n * legend.\n *\n * @type      {number}\n * @since     2.3.0\n * @apioption series.index\n */\n/**\n * The sequential index of the series in the legend.\n *\n * @see [legend.reversed](#legend.reversed),\n *      [yAxis.reversedStacks](#yAxis.reversedStacks)\n *\n * @sample {highcharts|highstock} highcharts/series/legendindex/\n *         Legend in opposite order\n *\n * @type      {number}\n * @apioption series.legendIndex\n */\n/**\n * The name of the series as shown in the legend, tooltip etc.\n *\n * @sample {highcharts} highcharts/series/name/\n *         Series name\n * @sample {highmaps} maps/demo/category-map/\n *         Series name\n *\n * @type      {string}\n * @apioption series.name\n */\n/**\n * This option allows grouping series in a stacked chart. The stack option\n * can be a string or anything else, as long as the grouped series' stack\n * options match each other after conversion into a string.\n *\n * @sample {highcharts} highcharts/series/stack/\n *         Stacked and grouped columns\n *\n * @type      {number|string}\n * @since     2.1\n * @product   highcharts highstock\n * @apioption series.stack\n */\n/**\n * The type of series, for example `line` or `column`. By default, the\n * series type is inherited from [chart.type](#chart.type), so unless the\n * chart is a combination of series types, there is no need to set it on the\n * series level.\n *\n * @sample {highcharts} highcharts/series/type/\n *         Line and column in the same chart\n * @sample highcharts/series/type-dynamic/\n *         Dynamic types with button selector\n * @sample {highmaps} maps/demo/mapline-mappoint/\n *         Multiple types in the same map\n *\n * @type      {string}\n * @apioption series.type\n */\n/**\n * When using dual or multiple x axes, this number defines which xAxis the\n * particular series is connected to. It refers to either the\n * {@link #xAxis.id|axis id}\n * or the index of the axis in the xAxis array, with 0 being the first.\n *\n * @type      {number|string}\n * @default   0\n * @product   highcharts highstock\n * @apioption series.xAxis\n */\n/**\n * When using dual or multiple y axes, this number defines which yAxis the\n * particular series is connected to. It refers to either the\n * {@link #yAxis.id|axis id}\n * or the index of the axis in the yAxis array, with 0 being the first.\n *\n * @sample {highcharts} highcharts/series/yaxis/\n *         Apply the column series to the secondary Y axis\n *\n * @type      {number|string}\n * @default   0\n * @product   highcharts highstock\n * @apioption series.yAxis\n */\n/**\n * Define the visual z index of the series.\n *\n * @sample {highcharts} highcharts/plotoptions/series-zindex-default/\n *         With no z index, the series defined last are on top\n * @sample {highcharts} highcharts/plotoptions/series-zindex/\n *         With a z index, the series with the highest z index is on top\n * @sample {highstock} highcharts/plotoptions/series-zindex-default/\n *         With no z index, the series defined last are on top\n * @sample {highstock} highcharts/plotoptions/series-zindex/\n *         With a z index, the series with the highest z index is on top\n *\n * @type      {number}\n * @product   highcharts highstock\n * @apioption series.zIndex\n */\n''; // include precedent doclets in transpilat\n"],"mappings":"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AACA2B,MAAM,CAACglB,YAAY,GAAG5mB,cAAc,CAAC6mB,kBAAkB;AACvDhmB,MAAM,CAACe,MAAM,CAACgE,SAAS,EAAE;EACrBb,SAAS,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC;EAC7BC,IAAI,EAAE,QAAQ;EACdwI,YAAY,EAAE,CAAC;EACfqS,WAAW,EAAE,KAAK;EAClB5b,WAAW,EAAE,IAAI;EACjByb,WAAW,EAAE,CAAC,SAAS,EAAE,OAAO,CAAC;EACjC;EACA5b,cAAc,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC;EAC1BgI,UAAU,EAAEhM,KAAK;EACjBwH,cAAc,EAAE,IAAI;EACpB;EACAC,MAAM,EAAE;AACZ,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA;AACAvH,cAAc,CAAC+C,MAAM,GAAGnB,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA,eAAeA,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GALA,CAKI;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA,SAJG,CAIA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA,SAJG,CAIA;AACH;AACA;AACA;AACA,YAJG,CAIA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GALA,CAKI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA;AACA,MAJI,CAID;AACH;AACA;AACA;AACA,SAJG,CAIA;AACH;AACA;AACA;AACA,YAJG,CAIA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAJA,CAII;AACJ;AACA;AACA,MAHI,CAGD;AACH;AACA;AACA,SAHG,CAGA;AACH;AACA;AACA,YAHG,CAGA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,CAAC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}