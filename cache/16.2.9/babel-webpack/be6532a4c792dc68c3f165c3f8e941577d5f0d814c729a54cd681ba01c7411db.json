{"ast":null,"code":"/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport U from '../Utilities.js';\nconst {\n  addEvent,\n  getMagnitude,\n  normalizeTickInterval,\n  timeUnits\n} = U;\n/* *\n *\n *  Composition\n *\n * */\n/* eslint-disable valid-jsdoc */\nvar DateTimeAxis;\n(function (DateTimeAxis) {\n  /* *\n   *\n   *  Declarations\n   *\n   * */\n  /* *\n   *\n   *  Constants\n   *\n   * */\n  const composedMembers = [];\n  /* *\n   *\n   *  Functions\n   *\n   * */\n  /**\n   * Extends axis class with date and time support.\n   * @private\n   */\n  function compose(AxisClass) {\n    if (U.pushUnique(composedMembers, AxisClass)) {\n      AxisClass.keepProps.push('dateTime');\n      const axisProto = AxisClass.prototype;\n      axisProto.getTimeTicks = getTimeTicks;\n      addEvent(AxisClass, 'init', onInit);\n    }\n    return AxisClass;\n  }\n  DateTimeAxis.compose = compose;\n  /**\n   * Set the tick positions to a time unit that makes sense, for example\n   * on the first of each month or on every Monday. Return an array with\n   * the time positions. Used in datetime axes as well as for grouping\n   * data on a datetime axis.\n   *\n   * @private\n   * @function Highcharts.Axis#getTimeTicks\n   * @param {Highcharts.TimeNormalizeObject} normalizedInterval\n   * The interval in axis values (ms) and thecount.\n   * @param {number} min\n   * The minimum in axis values.\n   * @param {number} max\n   * The maximum in axis values.\n   */\n  function getTimeTicks() {\n    return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n  }\n  /**\n   * @private\n   */\n  function onInit(e) {\n    const axis = this;\n    const options = e.userOptions;\n    if (options.type !== 'datetime') {\n      axis.dateTime = void 0;\n      return;\n    }\n    if (!axis.dateTime) {\n      axis.dateTime = new Additions(axis);\n    }\n  }\n  /* *\n   *\n   *  Classes\n   *\n   * */\n  class Additions {\n    /* *\n     *\n     *  Constructors\n     *\n     * */\n    constructor(axis) {\n      this.axis = axis;\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Get a normalized tick interval for dates. Returns a configuration\n     * object with unit range (interval), count and name. Used to prepare\n     * data for `getTimeTicks`. Previously this logic was part of\n     * getTimeTicks, but as `getTimeTicks` now runs of segments in stock\n     * charts, the normalizing logic was extracted in order to prevent it\n     * for running over again for each segment having the same interval.\n     * #662, #697.\n     * @private\n     */\n    normalizeTimeTickInterval(tickInterval, unitsOption) {\n      const units = unitsOption || [[\n      // unit name\n      'millisecond',\n      // allowed multiples\n      [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ['second', [1, 2, 5, 10, 15, 30]], ['minute', [1, 2, 5, 10, 15, 30]], ['hour', [1, 2, 3, 4, 6, 8, 12]], ['day', [1, 2]], ['week', [1, 2]], ['month', [1, 2, 3, 4, 6]], ['year', null]];\n      let unit = units[units.length - 1],\n        // default unit is years\n        interval = timeUnits[unit[0]],\n        multiples = unit[1],\n        i;\n      // loop through the units to find the one that best fits the\n      // tickInterval\n      for (i = 0; i < units.length; i++) {\n        unit = units[i];\n        interval = timeUnits[unit[0]];\n        multiples = unit[1];\n        if (units[i + 1]) {\n          // lessThan is in the middle between the highest multiple\n          // and the next unit.\n          const lessThan = (interval * multiples[multiples.length - 1] + timeUnits[units[i + 1][0]]) / 2;\n          // break and keep the current unit\n          if (tickInterval <= lessThan) {\n            break;\n          }\n        }\n      }\n      // prevent 2.5 years intervals, though 25, 250 etc. are allowed\n      if (interval === timeUnits.year && tickInterval < 5 * interval) {\n        multiples = [1, 2, 5];\n      }\n      // get the count\n      const count = normalizeTickInterval(tickInterval / interval, multiples, unit[0] === 'year' ?\n      // #1913, #2360\n      Math.max(getMagnitude(tickInterval / interval), 1) : 1);\n      return {\n        unitRange: interval,\n        count: count,\n        unitName: unit[0]\n      };\n    }\n    /**\n     * Get the best date format for a specific X value based on the closest\n     * point range on the axis.\n     *\n     * @private\n     */\n    getXDateFormat(x, dateTimeLabelFormats) {\n      const {\n          axis\n        } = this,\n        time = axis.chart.time;\n      return axis.closestPointRange ? time.getDateFormat(axis.closestPointRange, x, axis.options.startOfWeek, dateTimeLabelFormats) ||\n      // #2546, 2581\n      time.resolveDTLFormat(dateTimeLabelFormats.year).main : time.resolveDTLFormat(dateTimeLabelFormats.day).main;\n    }\n  }\n  DateTimeAxis.Additions = Additions;\n})(DateTimeAxis || (DateTimeAxis = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default DateTimeAxis;","map":{"version":3,"names":["U","addEvent","getMagnitude","normalizeTickInterval","timeUnits","DateTimeAxis","composedMembers","compose","AxisClass","pushUnique","keepProps","push","axisProto","prototype","getTimeTicks","onInit","chart","time","apply","arguments","e","axis","options","userOptions","type","dateTime","Additions","constructor","normalizeTimeTickInterval","tickInterval","unitsOption","units","unit","length","interval","multiples","i","lessThan","year","count","Math","max","unitRange","unitName","getXDateFormat","x","dateTimeLabelFormats","closestPointRange","getDateFormat","startOfWeek","resolveDTLFormat","main","day"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Core/Axis/DateTimeAxis.js"],"sourcesContent":["/* *\n *\n *  (c) 2010-2021 Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport U from '../Utilities.js';\nconst { addEvent, getMagnitude, normalizeTickInterval, timeUnits } = U;\n/* *\n *\n *  Composition\n *\n * */\n/* eslint-disable valid-jsdoc */\nvar DateTimeAxis;\n(function (DateTimeAxis) {\n    /* *\n     *\n     *  Declarations\n     *\n     * */\n    /* *\n     *\n     *  Constants\n     *\n     * */\n    const composedMembers = [];\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Extends axis class with date and time support.\n     * @private\n     */\n    function compose(AxisClass) {\n        if (U.pushUnique(composedMembers, AxisClass)) {\n            AxisClass.keepProps.push('dateTime');\n            const axisProto = AxisClass.prototype;\n            axisProto.getTimeTicks = getTimeTicks;\n            addEvent(AxisClass, 'init', onInit);\n        }\n        return AxisClass;\n    }\n    DateTimeAxis.compose = compose;\n    /**\n     * Set the tick positions to a time unit that makes sense, for example\n     * on the first of each month or on every Monday. Return an array with\n     * the time positions. Used in datetime axes as well as for grouping\n     * data on a datetime axis.\n     *\n     * @private\n     * @function Highcharts.Axis#getTimeTicks\n     * @param {Highcharts.TimeNormalizeObject} normalizedInterval\n     * The interval in axis values (ms) and thecount.\n     * @param {number} min\n     * The minimum in axis values.\n     * @param {number} max\n     * The maximum in axis values.\n     */\n    function getTimeTicks() {\n        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n    }\n    /**\n     * @private\n     */\n    function onInit(e) {\n        const axis = this;\n        const options = e.userOptions;\n        if (options.type !== 'datetime') {\n            axis.dateTime = void 0;\n            return;\n        }\n        if (!axis.dateTime) {\n            axis.dateTime = new Additions(axis);\n        }\n    }\n    /* *\n     *\n     *  Classes\n     *\n     * */\n    class Additions {\n        /* *\n         *\n         *  Constructors\n         *\n         * */\n        constructor(axis) {\n            this.axis = axis;\n        }\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get a normalized tick interval for dates. Returns a configuration\n         * object with unit range (interval), count and name. Used to prepare\n         * data for `getTimeTicks`. Previously this logic was part of\n         * getTimeTicks, but as `getTimeTicks` now runs of segments in stock\n         * charts, the normalizing logic was extracted in order to prevent it\n         * for running over again for each segment having the same interval.\n         * #662, #697.\n         * @private\n         */\n        normalizeTimeTickInterval(tickInterval, unitsOption) {\n            const units = (unitsOption || [[\n                    // unit name\n                    'millisecond',\n                    // allowed multiples\n                    [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]\n                ], [\n                    'second',\n                    [1, 2, 5, 10, 15, 30]\n                ], [\n                    'minute',\n                    [1, 2, 5, 10, 15, 30]\n                ], [\n                    'hour',\n                    [1, 2, 3, 4, 6, 8, 12]\n                ], [\n                    'day',\n                    [1, 2]\n                ], [\n                    'week',\n                    [1, 2]\n                ], [\n                    'month',\n                    [1, 2, 3, 4, 6]\n                ], [\n                    'year',\n                    null\n                ]]);\n            let unit = units[units.length - 1], // default unit is years\n            interval = timeUnits[unit[0]], multiples = unit[1], i;\n            // loop through the units to find the one that best fits the\n            // tickInterval\n            for (i = 0; i < units.length; i++) {\n                unit = units[i];\n                interval = timeUnits[unit[0]];\n                multiples = unit[1];\n                if (units[i + 1]) {\n                    // lessThan is in the middle between the highest multiple\n                    // and the next unit.\n                    const lessThan = (interval *\n                        multiples[multiples.length - 1] +\n                        timeUnits[units[i + 1][0]]) / 2;\n                    // break and keep the current unit\n                    if (tickInterval <= lessThan) {\n                        break;\n                    }\n                }\n            }\n            // prevent 2.5 years intervals, though 25, 250 etc. are allowed\n            if (interval === timeUnits.year && tickInterval < 5 * interval) {\n                multiples = [1, 2, 5];\n            }\n            // get the count\n            const count = normalizeTickInterval(tickInterval / interval, multiples, unit[0] === 'year' ? // #1913, #2360\n                Math.max(getMagnitude(tickInterval / interval), 1) :\n                1);\n            return {\n                unitRange: interval,\n                count: count,\n                unitName: unit[0]\n            };\n        }\n        /**\n         * Get the best date format for a specific X value based on the closest\n         * point range on the axis.\n         *\n         * @private\n         */\n        getXDateFormat(x, dateTimeLabelFormats) {\n            const { axis } = this, time = axis.chart.time;\n            return axis.closestPointRange ?\n                time.getDateFormat(axis.closestPointRange, x, axis.options.startOfWeek, dateTimeLabelFormats) ||\n                    // #2546, 2581\n                    time.resolveDTLFormat(dateTimeLabelFormats.year).main :\n                time.resolveDTLFormat(dateTimeLabelFormats.day).main;\n        }\n    }\n    DateTimeAxis.Additions = Additions;\n})(DateTimeAxis || (DateTimeAxis = {}));\n/* *\n *\n *  Default Export\n *\n * */\nexport default DateTimeAxis;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}