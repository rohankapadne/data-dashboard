{"ast":null,"code":"/* *\n *\n *  Highcharts Border Radius module\n *\n *  Author: Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\n\nimport D from '../Core/Defaults.js';\nconst {\n  defaultOptions\n} = D;\nimport G from '../Core/Globals.js';\nconst {\n  noop\n} = G;\nimport U from '../Core/Utilities.js';\nconst {\n  addEvent,\n  extend,\n  isObject,\n  merge,\n  pushUnique,\n  relativeLength\n} = U;\n/* *\n *\n *  Constants\n *\n * */\nconst composedMembers = [];\nconst defaultBorderRadiusOptions = {\n  radius: 0,\n  scope: 'stack',\n  where: void 0\n};\n/* *\n *\n *  Variables\n *\n * */\nlet oldArc = noop;\nlet oldRoundedRect = noop;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * @private\n */\nfunction applyBorderRadius(path, i, r) {\n  const a = path[i];\n  let b = path[i + 1];\n  if (b[0] === 'Z') {\n    b = path[0];\n  }\n  let line, arc, fromLineToArc;\n  // From straight line to arc\n  if ((a[0] === 'M' || a[0] === 'L') && b[0] === 'A') {\n    line = a;\n    arc = b;\n    fromLineToArc = true;\n    // From arc to straight line\n  } else if (a[0] === 'A' && (b[0] === 'M' || b[0] === 'L')) {\n    line = b;\n    arc = a;\n  }\n  if (line && arc && arc.params) {\n    const bigR = arc[1],\n      // In our use cases, outer pie slice arcs are clockwise and inner\n      // arcs (donut/sunburst etc) are anti-clockwise\n      clockwise = arc[5],\n      params = arc.params,\n      {\n        start,\n        end,\n        cx,\n        cy\n      } = params;\n    // Some geometric constants\n    const relativeR = clockwise ? bigR - r : bigR + r,\n      // The angle, on the big arc, that the border radius arc takes up\n      angleOfBorderRadius = relativeR ? Math.asin(r / relativeR) : 0,\n      angleOffset = clockwise ? angleOfBorderRadius : -angleOfBorderRadius,\n      // The distance along the radius of the big arc to the starting\n      // point of the small border radius arc\n      distanceBigCenterToStartArc = Math.cos(angleOfBorderRadius) * relativeR;\n    // From line to arc\n    if (fromLineToArc) {\n      // Update the cache\n      params.start = start + angleOffset;\n      // First move to the start position at the radial line. We want to\n      // start one borderRadius closer to the center.\n      line[1] = cx + distanceBigCenterToStartArc * Math.cos(start);\n      line[2] = cy + distanceBigCenterToStartArc * Math.sin(start);\n      // Now draw an arc towards the point where the small circle touches\n      // the great circle.\n      path.splice(i + 1, 0, ['A', r, r, 0, 0, 1, cx + bigR * Math.cos(params.start), cy + bigR * Math.sin(params.start)]);\n      // From arc to line\n    } else {\n      // Update the cache\n      params.end = end - angleOffset;\n      // End the big arc a bit earlier\n      arc[6] = cx + bigR * Math.cos(params.end);\n      arc[7] = cy + bigR * Math.sin(params.end);\n      // Draw a small arc towards a point on the end angle, but one\n      // borderRadius closer to the center relative to the perimeter.\n      path.splice(i + 1, 0, ['A', r, r, 0, 0, 1, cx + distanceBigCenterToStartArc * Math.cos(end), cy + distanceBigCenterToStartArc * Math.sin(end)]);\n    }\n    // Long or short arc must be reconsidered because we have modified the\n    // start and end points\n    arc[4] = Math.abs(params.end - params.start) < Math.PI ? 0 : 1;\n  }\n}\n/**\n * Extend arc with borderRadius.\n * @private\n */\nfunction arc(x, y, w, h, options = {}) {\n  const path = oldArc(x, y, w, h, options),\n    {\n      innerR = 0,\n      r = w,\n      start = 0,\n      end = 0\n    } = options;\n  if (options.open || !options.borderRadius) {\n    return path;\n  }\n  const alpha = end - start,\n    sinHalfAlpha = Math.sin(alpha / 2),\n    borderRadius = Math.max(Math.min(relativeLength(options.borderRadius || 0, r - innerR),\n    // Cap to half the sector radius\n    (r - innerR) / 2,\n    // For smaller pie slices, cap to the largest small circle that\n    // can be fitted within the sector\n    r * sinHalfAlpha / (1 + sinHalfAlpha)), 0),\n    // For the inner radius, we need an extra cap because the inner arc\n    // is shorter than the outer arc\n    innerBorderRadius = Math.min(borderRadius, 2 * (alpha / Math.PI) * innerR);\n  // Apply turn-by-turn border radius. Start at the end since we're\n  // splicing in arc segments.\n  let i = path.length - 1;\n  while (i--) {\n    applyBorderRadius(path, i, i > 1 ? innerBorderRadius : borderRadius);\n  }\n  return path;\n}\n/** @private */\nfunction seriesOnAfterColumnTranslate() {\n  if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {\n    const {\n        options,\n        yAxis\n      } = this,\n      percent = options.stacking === 'percent',\n      seriesDefault = defaultOptions.plotOptions?.[this.type]?.borderRadius,\n      borderRadius = optionsToObject(options.borderRadius, isObject(seriesDefault) ? seriesDefault : {}),\n      reversed = yAxis.options.reversed;\n    for (const point of this.points) {\n      const {\n        shapeArgs\n      } = point;\n      if (point.shapeType === 'roundedRect' && shapeArgs) {\n        const {\n          width = 0,\n          height = 0,\n          y = 0\n        } = shapeArgs;\n        let brBoxY = y,\n          brBoxHeight = height;\n        // It would be nice to refactor StackItem.getStackBox/\n        // setOffset so that we could get a reliable box out of\n        // it. Currently it is close if we remove the label\n        // offset, but we still need to run crispCol and also\n        // flip it if inverted, so atm it is simpler to do it\n        // like the below.\n        if (borderRadius.scope === 'stack' && point.stackTotal) {\n          const stackEnd = yAxis.translate(percent ? 100 : point.stackTotal, false, true, false, true),\n            stackThreshold = yAxis.translate(options.threshold || 0, false, true, false, true),\n            box = this.crispCol(0, Math.min(stackEnd, stackThreshold), 0, Math.abs(stackEnd - stackThreshold));\n          brBoxY = box.y;\n          brBoxHeight = box.height;\n        }\n        const flip = (point.negative ? -1 : 1) * (reversed ? -1 : 1) === -1;\n        // Handle the where option\n        let where = borderRadius.where;\n        // Waterfall, hanging columns should have rounding on\n        // all sides\n        if (!where && this.is('waterfall') && Math.abs((point.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth) {\n          where = 'all';\n        }\n        if (!where) {\n          where = 'end';\n        }\n        // Get the radius\n        const r = Math.min(relativeLength(borderRadius.radius, width), width / 2,\n        // Cap to the height, but not if where is `end`\n        where === 'all' ? height / 2 : Infinity) || 0;\n        // If the `where` option is 'end', cut off the\n        // rectangles by making the border-radius box one r\n        // greater, so that the imaginary radius falls outside\n        // the rectangle.\n        if (where === 'end') {\n          if (flip) {\n            brBoxY -= r;\n            brBoxHeight += r;\n          } else {\n            brBoxHeight += r;\n          }\n        }\n        extend(shapeArgs, {\n          brBoxHeight,\n          brBoxY,\n          r\n        });\n      }\n    }\n  }\n}\n/** @private */\nfunction compose(SeriesClass, PieSeriesClass, SVGElementClass, SVGRendererClass) {\n  if (pushUnique(composedMembers, SeriesClass)) {\n    addEvent(SeriesClass, 'afterColumnTranslate', seriesOnAfterColumnTranslate, {\n      // After columnrange and polar column modifications\n      order: 9\n    });\n  }\n  if (pushUnique(composedMembers, PieSeriesClass)) {\n    addEvent(PieSeriesClass, 'afterTranslate', pieSeriesOnAfterTranslate);\n  }\n  if (pushUnique(composedMembers, SVGElementClass)) {\n    SVGElementClass.symbolCustomAttribs.push('borderRadius', 'brBoxHeight', 'brBoxY');\n  }\n  if (pushUnique(composedMembers, SVGRendererClass)) {\n    const symbols = SVGRendererClass.prototype.symbols;\n    oldArc = symbols.arc;\n    oldRoundedRect = symbols.roundedRect;\n    symbols.arc = arc;\n    symbols.roundedRect = roundedRect;\n  }\n}\n/** @private */\nfunction optionsToObject(options, seriesBROptions) {\n  if (!isObject(options)) {\n    options = {\n      radius: options || 0\n    };\n  }\n  return merge(defaultBorderRadiusOptions, seriesBROptions, options);\n}\n/** @private */\nfunction pieSeriesOnAfterTranslate() {\n  const borderRadius = optionsToObject(this.options.borderRadius);\n  for (const point of this.points) {\n    const shapeArgs = point.shapeArgs;\n    if (shapeArgs) {\n      shapeArgs.borderRadius = relativeLength(borderRadius.radius, (shapeArgs.r || 0) - (shapeArgs.innerR || 0));\n    }\n  }\n}\n/**\n * Extend roundedRect with individual cutting through rOffset.\n * @private\n */\nfunction roundedRect(x, y, width, height, options = {}) {\n  const path = oldRoundedRect(x, y, width, height, options),\n    {\n      r = 0,\n      brBoxHeight = height,\n      brBoxY = y\n    } = options,\n    brOffsetTop = y - brBoxY,\n    brOffsetBtm = brBoxY + brBoxHeight - (y + height),\n    // When the distance to the border-radius box is greater than the r\n    // itself, it means no border radius. The -0.1 accounts for float\n    // rounding errors.\n    rTop = brOffsetTop - r > -0.1 ? 0 : r,\n    rBtm = brOffsetBtm - r > -0.1 ? 0 : r,\n    cutTop = Math.max(rTop && brOffsetTop, 0),\n    cutBtm = Math.max(rBtm && brOffsetBtm, 0);\n  /*\n   The naming of control points:\n     / a -------- b \\\n   /                \\\n  h                  c\n  |                  |\n  |                  |\n  |                  |\n  g                  d\n   \\                /\n    \\ f -------- e /\n   */\n  const a = [x + rTop, y],\n    b = [x + width - rTop, y],\n    c = [x + width, y + rTop],\n    d = [x + width, y + height - rBtm],\n    e = [x + width - rBtm, y + height],\n    f = [x + rBtm, y + height],\n    g = [x, y + height - rBtm],\n    h = [x, y + rTop];\n  const applyPythagoras = (r, altitude) => Math.sqrt(Math.pow(r, 2) - Math.pow(altitude, 2));\n  // Inside stacks, cut off part of the top\n  if (cutTop) {\n    const base = applyPythagoras(rTop, rTop - cutTop);\n    a[0] -= base;\n    b[0] += base;\n    c[1] = h[1] = y + rTop - cutTop;\n  }\n  // Column is lower than the radius. Cut off bottom inside the top\n  // radius.\n  if (height < rTop - cutTop) {\n    const base = applyPythagoras(rTop, rTop - cutTop - height);\n    c[0] = d[0] = x + width - rTop + base;\n    e[0] = Math.min(c[0], e[0]);\n    f[0] = Math.max(d[0], f[0]);\n    g[0] = h[0] = x + rTop - base;\n    c[1] = h[1] = y + height;\n  }\n  // Inside stacks, cut off part of the bottom\n  if (cutBtm) {\n    const base = applyPythagoras(rBtm, rBtm - cutBtm);\n    e[0] += base;\n    f[0] -= base;\n    d[1] = g[1] = y + height - rBtm + cutBtm;\n  }\n  // Cut off top inside the bottom radius\n  if (height < rBtm - cutBtm) {\n    const base = applyPythagoras(rBtm, rBtm - cutBtm - height);\n    c[0] = d[0] = x + width - rBtm + base;\n    b[0] = Math.min(c[0], b[0]);\n    a[0] = Math.max(d[0], a[0]);\n    g[0] = h[0] = x + rBtm - base;\n    d[1] = g[1] = y;\n  }\n  // Preserve the box for data labels\n  path.length = 0;\n  path.push(['M', ...a],\n  // top side\n  ['L', ...b],\n  // top right corner\n  ['A', rTop, rTop, 0, 0, 1, ...c],\n  // right side\n  ['L', ...d],\n  // bottom right corner\n  ['A', rBtm, rBtm, 0, 0, 1, ...e],\n  // bottom side\n  ['L', ...f],\n  // bottom left corner\n  ['A', rBtm, rBtm, 0, 0, 1, ...g],\n  // left side\n  ['L', ...h],\n  // top left corner\n  ['A', rTop, rTop, 0, 0, 1, ...a], ['Z']);\n  return path;\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst BorderRadius = {\n  compose,\n  optionsToObject\n};\nexport default BorderRadius;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Detailed options for border radius.\n *\n * @sample  {highcharts} highcharts/plotoptions/column-borderradius/\n *          Rounded columns\n * @sample  highcharts/plotoptions/series-border-radius\n *          Column and pie with rounded border\n *\n * @interface Highcharts.BorderRadiusOptionsObject\n */ /**\n    * The border radius. A number signifies pixels. A percentage string, like for\n    * example `50%`, signifies a relative size. For columns this is relative to the\n    * column width, for pies it is relative to the radius and the inner radius.\n    *\n    * @name Highcharts.BorderRadiusOptionsObject#radius\n    * @type {string|number}\n    */ /**\n       * The scope of the rounding for column charts. In a stacked column chart, the\n       * value `point` means each single point will get rounded corners. The value\n       * `stack` means the rounding will apply to the full stack, so that only points\n       * close to the top or bottom will receive rounding.\n       *\n       * @name Highcharts.BorderRadiusOptionsObject#scope\n       * @validvalue [\"point\", \"stack\"]\n       * @type {string}\n       */ /**\n          * For column charts, where in the point or stack to apply rounding. The `end`\n          * value means only those corners at the point value will be rounded, leaving\n          * the corners at the base or threshold unrounded. This is the most intuitive\n          * behaviour. The `all` value means also the base will be rounded.\n          *\n          * @name Highcharts.BorderRadiusOptionsObject#where\n          * @validvalue [\"all\", \"end\"]\n          * @type {string}\n          * @default end\n          */\n''; // keeps doclets above in JS file","map":{"version":3,"names":["D","defaultOptions","G","noop","U","addEvent","extend","isObject","merge","pushUnique","relativeLength","composedMembers","defaultBorderRadiusOptions","radius","scope","where","oldArc","oldRoundedRect","applyBorderRadius","path","i","r","a","b","line","arc","fromLineToArc","params","bigR","clockwise","start","end","cx","cy","relativeR","angleOfBorderRadius","Math","asin","angleOffset","distanceBigCenterToStartArc","cos","sin","splice","abs","PI","x","y","w","h","options","innerR","open","borderRadius","alpha","sinHalfAlpha","max","min","innerBorderRadius","length","seriesOnAfterColumnTranslate","chart","is3d","yAxis","percent","stacking","seriesDefault","plotOptions","type","optionsToObject","reversed","point","points","shapeArgs","shapeType","width","height","brBoxY","brBoxHeight","stackTotal","stackEnd","translate","stackThreshold","threshold","box","crispCol","flip","negative","is","yBottom","translatedThreshold","borderWidth","Infinity","compose","SeriesClass","PieSeriesClass","SVGElementClass","SVGRendererClass","order","pieSeriesOnAfterTranslate","symbolCustomAttribs","push","symbols","prototype","roundedRect","seriesBROptions","brOffsetTop","brOffsetBtm","rTop","rBtm","cutTop","cutBtm","c","d","e","f","g","applyPythagoras","altitude","sqrt","pow","base","BorderRadius"],"sources":["D:/Vamtage/angular-widget-project/node_modules/highcharts/es-modules/Extensions/BorderRadius.js"],"sourcesContent":["/* *\n *\n *  Highcharts Border Radius module\n *\n *  Author: Torstein Honsi\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n'use strict';\nimport D from '../Core/Defaults.js';\nconst { defaultOptions } = D;\nimport G from '../Core/Globals.js';\nconst { noop } = G;\nimport U from '../Core/Utilities.js';\nconst { addEvent, extend, isObject, merge, pushUnique, relativeLength } = U;\n/* *\n *\n *  Constants\n *\n * */\nconst composedMembers = [];\nconst defaultBorderRadiusOptions = {\n    radius: 0,\n    scope: 'stack',\n    where: void 0\n};\n/* *\n *\n *  Variables\n *\n * */\nlet oldArc = noop;\nlet oldRoundedRect = noop;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * @private\n */\nfunction applyBorderRadius(path, i, r) {\n    const a = path[i];\n    let b = path[i + 1];\n    if (b[0] === 'Z') {\n        b = path[0];\n    }\n    let line, arc, fromLineToArc;\n    // From straight line to arc\n    if ((a[0] === 'M' || a[0] === 'L') && b[0] === 'A') {\n        line = a;\n        arc = b;\n        fromLineToArc = true;\n        // From arc to straight line\n    }\n    else if (a[0] === 'A' && (b[0] === 'M' || b[0] === 'L')) {\n        line = b;\n        arc = a;\n    }\n    if (line && arc && arc.params) {\n        const bigR = arc[1], \n        // In our use cases, outer pie slice arcs are clockwise and inner\n        // arcs (donut/sunburst etc) are anti-clockwise\n        clockwise = arc[5], params = arc.params, { start, end, cx, cy } = params;\n        // Some geometric constants\n        const relativeR = clockwise ? (bigR - r) : (bigR + r), \n        // The angle, on the big arc, that the border radius arc takes up\n        angleOfBorderRadius = relativeR ? Math.asin(r / relativeR) : 0, angleOffset = clockwise ?\n            angleOfBorderRadius :\n            -angleOfBorderRadius, \n        // The distance along the radius of the big arc to the starting\n        // point of the small border radius arc\n        distanceBigCenterToStartArc = (Math.cos(angleOfBorderRadius) *\n            relativeR);\n        // From line to arc\n        if (fromLineToArc) {\n            // Update the cache\n            params.start = start + angleOffset;\n            // First move to the start position at the radial line. We want to\n            // start one borderRadius closer to the center.\n            line[1] = cx + distanceBigCenterToStartArc * Math.cos(start);\n            line[2] = cy + distanceBigCenterToStartArc * Math.sin(start);\n            // Now draw an arc towards the point where the small circle touches\n            // the great circle.\n            path.splice(i + 1, 0, [\n                'A',\n                r,\n                r,\n                0,\n                0,\n                1,\n                cx + bigR * Math.cos(params.start),\n                cy + bigR * Math.sin(params.start)\n            ]);\n            // From arc to line\n        }\n        else {\n            // Update the cache\n            params.end = end - angleOffset;\n            // End the big arc a bit earlier\n            arc[6] = cx + bigR * Math.cos(params.end);\n            arc[7] = cy + bigR * Math.sin(params.end);\n            // Draw a small arc towards a point on the end angle, but one\n            // borderRadius closer to the center relative to the perimeter.\n            path.splice(i + 1, 0, [\n                'A',\n                r,\n                r,\n                0,\n                0,\n                1,\n                cx + distanceBigCenterToStartArc * Math.cos(end),\n                cy + distanceBigCenterToStartArc * Math.sin(end)\n            ]);\n        }\n        // Long or short arc must be reconsidered because we have modified the\n        // start and end points\n        arc[4] = Math.abs(params.end - params.start) < Math.PI ? 0 : 1;\n    }\n}\n/**\n * Extend arc with borderRadius.\n * @private\n */\nfunction arc(x, y, w, h, options = {}) {\n    const path = oldArc(x, y, w, h, options), { innerR = 0, r = w, start = 0, end = 0 } = options;\n    if (options.open || !options.borderRadius) {\n        return path;\n    }\n    const alpha = end - start, sinHalfAlpha = Math.sin(alpha / 2), borderRadius = Math.max(Math.min(relativeLength(options.borderRadius || 0, r - innerR), \n    // Cap to half the sector radius\n    (r - innerR) / 2, \n    // For smaller pie slices, cap to the largest small circle that\n    // can be fitted within the sector\n    (r * sinHalfAlpha) / (1 + sinHalfAlpha)), 0), \n    // For the inner radius, we need an extra cap because the inner arc\n    // is shorter than the outer arc\n    innerBorderRadius = Math.min(borderRadius, 2 * (alpha / Math.PI) * innerR);\n    // Apply turn-by-turn border radius. Start at the end since we're\n    // splicing in arc segments.\n    let i = path.length - 1;\n    while (i--) {\n        applyBorderRadius(path, i, i > 1 ? innerBorderRadius : borderRadius);\n    }\n    return path;\n}\n/** @private */\nfunction seriesOnAfterColumnTranslate() {\n    if (this.options.borderRadius &&\n        !(this.chart.is3d && this.chart.is3d())) {\n        const { options, yAxis } = this, percent = options.stacking === 'percent', seriesDefault = defaultOptions.plotOptions?.[this.type]\n            ?.borderRadius, borderRadius = optionsToObject(options.borderRadius, isObject(seriesDefault) ? seriesDefault : {}), reversed = yAxis.options.reversed;\n        for (const point of this.points) {\n            const { shapeArgs } = point;\n            if (point.shapeType === 'roundedRect' && shapeArgs) {\n                const { width = 0, height = 0, y = 0 } = shapeArgs;\n                let brBoxY = y, brBoxHeight = height;\n                // It would be nice to refactor StackItem.getStackBox/\n                // setOffset so that we could get a reliable box out of\n                // it. Currently it is close if we remove the label\n                // offset, but we still need to run crispCol and also\n                // flip it if inverted, so atm it is simpler to do it\n                // like the below.\n                if (borderRadius.scope === 'stack' &&\n                    point.stackTotal) {\n                    const stackEnd = yAxis.translate(percent ? 100 : point.stackTotal, false, true, false, true), stackThreshold = yAxis.translate(options.threshold || 0, false, true, false, true), box = this.crispCol(0, Math.min(stackEnd, stackThreshold), 0, Math.abs(stackEnd - stackThreshold));\n                    brBoxY = box.y;\n                    brBoxHeight = box.height;\n                }\n                const flip = (point.negative ? -1 : 1) *\n                    (reversed ? -1 : 1) === -1;\n                // Handle the where option\n                let where = borderRadius.where;\n                // Waterfall, hanging columns should have rounding on\n                // all sides\n                if (!where &&\n                    this.is('waterfall') &&\n                    Math.abs((point.yBottom || 0) -\n                        (this.translatedThreshold || 0)) > this.borderWidth) {\n                    where = 'all';\n                }\n                if (!where) {\n                    where = 'end';\n                }\n                // Get the radius\n                const r = Math.min(relativeLength(borderRadius.radius, width), width / 2, \n                // Cap to the height, but not if where is `end`\n                where === 'all' ? height / 2 : Infinity) || 0;\n                // If the `where` option is 'end', cut off the\n                // rectangles by making the border-radius box one r\n                // greater, so that the imaginary radius falls outside\n                // the rectangle.\n                if (where === 'end') {\n                    if (flip) {\n                        brBoxY -= r;\n                        brBoxHeight += r;\n                    }\n                    else {\n                        brBoxHeight += r;\n                    }\n                }\n                extend(shapeArgs, { brBoxHeight, brBoxY, r });\n            }\n        }\n    }\n}\n/** @private */\nfunction compose(SeriesClass, PieSeriesClass, SVGElementClass, SVGRendererClass) {\n    if (pushUnique(composedMembers, SeriesClass)) {\n        addEvent(SeriesClass, 'afterColumnTranslate', seriesOnAfterColumnTranslate, {\n            // After columnrange and polar column modifications\n            order: 9\n        });\n    }\n    if (pushUnique(composedMembers, PieSeriesClass)) {\n        addEvent(PieSeriesClass, 'afterTranslate', pieSeriesOnAfterTranslate);\n    }\n    if (pushUnique(composedMembers, SVGElementClass)) {\n        SVGElementClass.symbolCustomAttribs.push('borderRadius', 'brBoxHeight', 'brBoxY');\n    }\n    if (pushUnique(composedMembers, SVGRendererClass)) {\n        const symbols = SVGRendererClass.prototype.symbols;\n        oldArc = symbols.arc;\n        oldRoundedRect = symbols.roundedRect;\n        symbols.arc = arc;\n        symbols.roundedRect = roundedRect;\n    }\n}\n/** @private */\nfunction optionsToObject(options, seriesBROptions) {\n    if (!isObject(options)) {\n        options = { radius: options || 0 };\n    }\n    return merge(defaultBorderRadiusOptions, seriesBROptions, options);\n}\n/** @private */\nfunction pieSeriesOnAfterTranslate() {\n    const borderRadius = optionsToObject(this.options.borderRadius);\n    for (const point of this.points) {\n        const shapeArgs = point.shapeArgs;\n        if (shapeArgs) {\n            shapeArgs.borderRadius = relativeLength(borderRadius.radius, (shapeArgs.r || 0) - ((shapeArgs.innerR) || 0));\n        }\n    }\n}\n/**\n * Extend roundedRect with individual cutting through rOffset.\n * @private\n */\nfunction roundedRect(x, y, width, height, options = {}) {\n    const path = oldRoundedRect(x, y, width, height, options), { r = 0, brBoxHeight = height, brBoxY = y } = options, brOffsetTop = y - brBoxY, brOffsetBtm = (brBoxY + brBoxHeight) - (y + height), \n    // When the distance to the border-radius box is greater than the r\n    // itself, it means no border radius. The -0.1 accounts for float\n    // rounding errors.\n    rTop = (brOffsetTop - r) > -0.1 ? 0 : r, rBtm = (brOffsetBtm - r) > -0.1 ? 0 : r, cutTop = Math.max(rTop && brOffsetTop, 0), cutBtm = Math.max(rBtm && brOffsetBtm, 0);\n    /*\n\n    The naming of control points:\n\n      / a -------- b \\\n     /                \\\n    h                  c\n    |                  |\n    |                  |\n    |                  |\n    g                  d\n     \\                /\n      \\ f -------- e /\n\n    */\n    const a = [x + rTop, y], b = [x + width - rTop, y], c = [x + width, y + rTop], d = [\n        x + width, y + height - rBtm\n    ], e = [\n        x + width - rBtm,\n        y + height\n    ], f = [x + rBtm, y + height], g = [x, y + height - rBtm], h = [x, y + rTop];\n    const applyPythagoras = (r, altitude) => Math.sqrt(Math.pow(r, 2) - Math.pow(altitude, 2));\n    // Inside stacks, cut off part of the top\n    if (cutTop) {\n        const base = applyPythagoras(rTop, rTop - cutTop);\n        a[0] -= base;\n        b[0] += base;\n        c[1] = h[1] = y + rTop - cutTop;\n    }\n    // Column is lower than the radius. Cut off bottom inside the top\n    // radius.\n    if (height < rTop - cutTop) {\n        const base = applyPythagoras(rTop, rTop - cutTop - height);\n        c[0] = d[0] = x + width - rTop + base;\n        e[0] = Math.min(c[0], e[0]);\n        f[0] = Math.max(d[0], f[0]);\n        g[0] = h[0] = x + rTop - base;\n        c[1] = h[1] = y + height;\n    }\n    // Inside stacks, cut off part of the bottom\n    if (cutBtm) {\n        const base = applyPythagoras(rBtm, rBtm - cutBtm);\n        e[0] += base;\n        f[0] -= base;\n        d[1] = g[1] = y + height - rBtm + cutBtm;\n    }\n    // Cut off top inside the bottom radius\n    if (height < rBtm - cutBtm) {\n        const base = applyPythagoras(rBtm, rBtm - cutBtm - height);\n        c[0] = d[0] = x + width - rBtm + base;\n        b[0] = Math.min(c[0], b[0]);\n        a[0] = Math.max(d[0], a[0]);\n        g[0] = h[0] = x + rBtm - base;\n        d[1] = g[1] = y;\n    }\n    // Preserve the box for data labels\n    path.length = 0;\n    path.push(['M', ...a], \n    // top side\n    ['L', ...b], \n    // top right corner\n    ['A', rTop, rTop, 0, 0, 1, ...c], \n    // right side\n    ['L', ...d], \n    // bottom right corner\n    ['A', rBtm, rBtm, 0, 0, 1, ...e], \n    // bottom side\n    ['L', ...f], \n    // bottom left corner\n    ['A', rBtm, rBtm, 0, 0, 1, ...g], \n    // left side\n    ['L', ...h], \n    // top left corner\n    ['A', rTop, rTop, 0, 0, 1, ...a], ['Z']);\n    return path;\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst BorderRadius = {\n    compose,\n    optionsToObject\n};\nexport default BorderRadius;\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * Detailed options for border radius.\n *\n * @sample  {highcharts} highcharts/plotoptions/column-borderradius/\n *          Rounded columns\n * @sample  highcharts/plotoptions/series-border-radius\n *          Column and pie with rounded border\n *\n * @interface Highcharts.BorderRadiusOptionsObject\n */ /**\n* The border radius. A number signifies pixels. A percentage string, like for\n* example `50%`, signifies a relative size. For columns this is relative to the\n* column width, for pies it is relative to the radius and the inner radius.\n*\n* @name Highcharts.BorderRadiusOptionsObject#radius\n* @type {string|number}\n*/ /**\n* The scope of the rounding for column charts. In a stacked column chart, the\n* value `point` means each single point will get rounded corners. The value\n* `stack` means the rounding will apply to the full stack, so that only points\n* close to the top or bottom will receive rounding.\n*\n* @name Highcharts.BorderRadiusOptionsObject#scope\n* @validvalue [\"point\", \"stack\"]\n* @type {string}\n*/ /**\n* For column charts, where in the point or stack to apply rounding. The `end`\n* value means only those corners at the point value will be rounded, leaving\n* the corners at the base or threshold unrounded. This is the most intuitive\n* behaviour. The `all` value means also the base will be rounded.\n*\n* @name Highcharts.BorderRadiusOptionsObject#where\n* @validvalue [\"all\", \"end\"]\n* @type {string}\n* @default end\n*/\n(''); // keeps doclets above in JS file\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AACZ,OAAOA,CAAC,MAAM,qBAAqB;AACnC,MAAM;EAAEC;AAAe,CAAC,GAAGD,CAAC;AAC5B,OAAOE,CAAC,MAAM,oBAAoB;AAClC,MAAM;EAAEC;AAAK,CAAC,GAAGD,CAAC;AAClB,OAAOE,CAAC,MAAM,sBAAsB;AACpC,MAAM;EAAEC,QAAQ;EAAEC,MAAM;EAAEC,QAAQ;EAAEC,KAAK;EAAEC,UAAU;EAAEC;AAAe,CAAC,GAAGN,CAAC;AAC3E;AACA;AACA;AACA;AACA;AACA,MAAMO,eAAe,GAAG,EAAE;AAC1B,MAAMC,0BAA0B,GAAG;EAC/BC,MAAM,EAAE,CAAC;EACTC,KAAK,EAAE,OAAO;EACdC,KAAK,EAAE,KAAK;AAChB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,IAAIC,MAAM,GAAGb,IAAI;AACjB,IAAIc,cAAc,GAAGd,IAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASe,iBAAiBA,CAACC,IAAI,EAAEC,CAAC,EAAEC,CAAC,EAAE;EACnC,MAAMC,CAAC,GAAGH,IAAI,CAACC,CAAC,CAAC;EACjB,IAAIG,CAAC,GAAGJ,IAAI,CAACC,CAAC,GAAG,CAAC,CAAC;EACnB,IAAIG,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;IACdA,CAAC,GAAGJ,IAAI,CAAC,CAAC,CAAC;EACf;EACA,IAAIK,IAAI,EAAEC,GAAG,EAAEC,aAAa;EAC5B;EACA,IAAI,CAACJ,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,KAAKC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;IAChDC,IAAI,GAAGF,CAAC;IACRG,GAAG,GAAGF,CAAC;IACPG,aAAa,GAAG,IAAI;IACpB;EACJ,CAAC,MACI,IAAIJ,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,KAAKC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,EAAE;IACrDC,IAAI,GAAGD,CAAC;IACRE,GAAG,GAAGH,CAAC;EACX;EACA,IAAIE,IAAI,IAAIC,GAAG,IAAIA,GAAG,CAACE,MAAM,EAAE;IAC3B,MAAMC,IAAI,GAAGH,GAAG,CAAC,CAAC,CAAC;MACnB;MACA;MACAI,SAAS,GAAGJ,GAAG,CAAC,CAAC,CAAC;MAAEE,MAAM,GAAGF,GAAG,CAACE,MAAM;MAAE;QAAEG,KAAK;QAAEC,GAAG;QAAEC,EAAE;QAAEC;MAAG,CAAC,GAAGN,MAAM;IACxE;IACA,MAAMO,SAAS,GAAGL,SAAS,GAAID,IAAI,GAAGP,CAAC,GAAKO,IAAI,GAAGP,CAAE;MACrD;MACAc,mBAAmB,GAAGD,SAAS,GAAGE,IAAI,CAACC,IAAI,CAAChB,CAAC,GAAGa,SAAS,CAAC,GAAG,CAAC;MAAEI,WAAW,GAAGT,SAAS,GACnFM,mBAAmB,GACnB,CAACA,mBAAmB;MACxB;MACA;MACAI,2BAA2B,GAAIH,IAAI,CAACI,GAAG,CAACL,mBAAmB,CAAC,GACxDD,SAAU;IACd;IACA,IAAIR,aAAa,EAAE;MACf;MACAC,MAAM,CAACG,KAAK,GAAGA,KAAK,GAAGQ,WAAW;MAClC;MACA;MACAd,IAAI,CAAC,CAAC,CAAC,GAAGQ,EAAE,GAAGO,2BAA2B,GAAGH,IAAI,CAACI,GAAG,CAACV,KAAK,CAAC;MAC5DN,IAAI,CAAC,CAAC,CAAC,GAAGS,EAAE,GAAGM,2BAA2B,GAAGH,IAAI,CAACK,GAAG,CAACX,KAAK,CAAC;MAC5D;MACA;MACAX,IAAI,CAACuB,MAAM,CAACtB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAClB,GAAG,EACHC,CAAC,EACDA,CAAC,EACD,CAAC,EACD,CAAC,EACD,CAAC,EACDW,EAAE,GAAGJ,IAAI,GAAGQ,IAAI,CAACI,GAAG,CAACb,MAAM,CAACG,KAAK,CAAC,EAClCG,EAAE,GAAGL,IAAI,GAAGQ,IAAI,CAACK,GAAG,CAACd,MAAM,CAACG,KAAK,CAAC,CACrC,CAAC;MACF;IACJ,CAAC,MACI;MACD;MACAH,MAAM,CAACI,GAAG,GAAGA,GAAG,GAAGO,WAAW;MAC9B;MACAb,GAAG,CAAC,CAAC,CAAC,GAAGO,EAAE,GAAGJ,IAAI,GAAGQ,IAAI,CAACI,GAAG,CAACb,MAAM,CAACI,GAAG,CAAC;MACzCN,GAAG,CAAC,CAAC,CAAC,GAAGQ,EAAE,GAAGL,IAAI,GAAGQ,IAAI,CAACK,GAAG,CAACd,MAAM,CAACI,GAAG,CAAC;MACzC;MACA;MACAZ,IAAI,CAACuB,MAAM,CAACtB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAClB,GAAG,EACHC,CAAC,EACDA,CAAC,EACD,CAAC,EACD,CAAC,EACD,CAAC,EACDW,EAAE,GAAGO,2BAA2B,GAAGH,IAAI,CAACI,GAAG,CAACT,GAAG,CAAC,EAChDE,EAAE,GAAGM,2BAA2B,GAAGH,IAAI,CAACK,GAAG,CAACV,GAAG,CAAC,CACnD,CAAC;IACN;IACA;IACA;IACAN,GAAG,CAAC,CAAC,CAAC,GAAGW,IAAI,CAACO,GAAG,CAAChB,MAAM,CAACI,GAAG,GAAGJ,MAAM,CAACG,KAAK,CAAC,GAAGM,IAAI,CAACQ,EAAE,GAAG,CAAC,GAAG,CAAC;EAClE;AACJ;AACA;AACA;AACA;AACA;AACA,SAASnB,GAAGA,CAACoB,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACnC,MAAM9B,IAAI,GAAGH,MAAM,CAAC6B,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,OAAO,CAAC;IAAE;MAAEC,MAAM,GAAG,CAAC;MAAE7B,CAAC,GAAG0B,CAAC;MAAEjB,KAAK,GAAG,CAAC;MAAEC,GAAG,GAAG;IAAE,CAAC,GAAGkB,OAAO;EAC7F,IAAIA,OAAO,CAACE,IAAI,IAAI,CAACF,OAAO,CAACG,YAAY,EAAE;IACvC,OAAOjC,IAAI;EACf;EACA,MAAMkC,KAAK,GAAGtB,GAAG,GAAGD,KAAK;IAAEwB,YAAY,GAAGlB,IAAI,CAACK,GAAG,CAACY,KAAK,GAAG,CAAC,CAAC;IAAED,YAAY,GAAGhB,IAAI,CAACmB,GAAG,CAACnB,IAAI,CAACoB,GAAG,CAAC9C,cAAc,CAACuC,OAAO,CAACG,YAAY,IAAI,CAAC,EAAE/B,CAAC,GAAG6B,MAAM,CAAC;IACrJ;IACA,CAAC7B,CAAC,GAAG6B,MAAM,IAAI,CAAC;IAChB;IACA;IACC7B,CAAC,GAAGiC,YAAY,IAAK,CAAC,GAAGA,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC;IAC5C;IACA;IACAG,iBAAiB,GAAGrB,IAAI,CAACoB,GAAG,CAACJ,YAAY,EAAE,CAAC,IAAIC,KAAK,GAAGjB,IAAI,CAACQ,EAAE,CAAC,GAAGM,MAAM,CAAC;EAC1E;EACA;EACA,IAAI9B,CAAC,GAAGD,IAAI,CAACuC,MAAM,GAAG,CAAC;EACvB,OAAOtC,CAAC,EAAE,EAAE;IACRF,iBAAiB,CAACC,IAAI,EAAEC,CAAC,EAAEA,CAAC,GAAG,CAAC,GAAGqC,iBAAiB,GAAGL,YAAY,CAAC;EACxE;EACA,OAAOjC,IAAI;AACf;AACA;AACA,SAASwC,4BAA4BA,CAAA,EAAG;EACpC,IAAI,IAAI,CAACV,OAAO,CAACG,YAAY,IACzB,EAAE,IAAI,CAACQ,KAAK,CAACC,IAAI,IAAI,IAAI,CAACD,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC,EAAE;IACzC,MAAM;QAAEZ,OAAO;QAAEa;MAAM,CAAC,GAAG,IAAI;MAAEC,OAAO,GAAGd,OAAO,CAACe,QAAQ,KAAK,SAAS;MAAEC,aAAa,GAAGhE,cAAc,CAACiE,WAAW,GAAG,IAAI,CAACC,IAAI,CAAC,EAC5Hf,YAAY;MAAEA,YAAY,GAAGgB,eAAe,CAACnB,OAAO,CAACG,YAAY,EAAE7C,QAAQ,CAAC0D,aAAa,CAAC,GAAGA,aAAa,GAAG,CAAC,CAAC,CAAC;MAAEI,QAAQ,GAAGP,KAAK,CAACb,OAAO,CAACoB,QAAQ;IACzJ,KAAK,MAAMC,KAAK,IAAI,IAAI,CAACC,MAAM,EAAE;MAC7B,MAAM;QAAEC;MAAU,CAAC,GAAGF,KAAK;MAC3B,IAAIA,KAAK,CAACG,SAAS,KAAK,aAAa,IAAID,SAAS,EAAE;QAChD,MAAM;UAAEE,KAAK,GAAG,CAAC;UAAEC,MAAM,GAAG,CAAC;UAAE7B,CAAC,GAAG;QAAE,CAAC,GAAG0B,SAAS;QAClD,IAAII,MAAM,GAAG9B,CAAC;UAAE+B,WAAW,GAAGF,MAAM;QACpC;QACA;QACA;QACA;QACA;QACA;QACA,IAAIvB,YAAY,CAACtC,KAAK,KAAK,OAAO,IAC9BwD,KAAK,CAACQ,UAAU,EAAE;UAClB,MAAMC,QAAQ,GAAGjB,KAAK,CAACkB,SAAS,CAACjB,OAAO,GAAG,GAAG,GAAGO,KAAK,CAACQ,UAAU,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC;YAAEG,cAAc,GAAGnB,KAAK,CAACkB,SAAS,CAAC/B,OAAO,CAACiC,SAAS,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC;YAAEC,GAAG,GAAG,IAAI,CAACC,QAAQ,CAAC,CAAC,EAAEhD,IAAI,CAACoB,GAAG,CAACuB,QAAQ,EAAEE,cAAc,CAAC,EAAE,CAAC,EAAE7C,IAAI,CAACO,GAAG,CAACoC,QAAQ,GAAGE,cAAc,CAAC,CAAC;UACpRL,MAAM,GAAGO,GAAG,CAACrC,CAAC;UACd+B,WAAW,GAAGM,GAAG,CAACR,MAAM;QAC5B;QACA,MAAMU,IAAI,GAAG,CAACf,KAAK,CAACgB,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,KAChCjB,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC;QAC9B;QACA,IAAItD,KAAK,GAAGqC,YAAY,CAACrC,KAAK;QAC9B;QACA;QACA,IAAI,CAACA,KAAK,IACN,IAAI,CAACwE,EAAE,CAAC,WAAW,CAAC,IACpBnD,IAAI,CAACO,GAAG,CAAC,CAAC2B,KAAK,CAACkB,OAAO,IAAI,CAAC,KACvB,IAAI,CAACC,mBAAmB,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAACC,WAAW,EAAE;UACzD3E,KAAK,GAAG,KAAK;QACjB;QACA,IAAI,CAACA,KAAK,EAAE;UACRA,KAAK,GAAG,KAAK;QACjB;QACA;QACA,MAAMM,CAAC,GAAGe,IAAI,CAACoB,GAAG,CAAC9C,cAAc,CAAC0C,YAAY,CAACvC,MAAM,EAAE6D,KAAK,CAAC,EAAEA,KAAK,GAAG,CAAC;QACxE;QACA3D,KAAK,KAAK,KAAK,GAAG4D,MAAM,GAAG,CAAC,GAAGgB,QAAQ,CAAC,IAAI,CAAC;QAC7C;QACA;QACA;QACA;QACA,IAAI5E,KAAK,KAAK,KAAK,EAAE;UACjB,IAAIsE,IAAI,EAAE;YACNT,MAAM,IAAIvD,CAAC;YACXwD,WAAW,IAAIxD,CAAC;UACpB,CAAC,MACI;YACDwD,WAAW,IAAIxD,CAAC;UACpB;QACJ;QACAf,MAAM,CAACkE,SAAS,EAAE;UAAEK,WAAW;UAAED,MAAM;UAAEvD;QAAE,CAAC,CAAC;MACjD;IACJ;EACJ;AACJ;AACA;AACA,SAASuE,OAAOA,CAACC,WAAW,EAAEC,cAAc,EAAEC,eAAe,EAAEC,gBAAgB,EAAE;EAC7E,IAAIvF,UAAU,CAACE,eAAe,EAAEkF,WAAW,CAAC,EAAE;IAC1CxF,QAAQ,CAACwF,WAAW,EAAE,sBAAsB,EAAElC,4BAA4B,EAAE;MACxE;MACAsC,KAAK,EAAE;IACX,CAAC,CAAC;EACN;EACA,IAAIxF,UAAU,CAACE,eAAe,EAAEmF,cAAc,CAAC,EAAE;IAC7CzF,QAAQ,CAACyF,cAAc,EAAE,gBAAgB,EAAEI,yBAAyB,CAAC;EACzE;EACA,IAAIzF,UAAU,CAACE,eAAe,EAAEoF,eAAe,CAAC,EAAE;IAC9CA,eAAe,CAACI,mBAAmB,CAACC,IAAI,CAAC,cAAc,EAAE,aAAa,EAAE,QAAQ,CAAC;EACrF;EACA,IAAI3F,UAAU,CAACE,eAAe,EAAEqF,gBAAgB,CAAC,EAAE;IAC/C,MAAMK,OAAO,GAAGL,gBAAgB,CAACM,SAAS,CAACD,OAAO;IAClDrF,MAAM,GAAGqF,OAAO,CAAC5E,GAAG;IACpBR,cAAc,GAAGoF,OAAO,CAACE,WAAW;IACpCF,OAAO,CAAC5E,GAAG,GAAGA,GAAG;IACjB4E,OAAO,CAACE,WAAW,GAAGA,WAAW;EACrC;AACJ;AACA;AACA,SAASnC,eAAeA,CAACnB,OAAO,EAAEuD,eAAe,EAAE;EAC/C,IAAI,CAACjG,QAAQ,CAAC0C,OAAO,CAAC,EAAE;IACpBA,OAAO,GAAG;MAAEpC,MAAM,EAAEoC,OAAO,IAAI;IAAE,CAAC;EACtC;EACA,OAAOzC,KAAK,CAACI,0BAA0B,EAAE4F,eAAe,EAAEvD,OAAO,CAAC;AACtE;AACA;AACA,SAASiD,yBAAyBA,CAAA,EAAG;EACjC,MAAM9C,YAAY,GAAGgB,eAAe,CAAC,IAAI,CAACnB,OAAO,CAACG,YAAY,CAAC;EAC/D,KAAK,MAAMkB,KAAK,IAAI,IAAI,CAACC,MAAM,EAAE;IAC7B,MAAMC,SAAS,GAAGF,KAAK,CAACE,SAAS;IACjC,IAAIA,SAAS,EAAE;MACXA,SAAS,CAACpB,YAAY,GAAG1C,cAAc,CAAC0C,YAAY,CAACvC,MAAM,EAAE,CAAC2D,SAAS,CAACnD,CAAC,IAAI,CAAC,KAAMmD,SAAS,CAACtB,MAAM,IAAK,CAAC,CAAC,CAAC;IAChH;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA,SAASqD,WAAWA,CAAC1D,CAAC,EAAEC,CAAC,EAAE4B,KAAK,EAAEC,MAAM,EAAE1B,OAAO,GAAG,CAAC,CAAC,EAAE;EACpD,MAAM9B,IAAI,GAAGF,cAAc,CAAC4B,CAAC,EAAEC,CAAC,EAAE4B,KAAK,EAAEC,MAAM,EAAE1B,OAAO,CAAC;IAAE;MAAE5B,CAAC,GAAG,CAAC;MAAEwD,WAAW,GAAGF,MAAM;MAAEC,MAAM,GAAG9B;IAAE,CAAC,GAAGG,OAAO;IAAEwD,WAAW,GAAG3D,CAAC,GAAG8B,MAAM;IAAE8B,WAAW,GAAI9B,MAAM,GAAGC,WAAW,IAAK/B,CAAC,GAAG6B,MAAM,CAAC;IAC/L;IACA;IACA;IACAgC,IAAI,GAAIF,WAAW,GAAGpF,CAAC,GAAI,CAAC,GAAG,GAAG,CAAC,GAAGA,CAAC;IAAEuF,IAAI,GAAIF,WAAW,GAAGrF,CAAC,GAAI,CAAC,GAAG,GAAG,CAAC,GAAGA,CAAC;IAAEwF,MAAM,GAAGzE,IAAI,CAACmB,GAAG,CAACoD,IAAI,IAAIF,WAAW,EAAE,CAAC,CAAC;IAAEK,MAAM,GAAG1E,IAAI,CAACmB,GAAG,CAACqD,IAAI,IAAIF,WAAW,EAAE,CAAC,CAAC;EACtK;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAII,MAAMpF,CAAC,GAAG,CAACuB,CAAC,GAAG8D,IAAI,EAAE7D,CAAC,CAAC;IAAEvB,CAAC,GAAG,CAACsB,CAAC,GAAG6B,KAAK,GAAGiC,IAAI,EAAE7D,CAAC,CAAC;IAAEiE,CAAC,GAAG,CAAClE,CAAC,GAAG6B,KAAK,EAAE5B,CAAC,GAAG6D,IAAI,CAAC;IAAEK,CAAC,GAAG,CAC/EnE,CAAC,GAAG6B,KAAK,EAAE5B,CAAC,GAAG6B,MAAM,GAAGiC,IAAI,CAC/B;IAAEK,CAAC,GAAG,CACHpE,CAAC,GAAG6B,KAAK,GAAGkC,IAAI,EAChB9D,CAAC,GAAG6B,MAAM,CACb;IAAEuC,CAAC,GAAG,CAACrE,CAAC,GAAG+D,IAAI,EAAE9D,CAAC,GAAG6B,MAAM,CAAC;IAAEwC,CAAC,GAAG,CAACtE,CAAC,EAAEC,CAAC,GAAG6B,MAAM,GAAGiC,IAAI,CAAC;IAAE5D,CAAC,GAAG,CAACH,CAAC,EAAEC,CAAC,GAAG6D,IAAI,CAAC;EAC5E,MAAMS,eAAe,GAAGA,CAAC/F,CAAC,EAAEgG,QAAQ,KAAKjF,IAAI,CAACkF,IAAI,CAAClF,IAAI,CAACmF,GAAG,CAAClG,CAAC,EAAE,CAAC,CAAC,GAAGe,IAAI,CAACmF,GAAG,CAACF,QAAQ,EAAE,CAAC,CAAC,CAAC;EAC1F;EACA,IAAIR,MAAM,EAAE;IACR,MAAMW,IAAI,GAAGJ,eAAe,CAACT,IAAI,EAAEA,IAAI,GAAGE,MAAM,CAAC;IACjDvF,CAAC,CAAC,CAAC,CAAC,IAAIkG,IAAI;IACZjG,CAAC,CAAC,CAAC,CAAC,IAAIiG,IAAI;IACZT,CAAC,CAAC,CAAC,CAAC,GAAG/D,CAAC,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAG6D,IAAI,GAAGE,MAAM;EACnC;EACA;EACA;EACA,IAAIlC,MAAM,GAAGgC,IAAI,GAAGE,MAAM,EAAE;IACxB,MAAMW,IAAI,GAAGJ,eAAe,CAACT,IAAI,EAAEA,IAAI,GAAGE,MAAM,GAAGlC,MAAM,CAAC;IAC1DoC,CAAC,CAAC,CAAC,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC,GAAGnE,CAAC,GAAG6B,KAAK,GAAGiC,IAAI,GAAGa,IAAI;IACrCP,CAAC,CAAC,CAAC,CAAC,GAAG7E,IAAI,CAACoB,GAAG,CAACuD,CAAC,CAAC,CAAC,CAAC,EAAEE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3BC,CAAC,CAAC,CAAC,CAAC,GAAG9E,IAAI,CAACmB,GAAG,CAACyD,CAAC,CAAC,CAAC,CAAC,EAAEE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3BC,CAAC,CAAC,CAAC,CAAC,GAAGnE,CAAC,CAAC,CAAC,CAAC,GAAGH,CAAC,GAAG8D,IAAI,GAAGa,IAAI;IAC7BT,CAAC,CAAC,CAAC,CAAC,GAAG/D,CAAC,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAG6B,MAAM;EAC5B;EACA;EACA,IAAImC,MAAM,EAAE;IACR,MAAMU,IAAI,GAAGJ,eAAe,CAACR,IAAI,EAAEA,IAAI,GAAGE,MAAM,CAAC;IACjDG,CAAC,CAAC,CAAC,CAAC,IAAIO,IAAI;IACZN,CAAC,CAAC,CAAC,CAAC,IAAIM,IAAI;IACZR,CAAC,CAAC,CAAC,CAAC,GAAGG,CAAC,CAAC,CAAC,CAAC,GAAGrE,CAAC,GAAG6B,MAAM,GAAGiC,IAAI,GAAGE,MAAM;EAC5C;EACA;EACA,IAAInC,MAAM,GAAGiC,IAAI,GAAGE,MAAM,EAAE;IACxB,MAAMU,IAAI,GAAGJ,eAAe,CAACR,IAAI,EAAEA,IAAI,GAAGE,MAAM,GAAGnC,MAAM,CAAC;IAC1DoC,CAAC,CAAC,CAAC,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC,GAAGnE,CAAC,GAAG6B,KAAK,GAAGkC,IAAI,GAAGY,IAAI;IACrCjG,CAAC,CAAC,CAAC,CAAC,GAAGa,IAAI,CAACoB,GAAG,CAACuD,CAAC,CAAC,CAAC,CAAC,EAAExF,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3BD,CAAC,CAAC,CAAC,CAAC,GAAGc,IAAI,CAACmB,GAAG,CAACyD,CAAC,CAAC,CAAC,CAAC,EAAE1F,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3B6F,CAAC,CAAC,CAAC,CAAC,GAAGnE,CAAC,CAAC,CAAC,CAAC,GAAGH,CAAC,GAAG+D,IAAI,GAAGY,IAAI;IAC7BR,CAAC,CAAC,CAAC,CAAC,GAAGG,CAAC,CAAC,CAAC,CAAC,GAAGrE,CAAC;EACnB;EACA;EACA3B,IAAI,CAACuC,MAAM,GAAG,CAAC;EACfvC,IAAI,CAACiF,IAAI,CAAC,CAAC,GAAG,EAAE,GAAG9E,CAAC,CAAC;EACrB;EACA,CAAC,GAAG,EAAE,GAAGC,CAAC,CAAC;EACX;EACA,CAAC,GAAG,EAAEoF,IAAI,EAAEA,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAGI,CAAC,CAAC;EAChC;EACA,CAAC,GAAG,EAAE,GAAGC,CAAC,CAAC;EACX;EACA,CAAC,GAAG,EAAEJ,IAAI,EAAEA,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAGK,CAAC,CAAC;EAChC;EACA,CAAC,GAAG,EAAE,GAAGC,CAAC,CAAC;EACX;EACA,CAAC,GAAG,EAAEN,IAAI,EAAEA,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAGO,CAAC,CAAC;EAChC;EACA,CAAC,GAAG,EAAE,GAAGnE,CAAC,CAAC;EACX;EACA,CAAC,GAAG,EAAE2D,IAAI,EAAEA,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAGrF,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;EACxC,OAAOH,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA,MAAMsG,YAAY,GAAG;EACjB7B,OAAO;EACPxB;AACJ,CAAC;AACD,eAAeqD,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GATA,CASI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAPI,CAOD;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SATG,CASA;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACC,EAAE,CAAE,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}